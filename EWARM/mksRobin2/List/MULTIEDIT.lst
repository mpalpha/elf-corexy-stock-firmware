###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  17:01:02
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\MULTIEDIT.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\MULTIEDIT.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\MULTIEDIT.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\MULTIEDIT.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\MULTIEDIT.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : MULTIEDIT.c
     16          Purpose     : Implementation of MULTIEDIT widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "MULTIEDIT.h"
     23          #include "WIDGET.h"
     24          #include "WM_Intern.h"
     25          
     26          #if GUI_WINSUPPORT
     27          
     28          /*********************************************************************
     29          *
     30          *       Private config defaults
     31          *
     32          **********************************************************************
     33          */
     34          
     35          /* Define default fonts */
     36          #ifndef MULTIEDIT_FONT_DEFAULT
     37            #define MULTIEDIT_FONT_DEFAULT &GUI_Font13_1
     38          #endif
     39          
     40          /* Define colors */
     41          #ifndef MULTIEDIT_BKCOLOR0_DEFAULT
     42            #define MULTIEDIT_BKCOLOR0_DEFAULT   GUI_WHITE
     43          #endif
     44          
     45          #ifndef MULTIEDIT_BKCOLOR1_DEFAULT
     46            #define MULTIEDIT_BKCOLOR1_DEFAULT   0xC0C0C0
     47          #endif
     48          
     49          #ifndef MULTIEDIT_TEXTCOLOR0_DEFAULT
     50            #define MULTIEDIT_TEXTCOLOR0_DEFAULT GUI_BLACK
     51          #endif
     52          
     53          #ifndef MULTIEDIT_TEXTCOLOR1_DEFAULT
     54            #define MULTIEDIT_TEXTCOLOR1_DEFAULT GUI_BLACK
     55          #endif
     56          
     57          /* Define character for password mode */
     58          #define MULTIEDIT_PASSWORD_CHAR   '*'
     59          
     60          /*********************************************************************
     61          *
     62          *       Object definition
     63          *
     64          **********************************************************************
     65          */
     66          
     67          #define NUM_DISP_MODES 2
     68          
     69          #define INVALID_NUMCHARS (1 << 0)
     70          #define INVALID_NUMLINES (1 << 1)
     71          #define INVALID_TEXTSIZE (1 << 2)
     72          #define INVALID_CURSORXY (1 << 3)
     73          #define INVALID_LINEPOSB (1 << 4)
     74          
     75          typedef struct {
     76            WIDGET Widget;
     77            GUI_COLOR aBkColor[NUM_DISP_MODES];
     78            GUI_COLOR aColor[NUM_DISP_MODES];
     79            WM_HMEM hText;
     80            U16 MaxNumChars;         /* Maximum number of characters including the prompt */            
     81            U16 NumChars;            /* Number of characters (text and prompt) in object */                    
     82            U16 NumCharsPrompt;      /* Number of prompt characters */
     83            U16 NumLines;            /* Number of text lines needed to show all data */
     84            U16 TextSizeX;           /* Size in X of text depending of wrapping mode */
     85            U16 BufferSize;
     86            U16 CursorLine;          /* Number of current cursor line */
     87            U16 CursorPosChar;       /* Character offset number of cursor */
     88            U16 CursorPosByte;       /* Byte offset number of cursor */
     89            U16 CursorPosX;          /* Cursor position in X */
     90            U16 CursorPosY;          /* Cursor position in Y */
     91            U16 CacheLinePosByte;    /*  */
     92            U16 CacheLineNumber;     /*  */
     93            U16 CacheFirstVisibleLine;
     94            U16 CacheFirstVisibleByte;
     95            WM_SCROLL_STATE ScrollStateV;
     96            WM_SCROLL_STATE ScrollStateH;
     97            const GUI_FONT GUI_UNI_PTR * pFont;
     98            U8 Flags;
     99            U8 InvalidFlags;         /* Flags to save validation status */
    100            U8 EditMode;
    101            U8 HBorder;
    102            GUI_WRAPMODE WrapMode;
    103            #if GUI_DEBUG_LEVEL >1
    104              int DebugId;
    105            #endif
    106          } MULTIEDIT_OBJ;
    107          
    108          /*********************************************************************
    109          *
    110          *       Static data
    111          *
    112          **********************************************************************
    113          */
    114          

   \                                 In section .data, align 4
    115          static GUI_COLOR _aDefaultBkColor[2] = {
   \                     _aDefaultBkColor:
   \   00000000   0x00FFFFFF         DC32 16777215, 12632256
   \              0x00C0C0C0   
   \   00000008   0x00000000         DC32 0, 0
   \              0x00000000   
   \   00000010   0x........         DC32 GUI_Font13_1
    116            MULTIEDIT_BKCOLOR0_DEFAULT,
    117            MULTIEDIT_BKCOLOR1_DEFAULT,
    118          };
    119          
    120          static GUI_COLOR _aDefaultColor[2] = {
    121            MULTIEDIT_TEXTCOLOR0_DEFAULT,
    122            MULTIEDIT_TEXTCOLOR1_DEFAULT,
    123          };
    124          
    125          static const GUI_FONT GUI_UNI_PTR * _pDefaultFont = MULTIEDIT_FONT_DEFAULT;
    126          
    127          /*********************************************************************
    128          *
    129          *       Macros for internal use
    130          *
    131          **********************************************************************
    132          */
    133          
    134          #define MULTIEDIT_ID 0x8793   /* Magic numer, should be unique if possible */
    135          
    136          #define MULTIEDIT_H2P(h) (MULTIEDIT_OBJ*) WM_H2P(h)
    137          
    138          #define MULTIEDIT_REALLOC_SIZE  16
    139          
    140          #if GUI_DEBUG_LEVEL > 1
    141            #define MULTIEDIT_ASSERT_IS_VALID_PTR(p) DEBUG_ERROROUT_IF(p->DebugId != MULTIEDIT_ID, "MULTIEDIT.c: Wrong handle type or Object not init'ed")
    142            #define MULTIEDIT_INIT_ID(p)   p->DebugId = MULTIEDIT_ID
    143            #define MULTIEDIT_DEINIT_ID(p) p->DebugId = MULTIEDIT_ID+1
    144          #else
    145            #define MULTIEDIT_ASSERT_IS_VALID_PTR(p)
    146            #define MULTIEDIT_INIT_ID(p)
    147            #define MULTIEDIT_DEINIT_ID(p)
    148          #endif
    149          
    150          /*********************************************************************
    151          *
    152          *       static code, helper functions
    153          *
    154          **********************************************************************
    155          */
    156          
    157          /*********************************************************************
    158          *
    159          *       _InvalidateNumChars
    160          *
    161          * Invalidates the number of characters including the prompt
    162          */

   \                                 In section .text, align 2, keep-with-next
    163          static void _InvalidateNumChars(MULTIEDIT_OBJ * pObj) {
    164            pObj->InvalidFlags |= INVALID_NUMCHARS;
   \                     _InvalidateNumChars: (+1)
   \   00000000   0xF890 0x1075      LDRB     R1,[R0, #+117]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0xF880 0x1075      STRB     R1,[R0, #+117]
    165          }
   \   0000000C   0x4770             BX       LR               ;; return
    166          
    167          /*********************************************************************
    168          *
    169          *       _GetNumChars
    170          *
    171          * Calculates (if needed) and returns the number of characters including the prompt
    172          */

   \                                 In section .text, align 2, keep-with-next
    173          static int _GetNumChars(MULTIEDIT_OBJ * pObj) {
   \                     _GetNumChars: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    174            if (pObj->InvalidFlags & INVALID_NUMCHARS) {
   \   00000004   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000008   0xF894 0x0075      LDRB     R0,[R4, #+117]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD50C             BPL.N    ??_GetNumChars_0
    175              char * pText;
    176              pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000010   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   00000014   0x.... 0x....      BL       GUI_ALLOC_h2p
    177              pObj->NumChars = GUI__GetNumChars(pText);
   \   00000018   0x.... 0x....      BL       GUI__GetNumChars
   \   0000001C   0x80A8             STRH     R0,[R5, #+4]
    178              pObj->InvalidFlags &= ~INVALID_NUMCHARS;
   \   0000001E   0xF894 0x0075      LDRB     R0,[R4, #+117]
   \   00000022   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   00000026   0xF884 0x0075      STRB     R0,[R4, #+117]
    179            }
    180            return pObj->NumChars;
   \                     ??_GetNumChars_0: (+1)
   \   0000002A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    181          }
    182          
    183          /*********************************************************************
    184          *
    185          *       _GetXSize
    186          *
    187          * Returns the x size for displaying text.
    188          */

   \                                 In section .text, align 2, keep-with-next
    189          static int _GetXSize(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj) {
   \                     _GetXSize: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    190            GUI_RECT Rect;
    191            WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    192            return Rect.x1 - Rect.x0 - (pObj->HBorder * 2) - 1;
   \   0000000A   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   0000000E   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000012   0x1A40             SUBS     R0,R0,R1
   \   00000014   0xF894 0x1077      LDRB     R1,[R4, #+119]
   \   00000018   0xEBA0 0x0041      SUB      R0,R0,R1, LSL #+1
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    193          }
    194          
    195          /*********************************************************************
    196          *
    197          *       _GetNumCharsInPrompt
    198          */

   \                                 In section .text, align 2, keep-with-next
    199          static int _GetNumCharsInPrompt(const MULTIEDIT_OBJ* pObj, const char GUI_UNI_PTR * pText) {
   \                     _GetNumCharsInPrompt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    200            char *pString, *pEndPrompt;
    201            int r = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    202            pString = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000008   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4607             MOV      R7,R0
    203            pEndPrompt = pString + GUI_UC__NumChars2NumBytes(pString, pObj->NumCharsPrompt);
   \   00000012   0x8FE1             LDRH     R1,[R4, #+62]
   \   00000014   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000018   0x19C0             ADDS     R0,R0,R7
    204            if (pText < pEndPrompt) {
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xD204             BCS.N    ??_GetNumCharsInPrompt_0
    205              r = GUI_UC__NumBytes2NumChars(pText, pEndPrompt - pText);
   \   0000001E   0x1B41             SUBS     R1,R0,R5
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       GUI_UC__NumBytes2NumChars
   \   00000026   0x4606             MOV      R6,R0
    206            }
    207            return r;
   \                     ??_GetNumCharsInPrompt_0: (+1)
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    208          }
    209          
    210          /*********************************************************************
    211          *
    212          *       _NumChars2XSize
    213          */

   \                                 In section .text, align 2, keep-with-next
    214          static int _NumChars2XSize(const char GUI_UNI_PTR * pText, int NumChars) {
   \                     _NumChars2XSize: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    215            int xSize = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE005             B.N      ??_NumChars2XSize_0
    216            U16 Char;
    217            while (NumChars--) {
    218              Char   = GUI_UC__GetCharCodeInc(&pText);
   \                     ??_NumChars2XSize_1: (+1)
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
    219              xSize += GUI_GetCharDistX(Char);
   \   0000000E   0x.... 0x....      BL       GUI_GetCharDistX
   \   00000012   0x1945             ADDS     R5,R0,R5
    220            }
   \                     ??_NumChars2XSize_0: (+1)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x1E44             SUBS     R4,R0,#+1
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F5             BNE.N    ??_NumChars2XSize_1
    221            return xSize;
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    222          }
    223          
    224          /*********************************************************************
    225          *
    226          *       _WrapGetNumCharsDisp
    227          */

   \                                 In section .text, align 2, keep-with-next
    228          static int _WrapGetNumCharsDisp(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char GUI_UNI_PTR * pText) {
   \                     _WrapGetNumCharsDisp: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
    229            int xSize, r;
    230            xSize = _GetXSize(hObj, pObj);
   \   00000004   0x.... 0x....      BL       _GetXSize
   \   00000008   0x4604             MOV      R4,R0
    231            if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   0000000A   0xF105 0x0674      ADD      R6,R5,#+116
   \   0000000E   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   00000012   0x0680             LSLS     R0,R0,#+26
   \   00000014   0xD532             BPL.N    ??_WrapGetNumCharsDisp_0
    232              int NumCharsPrompt;
    233              NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _GetNumCharsInPrompt
   \   0000001E   0x4607             MOV      R7,R0
    234              r = GUI__WrapGetNumCharsDisp(pText, xSize, pObj->WrapMode);
   \   00000020   0xF996 0x2004      LDRSB    R2,[R6, #+4]
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x.... 0x....      BL       GUI__WrapGetNumCharsDisp
   \   0000002C   0x4605             MOV      R5,R0
    235              if (r >= NumCharsPrompt) {
   \   0000002E   0x42BD             CMP      R5,R7
   \   00000030   0xDB2B             BLT.N    ??_WrapGetNumCharsDisp_1
    236                int x;
    237                switch (pObj->WrapMode) {
   \   00000032   0xF996 0x0004      LDRSB    R0,[R6, #+4]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD104             BNE.N    ??_WrapGetNumCharsDisp_2
    238                case GUI_WRAPMODE_NONE:
    239                  r = GUI__GetNumChars(pText);
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x.... 0x....      BL       GUI__GetNumChars
   \   00000040   0x4605             MOV      R5,R0
    240                  break;
   \   00000042   0xE022             B.N      ??_WrapGetNumCharsDisp_1
    241                default:
    242                  r = NumCharsPrompt;
   \                     ??_WrapGetNumCharsDisp_2: (+1)
   \   00000044   0x463D             MOV      R5,R7
    243                  x = _NumChars2XSize(pText, NumCharsPrompt);
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x.... 0x....      BL       _NumChars2XSize
   \   0000004E   0x4606             MOV      R6,R0
    244                  pText += GUI_UC__NumChars2NumBytes(pText, NumCharsPrompt);
   \   00000050   0x4639             MOV      R1,R7
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000058   0x9900             LDR      R1,[SP, #+0]
   \   0000005A   0x1840             ADDS     R0,R0,R1
   \   0000005C   0x9000             STR      R0,[SP, #+0]
    245                  while (GUI_UC__GetCharCodeInc(&pText) != 0) {
   \                     ??_WrapGetNumCharsDisp_3: (+1)
   \   0000005E   0xA800             ADD      R0,SP,#+0
   \   00000060   0x.... 0x....      BL       GUI_UC__GetCharCodeInc
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD010             BEQ.N    ??_WrapGetNumCharsDisp_1
    246                    x += GUI_GetCharDistX(MULTIEDIT_PASSWORD_CHAR);
   \   00000068   0x202A             MOVS     R0,#+42
   \   0000006A   0x.... 0x....      BL       GUI_GetCharDistX
   \   0000006E   0x1986             ADDS     R6,R0,R6
    247                    if (r && (x > xSize)) {
   \   00000070   0x2D00             CMP      R5,#+0
   \   00000072   0xD001             BEQ.N    ??_WrapGetNumCharsDisp_4
   \   00000074   0x42B4             CMP      R4,R6
   \   00000076   0xDB08             BLT.N    ??_WrapGetNumCharsDisp_1
    248                      break;
    249                    }
    250                    r++;
   \                     ??_WrapGetNumCharsDisp_4: (+1)
   \   00000078   0x1C6D             ADDS     R5,R5,#+1
   \   0000007A   0xE7F0             B.N      ??_WrapGetNumCharsDisp_3
    251                  }
    252                  break;
    253                }
    254              }
    255            } else {
    256              r = GUI__WrapGetNumCharsDisp(pText, xSize, pObj->WrapMode);
   \                     ??_WrapGetNumCharsDisp_0: (+1)
   \   0000007C   0xF996 0x2004      LDRSB    R2,[R6, #+4]
   \   00000080   0x4621             MOV      R1,R4
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x.... 0x....      BL       GUI__WrapGetNumCharsDisp
   \   00000088   0x4605             MOV      R5,R0
    257            }
    258            return r;
   \                     ??_WrapGetNumCharsDisp_1: (+1)
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    259          }
    260          
    261          /*********************************************************************
    262          *
    263          *       _WrapGetNumBytesToNextLine
    264          */

   \                                 In section .text, align 2, keep-with-next
    265          static int _WrapGetNumBytesToNextLine(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char* pText) {
   \                     _WrapGetNumBytesToNextLine: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    266            int xSize, r;
    267            xSize = _GetXSize(hObj, pObj);
   \   00000008   0x.... 0x....      BL       _GetXSize
   \   0000000C   0x4601             MOV      R1,R0
    268            if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   0000000E   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   00000012   0x0680             LSLS     R0,R0,#+26
   \   00000014   0xD515             BPL.N    ??_WrapGetNumBytesToNextLine_0
    269              int NumChars, NumCharsPrompt;
    270              NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
   \   00000016   0x4631             MOV      R1,R6
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _GetNumCharsInPrompt
   \   0000001E   0x4607             MOV      R7,R0
    271              NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   0000002A   0x4604             MOV      R4,R0
    272              r        = GUI_UC__NumChars2NumBytes(pText, NumChars);
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
    273              if (NumChars < NumCharsPrompt) {
   \   00000034   0x42BC             CMP      R4,R7
   \   00000036   0xDA0B             BGE.N    ??_WrapGetNumBytesToNextLine_1
    274                if (*(pText + r) == '\n') {
   \   00000038   0x5781             LDRSB    R1,[R0, R6]
   \   0000003A   0x290A             CMP      R1,#+10
   \   0000003C   0xD108             BNE.N    ??_WrapGetNumBytesToNextLine_1
    275                  r++;
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}
    276                }
    277              }
    278            } else {
    279              r = GUI__WrapGetNumBytesToNextLine(pText, xSize, pObj->WrapMode);
   \                     ??_WrapGetNumBytesToNextLine_0: (+1)
   \   00000042   0xF995 0x2078      LDRSB    R2,[R5, #+120]
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   0000004C   0x.... 0x....      B.W      GUI__WrapGetNumBytesToNextLine
    280            }
    281            return r;
   \                     ??_WrapGetNumBytesToNextLine_1: (+1)
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    282          }
    283          
    284          /*********************************************************************
    285          *
    286          *       _GetCharDistX
    287          */

   \                                 In section .text, align 2, keep-with-next
    288          static int _GetCharDistX(const MULTIEDIT_OBJ* pObj, const char* pText) {
   \                     _GetCharDistX: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    289            int r;
    290            if ((pObj->Flags & MULTIEDIT_SF_PASSWORD) && (_GetNumCharsInPrompt(pObj, pText) == 0)) {
   \   00000004   0xF890 0x1074      LDRB     R1,[R0, #+116]
   \   00000008   0x0689             LSLS     R1,R1,#+26
   \   0000000A   0xD509             BPL.N    ??_GetCharDistX_0
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x.... 0x....      BL       _GetNumCharsInPrompt
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??_GetCharDistX_0
    291              r = GUI_GetCharDistX(MULTIEDIT_PASSWORD_CHAR);
   \   00000016   0x202A             MOVS     R0,#+42
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x.... 0x....      B.W      GUI_GetCharDistX
    292            } else {
    293              U16 c;
    294              c = GUI_UC_GetCharCode(pText);
   \                     ??_GetCharDistX_0: (+1)
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       GUI_UC_GetCharCode
    295              r = GUI_GetCharDistX(c);
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x.... 0x....      B.W      GUI_GetCharDistX
    296            }
    297            return r;
    298          }
    299          
    300          /*********************************************************************
    301          *
    302          *       _DispString
    303          */

   \                                 In section .text, align 2, keep-with-next
    304          static void _DispString(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char* pText, GUI_RECT* pRect) {
   \                     _DispString: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
    305            int NumCharsDisp;
    306            NumCharsDisp = _WrapGetNumCharsDisp(hObj, pObj, pText);
   \   0000000A   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   0000000E   0x4607             MOV      R7,R0
    307            if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000010   0xF896 0x0074      LDRB     R0,[R6, #+116]
   \   00000014   0x0680             LSLS     R0,R0,#+26
   \   00000016   0xD529             BPL.N    ??_DispString_0
    308              int x, NumCharsPrompt, NumCharsLeft = 0;
   \   00000018   0xF04F 0x0800      MOV      R8,#+0
    309              NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       _GetNumCharsInPrompt
   \   00000024   0x4606             MOV      R6,R0
    310              if (NumCharsDisp < NumCharsPrompt) {
   \   00000026   0x42B7             CMP      R7,R6
   \   00000028   0xDA01             BGE.N    ??_DispString_1
    311                NumCharsPrompt = NumCharsDisp;
   \   0000002A   0x463E             MOV      R6,R7
   \   0000002C   0xE001             B.N      ??_DispString_2
    312              } else {
    313                NumCharsLeft = NumCharsDisp - NumCharsPrompt;
   \                     ??_DispString_1: (+1)
   \   0000002E   0xEBA7 0x0806      SUB      R8,R7,R6
    314              }
    315              GUI_DispStringInRectMax(pText, pRect, GUI_TA_LEFT, NumCharsPrompt);
   \                     ??_DispString_2: (+1)
   \   00000032   0x4633             MOV      R3,R6
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       GUI_DispStringInRectMax
    316              x = pRect->x0 + _NumChars2XSize(pText, NumCharsPrompt);
   \   0000003E   0xF9B5 0x7000      LDRSH    R7,[R5, #+0]
   \   00000042   0x4631             MOV      R1,R6
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       _NumChars2XSize
   \   0000004A   0x19C1             ADDS     R1,R0,R7
    317              if (NumCharsLeft) {
   \   0000004C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000050   0xD014             BEQ.N    ??_DispString_3
    318                GUI_DispCharAt(MULTIEDIT_PASSWORD_CHAR, x, pRect->y0);
   \   00000052   0xF9B5 0x2002      LDRSH    R2,[R5, #+2]
   \   00000056   0xB209             SXTH     R1,R1
   \   00000058   0x202A             MOVS     R0,#+42
   \   0000005A   0x.... 0x....      BL       GUI_DispCharAt
    319                GUI_DispChars(MULTIEDIT_PASSWORD_CHAR, NumCharsLeft - 1);
   \   0000005E   0xF1A8 0x0101      SUB      R1,R8,#+1
   \   00000062   0x202A             MOVS     R0,#+42
   \   00000064   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000068   0x.... 0x....      B.W      GUI_DispChars
    320              }
    321            } else {
    322              GUI_DispStringInRectMax(pText, pRect, GUI_TA_LEFT, NumCharsDisp);
   \                     ??_DispString_0: (+1)
   \   0000006C   0x463B             MOV      R3,R7
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000078   0x.... 0x....      B.W      GUI_DispStringInRectMax
    323            }  
    324          }
   \                     ??_DispString_3: (+1)
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    325          
    326          /*********************************************************************
    327          *
    328          *       static code, cursor routines
    329          *
    330          **********************************************************************
    331          */
    332          /*********************************************************************
    333          *
    334          *       _GetpLine
    335          *
    336          * Returns a pointer to the beginning of the line with the
    337          * given line number.
    338          */

   \                                 In section .text, align 2, keep-with-next
    339          static char * _GetpLine(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, unsigned LineNumber) {
   \                     _GetpLine: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
    340            char * pText, * pLine;
    341            pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   0000000A   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x4606             MOV      R6,R0
    342            if ((unsigned)pObj->CacheLineNumber != LineNumber) {
   \   00000014   0xF105 0x0738      ADD      R7,R5,#+56
   \   00000018   0x8B78             LDRH     R0,[R7, #+26]
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x4541             CMP      R1,R8
   \   0000001E   0xD01A             BEQ.N    ??_GetpLine_0
    343              if (LineNumber > (unsigned)pObj->CacheLineNumber) {
   \   00000020   0xD207             BCS.N    ??_GetpLine_1
    344                /* If new line number > cache we can start with old pointer */
    345                int OldNumber = pObj->CacheLineNumber;
    346                pLine = pText + pObj->CacheLinePosByte;
   \   00000022   0x8B39             LDRH     R1,[R7, #+24]
   \   00000024   0xEB01 0x0906      ADD      R9,R1,R6
    347                pObj->CacheLineNumber  = LineNumber;
   \   00000028   0xF8A7 0x801A      STRH     R8,[R7, #+26]
    348                LineNumber -= OldNumber;
   \   0000002C   0xEBA8 0x0800      SUB      R8,R8,R0
   \   00000030   0xE009             B.N      ??_GetpLine_2
    349              } else {
    350                /* If new line number < cache we need to start with first byte */
    351                pLine = pText;
   \                     ??_GetpLine_1: (+1)
   \   00000032   0x46B1             MOV      R9,R6
    352                pObj->CacheLineNumber  = LineNumber;
   \   00000034   0xF8A7 0x801A      STRH     R8,[R7, #+26]
   \   00000038   0xE005             B.N      ??_GetpLine_2
    353              }
    354              while (LineNumber--) {
    355                pLine += _WrapGetNumBytesToNextLine(hObj, pObj, pLine);
   \                     ??_GetpLine_3: (+1)
   \   0000003A   0x464A             MOV      R2,R9
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       _WrapGetNumBytesToNextLine
   \   00000044   0x4481             ADD      R9,R0,R9
    356              }
   \                     ??_GetpLine_2: (+1)
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0xF1A0 0x0801      SUB      R8,R0,#+1
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD1F4             BNE.N    ??_GetpLine_3
    357              pObj->CacheLinePosByte = pLine - pText;
   \   00000050   0xEBA9 0x0006      SUB      R0,R9,R6
   \   00000054   0x8338             STRH     R0,[R7, #+24]
    358            }
    359            return pText + pObj->CacheLinePosByte;
   \                     ??_GetpLine_0: (+1)
   \   00000056   0x8B38             LDRH     R0,[R7, #+24]
   \   00000058   0x1980             ADDS     R0,R0,R6
   \   0000005A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    360          }
    361          
    362          /*********************************************************************
    363          *
    364          *       _ClearCache
    365          *
    366          * Clears the cached position of the linenumber and the first byte
    367          * of the line which holds the cursor.
    368          */

   \                                 In section .text, align 2, keep-with-next
    369          static void _ClearCache(MULTIEDIT_OBJ* pObj) {
    370            pObj->CacheLineNumber = 0;
   \                     _ClearCache: (+1)
   \   00000000   0xF100 0x0150      ADD      R1,R0,#+80
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x804A             STRH     R2,[R1, #+2]
    371            pObj->CacheLinePosByte = 0;
   \   00000008   0xF8A0 0x2050      STRH     R2,[R0, #+80]
    372            pObj->CacheFirstVisibleByte = 0;
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x80C8             STRH     R0,[R1, #+6]
    373            pObj->CacheFirstVisibleLine = 0;
   \   00000010   0x8088             STRH     R0,[R1, #+4]
    374          }
   \   00000012   0x4770             BX       LR               ;; return
    375          
    376          /*********************************************************************
    377          *
    378          *       _GetCursorLine
    379          *
    380          * Returns the line number of the cursor position.
    381          */

   \                                 In section .text, align 2, keep-with-next
    382          static int _GetCursorLine(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char* pText, int CursorPosChar) {
   \                     _GetCursorLine: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4619             MOV      R1,R3
    383            const char *pCursor;
    384            const char *pEndLine;
    385            int NumChars, ByteOffsetNewCursor, LineNumber = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    386            ByteOffsetNewCursor = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
   \   00000010   0x4638             MOV      R0,R7
   \   00000012   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
    387            pCursor = pText + ByteOffsetNewCursor;
   \   00000016   0x19C6             ADDS     R6,R0,R7
    388            if (pObj->CacheLinePosByte < ByteOffsetNewCursor) {
   \   00000018   0xF8B5 0x1050      LDRH     R1,[R5, #+80]
   \   0000001C   0x4281             CMP      R1,R0
   \   0000001E   0xDA05             BGE.N    ??_GetCursorLine_0
    389              /* If cache pos < new position we can use it as start position */
    390              pText      += pObj->CacheLinePosByte;
   \   00000020   0x19CF             ADDS     R7,R1,R7
    391              LineNumber += pObj->CacheLineNumber;
   \   00000022   0xF8B5 0x8052      LDRH     R8,[R5, #+82]
   \   00000026   0xE001             B.N      ??_GetCursorLine_0
    392            }
    393            while (*pText && (pCursor > pText)) {
    394              NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
    395              pEndLine = pText + GUI_UC__NumChars2NumBytes(pText, NumChars);
    396              pText   += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
    397              if (pCursor <= pEndLine) {
    398                if ((pCursor == pEndLine) && (pEndLine == pText) && *pText) {
    399                  LineNumber++;
    400                }
    401                break;
    402              }
    403              LineNumber++;
   \                     ??_GetCursorLine_1: (+1)
   \   00000028   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_GetCursorLine_0: (+1)
   \   0000002C   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD01F             BEQ.N    ??_GetCursorLine_2
   \   00000034   0x46B1             MOV      R9,R6
   \   00000036   0x454F             CMP      R7,R9
   \   00000038   0xD21C             BCS.N    ??_GetCursorLine_2
   \   0000003A   0x463A             MOV      R2,R7
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x4638             MOV      R0,R7
   \   00000048   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000004C   0xEB00 0x0A07      ADD      R10,R0,R7
   \   00000050   0x463A             MOV      R2,R7
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       _WrapGetNumBytesToNextLine
   \   0000005A   0x19C7             ADDS     R7,R0,R7
   \   0000005C   0x45CA             CMP      R10,R9
   \   0000005E   0xD3E3             BCC.N    ??_GetCursorLine_1
   \   00000060   0x4556             CMP      R6,R10
   \   00000062   0xD107             BNE.N    ??_GetCursorLine_2
   \   00000064   0x45BA             CMP      R10,R7
   \   00000066   0xD105             BNE.N    ??_GetCursorLine_2
   \   00000068   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD001             BEQ.N    ??_GetCursorLine_2
   \   00000070   0xF108 0x0801      ADD      R8,R8,#+1
    404            }
    405            return LineNumber;
   \                     ??_GetCursorLine_2: (+1)
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    406          }
    407          
    408          /*********************************************************************
    409          *
    410          *       _GetCursorXY
    411          */

   \                                 In section .text, align 2, keep-with-next
    412          static void _GetCursorXY(MULTIEDIT_HANDLE hObj, /*const*/ MULTIEDIT_OBJ* pObj, int* px, int* py) {
   \                     _GetCursorXY: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    413            if (pObj->InvalidFlags & INVALID_CURSORXY) {
   \   0000000C   0xF105 0x0838      ADD      R8,R5,#+56
   \   00000010   0xF895 0x0075      LDRB     R0,[R5, #+117]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD532             BPL.N    ??_GetCursorXY_0
    414              int CursorLine = 0, x = 0;
   \   00000018   0xF04F 0x0B00      MOV      R11,#+0
   \   0000001C   0x46D9             MOV      R9,R11
    415              GUI_SetFont(pObj->pFont);
   \   0000001E   0xF8D8 0x0038      LDR      R0,[R8, #+56]
   \   00000022   0x.... 0x....      BL       GUI_SetFont
    416              if (pObj->hText) {
   \   00000026   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD019             BEQ.N    ??_GetCursorXY_1
    417                const char *pLine;
    418                const char *pCursor;
    419                pLine      = (const char *)GUI_ALLOC_h2p(pObj->hText);
   \   0000002E   0x.... 0x....      BL       GUI_ALLOC_h2p
    420                pCursor    = pLine + pObj->CursorPosByte;
   \   00000032   0xF8B8 0x1012      LDRH     R1,[R8, #+18]
   \   00000036   0xEB01 0x0A00      ADD      R10,R1,R0
    421                CursorLine = pObj->CursorLine;
   \   0000003A   0xF8B8 0xB00E      LDRH     R11,[R8, #+14]
    422                pLine      = _GetpLine(hObj, pObj, CursorLine);
   \   0000003E   0x465A             MOV      R2,R11
   \   00000040   0x4629             MOV      R1,R5
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _GetpLine
   \   00000048   0x4604             MOV      R4,R0
   \   0000004A   0xE008             B.N      ??_GetCursorXY_2
    423                while (pLine < pCursor) {
    424                  x     += _GetCharDistX(pObj, pLine);
   \                     ??_GetCursorXY_3: (+1)
   \   0000004C   0x4621             MOV      R1,R4
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0x.... 0x....      BL       _GetCharDistX
   \   00000054   0x4481             ADD      R9,R0,R9
    425                  pLine += GUI_UC_GetCharSize(pLine);
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       GUI_UC_GetCharSize
   \   0000005C   0x1904             ADDS     R4,R0,R4
    426                }
   \                     ??_GetCursorXY_2: (+1)
   \   0000005E   0x4554             CMP      R4,R10
   \   00000060   0xD3F4             BCC.N    ??_GetCursorXY_3
    427              }
    428              pObj->CursorPosX = x;
   \                     ??_GetCursorXY_1: (+1)
   \   00000062   0xF8A8 0x9014      STRH     R9,[R8, #+20]
    429              pObj->CursorPosY = CursorLine * GUI_GetFontDistY();
   \   00000066   0x.... 0x....      BL       GUI_GetFontDistY
   \   0000006A   0xFB00 0xF00B      MUL      R0,R0,R11
   \   0000006E   0xF8A8 0x0016      STRH     R0,[R8, #+22]
    430              pObj->InvalidFlags &= ~INVALID_CURSORXY;
   \   00000072   0xF895 0x0075      LDRB     R0,[R5, #+117]
   \   00000076   0xF000 0x00F7      AND      R0,R0,#0xF7
   \   0000007A   0xF885 0x0075      STRB     R0,[R5, #+117]
    431            }
    432            *px = pObj->CursorPosX;
   \                     ??_GetCursorXY_0: (+1)
   \   0000007E   0xF8B8 0x0014      LDRH     R0,[R8, #+20]
   \   00000082   0x6030             STR      R0,[R6, #+0]
    433            *py = pObj->CursorPosY;
   \   00000084   0xF8B8 0x0016      LDRH     R0,[R8, #+22]
   \   00000088   0x6038             STR      R0,[R7, #+0]
    434          }
   \   0000008A   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    435          
    436          /*********************************************************************
    437          *
    438          *       _InvalidateCursorXY
    439          */

   \                                 In section .text, align 2, keep-with-next
    440          static void _InvalidateCursorXY(MULTIEDIT_OBJ * pObj) {
    441            pObj->InvalidFlags |= INVALID_CURSORXY;
   \                     _InvalidateCursorXY: (+1)
   \   00000000   0xF890 0x1075      LDRB     R1,[R0, #+117]
   \   00000004   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000008   0xF880 0x1075      STRB     R1,[R0, #+117]
    442          }
   \   0000000C   0x4770             BX       LR               ;; return
    443          
    444          /*********************************************************************
    445          *
    446          *       _SetScrollState
    447          */

   \                                 In section .text, align 2, keep-with-next
    448          static void _SetScrollState(WM_HWIN hObj) {
   \                     _SetScrollState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    449            MULTIEDIT_OBJ* pObj = MULTIEDIT_H2P(hObj);
   \   00000004   0x.... 0x....      BL       GUI_ALLOC_h2p
    450            WIDGET__SetScrollState(hObj, &pObj->ScrollStateV, &pObj->ScrollStateH);
   \   00000008   0xF100 0x0264      ADD      R2,R0,#+100
   \   0000000C   0xF100 0x0158      ADD      R1,R0,#+88
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4010      POP      {R4,LR}
   \   00000016   0x.... 0x....      B.W      WIDGET__SetScrollState
    451          }
    452          
    453          /*********************************************************************
    454          *
    455          *       _CalcScrollPos
    456          *
    457          * Purpose:
    458          *   Find out if the current position of the cursor is still in the
    459          *   visible area. If it is not, the scroll position is updated.
    460          *   Needs to be called every time the cursor is move, wrap, font or
    461          *   window size are changed.
    462          */

   \                                 In section .text, align 2, keep-with-next
    463          static void _CalcScrollPos(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _CalcScrollPos: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    464            int xCursor, yCursor;
    465            _GetCursorXY(hObj, pObj, &xCursor, &yCursor);
   \   00000008   0xAB00             ADD      R3,SP,#+0
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x.... 0x....      BL       _GetCursorXY
    466            yCursor /= GUI_GetYDistOfFont(pObj->pFont);
   \   00000010   0x6F28             LDR      R0,[R5, #+112]
   \   00000012   0x.... 0x....      BL       GUI_GetYDistOfFont
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   0000001C   0x9000             STR      R0,[SP, #+0]
    467            WM_CheckScrollPos(&pObj->ScrollStateV, yCursor, 0, 0);       /* Vertical */
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x461A             MOV      R2,R3
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0xF105 0x0058      ADD      R0,R5,#+88
   \   00000028   0x.... 0x....      BL       WM_CheckScrollPos
    468            WM_CheckScrollPos(&pObj->ScrollStateH, xCursor, 30, 30);     /* Horizontal */
   \   0000002C   0x231E             MOVS     R3,#+30
   \   0000002E   0x461A             MOV      R2,R3
   \   00000030   0x9901             LDR      R1,[SP, #+4]
   \   00000032   0xF105 0x0064      ADD      R0,R5,#+100
   \   00000036   0x.... 0x....      BL       WM_CheckScrollPos
    469            _SetScrollState(hObj);
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _SetScrollState
    470          }
   \   00000040   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    471          
    472          /*********************************************************************
    473          *
    474          *       _GetTextSizeX
    475          *
    476          * Returns the width of the displayed text.
    477          */

   \                                 In section .text, align 2, keep-with-next
    478          static int _GetTextSizeX(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _GetTextSizeX: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    479            if (pObj->InvalidFlags & INVALID_TEXTSIZE) {
   \   00000008   0xF105 0x0638      ADD      R6,R5,#+56
   \   0000000C   0xF895 0x0075      LDRB     R0,[R5, #+117]
   \   00000010   0x0740             LSLS     R0,R0,#+29
   \   00000012   0xD53A             BPL.N    ??_GetTextSizeX_0
    480              pObj->TextSizeX = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x8170             STRH     R0,[R6, #+10]
    481              if (pObj->hText) {
   \   00000018   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD02E             BEQ.N    ??_GetTextSizeX_1
    482                int NumChars, xSizeLine;
    483                char *pText, *pLine;
    484                GUI_SetFont(pObj->pFont);
   \   00000020   0x6BB0             LDR      R0,[R6, #+56]
   \   00000022   0x.... 0x....      BL       GUI_SetFont
    485                pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000026   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   0000002A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000002E   0x4607             MOV      R7,R0
    486                do {
    487                  NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
   \                     ??_GetTextSizeX_2: (+1)
   \   00000030   0x463A             MOV      R2,R7
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   0000003A   0x4681             MOV      R9,R0
    488                  xSizeLine = 0;
   \   0000003C   0xF04F 0x0800      MOV      R8,#+0
    489                  pLine = pText;
   \   00000040   0x46BA             MOV      R10,R7
   \   00000042   0xE008             B.N      ??_GetTextSizeX_3
    490                  while (NumChars--) {
    491                    xSizeLine += _GetCharDistX(pObj, pLine);
   \                     ??_GetTextSizeX_4: (+1)
   \   00000044   0x4651             MOV      R1,R10
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x.... 0x....      BL       _GetCharDistX
   \   0000004C   0x4480             ADD      R8,R0,R8
    492                    pLine     += GUI_UC_GetCharSize(pLine);
   \   0000004E   0x4650             MOV      R0,R10
   \   00000050   0x.... 0x....      BL       GUI_UC_GetCharSize
   \   00000054   0x4482             ADD      R10,R0,R10
    493                  }
   \                     ??_GetTextSizeX_3: (+1)
   \   00000056   0x4648             MOV      R0,R9
   \   00000058   0xF1A0 0x0901      SUB      R9,R0,#+1
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD1F1             BNE.N    ??_GetTextSizeX_4
    494                  if (xSizeLine > pObj->TextSizeX) {
   \   00000060   0x8970             LDRH     R0,[R6, #+10]
   \   00000062   0x4540             CMP      R0,R8
   \   00000064   0xDA01             BGE.N    ??_GetTextSizeX_5
    495                    pObj->TextSizeX = xSizeLine;
   \   00000066   0xF8A6 0x800A      STRH     R8,[R6, #+10]
    496                  }
    497                  pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
   \                     ??_GetTextSizeX_5: (+1)
   \   0000006A   0x463A             MOV      R2,R7
   \   0000006C   0x4629             MOV      R1,R5
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       _WrapGetNumBytesToNextLine
   \   00000074   0x19C7             ADDS     R7,R0,R7
    498                } while (*pText);
   \   00000076   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD1D8             BNE.N    ??_GetTextSizeX_2
    499              }
    500              pObj->InvalidFlags &= ~INVALID_TEXTSIZE;
   \                     ??_GetTextSizeX_1: (+1)
   \   0000007E   0xF895 0x0075      LDRB     R0,[R5, #+117]
   \   00000082   0xF000 0x00FB      AND      R0,R0,#0xFB
   \   00000086   0xF885 0x0075      STRB     R0,[R5, #+117]
    501            }
    502            return pObj->TextSizeX;
   \                     ??_GetTextSizeX_0: (+1)
   \   0000008A   0x8970             LDRH     R0,[R6, #+10]
   \   0000008C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    503          }
    504          
    505          /*********************************************************************
    506          *
    507          *       _GetNumVisLines
    508          */

   \                                 In section .text, align 2, keep-with-next
    509          static int _GetNumVisLines(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj) {
   \                     _GetNumVisLines: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    510            GUI_RECT Rect;
    511            WM_GetInsideRectExScrollbar(hObj, &Rect);
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    512            return (Rect.y1 - Rect.y0 + 1) / GUI_GetYDistOfFont(pObj->pFont);
   \   0000000A   0x6F20             LDR      R0,[R4, #+112]
   \   0000000C   0x.... 0x....      BL       GUI_GetYDistOfFont
   \   00000010   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000014   0xF9BD 0x2002      LDRSH    R2,[SP, #+2]
   \   00000018   0x1A89             SUBS     R1,R1,R2
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000020   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    513          }
    514          
    515          /*********************************************************************
    516          *
    517          *       _GetNumLines
    518          *
    519          * Calculates (if needed) and returns the number of lines
    520          */

   \                                 In section .text, align 2, keep-with-next
    521          static int _GetNumLines(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj) {
   \                     _GetNumLines: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    522            if (pObj->InvalidFlags & INVALID_NUMLINES) {
   \   00000008   0xF105 0x0638      ADD      R6,R5,#+56
   \   0000000C   0xF895 0x0075      LDRB     R0,[R5, #+117]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD52C             BPL.N    ??_GetNumLines_0
    523              int NumLines = 0;
   \   00000014   0x2700             MOVS     R7,#+0
    524              if (pObj->hText) {
   \   00000016   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD01F             BEQ.N    ??_GetNumLines_1
    525                int NumChars, NumBytes;
    526                char *pText;
    527                U16 Char;
    528                pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   0000001E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000022   0x4680             MOV      R8,R0
    529                GUI_SetFont(pObj->pFont);
   \   00000024   0x6BB0             LDR      R0,[R6, #+56]
   \   00000026   0x.... 0x....      BL       GUI_SetFont
    530                do {
    531                  NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
   \                     ??_GetNumLines_2: (+1)
   \   0000002A   0x4642             MOV      R2,R8
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   00000034   0x4601             MOV      R1,R0
    532                  NumBytes = GUI_UC__NumChars2NumBytes(pText, NumChars);
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
    533                  Char     = GUI_UC_GetCharCode(pText + NumBytes);
   \   0000003C   0x4440             ADD      R0,R0,R8
   \   0000003E   0x.... 0x....      BL       GUI_UC_GetCharCode
   \   00000042   0x4681             MOV      R9,R0
    534                  if (Char) {
   \   00000044   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000048   0xD000             BEQ.N    ??_GetNumLines_3
    535                    NumLines++;
   \   0000004A   0x1C7F             ADDS     R7,R7,#+1
    536                  }
    537                  pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
   \                     ??_GetNumLines_3: (+1)
   \   0000004C   0x4642             MOV      R2,R8
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       _WrapGetNumBytesToNextLine
   \   00000056   0x4480             ADD      R8,R0,R8
    538                } while (Char);
   \   00000058   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000005C   0xD1E5             BNE.N    ??_GetNumLines_2
    539              }
    540              pObj->NumLines = NumLines + 1;
   \                     ??_GetNumLines_1: (+1)
   \   0000005E   0x1C78             ADDS     R0,R7,#+1
   \   00000060   0x8130             STRH     R0,[R6, #+8]
    541              pObj->InvalidFlags &= ~INVALID_NUMLINES;
   \   00000062   0xF895 0x0075      LDRB     R0,[R5, #+117]
   \   00000066   0xF000 0x00FD      AND      R0,R0,#0xFD
   \   0000006A   0xF885 0x0075      STRB     R0,[R5, #+117]
    542            }
    543            return pObj->NumLines;
   \                     ??_GetNumLines_0: (+1)
   \   0000006E   0x8930             LDRH     R0,[R6, #+8]
   \   00000070   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    544          }
    545          
    546          /*********************************************************************
    547          *
    548          *       _InvalidateNumLines
    549          *
    550          * Invalidates the number of lines
    551          */

   \                                 In section .text, align 2, keep-with-next
    552          static void _InvalidateNumLines(MULTIEDIT_OBJ * pObj) {
    553            pObj->InvalidFlags |= INVALID_NUMLINES;
   \                     _InvalidateNumLines: (+1)
   \   00000000   0xF890 0x1075      LDRB     R1,[R0, #+117]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0xF880 0x1075      STRB     R1,[R0, #+117]
    554          }
   \   0000000C   0x4770             BX       LR               ;; return
    555          
    556          /*********************************************************************
    557          *
    558          *       _InvalidateTextSizeX
    559          *
    560          * Calculates the TextSizeX
    561          */

   \                                 In section .text, align 2, keep-with-next
    562          static void _InvalidateTextSizeX(MULTIEDIT_OBJ * pObj) {
    563            pObj->InvalidFlags |= INVALID_TEXTSIZE;
   \                     _InvalidateTextSizeX: (+1)
   \   00000000   0xF890 0x1075      LDRB     R1,[R0, #+117]
   \   00000004   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000008   0xF880 0x1075      STRB     R1,[R0, #+117]
    564          }
   \   0000000C   0x4770             BX       LR               ;; return
    565          
    566          /*********************************************************************
    567          *
    568          *       _CalcScrollParas
    569          *
    570          * Purpose:
    571          *   Calculate page size ,number of items & position
    572          */

   \                                 In section .text, align 2, keep-with-next
    573          static void _CalcScrollParas(MULTIEDIT_HANDLE hObj) {
   \                     _CalcScrollParas: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    574            MULTIEDIT_OBJ* pObj = MULTIEDIT_H2P(hObj);
   \   00000004   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000008   0x4605             MOV      R5,R0
    575            /* Calc vertical scroll parameters */
    576            pObj->ScrollStateV.NumItems = _GetNumLines(hObj, pObj);
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       _GetNumLines
   \   00000012   0x65A8             STR      R0,[R5, #+88]
    577            pObj->ScrollStateV.PageSize = _GetNumVisLines(hObj, pObj);
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _GetNumVisLines
   \   0000001C   0x6628             STR      R0,[R5, #+96]
    578            /* Calc horizontal scroll parameters */
    579            pObj->ScrollStateH.NumItems = _GetTextSizeX(hObj, pObj);
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _GetTextSizeX
   \   00000026   0x6668             STR      R0,[R5, #+100]
    580            pObj->ScrollStateH.PageSize = _GetXSize(hObj, pObj);
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _GetXSize
   \   00000030   0x66E8             STR      R0,[R5, #+108]
    581            _CalcScrollPos(hObj, pObj);
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000003A   0x....             B.N      _CalcScrollPos
    582          }
    583          
    584          /*********************************************************************
    585          *
    586          *       _ManageAutoScrollV
    587          */

   \                                 In section .text, align 2, keep-with-next
    588          static void _ManageAutoScrollV(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _ManageAutoScrollV: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    589            if (pObj->Flags & MULTIEDIT_SF_AUTOSCROLLBAR_V) {
   \   00000006   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0xD51F             BPL.N    ??_ManageAutoScrollV_0
    590              char IsRequired = _GetNumVisLines(hObj, pObj) < _GetNumLines(hObj, pObj);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _GetNumVisLines
   \   00000014   0x4606             MOV      R6,R0
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _GetNumLines
   \   0000001E   0x4286             CMP      R6,R0
   \   00000020   0xDA01             BGE.N    ??_ManageAutoScrollV_1
   \   00000022   0x2601             MOVS     R6,#+1
   \   00000024   0xE000             B.N      ??_ManageAutoScrollV_2
   \                     ??_ManageAutoScrollV_1: (+1)
   \   00000026   0x2600             MOVS     R6,#+0
    591              if (WM_SetScrollbarV(hObj, IsRequired) != IsRequired) {
   \                     ??_ManageAutoScrollV_2: (+1)
   \   00000028   0x4631             MOV      R1,R6
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       WM_SetScrollbarV
   \   00000030   0x42B0             CMP      R0,R6
   \   00000032   0xD00C             BEQ.N    ??_ManageAutoScrollV_0
    592                _InvalidateNumLines(pObj);
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       _InvalidateNumLines
    593                _InvalidateTextSizeX(pObj);
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       _InvalidateTextSizeX
    594                _InvalidateCursorXY(pObj);
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x.... 0x....      BL       _InvalidateCursorXY
    595                _ClearCache(pObj);
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004C   0x....             B.N      _ClearCache
    596              }
    597            }
    598          }
   \                     ??_ManageAutoScrollV_0: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    599          
    600          /*********************************************************************
    601          *
    602          *       _ManageScrollers
    603          *
    604          * Function:
    605          * If autoscroll mode is enabled, add or remove the horizonatal and
    606          * vertical scrollbars as required.
    607          * Caution: This routine should not be called as reaction to a message
    608          * From the child, as this could lead to a recursion problem
    609          */

   \                                 In section .text, align 2, keep-with-next
    610          static void _ManageScrollers(MULTIEDIT_HANDLE hObj) {
   \                     _ManageScrollers: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    611            MULTIEDIT_OBJ* pObj;
    612            pObj = MULTIEDIT_H2P(hObj);
   \   00000004   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000008   0x4605             MOV      R5,R0
    613            /* 1. Step: Check if vertical scrollbar is required */
    614            _ManageAutoScrollV(hObj, pObj);
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       _ManageAutoScrollV
    615            /* 2. Step: Check if horizontal scrollbar is required */
    616            if (pObj->Flags & MULTIEDIT_SF_AUTOSCROLLBAR_H) {
   \   00000012   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   00000016   0x06C0             LSLS     R0,R0,#+27
   \   00000018   0xD517             BPL.N    ??_ManageScrollers_0
    617              char IsRequired;
    618              IsRequired = (_GetXSize(hObj, pObj) < _GetTextSizeX(hObj, pObj));
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _GetXSize
   \   00000022   0x4606             MOV      R6,R0
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _GetTextSizeX
   \   0000002C   0x4286             CMP      R6,R0
   \   0000002E   0xDA01             BGE.N    ??_ManageScrollers_1
   \   00000030   0x2601             MOVS     R6,#+1
   \   00000032   0xE000             B.N      ??_ManageScrollers_2
   \                     ??_ManageScrollers_1: (+1)
   \   00000034   0x2600             MOVS     R6,#+0
    619              if (WM_SetScrollbarH(hObj, IsRequired) != IsRequired) {
   \                     ??_ManageScrollers_2: (+1)
   \   00000036   0x4631             MOV      R1,R6
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       WM_SetScrollbarH
   \   0000003E   0x42B0             CMP      R0,R6
   \   00000040   0xD003             BEQ.N    ??_ManageScrollers_0
    620                /* 3. Step: Check vertical scrollbar again if horizontal has changed */
    621                _ManageAutoScrollV(hObj, pObj);
   \   00000042   0x4629             MOV      R1,R5
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       _ManageAutoScrollV
    622              }
    623            }
    624            _CalcScrollParas(hObj);
   \                     ??_ManageScrollers_0: (+1)
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000050   0x....             B.N      _CalcScrollParas
    625          }
    626          
    627          /*********************************************************************
    628          *
    629          *       _Invalidate
    630          */

   \                                 In section .text, align 2, keep-with-next
    631          static void _Invalidate(MULTIEDIT_HANDLE hObj) {
   \                     _Invalidate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    632            _ManageScrollers(hObj);
   \   00000004   0x.... 0x....      BL       _ManageScrollers
    633            WM_Invalidate(hObj);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000000E   0x.... 0x....      B.W      WM_InvalidateWindow
    634          }
    635          
    636          /*********************************************************************
    637          *
    638          *       _InvalidateTextArea
    639          *
    640          * Invalidates the text area only
    641          */

   \                                 In section .text, align 2, keep-with-next
    642          static void _InvalidateTextArea(MULTIEDIT_HANDLE hObj) {
   \                     _InvalidateTextArea: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    643            GUI_RECT rInsideRect;
    644            _ManageScrollers(hObj);
   \   00000004   0x.... 0x....      BL       _ManageScrollers
    645            WM_GetInsideRectExScrollbar(hObj, &rInsideRect);
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       WM_GetInsideRectExScrollbar
    646            WM_InvalidateRect(hObj, &rInsideRect);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       WM_InvalidateRect
    647          }
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    648          
    649          /*********************************************************************
    650          *
    651          *       _InvalidateCursorPos
    652          *
    653          * Sets the position of the cursor to an invalid value
    654          */

   \                                 In section .text, align 2, keep-with-next
    655          static int _InvalidateCursorPos(MULTIEDIT_OBJ * pObj) {
    656            int Value;
    657            Value = pObj->CursorPosChar;
   \                     _InvalidateCursorPos: (+1)
   \   00000000   0xF8B0 0x1048      LDRH     R1,[R0, #+72]
    658            pObj->CursorPosChar = 0xffff;
   \   00000004   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000008   0xF8A0 0x2048      STRH     R2,[R0, #+72]
    659            return Value;
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    660          }
    661          
    662          /*********************************************************************
    663          *
    664          *       _SetFlag
    665          */

   \                                 In section .text, align 2, keep-with-next
    666          static void _SetFlag(MULTIEDIT_HANDLE hObj, int OnOff, U8 Flag) {
   \                     _SetFlag: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    667            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD010             BEQ.N    ??_SetFlag_0
    668              MULTIEDIT_OBJ * pObj;
    669              WM_LOCK();
    670              pObj = MULTIEDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    671              if (OnOff) {
   \   00000010   0xF890 0x1074      LDRB     R1,[R0, #+116]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD003             BEQ.N    ??_SetFlag_1
    672                pObj->Flags |= Flag;
   \   00000018   0x4331             ORRS     R1,R6,R1
   \   0000001A   0xF880 0x1074      STRB     R1,[R0, #+116]
   \   0000001E   0xE002             B.N      ??_SetFlag_2
    673              } else {
    674                pObj->Flags &= ~Flag;
   \                     ??_SetFlag_1: (+1)
   \   00000020   0x43B1             BICS     R1,R1,R6
   \   00000022   0xF880 0x1074      STRB     R1,[R0, #+116]
    675              }
    676              _InvalidateTextArea(hObj);
   \                     ??_SetFlag_2: (+1)
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002C   0x....             B.N      _InvalidateTextArea
    677              WM_UNLOCK();
    678            }
    679          }
   \                     ??_SetFlag_0: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    680          
    681          /*********************************************************************
    682          *
    683          *       _CalcNextValidCursorPos
    684          *
    685          * Purpose:
    686          *   Calculates the next valid cursor position of the desired position.
    687          *
    688          * Parameters:
    689          *   hObj, pObj    : Obvious
    690          *   CursorPosChar : New character position of the cursor
    691          *   pCursorPosByte: Pointer to save the cursorposition in bytes. Used to abolish further calculations. Could be 0.
    692          *   pCursorLine   : Pointer to save the line number of the cursor. Used to abolish further calculations. Could be 0.
    693          */

   \                                 In section .text, align 2, keep-with-next
    694          static int _CalcNextValidCursorPos(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, int CursorPosChar, int * pCursorPosByte, int * pCursorLine) {
   \                     _CalcNextValidCursorPos: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x461E             MOV      R6,R3
    695            if (pObj->hText) {
   \   0000000C   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD055             BEQ.N    ??_CalcNextValidCursorPos_0
    696              char *pNextLine, *pCursor, *pText;
    697              int CursorLine, NumChars, CursorPosByte;
    698              pText    = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000014   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000018   0x4607             MOV      R7,R0
    699              NumChars = _GetNumChars(pObj);
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       _GetNumChars
    700              /* Set offset in valid range */
    701              if (CursorPosChar < pObj->NumCharsPrompt) {
   \   00000020   0xF105 0x0838      ADD      R8,R5,#+56
   \   00000024   0xF8B8 0x1006      LDRH     R1,[R8, #+6]
   \   00000028   0x4589             CMP      R9,R1
   \   0000002A   0xDA00             BGE.N    ??_CalcNextValidCursorPos_1
    702                CursorPosChar = pObj->NumCharsPrompt;
   \   0000002C   0x4689             MOV      R9,R1
    703              }
    704              if (CursorPosChar > NumChars) {
   \                     ??_CalcNextValidCursorPos_1: (+1)
   \   0000002E   0x4548             CMP      R0,R9
   \   00000030   0xDC00             BGT.N    ??_CalcNextValidCursorPos_2
   \   00000032   0x4681             MOV      R9,R0
    705                CursorPosChar = NumChars;
    706              }
    707              CursorPosByte = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
   \                     ??_CalcNextValidCursorPos_2: (+1)
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000003C   0x4682             MOV      R10,R0
    708              CursorLine    = _GetCursorLine(hObj, pObj, pText, CursorPosChar);
   \   0000003E   0x464B             MOV      R3,R9
   \   00000040   0x463A             MOV      R2,R7
   \   00000042   0x4629             MOV      R1,R5
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       _GetCursorLine
   \   0000004A   0x4683             MOV      R11,R0
    709              pCursor       = pText + CursorPosByte;
    710              pNextLine     = _GetpLine(hObj, pObj, CursorLine);
   \   0000004C   0x465A             MOV      R2,R11
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       _GetpLine
    711              if (pNextLine > pCursor) {
   \   00000056   0xEB0A 0x0107      ADD      R1,R10,R7
   \   0000005A   0x4281             CMP      R1,R0
   \   0000005C   0xD225             BCS.N    ??_CalcNextValidCursorPos_3
    712                if (pObj->CursorPosChar < CursorPosChar) {
   \   0000005E   0xF8B8 0x1010      LDRH     R1,[R8, #+16]
   \   00000062   0x4549             CMP      R1,R9
   \   00000064   0xDB10             BLT.N    ??_CalcNextValidCursorPos_4
    713                  pCursor = pNextLine;
    714                } else {
    715                  char *pPrevLine;
    716                  int NumChars;
    717                  pPrevLine  = _GetpLine(hObj, pObj, CursorLine - 1);
   \   00000066   0xF1AB 0x0201      SUB      R2,R11,#+1
   \   0000006A   0x4629             MOV      R1,R5
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       _GetpLine
   \   00000072   0x4680             MOV      R8,R0
    718                  NumChars   = _WrapGetNumCharsDisp(hObj, pObj, pPrevLine);
   \   00000074   0x4642             MOV      R2,R8
   \   00000076   0x4629             MOV      R1,R5
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   0000007E   0x4601             MOV      R1,R0
    719                  pPrevLine += GUI_UC__NumChars2NumBytes(pPrevLine, NumChars);
   \   00000080   0x4640             MOV      R0,R8
   \   00000082   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000086   0x4440             ADD      R0,R0,R8
    720                  pCursor = pPrevLine;
    721                }
    722                CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pCursor - pText);
   \                     ??_CalcNextValidCursorPos_4: (+1)
   \   00000088   0x1BC1             SUBS     R1,R0,R7
   \   0000008A   0x4638             MOV      R0,R7
   \   0000008C   0x.... 0x....      BL       GUI_UC__NumBytes2NumChars
   \   00000090   0x4681             MOV      R9,R0
    723                CursorPosByte = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
   \   00000092   0x4649             MOV      R1,R9
   \   00000094   0x4638             MOV      R0,R7
   \   00000096   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000009A   0x4682             MOV      R10,R0
    724                CursorLine    = _GetCursorLine(hObj, pObj, pText, CursorPosChar);
   \   0000009C   0x464B             MOV      R3,R9
   \   0000009E   0x463A             MOV      R2,R7
   \   000000A0   0x4629             MOV      R1,R5
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       _GetCursorLine
   \   000000A8   0x4683             MOV      R11,R0
    725              }
    726              if (pCursorPosByte) {
   \                     ??_CalcNextValidCursorPos_3: (+1)
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD001             BEQ.N    ??_CalcNextValidCursorPos_5
    727                *pCursorPosByte = CursorPosByte;
   \   000000AE   0xF8C6 0xA000      STR      R10,[R6, #+0]
   \                     ??_CalcNextValidCursorPos_5: (+1)
   \   000000B2   0x980A             LDR      R0,[SP, #+40]
    728              }
    729              if (pCursorLine) {
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD001             BEQ.N    ??_CalcNextValidCursorPos_6
    730                *pCursorLine = CursorLine;
   \   000000B8   0xF8C0 0xB000      STR      R11,[R0, #+0]
    731              }
    732              return CursorPosChar;
   \                     ??_CalcNextValidCursorPos_6: (+1)
   \   000000BC   0x4648             MOV      R0,R9
   \   000000BE   0xE000             B.N      ??_CalcNextValidCursorPos_7
    733            }
    734            return 0;
   \                     ??_CalcNextValidCursorPos_0: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \                     ??_CalcNextValidCursorPos_7: (+1)
   \   000000C2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    735          }
    736          
    737          /*********************************************************************
    738          *
    739          *       _SetCursorPos
    740          *
    741          * Sets a new cursor position.
    742          */

   \                                 In section .text, align 2, keep-with-next
    743          static void _SetCursorPos(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, int CursorPosChar) {
   \                     _SetCursorPos: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    744            int CursorPosByte, CursorLine;
    745            CursorPosChar = _CalcNextValidCursorPos(hObj, pObj, CursorPosChar, &CursorPosByte, &CursorLine);
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0xAB02             ADD      R3,SP,#+8
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       _CalcNextValidCursorPos
    746            /* Assign value and recalc whatever necessary */
    747            if (pObj->CursorPosChar != CursorPosChar) {
   \   00000012   0xF205 0x0146      ADDW     R1,R5,#+70
   \   00000016   0x884A             LDRH     R2,[R1, #+2]
   \   00000018   0x4282             CMP      R2,R0
   \   0000001A   0xD00C             BEQ.N    ??_SetCursorPos_0
    748              /* Save values */
    749              pObj->CursorPosByte = CursorPosByte;
   \   0000001C   0x9A02             LDR      R2,[SP, #+8]
   \   0000001E   0x808A             STRH     R2,[R1, #+4]
    750              pObj->CursorPosChar = CursorPosChar;
   \   00000020   0x8048             STRH     R0,[R1, #+2]
    751              pObj->CursorLine = CursorLine;
   \   00000022   0x9801             LDR      R0,[SP, #+4]
   \   00000024   0xF8A5 0x0046      STRH     R0,[R5, #+70]
    752              _InvalidateCursorXY(pObj); /* Invalidate X/Y position */
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       _InvalidateCursorXY
    753              _CalcScrollPos(hObj, pObj);
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       _CalcScrollPos
    754            }
    755          }
   \                     ??_SetCursorPos_0: (+1)
   \   00000036   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    756          
    757          /*********************************************************************
    758          *
    759          *       _SetWrapMode
    760          */

   \                                 In section .text, align 2, keep-with-next
    761          static int _SetWrapMode(MULTIEDIT_HANDLE hObj, GUI_WRAPMODE WrapMode) {
   \                     _SetWrapMode: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    762            int r;
    763            r = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    764            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD01D             BEQ.N    ??_SetWrapMode_0
    765              MULTIEDIT_OBJ * pObj;
    766              WM_LOCK();
    767              pObj = MULTIEDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4607             MOV      R7,R0
    768              r = pObj->WrapMode;
   \   00000012   0xF997 0x6078      LDRSB    R6,[R7, #+120]
    769              if (pObj->WrapMode != WrapMode) {
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x42A8             CMP      R0,R5
   \   0000001A   0xD015             BEQ.N    ??_SetWrapMode_0
    770                int Position;
    771                pObj->WrapMode = WrapMode;
   \   0000001C   0xF887 0x5078      STRB     R5,[R7, #+120]
    772                _ClearCache(pObj);
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0x.... 0x....      BL       _ClearCache
    773                _InvalidateNumLines(pObj);
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       _InvalidateNumLines
    774                _InvalidateTextSizeX(pObj);
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0x.... 0x....      BL       _InvalidateTextSizeX
    775                _InvalidateTextArea(hObj);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       _InvalidateTextArea
    776                Position = _InvalidateCursorPos(pObj);
   \   00000038   0x4638             MOV      R0,R7
   \   0000003A   0x.... 0x....      BL       _InvalidateCursorPos
    777                _SetCursorPos(hObj, pObj, Position);
   \   0000003E   0x4602             MOV      R2,R0
   \   00000040   0x4639             MOV      R1,R7
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _SetCursorPos
    778              }
    779              WM_UNLOCK();
    780            }
    781            return r;
   \                     ??_SetWrapMode_0: (+1)
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    782          }
    783          
    784          /*********************************************************************
    785          *
    786          *       _SetCursorXY
    787          *
    788          * Sets the cursor position from window coordinates.
    789          */

   \                                 In section .text, align 2, keep-with-next
    790          static void _SetCursorXY(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, int x, int y) {
   \                     _SetCursorXY: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
    791            int CursorPosChar = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
    792            if ((x < 0) || (y < 0)) {
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD465             BMI.N    ??_SetCursorXY_0
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xD462             BMI.N    ??_SetCursorXY_0
    793              return;
    794            }
    795            if (pObj->hText) {
   \   00000018   0xF9B5 0x1038      LDRSH    R1,[R5, #+56]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD058             BEQ.N    ??_SetCursorXY_1
    796              char *pLine, *pText;
    797              int CursorLine, WrapChars;
    798              int SizeX = 0;
   \   00000020   0x4607             MOV      R7,R0
    799              U16 Char;
    800              GUI_SetFont(pObj->pFont);
   \   00000022   0x6F28             LDR      R0,[R5, #+112]
   \   00000024   0x.... 0x....      BL       GUI_SetFont
    801              CursorLine = y / GUI_GetFontDistY();
   \   00000028   0x.... 0x....      BL       GUI_GetFontDistY
   \   0000002C   0xFB98 0xF2F0      SDIV     R2,R8,R0
    802              pLine      = _GetpLine(hObj, pObj, CursorLine);
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       _GetpLine
   \   00000038   0x4680             MOV      R8,R0
    803              pText      = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   0000003A   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   0000003E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000042   0x4681             MOV      R9,R0
    804              WrapChars  = _WrapGetNumCharsDisp(hObj, pObj, pLine);
   \   00000044   0x4642             MOV      R2,R8
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   0000004E   0x4682             MOV      R10,R0
    805              Char       = GUI_UC__GetCharCode(pLine + GUI_UC__NumChars2NumBytes(pLine, WrapChars));
   \   00000050   0x4651             MOV      R1,R10
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000058   0x4440             ADD      R0,R0,R8
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable1
   \   0000005E   0x69C9             LDR      R1,[R1, #+28]
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x4788             BLX      R1
   \   00000064   0x4683             MOV      R11,R0
    806              if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000066   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   0000006A   0x0680             LSLS     R0,R0,#+26
   \   0000006C   0xD505             BPL.N    ??_SetCursorXY_2
    807                if (!Char) {
   \   0000006E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000072   0xD116             BNE.N    ??_SetCursorXY_3
    808                  WrapChars++;
   \   00000074   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   00000078   0xE013             B.N      ??_SetCursorXY_3
    809                }
    810              } else {
    811                if (!Char || (Char == '\n') || ((Char == ' ') && (pObj->WrapMode == GUI_WRAPMODE_WORD))) {
   \                     ??_SetCursorXY_2: (+1)
   \   0000007A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000007E   0xD009             BEQ.N    ??_SetCursorXY_4
   \   00000080   0xF1BB 0x0F0A      CMP      R11,#+10
   \   00000084   0xD006             BEQ.N    ??_SetCursorXY_4
   \   00000086   0xF1BB 0x0F20      CMP      R11,#+32
   \   0000008A   0xD10A             BNE.N    ??_SetCursorXY_3
   \   0000008C   0xF995 0x0078      LDRSB    R0,[R5, #+120]
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD106             BNE.N    ??_SetCursorXY_3
    812                  WrapChars++;
   \                     ??_SetCursorXY_4: (+1)
   \   00000094   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   00000098   0xE003             B.N      ??_SetCursorXY_3
    813                }
    814              }
    815              while (--WrapChars > 0) {
    816                Char   = GUI_UC_GetCharCode(pLine);
    817                SizeX += _GetCharDistX(pObj, pLine);
    818                if (!Char || (SizeX > x)) {
    819                  break;
    820                }
    821                pLine += GUI_UC_GetCharSize(pLine);
   \                     ??_SetCursorXY_5: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0x.... 0x....      BL       GUI_UC_GetCharSize
   \   000000A0   0x4480             ADD      R8,R0,R8
   \                     ??_SetCursorXY_3: (+1)
   \   000000A2   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \   000000A6   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000AA   0xDB0D             BLT.N    ??_SetCursorXY_6
   \   000000AC   0x4640             MOV      R0,R8
   \   000000AE   0x.... 0x....      BL       GUI_UC_GetCharCode
   \   000000B2   0x4683             MOV      R11,R0
   \   000000B4   0x4641             MOV      R1,R8
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x.... 0x....      BL       _GetCharDistX
   \   000000BC   0x19C7             ADDS     R7,R0,R7
   \   000000BE   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000C2   0xD001             BEQ.N    ??_SetCursorXY_6
   \   000000C4   0x42BE             CMP      R6,R7
   \   000000C6   0xDAE8             BGE.N    ??_SetCursorXY_5
    822              }
    823              CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pLine - pText);
   \                     ??_SetCursorXY_6: (+1)
   \   000000C8   0xEBA8 0x0109      SUB      R1,R8,R9
   \   000000CC   0x4648             MOV      R0,R9
   \   000000CE   0x.... 0x....      BL       GUI_UC__NumBytes2NumChars
    824            }
    825            _SetCursorPos(hObj, pObj, CursorPosChar);
   \                     ??_SetCursorXY_1: (+1)
   \   000000D2   0x4602             MOV      R2,R0
   \   000000D4   0x4629             MOV      R1,R5
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0xE8BD 0x4FF8      POP      {R3-R11,LR}
   \   000000DC   0x....             B.N      _SetCursorPos
   \                     ??_SetCursorXY_0: (+1)
   \   000000DE   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    826          }
    827          
    828          /*********************************************************************
    829          *
    830          *       _MoveCursorUp
    831          */

   \                                 In section .text, align 2, keep-with-next
    832          static void _MoveCursorUp(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _MoveCursorUp: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    833            int xPos, yPos;
    834            _GetCursorXY(hObj, pObj, &xPos, &yPos);
   \   00000008   0xAB00             ADD      R3,SP,#+0
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x.... 0x....      BL       _GetCursorXY
    835            yPos -= GUI_GetYDistOfFont(pObj->pFont);
   \   00000010   0x6F28             LDR      R0,[R5, #+112]
   \   00000012   0x.... 0x....      BL       GUI_GetYDistOfFont
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x1A08             SUBS     R0,R1,R0
   \   0000001A   0x9000             STR      R0,[SP, #+0]
    836            _SetCursorXY(hObj, pObj, xPos, yPos);
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0x9A01             LDR      R2,[SP, #+4]
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _SetCursorXY
    837          }
   \   00000028   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    838          
    839          /*********************************************************************
    840          *
    841          *       _MoveCursorDown
    842          */

   \                                 In section .text, align 2, keep-with-next
    843          static void _MoveCursorDown(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _MoveCursorDown: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    844            int xPos, yPos;
    845            _GetCursorXY(hObj, pObj, &xPos, &yPos);
   \   00000008   0xAB00             ADD      R3,SP,#+0
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x.... 0x....      BL       _GetCursorXY
    846            yPos += GUI_GetYDistOfFont(pObj->pFont);
   \   00000010   0x6F28             LDR      R0,[R5, #+112]
   \   00000012   0x.... 0x....      BL       GUI_GetYDistOfFont
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x1840             ADDS     R0,R0,R1
   \   0000001A   0x9000             STR      R0,[SP, #+0]
    847            _SetCursorXY(hObj, pObj, xPos, yPos);
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0x9A01             LDR      R2,[SP, #+4]
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _SetCursorXY
    848          }
   \   00000028   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    849          
    850          /*********************************************************************
    851          *
    852          *       _MoveCursor2NextLine
    853          */

   \                                 In section .text, align 2, keep-with-next
    854          static void _MoveCursor2NextLine(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _MoveCursor2NextLine: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    855            int xPos, yPos;
    856            _GetCursorXY(hObj, pObj, &xPos, &yPos);
   \   00000008   0xAB00             ADD      R3,SP,#+0
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x.... 0x....      BL       _GetCursorXY
    857            yPos += GUI_GetYDistOfFont(pObj->pFont);
   \   00000010   0x6F28             LDR      R0,[R5, #+112]
   \   00000012   0x.... 0x....      BL       GUI_GetYDistOfFont
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x1840             ADDS     R0,R0,R1
   \   0000001A   0x9000             STR      R0,[SP, #+0]
    858            _SetCursorXY(hObj, pObj, 0, yPos);
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _SetCursorXY
    859          }
   \   00000028   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    860          
    861          /*********************************************************************
    862          *
    863          *       _MoveCursor2LineEnd
    864          */

   \                                 In section .text, align 2, keep-with-next
    865          static void _MoveCursor2LineEnd(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _MoveCursor2LineEnd: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    866            int xPos, yPos;
    867            _GetCursorXY(hObj, pObj, &xPos, &yPos);
   \   00000008   0xAB00             ADD      R3,SP,#+0
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x.... 0x....      BL       _GetCursorXY
    868            _SetCursorXY(hObj, pObj, 0x7FFF, yPos);
   \   00000010   0x9B00             LDR      R3,[SP, #+0]
   \   00000012   0xF647 0x72FF      MOVW     R2,#+32767
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _SetCursorXY
    869          }
   \   0000001E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    870          
    871          /*********************************************************************
    872          *
    873          *       _MoveCursor2LinePos1
    874          */

   \                                 In section .text, align 2, keep-with-next
    875          static void _MoveCursor2LinePos1(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _MoveCursor2LinePos1: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    876            int xPos, yPos;
    877            _GetCursorXY(hObj, pObj, &xPos, &yPos);
   \   00000008   0xAB00             ADD      R3,SP,#+0
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x.... 0x....      BL       _GetCursorXY
    878            _SetCursorXY(hObj, pObj, 0, yPos);
   \   00000010   0x9B00             LDR      R3,[SP, #+0]
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _SetCursorXY
    879          }
   \   0000001C   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    880          
    881          /*********************************************************************
    882          *
    883          *       _IsOverwriteAtThisChar
    884          */

   \                                 In section .text, align 2, keep-with-next
    885          static int _IsOverwriteAtThisChar(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _IsOverwriteAtThisChar: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460C             MOV      R4,R1
    886            int r = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    887            if (pObj->hText && !(pObj->Flags & MULTIEDIT_CF_INSERT)) {
   \   0000000A   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD031             BEQ.N    ??_IsOverwriteAtThisChar_0
   \   00000012   0xF894 0x1074      LDRB     R1,[R4, #+116]
   \   00000016   0x0749             LSLS     R1,R1,#+29
   \   00000018   0xD42D             BMI.N    ??_IsOverwriteAtThisChar_0
    888              const char *pText;
    889              int CurPos, Line1, Line2;
    890              U16 Char;
    891              pText  = (const char *)GUI_ALLOC_h2p(pObj->hText);
   \   0000001A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001E   0x4680             MOV      R8,R0
    892              Line1  = pObj->CursorLine;
   \   00000020   0xF104 0x0938      ADD      R9,R4,#+56
   \   00000024   0xF8B9 0x700E      LDRH     R7,[R9, #+14]
    893              CurPos = _CalcNextValidCursorPos(hObj, pObj, pObj->CursorPosChar + 1, 0, 0);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x4603             MOV      R3,R0
   \   0000002E   0xF8B9 0x0010      LDRH     R0,[R9, #+16]
   \   00000032   0x1C42             ADDS     R2,R0,#+1
   \   00000034   0x4621             MOV      R1,R4
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       _CalcNextValidCursorPos
   \   0000003C   0x4603             MOV      R3,R0
    894              Line2  = _GetCursorLine(hObj, pObj, pText, CurPos);
   \   0000003E   0x4642             MOV      R2,R8
   \   00000040   0x4621             MOV      R1,R4
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       _GetCursorLine
   \   00000048   0x4606             MOV      R6,R0
    895              pText += pObj->CursorPosByte;
    896              Char   = GUI_UC_GetCharCode(pText);
   \   0000004A   0xF8B9 0x0012      LDRH     R0,[R9, #+18]
   \   0000004E   0x4440             ADD      R0,R0,R8
   \   00000050   0x.... 0x....      BL       GUI_UC_GetCharCode
    897              if (Char) {
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD00E             BEQ.N    ??_IsOverwriteAtThisChar_0
    898                if ((Line1 == Line2) || (pObj->Flags & MULTIEDIT_SF_PASSWORD)) {
   \   00000058   0x42B7             CMP      R7,R6
   \   0000005A   0xD00B             BEQ.N    ??_IsOverwriteAtThisChar_1
   \   0000005C   0xF894 0x1074      LDRB     R1,[R4, #+116]
   \   00000060   0x0689             LSLS     R1,R1,#+26
   \   00000062   0xD407             BMI.N    ??_IsOverwriteAtThisChar_1
    899                  r = 1;
    900                } else {
    901                  if (Char != '\n') {
   \   00000064   0x280A             CMP      R0,#+10
   \   00000066   0xD006             BEQ.N    ??_IsOverwriteAtThisChar_0
    902                    if ((Char != ' ') || (pObj->WrapMode == GUI_WRAPMODE_CHAR)) {
   \   00000068   0x2820             CMP      R0,#+32
   \   0000006A   0xD103             BNE.N    ??_IsOverwriteAtThisChar_1
   \   0000006C   0xF994 0x0078      LDRSB    R0,[R4, #+120]
   \   00000070   0x2802             CMP      R0,#+2
   \   00000072   0xD100             BNE.N    ??_IsOverwriteAtThisChar_0
    903                      r = 1;
   \                     ??_IsOverwriteAtThisChar_1: (+1)
   \   00000074   0x2501             MOVS     R5,#+1
    904                    }
    905                  }
    906                }
    907              }
    908            }
    909            return r;
   \                     ??_IsOverwriteAtThisChar_0: (+1)
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    910          }
    911          
    912          /*********************************************************************
    913          *
    914          *       _GetCursorSizeX
    915          *
    916          * Returns the width of the cursor to be draw according to the
    917          * insert mode flag and the cursor position.
    918          */

   \                                 In section .text, align 2, keep-with-next
    919          static int _GetCursorSizeX(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _GetCursorSizeX: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    920            if (_IsOverwriteAtThisChar(hObj, pObj)) {
   \   00000004   0x.... 0x....      BL       _IsOverwriteAtThisChar
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00B             BEQ.N    ??_GetCursorSizeX_0
    921              const char *pText;
    922              pText  = (const char *)GUI_ALLOC_h2p(pObj->hText);
   \   0000000C   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
    923              pText += pObj->CursorPosByte;
    924              return _GetCharDistX(pObj, pText);
   \   00000014   0xF8B4 0x104A      LDRH     R1,[R4, #+74]
   \   00000018   0x1809             ADDS     R1,R1,R0
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x.... 0x....      B.W      _GetCharDistX
    925            } else {
    926              return 2;
   \                     ??_GetCursorSizeX_0: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    927            }
    928          }
    929          
    930          /*********************************************************************
    931          *
    932          *       static code, buffer management
    933          *
    934          **********************************************************************
    935          */
    936          /*********************************************************************
    937          *
    938          *       _IncrementBuffer
    939          *
    940          * Increments the buffer size by AddBytes.
    941          */

   \                                 In section .text, align 2, keep-with-next
    942          static int _IncrementBuffer(MULTIEDIT_OBJ* pObj, unsigned AddBytes) {
   \                     _IncrementBuffer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    943            WM_HMEM hNew;
    944            int NewSize;
    945            NewSize = pObj->BufferSize + AddBytes;
   \   00000004   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000008   0x89A8             LDRH     R0,[R5, #+12]
   \   0000000A   0x180E             ADDS     R6,R1,R0
    946            hNew    = GUI_ALLOC_Realloc(pObj->hText, NewSize);
   \   0000000C   0x4631             MOV      R1,R6
   \   0000000E   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_Realloc
   \   00000016   0x0007             MOVS     R7,R0
    947            if (hNew) {
   \   00000018   0xD00C             BEQ.N    ??_IncrementBuffer_0
    948              if (!(pObj->hText)) {
   \   0000001A   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD104             BNE.N    ??_IncrementBuffer_1
    949                char* pText;
    950                pText  = (char*) GUI_ALLOC_h2p(hNew);
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x.... 0x....      BL       GUI_ALLOC_h2p
    951                *pText = 0;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7001             STRB     R1,[R0, #+0]
    952              }
    953              pObj->BufferSize = NewSize;
   \                     ??_IncrementBuffer_1: (+1)
   \   0000002C   0x81AE             STRH     R6,[R5, #+12]
    954              pObj->hText = hNew;
   \   0000002E   0x8727             STRH     R7,[R4, #+56]
    955              return 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
    956            }
    957            return 0;
   \                     ??_IncrementBuffer_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    958          }
    959          
    960          /*********************************************************************
    961          *
    962          *       _IsSpaceInBuffer
    963          *
    964          * Checks the available space in the buffer. If there is not enough
    965          * space left this function attempts to get more.
    966          *
    967          * Returns:
    968          *  1 = requested space is available
    969          *  0 = failed to get enough space
    970          */

   \                                 In section .text, align 2, keep-with-next
    971          static int _IsSpaceInBuffer(MULTIEDIT_OBJ* pObj, int BytesNeeded) {
   \                     _IsSpaceInBuffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    972            int NumBytes = 0;
   \   00000006   0x2100             MOVS     R1,#+0
    973            if (pObj->hText) {
   \   00000008   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??_IsSpaceInBuffer_0
    974              NumBytes = strlen((char*)GUI_ALLOC_h2p(pObj->hText));
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x.... 0x....      BL       strlen
   \   00000018   0x4601             MOV      R1,R0
    975            }
    976            BytesNeeded = (BytesNeeded + NumBytes + 1) - pObj->BufferSize;
   \                     ??_IsSpaceInBuffer_0: (+1)
   \   0000001A   0x1948             ADDS     R0,R1,R5
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0xF8B4 0x1044      LDRH     R1,[R4, #+68]
   \   00000022   0x1A40             SUBS     R0,R0,R1
    977            if (BytesNeeded > 0) {
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xDB08             BLT.N    ??_IsSpaceInBuffer_1
    978              if (!_IncrementBuffer(pObj, BytesNeeded + MULTIEDIT_REALLOC_SIZE)) {
   \   00000028   0xF100 0x0110      ADD      R1,R0,#+16
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _IncrementBuffer
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD101             BNE.N    ??_IsSpaceInBuffer_1
    979                return 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
    980              }
    981            }
    982            return 1;
   \                     ??_IsSpaceInBuffer_1: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    983          }
    984          
    985          /*********************************************************************
    986          *
    987          *       _IsCharsAvailable
    988          *
    989          * Checks weither the maximum number of characters is reached or not.
    990          *
    991          * Returns:
    992          *  1 = requested number of chars is available
    993          *  0 = maximum number of chars have reached
    994          */

   \                                 In section .text, align 2, keep-with-next
    995          static int _IsCharsAvailable(MULTIEDIT_OBJ* pObj, int CharsNeeded) {
   \                     _IsCharsAvailable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    996            if ((CharsNeeded > 0) && (pObj->MaxNumChars > 0)) {
   \   00000006   0x2D01             CMP      R5,#+1
   \   00000008   0xDB10             BLT.N    ??_IsCharsAvailable_0
   \   0000000A   0x8F60             LDRH     R0,[R4, #+58]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00D             BEQ.N    ??_IsCharsAvailable_0
    997              int NumChars = 0;
   \   00000010   0x2000             MOVS     R0,#+0
    998              if (pObj->hText) {
   \   00000012   0xF9B4 0x1038      LDRSH    R1,[R4, #+56]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD002             BEQ.N    ??_IsCharsAvailable_1
    999                NumChars = _GetNumChars(pObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _GetNumChars
   1000              }
   1001              if ((CharsNeeded + NumChars) > pObj->MaxNumChars) {
   \                     ??_IsCharsAvailable_1: (+1)
   \   00000020   0x8F61             LDRH     R1,[R4, #+58]
   \   00000022   0x1940             ADDS     R0,R0,R5
   \   00000024   0x4281             CMP      R1,R0
   \   00000026   0xDA01             BGE.N    ??_IsCharsAvailable_0
   1002                return 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
   1003              }
   1004            }
   1005            return 1;
   \                     ??_IsCharsAvailable_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1006          }
   1007          
   1008          /*********************************************************************
   1009          *
   1010          *       static code, string manipulation routines
   1011          *
   1012          **********************************************************************
   1013          */
   1014          /*********************************************************************
   1015          *
   1016          *       _DeleteChar
   1017          *
   1018          * Deletes a character at the current cursor position and moves
   1019          * all bytes after the cursor position.
   1020          */

   \                                 In section .text, align 2, keep-with-next
   1021          static void _DeleteChar(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
   \                     _DeleteChar: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1022            if (pObj->hText) {
   \   00000008   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD050             BEQ.N    ??_DeleteChar_0
   1023              unsigned CursorOffset;
   1024              char* s;
   1025              s = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4606             MOV      R6,R0
   1026              CursorOffset = pObj->CursorPosByte;
   \   00000016   0xF105 0x0738      ADD      R7,R5,#+56
   \   0000001A   0xF8B7 0x8012      LDRH     R8,[R7, #+18]
   1027              if (CursorOffset < strlen(s)) {
   \   0000001E   0x.... 0x....      BL       strlen
   \   00000022   0x4580             CMP      R8,R0
   \   00000024   0xD245             BCS.N    ??_DeleteChar_0
   1028                char *pCursor, *pLine, *pEndLine;
   1029                int CursorLine, NumChars, NumBytes;
   1030                pCursor    = s + CursorOffset;
   \   00000026   0x44B0             ADD      R8,R8,R6
   1031                CursorLine = pObj->CursorLine;
   1032                pLine      = _GetpLine(hObj, pObj, CursorLine);
   \   00000028   0x89FA             LDRH     R2,[R7, #+14]
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _GetpLine
   \   00000032   0x4681             MOV      R9,R0
   1033                NumChars   = _WrapGetNumCharsDisp(hObj, pObj, pLine);
   \   00000034   0x464A             MOV      R2,R9
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       _WrapGetNumCharsDisp
   \   0000003E   0x4601             MOV      R1,R0
   1034                pEndLine   = pLine + GUI_UC__NumChars2NumBytes(pLine, NumChars);
   \   00000040   0x4648             MOV      R0,R9
   \   00000042   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000046   0xEB00 0x0A09      ADD      R10,R0,R9
   1035                pLine      = pLine + _WrapGetNumBytesToNextLine(hObj, pObj, pLine);
   \   0000004A   0x464A             MOV      R2,R9
   \   0000004C   0x4629             MOV      R1,R5
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _WrapGetNumBytesToNextLine
   \   00000054   0x4448             ADD      R0,R0,R9
   1036                if (pCursor == pEndLine) {
   \   00000056   0x45D0             CMP      R8,R10
   \   00000058   0xD102             BNE.N    ??_DeleteChar_1
   1037                  NumBytes = pLine - pEndLine;
   \   0000005A   0xEBA0 0x090A      SUB      R9,R0,R10
   \   0000005E   0xE003             B.N      ??_DeleteChar_2
   1038                } else {
   1039                  NumBytes = GUI_UC_GetCharSize(pCursor);
   \                     ??_DeleteChar_1: (+1)
   \   00000060   0x4640             MOV      R0,R8
   \   00000062   0x.... 0x....      BL       GUI_UC_GetCharSize
   \   00000066   0x4681             MOV      R9,R0
   1040                }
   1041                NumChars = GUI_UC__NumBytes2NumChars(pCursor, NumBytes);
   \                     ??_DeleteChar_2: (+1)
   \   00000068   0x4649             MOV      R1,R9
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       GUI_UC__NumBytes2NumChars
   \   00000070   0x4682             MOV      R10,R0
   1042                strcpy(pCursor, pCursor + NumBytes);
   \   00000072   0xEB09 0x0108      ADD      R1,R9,R8
   \   00000076   0x4640             MOV      R0,R8
   \   00000078   0x.... 0x....      BL       strcpy
   1043                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   0000007C   0x2105             MOVS     R1,#+5
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       WM_NotifyParent
   1044                pObj->NumChars -= NumChars;
   \   00000084   0x88B8             LDRH     R0,[R7, #+4]
   \   00000086   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000008A   0x80B8             STRH     R0,[R7, #+4]
   1045                _InvalidateNumLines(pObj);
   \   0000008C   0x4628             MOV      R0,R5
   \   0000008E   0x.... 0x....      BL       _InvalidateNumLines
   1046                _InvalidateTextSizeX(pObj);
   \   00000092   0x4628             MOV      R0,R5
   \   00000094   0x.... 0x....      BL       _InvalidateTextSizeX
   1047                _InvalidateCursorXY(pObj); /* Invalidate X/Y position */
   \   00000098   0x4628             MOV      R0,R5
   \   0000009A   0x.... 0x....      BL       _InvalidateCursorXY
   1048                _ClearCache(pObj);
   \   0000009E   0x4628             MOV      R0,R5
   \   000000A0   0x.... 0x....      BL       _ClearCache
   1049                pObj->CursorLine = _GetCursorLine(hObj, pObj, s, pObj->CursorPosChar);
   \   000000A4   0x8A3B             LDRH     R3,[R7, #+16]
   \   000000A6   0x4632             MOV      R2,R6
   \   000000A8   0x4629             MOV      R1,R5
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       _GetCursorLine
   \   000000B0   0x81F8             STRH     R0,[R7, #+14]
   1050              }
   1051            }
   1052          }
   \                     ??_DeleteChar_0: (+1)
   \   000000B2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1053          
   1054          /*********************************************************************
   1055          *
   1056          *       _InsertChar
   1057          *
   1058          * Create space at the current cursor position and inserts a character.
   1059          */

   \                                 In section .text, align 2, keep-with-next
   1060          static int _InsertChar(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, U16 Char) {
   \                     _InsertChar: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4617             MOV      R7,R2
   1061            if (_IsCharsAvailable(pObj, 1)) {
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       _IsCharsAvailable
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD031             BEQ.N    ??_InsertChar_0
   1062              int BytesNeeded;
   1063              BytesNeeded = GUI_UC__CalcSizeOfChar(Char);
   \   00000016   0x4638             MOV      R0,R7
   \   00000018   0x.... 0x....      BL       GUI_UC__CalcSizeOfChar
   \   0000001C   0x4680             MOV      R8,R0
   1064              if (_IsSpaceInBuffer(pObj, BytesNeeded)) {
   \   0000001E   0x4641             MOV      R1,R8
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _IsSpaceInBuffer
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD027             BEQ.N    ??_InsertChar_0
   1065                int CursorOffset;
   1066                char* pText;
   1067                pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   0000002A   0xF9B4 0x0038      LDRSH    R0,[R4, #+56]
   \   0000002E   0x.... 0x....      BL       GUI_ALLOC_h2p
   1068                CursorOffset = pObj->CursorPosByte;
   1069                pText += CursorOffset;
   \   00000032   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000036   0x8A69             LDRH     R1,[R5, #+18]
   \   00000038   0xEB01 0x0900      ADD      R9,R1,R0
   1070                memmove(pText + BytesNeeded, pText, strlen(pText) + 1);
   \   0000003C   0x4648             MOV      R0,R9
   \   0000003E   0x.... 0x....      BL       strlen
   \   00000042   0x1C42             ADDS     R2,R0,#+1
   \   00000044   0x4649             MOV      R1,R9
   \   00000046   0xEB08 0x0009      ADD      R0,R8,R9
   \   0000004A   0x.... 0x....      BL       memmove
   1071                GUI_UC_Encode(pText, Char);
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x4648             MOV      R0,R9
   \   00000052   0x.... 0x....      BL       GUI_UC_Encode
   1072                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000056   0x2105             MOVS     R1,#+5
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       WM_NotifyParent
   1073                pObj->NumChars += 1;
   \   0000005E   0x88A8             LDRH     R0,[R5, #+4]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x80A8             STRH     R0,[R5, #+4]
   1074                _InvalidateNumLines(pObj);
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       _InvalidateNumLines
   1075                _InvalidateTextSizeX(pObj);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       _InvalidateTextSizeX
   1076                _ClearCache(pObj);
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       _ClearCache
   1077                return 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE000             B.N      ??_InsertChar_1
   1078              }
   1079            }
   1080            return 0;
   \                     ??_InsertChar_0: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??_InsertChar_1: (+1)
   \   0000007C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1081          }
   1082          
   1083          /*********************************************************************
   1084          *
   1085          *       static code
   1086          *
   1087          **********************************************************************
   1088          */
   1089          /*********************************************************************
   1090          *
   1091          *       _MULTIEDIT_Paint
   1092          */

   \                                 In section .text, align 2, keep-with-next
   1093          static void _MULTIEDIT_Paint(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj) {
   \                     _MULTIEDIT_Paint: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   1094            int ScrollPosX, ScrollPosY, EffectSize, HBorder;
   1095            int x, y, xOff, yOff, ColorIndex, FontSizeY;
   1096            GUI_RECT r, rClip;
   1097            const GUI_RECT *prOldClip;
   1098            /* Init some values */
   1099            GUI_SetFont(pObj->pFont);
   \   0000000A   0xF105 0x0620      ADD      R6,R5,#+32
   \   0000000E   0x6D30             LDR      R0,[R6, #+80]
   \   00000010   0x.... 0x....      BL       GUI_SetFont
   1100            FontSizeY  = GUI_GetFontDistY();
   \   00000014   0x.... 0x....      BL       GUI_GetFontDistY
   \   00000018   0x9003             STR      R0,[SP, #+12]
   1101            ScrollPosX = pObj->ScrollStateH.v;
   1102            ScrollPosY = pObj->ScrollStateV.v;
   \   0000001A   0x6BF7             LDR      R7,[R6, #+60]
   1103            EffectSize = pObj->Widget.pEffect->EffectSize;
   \   0000001C   0x6A28             LDR      R0,[R5, #+32]
   \   0000001E   0xF8D0 0xA014      LDR      R10,[R0, #+20]
   1104            HBorder    = pObj->HBorder;
   \   00000022   0xF895 0x0077      LDRB     R0,[R5, #+119]
   \   00000026   0x9002             STR      R0,[SP, #+8]
   1105            xOff       = EffectSize + HBorder - ScrollPosX ;
   \   00000028   0x4450             ADD      R0,R0,R10
   \   0000002A   0x6CB1             LDR      R1,[R6, #+72]
   \   0000002C   0x1A40             SUBS     R0,R0,R1
   \   0000002E   0x9005             STR      R0,[SP, #+20]
   1106            yOff       = EffectSize - ScrollPosY * FontSizeY;
   \   00000030   0x9803             LDR      R0,[SP, #+12]
   \   00000032   0xFB00 0xA017      MLS      R0,R0,R7,R10
   \   00000036   0x900B             STR      R0,[SP, #+44]
   1107            ColorIndex = ((pObj->Flags & MULTIEDIT_SF_READONLY) ? 1 : 0);
   \   00000038   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   0000003C   0xF000 0x0001      AND      R0,R0,#0x1
   1108            /* Set colors and draw the background */
   1109            LCD_SetBkColor(pObj->aBkColor[ColorIndex]);
   \   00000040   0xEB05 0x0880      ADD      R8,R5,R0, LSL #+2
   \   00000044   0xF8D8 0x0028      LDR      R0,[R8, #+40]
   \   00000048   0x.... 0x....      BL       LCD_SetBkColor
   1110            LCD_SetColor(pObj->aColor[ColorIndex]);
   \   0000004C   0xF8D8 0x0030      LDR      R0,[R8, #+48]
   \   00000050   0x.... 0x....      BL       LCD_SetColor
   1111            GUI_Clear();
   \   00000054   0x.... 0x....      BL       GUI_Clear
   1112            /* Draw the text if necessary */
   1113            rClip.x0 = EffectSize + HBorder;
   \   00000058   0x9802             LDR      R0,[SP, #+8]
   \   0000005A   0x4450             ADD      R0,R0,R10
   \   0000005C   0xF8AD 0x0018      STRH     R0,[SP, #+24]
   1114            rClip.y0 = EffectSize;
   \   00000060   0x4650             MOV      R0,R10
   \   00000062   0xF8AD 0x001A      STRH     R0,[SP, #+26]
   1115            rClip.x1 = WM_GetWindowSizeX(hObj) - EffectSize - HBorder - 1;
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       WM_GetWindowSizeX
   \   0000006C   0xEBA0 0x000A      SUB      R0,R0,R10
   \   00000070   0x9902             LDR      R1,[SP, #+8]
   \   00000072   0x1A40             SUBS     R0,R0,R1
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0xF8AD 0x001C      STRH     R0,[SP, #+28]
   1116            rClip.y1 = WM_GetWindowSizeY(hObj) - EffectSize - 1;
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       WM_GetWindowSizeY
   \   00000080   0xEBA0 0x000A      SUB      R0,R0,R10
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0xF8AD 0x001E      STRH     R0,[SP, #+30]
   1117            prOldClip = WM_SetUserClipRect(&rClip);
   \   0000008A   0xA806             ADD      R0,SP,#+24
   \   0000008C   0x.... 0x....      BL       WM_SetUserClipRect
   \   00000090   0x900A             STR      R0,[SP, #+40]
   1118            if (pObj->hText) {
   \   00000092   0xF9B6 0x0018      LDRSH    R0,[R6, #+24]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD05D             BEQ.N    ??_MULTIEDIT_Paint_0
   1119              const char* pText;
   1120              int Line = 0;
   \   0000009A   0xF04F 0x0800      MOV      R8,#+0
   1121              int xSize       = _GetXSize(hObj, pObj);
   \   0000009E   0x4629             MOV      R1,R5
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       _GetXSize
   \   000000A6   0x4683             MOV      R11,R0
   1122              int NumVisLines = _GetNumVisLines(hObj, pObj);
   \   000000A8   0x4629             MOV      R1,R5
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       _GetNumVisLines
   \   000000B0   0x9004             STR      R0,[SP, #+16]
   1123              /* Get the text */
   1124              pText = (const char *)GUI_ALLOC_h2p(pObj->hText);
   \   000000B2   0xF9B6 0x0018      LDRSH    R0,[R6, #+24]
   \   000000B6   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   000000BA   0x4681             MOV      R9,R0
   1125              /* Set the rectangle for drawing */
   1126              r.x0 = xOff;
   \   000000BC   0x9805             LDR      R0,[SP, #+20]
   \   000000BE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1127              r.y0 = EffectSize;
   \   000000C2   0x4650             MOV      R0,R10
   \   000000C4   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1128              r.x1 = xSize + EffectSize + HBorder - 1;
   \   000000C8   0xEB0A 0x000B      ADD      R0,R10,R11
   \   000000CC   0x9902             LDR      R1,[SP, #+8]
   \   000000CE   0x1808             ADDS     R0,R1,R0
   \   000000D0   0x1E40             SUBS     R0,R0,#+1
   \   000000D2   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1129              r.y1 = pObj->Widget.Win.Rect.y1 - pObj->Widget.Win.Rect.y0 + 1;
   \   000000D6   0x88E8             LDRH     R0,[R5, #+6]
   \   000000D8   0x8869             LDRH     R1,[R5, #+2]
   \   000000DA   0x1A40             SUBS     R0,R0,R1
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   \   000000E2   0x8EB0             LDRH     R0,[R6, #+52]
   \   000000E4   0x4287             CMP      R7,R0
   \   000000E6   0xDB04             BLT.N    ??_MULTIEDIT_Paint_1
   1130              /* Use cached position of first visible byte if possible */
   1131              if (ScrollPosY >= pObj->CacheFirstVisibleLine) {
   1132                if (pObj->CacheFirstVisibleByte) {
   \   000000E8   0x8EF1             LDRH     R1,[R6, #+54]
   \   000000EA   0x2900             CMP      R1,#+0
   \   000000EC   0xD001             BEQ.N    ??_MULTIEDIT_Paint_1
   1133                  pText += pObj->CacheFirstVisibleByte;
   \   000000EE   0x4489             ADD      R9,R1,R9
   1134                  Line   = pObj->CacheFirstVisibleLine;
   \   000000F0   0x4680             MOV      R8,R0
   1135                }
   1136              }
   1137              /* Do the drawing of the text */
   1138              do {
   1139                /* Cache the position of the first visible byte and the depending line number */
   1140                if (pObj->CacheFirstVisibleLine != ScrollPosY) {
   \                     ??_MULTIEDIT_Paint_1: (+1)
   \   000000F2   0x8EB0             LDRH     R0,[R6, #+52]
   \   000000F4   0x42B8             CMP      R0,R7
   \   000000F6   0xD009             BEQ.N    ??_MULTIEDIT_Paint_2
   1141                  if (Line == ScrollPosY) {
   \   000000F8   0x45B8             CMP      R8,R7
   \   000000FA   0xD107             BNE.N    ??_MULTIEDIT_Paint_2
   1142                    pObj->CacheFirstVisibleByte = pText - (const char *)GUI_ALLOC_h2p(pObj->hText);
   \   000000FC   0xF9B6 0x0018      LDRSH    R0,[R6, #+24]
   \   00000100   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000104   0xEBA9 0x0000      SUB      R0,R9,R0
   \   00000108   0x86F0             STRH     R0,[R6, #+54]
   1143                    pObj->CacheFirstVisibleLine = ScrollPosY;
   \   0000010A   0x86B7             STRH     R7,[R6, #+52]
   1144                  }
   1145                }
   1146                /* Draw it */
   1147                if ((Line >= ScrollPosY) && ((Line - ScrollPosY) <= NumVisLines)) {
   \                     ??_MULTIEDIT_Paint_2: (+1)
   \   0000010C   0x45B8             CMP      R8,R7
   \   0000010E   0xDB10             BLT.N    ??_MULTIEDIT_Paint_3
   \   00000110   0x9804             LDR      R0,[SP, #+16]
   \   00000112   0xEBA8 0x0107      SUB      R1,R8,R7
   \   00000116   0x4288             CMP      R0,R1
   \   00000118   0xDB0B             BLT.N    ??_MULTIEDIT_Paint_3
   1148                  _DispString(hObj, pObj, pText, &r);
   \   0000011A   0xAB00             ADD      R3,SP,#+0
   \   0000011C   0x464A             MOV      R2,R9
   \   0000011E   0x4629             MOV      R1,R5
   \   00000120   0x4620             MOV      R0,R4
   \   00000122   0x.... 0x....      BL       _DispString
   1149                  r.y0 += FontSizeY;  /* Next line */
   \   00000126   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000012A   0x9903             LDR      R1,[SP, #+12]
   \   0000012C   0x1808             ADDS     R0,R1,R0
   \   0000012E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1150                }
   1151                pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
   \                     ??_MULTIEDIT_Paint_3: (+1)
   \   00000132   0x464A             MOV      R2,R9
   \   00000134   0x4629             MOV      R1,R5
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       _WrapGetNumBytesToNextLine
   \   0000013C   0x4481             ADD      R9,R0,R9
   1152                Line++;
   \   0000013E   0xF108 0x0801      ADD      R8,R8,#+1
   1153              } while (GUI_UC_GetCharCode(pText) && ((Line - ScrollPosY) <= NumVisLines));
   \   00000142   0x4648             MOV      R0,R9
   \   00000144   0x.... 0x....      BL       GUI_UC_GetCharCode
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD004             BEQ.N    ??_MULTIEDIT_Paint_0
   \   0000014C   0x9804             LDR      R0,[SP, #+16]
   \   0000014E   0xEBA8 0x0107      SUB      R1,R8,R7
   \   00000152   0x4288             CMP      R0,R1
   \   00000154   0xDACD             BGE.N    ??_MULTIEDIT_Paint_1
   1154            }
   1155            /* Draw cursor if necessary */
   1156            if (WM_HasFocus(hObj)) {
   \                     ??_MULTIEDIT_Paint_0: (+1)
   \   00000156   0x4620             MOV      R0,R4
   \   00000158   0x.... 0x....      BL       WM_HasFocus
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD026             BEQ.N    ??_MULTIEDIT_Paint_4
   1157              _GetCursorXY(hObj, pObj, &x, &y);
   \   00000160   0xAB08             ADD      R3,SP,#+32
   \   00000162   0xAA09             ADD      R2,SP,#+36
   \   00000164   0x4629             MOV      R1,R5
   \   00000166   0x4620             MOV      R0,R4
   \   00000168   0x.... 0x....      BL       _GetCursorXY
   1158              r.x0 = x + xOff;
   \   0000016C   0x9809             LDR      R0,[SP, #+36]
   \   0000016E   0x9905             LDR      R1,[SP, #+20]
   \   00000170   0x1808             ADDS     R0,R1,R0
   \   00000172   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1159              r.y0 = y + yOff;
   \   00000176   0x9808             LDR      R0,[SP, #+32]
   \   00000178   0x990B             LDR      R1,[SP, #+44]
   \   0000017A   0x1808             ADDS     R0,R1,R0
   \   0000017C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1160              r.x1 = r.x0 + _GetCursorSizeX(hObj, pObj) - 1;
   \   00000180   0x4629             MOV      R1,R5
   \   00000182   0x4620             MOV      R0,R4
   \   00000184   0x.... 0x....      BL       _GetCursorSizeX
   \   00000188   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000018C   0x1840             ADDS     R0,R0,R1
   \   0000018E   0x1E42             SUBS     R2,R0,#+1
   \   00000190   0xF8AD 0x2004      STRH     R2,[SP, #+4]
   1161              r.y1 = r.y0 + FontSizeY - 1;
   \   00000194   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000198   0x9803             LDR      R0,[SP, #+12]
   \   0000019A   0x1840             ADDS     R0,R0,R1
   \   0000019C   0x1E43             SUBS     R3,R0,#+1
   \   0000019E   0xF8AD 0x3006      STRH     R3,[SP, #+6]
   1162              GUI_InvertRect(r.x0, r.y0, r.x1, r.y1);
   \   000001A2   0xB21B             SXTH     R3,R3
   \   000001A4   0xB212             SXTH     R2,R2
   \   000001A6   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000001AA   0x.... 0x....      BL       GUI_InvertRect
   1163            }
   1164            WM_SetUserClipRect(prOldClip);
   \                     ??_MULTIEDIT_Paint_4: (+1)
   \   000001AE   0x980A             LDR      R0,[SP, #+40]
   \   000001B0   0x.... 0x....      BL       WM_SetUserClipRect
   1165            /* Draw the 3D effect (if configured) */
   1166            WIDGET__EFFECT_DrawDown(&pObj->Widget);
   \   000001B4   0x4628             MOV      R0,R5
   \   000001B6   0x.... 0x....      BL       WIDGET__EFFECT_DrawDown
   1167          }
   \   000001BA   0xB00D             ADD      SP,SP,#+52
   \   000001BC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1168          
   1169          /*********************************************************************
   1170          *
   1171          *       _OnTouch
   1172          */

   \                                 In section .text, align 2, keep-with-next
   1173          static void _OnTouch(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1174            int Notification;
   1175            const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
   \   00000008   0x6890             LDR      R0,[R2, #+8]
   1176            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD023             BEQ.N    ??_OnTouch_0
   1177              if (pState->Pressed) {
   \   0000000E   0x7A01             LDRB     R1,[R0, #+8]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD01E             BEQ.N    ??_OnTouch_1
   1178                int Effect, xPos, yPos;
   1179                Effect = pObj->Widget.pEffect->EffectSize;
   \   00000014   0x6A29             LDR      R1,[R5, #+32]
   \   00000016   0x694E             LDR      R6,[R1, #+20]
   1180                xPos   = pState->x + pObj->ScrollStateH.v - Effect - pObj->HBorder;
   \   00000018   0xF105 0x0120      ADD      R1,R5,#+32
   \   0000001C   0x6802             LDR      R2,[R0, #+0]
   \   0000001E   0x6C8B             LDR      R3,[R1, #+72]
   \   00000020   0x189A             ADDS     R2,R3,R2
   \   00000022   0x1B92             SUBS     R2,R2,R6
   \   00000024   0xF895 0x3077      LDRB     R3,[R5, #+119]
   \   00000028   0x1AD7             SUBS     R7,R2,R3
   1181                yPos   = pState->y + pObj->ScrollStateV.v * GUI_GetYDistOfFont(pObj->pFont) - Effect;
   \   0000002A   0xF8D0 0x8004      LDR      R8,[R0, #+4]
   \   0000002E   0xF8D1 0x903C      LDR      R9,[R1, #+60]
   \   00000032   0x6D08             LDR      R0,[R1, #+80]
   \   00000034   0x.... 0x....      BL       GUI_GetYDistOfFont
   \   00000038   0xFB00 0x8009      MLA      R0,R0,R9,R8
   \   0000003C   0x1B83             SUBS     R3,R0,R6
   1182                _SetCursorXY(hObj, pObj, xPos, yPos);
   \   0000003E   0x463A             MOV      R2,R7
   \   00000040   0x4629             MOV      R1,R5
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _SetCursorXY
   1183                _Invalidate(hObj);
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _Invalidate
   1184                Notification = WM_NOTIFICATION_CLICKED;
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0xE002             B.N      ??_OnTouch_2
   1185              } else {
   1186                Notification = WM_NOTIFICATION_RELEASED;
   \                     ??_OnTouch_1: (+1)
   \   00000052   0x2102             MOVS     R1,#+2
   \   00000054   0xE000             B.N      ??_OnTouch_2
   1187              }
   1188            } else {
   1189              Notification = WM_NOTIFICATION_MOVED_OUT;
   \                     ??_OnTouch_0: (+1)
   \   00000056   0x2103             MOVS     R1,#+3
   1190            }
   1191            WM_NotifyParent(hObj, Notification);
   \                     ??_OnTouch_2: (+1)
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   0000005E   0x.... 0x....      B.W      WM_NotifyParent
   1192          }
   1193          
   1194          /*********************************************************************
   1195          *
   1196          *       _AddKey
   1197          *
   1198          * Returns: 1 if Key has been consumed
   1199          *          0 else 
   1200          */

   \                                 In section .text, align 4, keep-with-next
   1201          static int _AddKey(MULTIEDIT_HANDLE hObj, U16 Key) {
   \                     _AddKey: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   1202            int r = 0;               /* Key has not been consumed */
   \   00000006   0x2600             MOVS     R6,#+0
   1203            MULTIEDIT_OBJ* pObj;
   1204            pObj = MULTIEDIT_H2P(hObj);
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000C   0x4605             MOV      R5,R0
   1205            switch (Key) {
   \   0000000E   0x4638             MOV      R0,R7
   \   00000010   0x3808             SUBS     R0,R0,#+8
   \   00000012   0x2816             CMP      R0,#+22
   \   00000014   0xF200 0x808B      BHI.W    ??_AddKey_1
   \   00000018   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??_AddKey_0:
   \   0000001C   0x38 0x89          DC8      0x38,0x89,0x89,0x89
   \              0x89 0x89    
   \   00000020   0x89 0x66          DC8      0x89,0x66,0x89,0x89
   \              0x89 0x89    
   \   00000024   0x22 0x0C          DC8      0x22,0xC,0x18,0x12
   \              0x18 0x12    
   \   00000028   0x89 0x89          DC8      0x89,0x89,0x89,0x32
   \              0x89 0x32    
   \   0000002C   0x2C 0x89          DC8      0x2C,0x89,0x89,0xA9
   \              0x89 0xA9    
   \   00000030   0x89 0x57          DC8      0x89,0x57,0x4D,0x0
   \              0x4D 0x00    
   1206            case GUI_KEY_UP:
   1207              _MoveCursorUp(hObj, pObj);
   \                     ??_AddKey_2: (+1)
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _MoveCursorUp
   1208              r = 1;               /* Key has been consumed */
   \   0000003C   0x2601             MOVS     R6,#+1
   1209              break;
   \   0000003E   0xE096             B.N      ??_AddKey_3
   1210            case GUI_KEY_DOWN:
   1211              _MoveCursorDown(hObj, pObj);
   \                     ??_AddKey_4: (+1)
   \   00000040   0x4629             MOV      R1,R5
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _MoveCursorDown
   1212              r = 1;               /* Key has been consumed */
   \   00000048   0x2601             MOVS     R6,#+1
   1213              break;
   \   0000004A   0xE090             B.N      ??_AddKey_3
   1214            case GUI_KEY_RIGHT:
   1215              _SetCursorPos(hObj, pObj, pObj->CursorPosChar + 1);
   \                     ??_AddKey_5: (+1)
   \   0000004C   0xF105 0x003E      ADD      R0,R5,#+62
   \   00000050   0x8940             LDRH     R0,[R0, #+10]
   \   00000052   0x1C42             ADDS     R2,R0,#+1
   \   00000054   0x4629             MOV      R1,R5
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       _SetCursorPos
   1216              r = 1;               /* Key has been consumed */
   \   0000005C   0x2601             MOVS     R6,#+1
   1217              break;
   \   0000005E   0xE086             B.N      ??_AddKey_3
   1218            case GUI_KEY_LEFT:
   1219              _SetCursorPos(hObj, pObj, pObj->CursorPosChar - 1);
   \                     ??_AddKey_6: (+1)
   \   00000060   0xF105 0x003E      ADD      R0,R5,#+62
   \   00000064   0x8940             LDRH     R0,[R0, #+10]
   \   00000066   0x1E42             SUBS     R2,R0,#+1
   \   00000068   0x4629             MOV      R1,R5
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       _SetCursorPos
   1220              r = 1;               /* Key has been consumed */
   \   00000070   0x2601             MOVS     R6,#+1
   1221              break;
   \   00000072   0xE07C             B.N      ??_AddKey_3
   1222            case GUI_KEY_END:
   1223              _MoveCursor2LineEnd(hObj, pObj);
   \                     ??_AddKey_7: (+1)
   \   00000074   0x4629             MOV      R1,R5
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       _MoveCursor2LineEnd
   1224              r = 1;               /* Key has been consumed */
   \   0000007C   0x2601             MOVS     R6,#+1
   1225              break;
   \   0000007E   0xE076             B.N      ??_AddKey_3
   1226            case GUI_KEY_HOME:
   1227              _MoveCursor2LinePos1(hObj, pObj);
   \                     ??_AddKey_8: (+1)
   \   00000080   0x4629             MOV      R1,R5
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       _MoveCursor2LinePos1
   1228              r = 1;               /* Key has been consumed */
   \   00000088   0x2601             MOVS     R6,#+1
   1229              break;
   \   0000008A   0xE070             B.N      ??_AddKey_3
   1230            case GUI_KEY_BACKSPACE:
   1231              if (!(pObj->Flags & MULTIEDIT_SF_READONLY)) {
   \                     ??_AddKey_9: (+1)
   \   0000008C   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   00000090   0x07C0             LSLS     R0,R0,#+31
   \   00000092   0xD46C             BMI.N    ??_AddKey_3
   \   00000094   0xF105 0x003E      ADD      R0,R5,#+62
   \   00000098   0x8940             LDRH     R0,[R0, #+10]
   \   0000009A   0x8FE9             LDRH     R1,[R5, #+62]
   \   0000009C   0x4281             CMP      R1,R0
   \   0000009E   0xD208             BCS.N    ??_AddKey_10
   1232                if (pObj->CursorPosChar > pObj->NumCharsPrompt) {
   1233                  _SetCursorPos(hObj, pObj, pObj->CursorPosChar - 1);
   \   000000A0   0x1E42             SUBS     R2,R0,#+1
   \   000000A2   0x4629             MOV      R1,R5
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       _SetCursorPos
   1234                  _DeleteChar(hObj, pObj);
   \   000000AA   0x4629             MOV      R1,R5
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       _DeleteChar
   1235                }
   1236                r = 1;               /* Key has been consumed */
   \                     ??_AddKey_10: (+1)
   \   000000B2   0x2601             MOVS     R6,#+1
   \   000000B4   0xE05B             B.N      ??_AddKey_3
   1237              }
   1238              break;
   1239            case GUI_KEY_DELETE:
   1240              if (!(pObj->Flags & MULTIEDIT_SF_READONLY)) {
   \                     ??_AddKey_11: (+1)
   \   000000B6   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   000000BA   0x07C0             LSLS     R0,R0,#+31
   \   000000BC   0xD457             BMI.N    ??_AddKey_3
   1241                _DeleteChar(hObj, pObj);
   \   000000BE   0x4629             MOV      R1,R5
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       _DeleteChar
   1242                r = 1;               /* Key has been consumed */
   \   000000C6   0x2601             MOVS     R6,#+1
   \   000000C8   0xE051             B.N      ??_AddKey_3
   1243              }
   1244              break;
   1245            case GUI_KEY_INSERT:
   1246              if (!(pObj->Flags & MULTIEDIT_CF_INSERT)) {
   \                     ??_AddKey_12: (+1)
   \   000000CA   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   000000CE   0x0741             LSLS     R1,R0,#+29
   \   000000D0   0xD404             BMI.N    ??_AddKey_13
   1247                pObj->Flags |= MULTIEDIT_CF_INSERT;
   \   000000D2   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000D6   0xF885 0x0074      STRB     R0,[R5, #+116]
   \   000000DA   0xE003             B.N      ??_AddKey_14
   1248              } else {
   1249                pObj->Flags &= ~MULTIEDIT_CF_INSERT;
   \                     ??_AddKey_13: (+1)
   \   000000DC   0xF000 0x00FB      AND      R0,R0,#0xFB
   \   000000E0   0xF885 0x0074      STRB     R0,[R5, #+116]
   1250              }
   1251              r = 1;               /* Key has been consumed */
   \                     ??_AddKey_14: (+1)
   \   000000E4   0x2601             MOVS     R6,#+1
   1252              break;
   \   000000E6   0xE042             B.N      ??_AddKey_3
   1253            case GUI_KEY_ENTER:
   1254              if (pObj->Flags & MULTIEDIT_SF_READONLY) {
   \                     ??_AddKey_15: (+1)
   \   000000E8   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   000000EC   0x07C0             LSLS     R0,R0,#+31
   \   000000EE   0xD504             BPL.N    ??_AddKey_16
   1255                _MoveCursor2NextLine(hObj, pObj);
   \   000000F0   0x4629             MOV      R1,R5
   \   000000F2   0x4620             MOV      R0,R4
   \   000000F4   0x.... 0x....      BL       _MoveCursor2NextLine
   \   000000F8   0xE017             B.N      ??_AddKey_17
   1256              } else {
   1257                if (_InsertChar(hObj, pObj, (U8)('\n'))) {
   \                     ??_AddKey_16: (+1)
   \   000000FA   0x220A             MOVS     R2,#+10
   \   000000FC   0x4629             MOV      R1,R5
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       _InsertChar
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD010             BEQ.N    ??_AddKey_17
   1258                  if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000108   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   0000010C   0x0680             LSLS     R0,R0,#+26
   \   0000010E   0xD508             BPL.N    ??_AddKey_18
   1259                    _SetCursorPos(hObj, pObj, pObj->CursorPosChar + 1);
   \   00000110   0xF105 0x003E      ADD      R0,R5,#+62
   \   00000114   0x8940             LDRH     R0,[R0, #+10]
   \   00000116   0x1C42             ADDS     R2,R0,#+1
   \   00000118   0x4629             MOV      R1,R5
   \   0000011A   0x4620             MOV      R0,R4
   \   0000011C   0x.... 0x....      BL       _SetCursorPos
   \   00000120   0xE003             B.N      ??_AddKey_17
   1260                  } else {
   1261                    _MoveCursor2NextLine(hObj, pObj);
   \                     ??_AddKey_18: (+1)
   \   00000122   0x4629             MOV      R1,R5
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       _MoveCursor2NextLine
   1262                  }
   1263                }
   1264              }
   1265              r = 1;               /* Key has been consumed */
   \                     ??_AddKey_17: (+1)
   \   0000012A   0x2601             MOVS     R6,#+1
   1266              break;
   \   0000012C   0xE01F             B.N      ??_AddKey_3
   1267            case GUI_KEY_ESCAPE:
   1268              break;
   1269            default:
   1270              if (!(pObj->Flags & MULTIEDIT_SF_READONLY) && (Key >= 0x20)) {
   \                     ??_AddKey_1: (+1)
   \   0000012E   0xF895 0x0074      LDRB     R0,[R5, #+116]
   \   00000132   0x07C0             LSLS     R0,R0,#+31
   \   00000134   0xD41B             BMI.N    ??_AddKey_3
   \   00000136   0x2F20             CMP      R7,#+32
   \   00000138   0xDB19             BLT.N    ??_AddKey_3
   1271                if (_IsOverwriteAtThisChar(hObj, pObj)) {
   \   0000013A   0x4629             MOV      R1,R5
   \   0000013C   0x4620             MOV      R0,R4
   \   0000013E   0x.... 0x....      BL       _IsOverwriteAtThisChar
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD003             BEQ.N    ??_AddKey_19
   1272                  _DeleteChar(hObj, pObj);
   \   00000146   0x4629             MOV      R1,R5
   \   00000148   0x4620             MOV      R0,R4
   \   0000014A   0x.... 0x....      BL       _DeleteChar
   1273                }
   1274                if (_InsertChar(hObj, pObj, Key)) {
   \                     ??_AddKey_19: (+1)
   \   0000014E   0x463A             MOV      R2,R7
   \   00000150   0x4629             MOV      R1,R5
   \   00000152   0x4620             MOV      R0,R4
   \   00000154   0x.... 0x....      BL       _InsertChar
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD007             BEQ.N    ??_AddKey_20
   1275                  _SetCursorPos(hObj, pObj, pObj->CursorPosChar + 1);
   \   0000015C   0xF105 0x003E      ADD      R0,R5,#+62
   \   00000160   0x8940             LDRH     R0,[R0, #+10]
   \   00000162   0x1C42             ADDS     R2,R0,#+1
   \   00000164   0x4629             MOV      R1,R5
   \   00000166   0x4620             MOV      R0,R4
   \   00000168   0x.... 0x....      BL       _SetCursorPos
   1276                }
   1277                r = 1;               /* Key has been consumed */
   \                     ??_AddKey_20: (+1)
   \   0000016C   0x2601             MOVS     R6,#+1
   1278              }
   1279            }
   1280            _InvalidateTextArea(hObj);
   \                     ??_AddKey_3: (+1)
   \   0000016E   0x4620             MOV      R0,R4
   \   00000170   0x.... 0x....      BL       _InvalidateTextArea
   1281            return r;
   \   00000174   0x4630             MOV      R0,R6
   \   00000176   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1282          }
   1283          
   1284          /*********************************************************************
   1285          *
   1286          *       _MULTIEDIT_Callback
   1287          */

   \                                 In section .text, align 2, keep-with-next
   1288          static void _MULTIEDIT_Callback (WM_MESSAGE *pMsg) {
   \                     _MULTIEDIT_Callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   1289            MULTIEDIT_HANDLE hObj;
   1290            MULTIEDIT_OBJ* pObj;
   1291            WM_SCROLL_STATE ScrollState;
   1292            hObj = pMsg->hWin;
   \   00000006   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
   1293            /* Let widget handle the standard messages */
   1294            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD025             BEQ.N    ??_MULTIEDIT_Callback_0
   1295              return;
   1296            }
   1297            pObj = MULTIEDIT_H2P(hObj);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001C   0x4606             MOV      R6,R0
   1298            switch (pMsg->MsgId) {
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xD01F             BEQ.N    ??_MULTIEDIT_Callback_1
   \   00000024   0x280B             CMP      R0,#+11
   \   00000026   0xD06E             BEQ.N    ??_MULTIEDIT_Callback_2
   \   00000028   0x280C             CMP      R0,#+12
   \   0000002A   0xD066             BEQ.N    ??_MULTIEDIT_Callback_3
   \   0000002C   0x280E             CMP      R0,#+14
   \   0000002E   0xD06F             BEQ.N    ??_MULTIEDIT_Callback_4
   \   00000030   0x280F             CMP      R0,#+15
   \   00000032   0xD05D             BEQ.N    ??_MULTIEDIT_Callback_5
   \   00000034   0x2825             CMP      R0,#+37
   \   00000036   0xD002             BEQ.N    ??_MULTIEDIT_Callback_6
   \   00000038   0x2826             CMP      R0,#+38
   \   0000003A   0xD023             BEQ.N    ??_MULTIEDIT_Callback_7
   \   0000003C   0xE00E             B.N      ??_MULTIEDIT_Callback_8
   1299            case WM_NOTIFY_CLIENTCHANGE:
   1300              _InvalidateCursorXY(pObj);
   \                     ??_MULTIEDIT_Callback_6: (+1)
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       _InvalidateCursorXY
   1301              _InvalidateNumLines(pObj);
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       _InvalidateNumLines
   1302              _InvalidateTextSizeX(pObj);
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       _InvalidateTextSizeX
   1303              _ClearCache(pObj);
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       _ClearCache
   1304              _CalcScrollParas(hObj);
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       _CalcScrollParas
   1305              break;
   1306            case WM_SIZE:
   1307              _InvalidateCursorXY(pObj);
   1308              _InvalidateNumLines(pObj);
   1309              _InvalidateTextSizeX(pObj);
   1310              _ClearCache(pObj);
   1311              _Invalidate(hObj);
   1312              break;
   1313            case WM_NOTIFY_PARENT:
   1314              switch (pMsg->Data.v) {
   1315              case WM_NOTIFICATION_VALUE_CHANGED:
   1316                if (pMsg->hWinSrc  == WM_GetScrollbarV(hObj)) {
   1317                  WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
   1318                  pObj->ScrollStateV.v = ScrollState.v;
   1319                  WM_InvalidateWindow(hObj);
   1320                  WM_NotifyParent(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
   1321                } else if (pMsg->hWinSrc == WM_GetScrollbarH(hObj)) {
   1322                  WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
   1323                  pObj->ScrollStateH.v = ScrollState.v;
   1324                  WM_InvalidateWindow(hObj);
   1325                  WM_NotifyParent(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
   1326                }
   1327                break;
   1328              case WM_NOTIFICATION_SCROLLBAR_ADDED:
   1329                _SetScrollState(hObj);
   1330                break;
   1331              }
   1332              break;
   1333            case WM_PAINT:
   1334              _MULTIEDIT_Paint(hObj, pObj);
   1335              return;
   1336            case WM_TOUCH:
   1337              _OnTouch(hObj, pObj, pMsg);
   1338              break;
   1339            case WM_DELETE:
   1340              GUI_ALLOC_FreePtr(&pObj->hText);
   1341              break;
   1342            case WM_KEY:
   1343              if (((const WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt >0) {
   1344                int Key = ((const WM_KEY_INFO*)(pMsg->Data.p))->Key;
   1345                /* Leave code for test purpose
   1346                switch (Key) {
   1347                case '1': Key = GUI_KEY_LEFT;  break;
   1348                case '2': Key = GUI_KEY_UP;    break;
   1349                case '3': Key = GUI_KEY_RIGHT; break;
   1350                case '4': Key = GUI_KEY_DOWN;  break;
   1351                }
   1352                */
   1353                if (_AddKey(hObj, Key)) {
   1354                  return;
   1355                }
   1356              } else {
   1357                if (!(pObj->Flags & MULTIEDIT_SF_READONLY)) {
   1358                  return;                /* Key release is consumed (not sent to parent) */
   1359                }
   1360              }
   1361            }
   1362            WM_DefaultProc(pMsg);
   \                     ??_MULTIEDIT_Callback_8: (+1)
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       WM_DefaultProc
   1363          }
   \                     ??_MULTIEDIT_Callback_0: (+1)
   \   00000062   0xBD7F             POP      {R0-R6,PC}       ;; return
   \                     ??_MULTIEDIT_Callback_1: (+1)
   \   00000064   0x4630             MOV      R0,R6
   \   00000066   0x.... 0x....      BL       _InvalidateCursorXY
   \   0000006A   0x4630             MOV      R0,R6
   \   0000006C   0x.... 0x....      BL       _InvalidateNumLines
   \   00000070   0x4630             MOV      R0,R6
   \   00000072   0x.... 0x....      BL       _InvalidateTextSizeX
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       _ClearCache
   \   0000007C   0x4628             MOV      R0,R5
   \   0000007E   0x.... 0x....      BL       _Invalidate
   \   00000082   0xE7EB             B.N      ??_MULTIEDIT_Callback_8
   \                     ??_MULTIEDIT_Callback_7: (+1)
   \   00000084   0x68A0             LDR      R0,[R4, #+8]
   \   00000086   0x2805             CMP      R0,#+5
   \   00000088   0xD002             BEQ.N    ??_MULTIEDIT_Callback_9
   \   0000008A   0x2806             CMP      R0,#+6
   \   0000008C   0xD02C             BEQ.N    ??_MULTIEDIT_Callback_10
   \   0000008E   0xE7E5             B.N      ??_MULTIEDIT_Callback_8
   \                     ??_MULTIEDIT_Callback_9: (+1)
   \   00000090   0x4628             MOV      R0,R5
   \   00000092   0x.... 0x....      BL       WM_GetScrollbarV
   \   00000096   0xF9B4 0x2006      LDRSH    R2,[R4, #+6]
   \   0000009A   0x4282             CMP      R2,R0
   \   0000009C   0xD10D             BNE.N    ??_MULTIEDIT_Callback_11
   \   0000009E   0xA900             ADD      R1,SP,#+0
   \   000000A0   0x4610             MOV      R0,R2
   \   000000A2   0x.... 0x....      BL       WM_GetScrollState
   \   000000A6   0x9801             LDR      R0,[SP, #+4]
   \   000000A8   0x65F0             STR      R0,[R6, #+92]
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       WM_InvalidateWindow
   \   000000B0   0x210A             MOVS     R1,#+10
   \   000000B2   0x4628             MOV      R0,R5
   \   000000B4   0x.... 0x....      BL       WM_NotifyParent
   \   000000B8   0xE7D0             B.N      ??_MULTIEDIT_Callback_8
   \                     ??_MULTIEDIT_Callback_11: (+1)
   \   000000BA   0x4628             MOV      R0,R5
   \   000000BC   0x.... 0x....      BL       WM_GetScrollbarH
   \   000000C0   0x4601             MOV      R1,R0
   \   000000C2   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xD1C8             BNE.N    ??_MULTIEDIT_Callback_8
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x.... 0x....      BL       WM_GetScrollState
   \   000000D0   0x9801             LDR      R0,[SP, #+4]
   \   000000D2   0xF106 0x015C      ADD      R1,R6,#+92
   \   000000D6   0x60C8             STR      R0,[R1, #+12]
   \   000000D8   0x4628             MOV      R0,R5
   \   000000DA   0x.... 0x....      BL       WM_InvalidateWindow
   \   000000DE   0x210A             MOVS     R1,#+10
   \   000000E0   0x4628             MOV      R0,R5
   \   000000E2   0x.... 0x....      BL       WM_NotifyParent
   \   000000E6   0xE7B9             B.N      ??_MULTIEDIT_Callback_8
   \                     ??_MULTIEDIT_Callback_10: (+1)
   \   000000E8   0x4628             MOV      R0,R5
   \   000000EA   0x.... 0x....      BL       _SetScrollState
   \   000000EE   0xE7B5             B.N      ??_MULTIEDIT_Callback_8
   \                     ??_MULTIEDIT_Callback_5: (+1)
   \   000000F0   0x4631             MOV      R1,R6
   \   000000F2   0x4628             MOV      R0,R5
   \   000000F4   0x.... 0x....      BL       _MULTIEDIT_Paint
   \   000000F8   0xBD7F             POP      {R0-R6,PC}
   \                     ??_MULTIEDIT_Callback_3: (+1)
   \   000000FA   0x4622             MOV      R2,R4
   \   000000FC   0x4631             MOV      R1,R6
   \   000000FE   0x4628             MOV      R0,R5
   \   00000100   0x.... 0x....      BL       _OnTouch
   \   00000104   0xE7AA             B.N      ??_MULTIEDIT_Callback_8
   \                     ??_MULTIEDIT_Callback_2: (+1)
   \   00000106   0xF106 0x0038      ADD      R0,R6,#+56
   \   0000010A   0x.... 0x....      BL       GUI_ALLOC_FreePtr
   \   0000010E   0xE7A5             B.N      ??_MULTIEDIT_Callback_8
   \                     ??_MULTIEDIT_Callback_4: (+1)
   \   00000110   0x68A0             LDR      R0,[R4, #+8]
   \   00000112   0x6841             LDR      R1,[R0, #+4]
   \   00000114   0x2901             CMP      R1,#+1
   \   00000116   0xDB07             BLT.N    ??_MULTIEDIT_Callback_12
   \   00000118   0x6801             LDR      R1,[R0, #+0]
   \   0000011A   0xB289             UXTH     R1,R1
   \   0000011C   0x4628             MOV      R0,R5
   \   0000011E   0x.... 0x....      BL       _AddKey
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD09A             BEQ.N    ??_MULTIEDIT_Callback_8
   \   00000126   0xBD7F             POP      {R0-R6,PC}
   \                     ??_MULTIEDIT_Callback_12: (+1)
   \   00000128   0xF106 0x005C      ADD      R0,R6,#+92
   \   0000012C   0x7E00             LDRB     R0,[R0, #+24]
   \   0000012E   0x07C0             LSLS     R0,R0,#+31
   \   00000130   0xD494             BMI.N    ??_MULTIEDIT_Callback_8
   \   00000132   0xBD7F             POP      {R0-R6,PC}
   1364          
   1365          /*********************************************************************
   1366          *
   1367          *       Exported routines:  Create
   1368          *
   1369          **********************************************************************
   1370          */
   1371          
   1372          /* Note: the parameters to a create function may vary.
   1373                   Some widgets may have multiple create functions */
   1374          
   1375          /*********************************************************************
   1376          *
   1377          *       MULTIEDIT_CreateEx
   1378          */

   \                                 In section .text, align 2, keep-with-next
   1379          MULTIEDIT_HANDLE MULTIEDIT_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int WinFlags, int ExFlags,
   1380                                              int Id, int BufferSize, const char* pText)
   1381          {
   \                     MULTIEDIT_CreateEx: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0xF9BD 0x6028      LDRSH    R6,[SP, #+40]
   1382            MULTIEDIT_HANDLE hObj;
   1383            /* Create the window */
   1384            WM_LOCK();
   1385            if ((xsize == 0) && (ysize == 0) && (x0 == 0) && (y0 == 0)) {
   \   0000000C   0xEA43 0x0002      ORR      R0,R3,R2
   \   00000010   0x4320             ORRS     R0,R4,R0
   \   00000012   0x4328             ORRS     R0,R5,R0
   \   00000014   0xD10F             BNE.N    ??MULTIEDIT_CreateEx_0
   1386              GUI_RECT Rect;
   1387              WM_GetClientRectEx(hParent, &Rect);
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0x.... 0x....      BL       WM_GetClientRectEx
   1388              xsize = Rect.x1 - Rect.x0 + 1;
   \   0000001E   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000022   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000026   0x1A40             SUBS     R0,R0,R1
   \   00000028   0x1C42             ADDS     R2,R0,#+1
   1389              ysize = Rect.y1 - Rect.y0 + 1;
   \   0000002A   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   0000002E   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000032   0x1A40             SUBS     R0,R0,R1
   \   00000034   0x1C43             ADDS     R3,R0,#+1
   1390            }
   1391            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &_MULTIEDIT_Callback,
   1392                                          sizeof(MULTIEDIT_OBJ) - sizeof(WM_Obj));
   \                     ??MULTIEDIT_CreateEx_0: (+1)
   \   00000036   0x205C             MOVS     R0,#+92
   \   00000038   0x9003             STR      R0,[SP, #+12]
   \   0000003A   0x....             LDR.N    R0,??DataTable1_1
   \   0000003C   0x9002             STR      R0,[SP, #+8]
   \   0000003E   0x980B             LDR      R0,[SP, #+44]
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x9600             STR      R6,[SP, #+0]
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000004E   0x0004             MOVS     R4,R0
   1393            if (hObj) {
   \   00000050   0xD03E             BEQ.N    ??MULTIEDIT_CreateEx_1
   1394              int i;
   1395              MULTIEDIT_OBJ* pObj = MULTIEDIT_H2P(hObj);
   \   00000052   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000056   0x4605             MOV      R5,R0
   1396              /* init widget specific variables */
   1397              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   00000058   0x2210             MOVS     R2,#+16
   \   0000005A   0x990D             LDR      R1,[SP, #+52]
   \   0000005C   0x.... 0x....      BL       WIDGET__Init
   1398              /* init member variables */
   1399              MULTIEDIT_INIT_ID(pObj);
   1400              for (i = 0; i < NUM_DISP_MODES; i++) {
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE009             B.N      ??MULTIEDIT_CreateEx_2
   1401                pObj->aBkColor[i]  = _aDefaultBkColor[i];
   \                     ??MULTIEDIT_CreateEx_3: (+1)
   \   00000064   0xEB05 0x0180      ADD      R1,R5,R0, LSL #+2
   \   00000068   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \   0000006C   0x628B             STR      R3,[R1, #+40]
   1402                pObj->aColor[i]    = _aDefaultColor[i];
   \   0000006E   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \   00000072   0x6892             LDR      R2,[R2, #+8]
   \   00000074   0x630A             STR      R2,[R1, #+48]
   1403              }
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \                     ??MULTIEDIT_CreateEx_2: (+1)
   \   00000078   0x....             LDR.N    R2,??DataTable1_2
   \   0000007A   0x2802             CMP      R0,#+2
   \   0000007C   0xDBF2             BLT.N    ??MULTIEDIT_CreateEx_3
   1404              pObj->pFont          = _pDefaultFont;
   \   0000007E   0xF105 0x0638      ADD      R6,R5,#+56
   \   00000082   0x6910             LDR      R0,[R2, #+16]
   \   00000084   0x63B0             STR      R0,[R6, #+56]
   1405              pObj->Flags          = ExFlags;
   \   00000086   0x980C             LDR      R0,[SP, #+48]
   \   00000088   0xF885 0x0074      STRB     R0,[R5, #+116]
   1406              pObj->CursorPosChar  = 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x8230             STRH     R0,[R6, #+16]
   1407              pObj->CursorPosByte  = 0;
   \   00000090   0x8270             STRH     R0,[R6, #+18]
   1408              pObj->HBorder        = 1;
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xF885 0x0077      STRB     R0,[R5, #+119]
   1409              pObj->MaxNumChars    = 0;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x8070             STRH     R0,[R6, #+2]
   1410              pObj->NumCharsPrompt = 0;
   \   0000009C   0x80F0             STRH     R0,[R6, #+6]
   1411              pObj->BufferSize     = 0;
   \   0000009E   0x81B0             STRH     R0,[R6, #+12]
   1412              pObj->hText          = 0;
   \   000000A0   0x8728             STRH     R0,[R5, #+56]
   \   000000A2   0x9F0E             LDR      R7,[SP, #+56]
   1413              if (BufferSize > 0) {
   \   000000A4   0x2F01             CMP      R7,#+1
   \   000000A6   0xDB0C             BLT.N    ??MULTIEDIT_CreateEx_4
   1414                WM_HWIN hText;
   1415                if ((hText = GUI_ALLOC_AllocZero(BufferSize)) != 0) {
   \   000000A8   0x4638             MOV      R0,R7
   \   000000AA   0xB200             SXTH     R0,R0
   \   000000AC   0x.... 0x....      BL       GUI_ALLOC_AllocZero
   \   000000B0   0x0001             MOVS     R1,R0
   \   000000B2   0xD002             BEQ.N    ??MULTIEDIT_CreateEx_5
   1416                  pObj->BufferSize = BufferSize;
   \   000000B4   0x81B7             STRH     R7,[R6, #+12]
   1417                  pObj->hText      = hText;
   \   000000B6   0x8729             STRH     R1,[R5, #+56]
   \   000000B8   0xE003             B.N      ??MULTIEDIT_CreateEx_4
   1418                } else {
   1419                  GUI_DEBUG_ERROROUT("MULTIEDIT_CreateEx failed to alloc buffer");
   1420                  WM_DeleteWindow(hObj);
   \                     ??MULTIEDIT_CreateEx_5: (+1)
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       WM_DeleteWindow
   1421                  hObj = 0;
   \   000000C0   0x2400             MOVS     R4,#+0
   1422                }
   1423              }
   1424              MULTIEDIT_SetText(hObj, pText);
   \                     ??MULTIEDIT_CreateEx_4: (+1)
   \   000000C2   0x990F             LDR      R1,[SP, #+60]
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0x.... 0x....      BL       MULTIEDIT_SetText
   1425              _ManageScrollers(hObj);
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       _ManageScrollers
   1426            } else {
   1427              GUI_DEBUG_ERROROUT_IF(hObj==0, "MULTIEDIT_CreateEx failed")
   1428            }
   1429            WM_UNLOCK();
   1430            return hObj;
   \                     ??MULTIEDIT_CreateEx_1: (+1)
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0xB005             ADD      SP,SP,#+20
   \   000000D4   0xBDF0             POP      {R4-R7,PC}       ;; return
   1431          }
   1432          
   1433          /*********************************************************************
   1434          *
   1435          *       Exported routines:  Various methods
   1436          *
   1437          **********************************************************************
   1438          */
   1439          /*********************************************************************
   1440          *
   1441          *       MULTIEDIT_AddKey
   1442          */

   \                                 In section .text, align 2, keep-with-next
   1443          int MULTIEDIT_AddKey(MULTIEDIT_HANDLE hObj, U16 Key) {
   \                     MULTIEDIT_AddKey: (+1)
   \   00000000   0x4602             MOV      R2,R0
   1444            int r = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   1445            if (hObj) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD001             BEQ.N    ??MULTIEDIT_AddKey_0
   1446              WM_LOCK();
   1447              r = _AddKey(hObj, Key);
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0x....             B.N      _AddKey
   1448              WM_UNLOCK();
   1449            }
   1450            return r;
   \                     ??MULTIEDIT_AddKey_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
   1451          }
   1452          
   1453          /*********************************************************************
   1454          *
   1455          *       MULTIEDIT_SetText
   1456          */

   \                                 In section .text, align 2, keep-with-next
   1457          void MULTIEDIT_SetText(MULTIEDIT_HANDLE hObj, const char* pNew) {
   \                     MULTIEDIT_SetText: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1458            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD05E             BEQ.N    ??MULTIEDIT_SetText_0
   1459              MULTIEDIT_OBJ* pObj;
   1460              int NumCharsNew = 0, NumCharsOld = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0x46B1             MOV      R9,R6
   1461              int NumBytesNew = 0, NumBytesOld = 0;
   \   00000010   0x4637             MOV      R7,R6
   \   00000012   0x46B2             MOV      R10,R6
   1462              char* pText;
   1463              WM_LOCK();
   1464              pObj = MULTIEDIT_H2P(hObj);
   \   00000014   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000018   0x4680             MOV      R8,R0
   1465              if (pObj->hText) {
   \   0000001A   0xF9B8 0x0038      LDRSH    R0,[R8, #+56]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD011             BEQ.N    ??MULTIEDIT_SetText_1
   1466                pText  = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000022   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000026   0x4681             MOV      R9,R0
   1467                pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
   \   00000028   0xF8B8 0x103E      LDRH     R1,[R8, #+62]
   \   0000002C   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000030   0xEB00 0x0A09      ADD      R10,R0,R9
   1468                NumCharsOld = GUI__GetNumChars(pText);
   \   00000034   0x4650             MOV      R0,R10
   \   00000036   0x.... 0x....      BL       GUI__GetNumChars
   \   0000003A   0x4681             MOV      R9,R0
   1469                NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x4650             MOV      R0,R10
   \   00000040   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000044   0x4682             MOV      R10,R0
   1470              }
   1471              if (pNew) {
   \                     ??MULTIEDIT_SetText_1: (+1)
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD008             BEQ.N    ??MULTIEDIT_SetText_2
   1472                NumCharsNew = GUI__GetNumChars(pNew);
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       GUI__GetNumChars
   \   00000050   0x4606             MOV      R6,R0
   1473                NumBytesNew = GUI_UC__NumChars2NumBytes(pNew, NumCharsNew);
   \   00000052   0x4631             MOV      R1,R6
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000005A   0x4607             MOV      R7,R0
   1474              }
   1475              if (_IsCharsAvailable(pObj, NumCharsNew - NumCharsOld)) {
   \                     ??MULTIEDIT_SetText_2: (+1)
   \   0000005C   0xEBA6 0x0109      SUB      R1,R6,R9
   \   00000060   0x4640             MOV      R0,R8
   \   00000062   0x.... 0x....      BL       _IsCharsAvailable
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD02F             BEQ.N    ??MULTIEDIT_SetText_0
   1476                if (_IsSpaceInBuffer(pObj, NumBytesNew - NumBytesOld)) {
   \   0000006A   0xEBA7 0x010A      SUB      R1,R7,R10
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       _IsSpaceInBuffer
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD028             BEQ.N    ??MULTIEDIT_SetText_0
   1477                  pText  = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000078   0xF9B8 0x0038      LDRSH    R0,[R8, #+56]
   \   0000007C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000080   0x4606             MOV      R6,R0
   1478                  pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
   \   00000082   0xF8B8 0x103E      LDRH     R1,[R8, #+62]
   \   00000086   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   0000008A   0xEB00 0x0A06      ADD      R10,R0,R6
   1479                  if (pNew) {
   \   0000008E   0x2D00             CMP      R5,#+0
   \   00000090   0xD004             BEQ.N    ??MULTIEDIT_SetText_3
   1480                    strcpy(pText, pNew);
   \   00000092   0x4629             MOV      R1,R5
   \   00000094   0x4650             MOV      R0,R10
   \   00000096   0x.... 0x....      BL       strcpy
   \   0000009A   0xE002             B.N      ??MULTIEDIT_SetText_4
   1481                  } else {
   1482                    *pText = 0;
   \                     ??MULTIEDIT_SetText_3: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF88A 0x0000      STRB     R0,[R10, #+0]
   1483                  }
   1484                  _SetCursorPos(hObj, pObj, pObj->NumCharsPrompt);
   \                     ??MULTIEDIT_SetText_4: (+1)
   \   000000A2   0xF8B8 0x203E      LDRH     R2,[R8, #+62]
   \   000000A6   0x4641             MOV      R1,R8
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       _SetCursorPos
   1485                  _InvalidateTextArea(hObj);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       _InvalidateTextArea
   1486                  _InvalidateNumChars(pObj);
   \   000000B4   0x4640             MOV      R0,R8
   \   000000B6   0x.... 0x....      BL       _InvalidateNumChars
   1487                  _InvalidateNumLines(pObj);
   \   000000BA   0x4640             MOV      R0,R8
   \   000000BC   0x.... 0x....      BL       _InvalidateNumLines
   1488                  _InvalidateTextSizeX(pObj);
   \   000000C0   0x4640             MOV      R0,R8
   \   000000C2   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000C6   0x.... 0x....      B.W      _InvalidateTextSizeX
   1489                }
   1490              }
   1491              WM_UNLOCK();
   1492            }
   1493          }
   \                     ??MULTIEDIT_SetText_0: (+1)
   \   000000CA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1494          
   1495          /*********************************************************************
   1496          *
   1497          *       MULTIEDIT_GetText
   1498          */

   \                                 In section .text, align 2, keep-with-next
   1499          void MULTIEDIT_GetText(MULTIEDIT_HANDLE hObj, char* sDest, int MaxLen) {
   \                     MULTIEDIT_GetText: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
   1500            if (hObj) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01B             BEQ.N    ??MULTIEDIT_GetText_0
   1501              MULTIEDIT_OBJ* pObj;
   1502              WM_LOCK();
   1503              pObj = MULTIEDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x0006             MOVS     R6,R0
   1504              if (pObj) {
   \   00000010   0xD017             BEQ.N    ??MULTIEDIT_GetText_0
   1505                char* pText;
   1506                int Len;
   1507                pText  = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000012   0xF9B6 0x0038      LDRSH    R0,[R6, #+56]
   \   00000016   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001A   0x4607             MOV      R7,R0
   1508                pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
   \   0000001C   0x8FF1             LDRH     R1,[R6, #+62]
   \   0000001E   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000022   0x19C6             ADDS     R6,R0,R7
   1509                Len    = strlen(pText);
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       strlen
   \   0000002A   0x4607             MOV      R7,R0
   1510                if (Len > (MaxLen - 1)) {
   \   0000002C   0x1E68             SUBS     R0,R5,#+1
   \   0000002E   0x42B8             CMP      R0,R7
   \   00000030   0xDA00             BGE.N    ??MULTIEDIT_GetText_1
   1511                  Len = MaxLen - 1;
   \   00000032   0x4607             MOV      R7,R0
   1512                }
   1513                memcpy(sDest, pText, Len);
   \                     ??MULTIEDIT_GetText_1: (+1)
   \   00000034   0x463A             MOV      R2,R7
   \   00000036   0x4631             MOV      R1,R6
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       memcpy
   1514                *(sDest + Len) = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x5538             STRB     R0,[R7, R4]
   1515              }
   1516              WM_UNLOCK();
   1517            }
   1518          }
   \                     ??MULTIEDIT_GetText_0: (+1)
   \   00000042   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1519          
   1520          /*********************************************************************
   1521          *
   1522          *       MULTIEDIT_GetPrompt
   1523          */

   \                                 In section .text, align 2, keep-with-next
   1524          void MULTIEDIT_GetPrompt(MULTIEDIT_HANDLE hObj, char * sDest, int MaxLen) {
   \                     MULTIEDIT_GetPrompt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
   1525            if (hObj) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD017             BEQ.N    ??MULTIEDIT_GetPrompt_0
   1526              MULTIEDIT_OBJ * pObj;
   1527              WM_LOCK();
   1528              pObj = MULTIEDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x0006             MOVS     R6,R0
   1529              if (pObj) {
   \   00000010   0xD013             BEQ.N    ??MULTIEDIT_GetPrompt_0
   1530                char* sSource = (char*)GUI_ALLOC_h2p(pObj->hText);
   \   00000012   0xF9B6 0x0038      LDRSH    R0,[R6, #+56]
   \   00000016   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001A   0x4607             MOV      R7,R0
   1531                int Len = GUI_UC__NumChars2NumBytes(sSource, pObj->NumCharsPrompt);
   \   0000001C   0x8FF1             LDRH     R1,[R6, #+62]
   \   0000001E   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000022   0x4606             MOV      R6,R0
   1532                if (Len > (MaxLen - 1)) {
   \   00000024   0x1E68             SUBS     R0,R5,#+1
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xDA00             BGE.N    ??MULTIEDIT_GetPrompt_1
   1533                  Len = MaxLen - 1;
   \   0000002A   0x4606             MOV      R6,R0
   1534                }
   1535                memcpy(sDest, sSource, Len);
   \                     ??MULTIEDIT_GetPrompt_1: (+1)
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4639             MOV      R1,R7
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       memcpy
   1536                *(sDest + Len) = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x5530             STRB     R0,[R6, R4]
   1537              }
   1538              WM_UNLOCK();
   1539            }
   1540          }
   \                     ??MULTIEDIT_GetPrompt_0: (+1)
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1541          
   1542          /*********************************************************************
   1543          *
   1544          *       MULTIEDIT_SetWrapWord
   1545          */

   \                                 In section .text, align 2, keep-with-next
   1546          void MULTIEDIT_SetWrapWord(MULTIEDIT_HANDLE hObj) {
   1547            _SetWrapMode(hObj, GUI_WRAPMODE_WORD);
   \                     MULTIEDIT_SetWrapWord: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x.... 0x....      B.W      _SetWrapMode
   1548          }
   1549          
   1550          /*********************************************************************
   1551          *
   1552          *       MULTIEDIT_SetWrapChar
   1553          */

   \                                 In section .text, align 2, keep-with-next
   1554          void MULTIEDIT_SetWrapChar(MULTIEDIT_HANDLE hObj) {
   1555            _SetWrapMode(hObj, GUI_WRAPMODE_CHAR);
   \                     MULTIEDIT_SetWrapChar: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x.... 0x....      B.W      _SetWrapMode
   1556          }
   1557          
   1558          /*********************************************************************
   1559          *
   1560          *       MULTIEDIT_SetWrapNone
   1561          */

   \                                 In section .text, align 2, keep-with-next
   1562          void MULTIEDIT_SetWrapNone(MULTIEDIT_HANDLE hObj) {
   1563            _SetWrapMode(hObj, GUI_WRAPMODE_NONE);
   \                     MULTIEDIT_SetWrapNone: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      B.W      _SetWrapMode
   1564          }
   1565          
   1566          /*********************************************************************
   1567          *
   1568          *       MULTIEDIT_SetInsertMode
   1569          */

   \                                 In section .text, align 2, keep-with-next
   1570          void MULTIEDIT_SetInsertMode(MULTIEDIT_HANDLE hObj, int OnOff) {
   1571            _SetFlag(hObj, OnOff, MULTIEDIT_SF_INSERT);
   \                     MULTIEDIT_SetInsertMode: (+1)
   \   00000000   0x2204             MOVS     R2,#+4
   \   00000002   0x.... 0x....      B.W      _SetFlag
   1572          }
   1573          
   1574          /*********************************************************************
   1575          *
   1576          *       MULTIEDIT_SetReadOnly
   1577          */

   \                                 In section .text, align 2, keep-with-next
   1578          void MULTIEDIT_SetReadOnly(MULTIEDIT_HANDLE hObj, int OnOff) {
   1579            _SetFlag(hObj, OnOff, MULTIEDIT_SF_READONLY);
   \                     MULTIEDIT_SetReadOnly: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x.... 0x....      B.W      _SetFlag
   1580          }
   1581          
   1582          /*********************************************************************
   1583          *
   1584          *       MULTIEDIT_SetPasswordMode
   1585          */

   \                                 In section .text, align 2, keep-with-next
   1586          void MULTIEDIT_SetPasswordMode(MULTIEDIT_HANDLE hObj, int OnOff) {
   \                     MULTIEDIT_SetPasswordMode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1587            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD012             BEQ.N    ??MULTIEDIT_SetPasswordMode_0
   1588              MULTIEDIT_OBJ* pObj;
   1589              WM_LOCK();
   1590              pObj = MULTIEDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
   1591              _SetFlag(hObj, OnOff, MULTIEDIT_SF_PASSWORD);
   \   00000010   0x2220             MOVS     R2,#+32
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _SetFlag
   1592              _InvalidateCursorXY(pObj);
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0x.... 0x....      BL       _InvalidateCursorXY
   1593              _InvalidateNumLines(pObj);
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       _InvalidateNumLines
   1594              _InvalidateTextSizeX(pObj);
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002C   0x.... 0x....      B.W      _InvalidateTextSizeX
   1595              WM_UNLOCK();
   1596            }
   1597          }
   \                     ??MULTIEDIT_SetPasswordMode_0: (+1)
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
   1598          
   1599          /*********************************************************************
   1600          *
   1601          *       MULTIEDIT_SetAutoScrollV
   1602          */

   \                                 In section .text, align 2, keep-with-next
   1603          void MULTIEDIT_SetAutoScrollV(MULTIEDIT_HANDLE hObj, int OnOff) {
   1604            _SetFlag(hObj, OnOff, MULTIEDIT_SF_AUTOSCROLLBAR_V);
   \                     MULTIEDIT_SetAutoScrollV: (+1)
   \   00000000   0x2208             MOVS     R2,#+8
   \   00000002   0x.... 0x....      B.W      _SetFlag
   1605          }
   1606          
   1607          /*********************************************************************
   1608          *
   1609          *       MULTIEDIT_SetAutoScrollH
   1610          */

   \                                 In section .text, align 2, keep-with-next
   1611          void MULTIEDIT_SetAutoScrollH(MULTIEDIT_HANDLE hObj, int OnOff) {
   1612            _SetFlag(hObj, OnOff, MULTIEDIT_SF_AUTOSCROLLBAR_H);
   \                     MULTIEDIT_SetAutoScrollH: (+1)
   \   00000000   0x2210             MOVS     R2,#+16
   \   00000002   0x.... 0x....      B.W      _SetFlag
   1613          }
   1614          
   1615          /*********************************************************************
   1616          *
   1617          *       MULTIEDIT_SetHBorder
   1618          */

   \                                 In section .text, align 2, keep-with-next
   1619          void MULTIEDIT_SetHBorder(MULTIEDIT_HANDLE hObj, unsigned HBorder) {
   \                     MULTIEDIT_SetHBorder: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1620            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??MULTIEDIT_SetHBorder_0
   1621              MULTIEDIT_OBJ* pObj;
   1622              WM_LOCK();
   1623              pObj = MULTIEDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   1624              if ((unsigned)pObj->HBorder != HBorder) {
   \   0000000E   0xF890 0x1077      LDRB     R1,[R0, #+119]
   \   00000012   0x42A9             CMP      R1,R5
   \   00000014   0xD006             BEQ.N    ??MULTIEDIT_SetHBorder_0
   1625                pObj->HBorder = HBorder;
   \   00000016   0xF880 0x5077      STRB     R5,[R0, #+119]
   1626                _Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      _Invalidate
   1627              }
   1628              WM_UNLOCK();
   1629            }
   1630          }
   \                     ??MULTIEDIT_SetHBorder_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1631          
   1632          /*********************************************************************
   1633          *
   1634          *       MULTIEDIT_SetFont
   1635          */

   \                                 In section .text, align 2, keep-with-next
   1636          void MULTIEDIT_SetFont(MULTIEDIT_HANDLE hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
   \                     MULTIEDIT_SetFont: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1637            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD014             BEQ.N    ??MULTIEDIT_SetFont_0
   1638              MULTIEDIT_OBJ* pObj;
   1639              WM_LOCK();
   1640              pObj = MULTIEDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
   1641              if (pObj->pFont != pFont) {
   \   00000010   0x6F30             LDR      R0,[R6, #+112]
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xD00E             BEQ.N    ??MULTIEDIT_SetFont_0
   1642                pObj->pFont = pFont;
   \   00000016   0x6735             STR      R5,[R6, #+112]
   1643                _InvalidateTextArea(hObj);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _InvalidateTextArea
   1644                _InvalidateCursorXY(pObj);
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       _InvalidateCursorXY
   1645                _InvalidateNumLines(pObj);
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       _InvalidateNumLines
   1646                _InvalidateTextSizeX(pObj);
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000030   0x.... 0x....      B.W      _InvalidateTextSizeX
   1647              }
   1648              WM_UNLOCK();
   1649            }
   1650          }
   \                     ??MULTIEDIT_SetFont_0: (+1)
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
   1651          
   1652          /*********************************************************************
   1653          *
   1654          *       MULTIEDIT_SetBkColor
   1655          */

   \                                 In section .text, align 2, keep-with-next
   1656          void MULTIEDIT_SetBkColor(MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color) {
   \                     MULTIEDIT_SetBkColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1657            if (hObj && (Index < NUM_DISP_MODES)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00B             BEQ.N    ??MULTIEDIT_SetBkColor_0
   \   0000000C   0x2D02             CMP      R5,#+2
   \   0000000E   0xD209             BCS.N    ??MULTIEDIT_SetBkColor_0
   1658              MULTIEDIT_OBJ* pObj;
   1659              WM_LOCK();
   1660              pObj = MULTIEDIT_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   1661              pObj->aBkColor[Index] = color;
   \   00000014   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000018   0x6286             STR      R6,[R0, #+40]
   1662              _InvalidateTextArea(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000020   0x.... 0x....      B.W      _InvalidateTextArea
   1663              WM_UNLOCK();
   1664            }
   1665          }
   \                     ??MULTIEDIT_SetBkColor_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
   1666          
   1667          /*********************************************************************
   1668          *
   1669          *       MULTIEDIT_SetCursorOffset
   1670          */

   \                                 In section .text, align 2, keep-with-next
   1671          void MULTIEDIT_SetCursorOffset(MULTIEDIT_HANDLE hObj, int Offset) {
   \                     MULTIEDIT_SetCursorOffset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1672            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00B             BEQ.N    ??MULTIEDIT_SetCursorOffset_0
   1673              MULTIEDIT_OBJ* pObj;
   1674              WM_LOCK();
   1675              pObj = MULTIEDIT_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   1676              _SetCursorPos(hObj, pObj, Offset);
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       _SetCursorPos
   1677              WM_Invalidate(hObj);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000001E   0x.... 0x....      B.W      WM_InvalidateWindow
   1678              WM_UNLOCK();
   1679            }
   1680          }
   \                     ??MULTIEDIT_SetCursorOffset_0: (+1)
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1681          
   1682          /*********************************************************************
   1683          *
   1684          *       MULTIEDIT_SetTextColor
   1685          */

   \                                 In section .text, align 2, keep-with-next
   1686          void MULTIEDIT_SetTextColor(MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color) {
   \                     MULTIEDIT_SetTextColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1687            if (hObj && (Index < NUM_DISP_MODES)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00B             BEQ.N    ??MULTIEDIT_SetTextColor_0
   \   0000000C   0x2D02             CMP      R5,#+2
   \   0000000E   0xD209             BCS.N    ??MULTIEDIT_SetTextColor_0
   1688              MULTIEDIT_OBJ* pObj;
   1689              WM_LOCK();
   1690              pObj = MULTIEDIT_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   1691              pObj->aColor[Index] = color;
   \   00000014   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000018   0x6306             STR      R6,[R0, #+48]
   1692              WM_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
   1693              WM_UNLOCK();
   1694            }
   1695          }
   \                     ??MULTIEDIT_SetTextColor_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
   1696          
   1697          /*********************************************************************
   1698          *
   1699          *       MULTIEDIT_SetPrompt
   1700          */

   \                                 In section .text, align 2, keep-with-next
   1701          void MULTIEDIT_SetPrompt(MULTIEDIT_HANDLE hObj, const char* pPrompt) {
   \                     MULTIEDIT_SetPrompt: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1702            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD057             BEQ.N    ??MULTIEDIT_SetPrompt_0
   1703              MULTIEDIT_OBJ* pObj;
   1704              int NumCharsNew = 0, NumCharsOld = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0x46B3             MOV      R11,R6
   1705              int NumBytesNew = 0, NumBytesOld = 0;
   \   00000010   0x4637             MOV      R7,R6
   \   00000012   0x46B0             MOV      R8,R6
   1706              char* pText;
   1707              WM_LOCK();
   1708              pObj = MULTIEDIT_H2P(hObj);
   \   00000014   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000018   0x4681             MOV      R9,R0
   1709              if (pObj->hText) {
   \   0000001A   0xF9B9 0x0038      LDRSH    R0,[R9, #+56]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ.N    ??MULTIEDIT_SetPrompt_1
   1710                pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000022   0x.... 0x....      BL       GUI_ALLOC_h2p
   1711                NumCharsOld = pObj->NumCharsPrompt;
   \   00000026   0xF8B9 0xB03E      LDRH     R11,[R9, #+62]
   1712                NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
   \   0000002A   0x4659             MOV      R1,R11
   \   0000002C   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000030   0x4680             MOV      R8,R0
   1713              }
   1714              if (pPrompt) {
   \                     ??MULTIEDIT_SetPrompt_1: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD008             BEQ.N    ??MULTIEDIT_SetPrompt_2
   1715                NumCharsNew = GUI__GetNumChars(pPrompt);
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       GUI__GetNumChars
   \   0000003C   0x4606             MOV      R6,R0
   1716                NumBytesNew = GUI_UC__NumChars2NumBytes(pPrompt, NumCharsNew);
   \   0000003E   0x4631             MOV      R1,R6
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000046   0x4607             MOV      R7,R0
   1717              }
   1718              if (_IsCharsAvailable(pObj, NumCharsNew - NumCharsOld)) {
   \                     ??MULTIEDIT_SetPrompt_2: (+1)
   \   00000048   0xEBA6 0x010B      SUB      R1,R6,R11
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       _IsCharsAvailable
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD032             BEQ.N    ??MULTIEDIT_SetPrompt_0
   1719                if (_IsSpaceInBuffer(pObj, NumBytesNew - NumBytesOld)) {
   \   00000056   0xEBA7 0x0108      SUB      R1,R7,R8
   \   0000005A   0x4648             MOV      R0,R9
   \   0000005C   0x.... 0x....      BL       _IsSpaceInBuffer
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD02B             BEQ.N    ??MULTIEDIT_SetPrompt_0
   1720                  pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000064   0xF9B9 0x0038      LDRSH    R0,[R9, #+56]
   \   00000068   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000006C   0x4682             MOV      R10,R0
   1721                  memmove(pText + NumBytesNew, pText + NumBytesOld, strlen(pText + NumBytesOld) + 1);
   \   0000006E   0xEB08 0x000A      ADD      R0,R8,R10
   \   00000072   0x.... 0x....      BL       strlen
   \   00000076   0x1C42             ADDS     R2,R0,#+1
   \   00000078   0xEB08 0x010A      ADD      R1,R8,R10
   \   0000007C   0xEB07 0x000A      ADD      R0,R7,R10
   \   00000080   0x.... 0x....      BL       memmove
   1722                  if (pPrompt) {
   \   00000084   0x2D00             CMP      R5,#+0
   \   00000086   0xD004             BEQ.N    ??MULTIEDIT_SetPrompt_3
   1723                    memcpy(pText, pPrompt, NumBytesNew);
   \   00000088   0x463A             MOV      R2,R7
   \   0000008A   0x4629             MOV      R1,R5
   \   0000008C   0x4650             MOV      R0,R10
   \   0000008E   0x.... 0x....      BL       memcpy
   1724                  }
   1725                  pObj->NumCharsPrompt = NumCharsNew;
   \                     ??MULTIEDIT_SetPrompt_3: (+1)
   \   00000092   0xF8A9 0x603E      STRH     R6,[R9, #+62]
   1726                  _SetCursorPos(hObj, pObj, NumCharsNew);
   \   00000096   0x4632             MOV      R2,R6
   \   00000098   0x4649             MOV      R1,R9
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       _SetCursorPos
   1727                  _InvalidateTextArea(hObj);
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       _InvalidateTextArea
   1728                  _InvalidateNumChars(pObj);
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0x.... 0x....      BL       _InvalidateNumChars
   1729                  _InvalidateNumLines(pObj);
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0x.... 0x....      BL       _InvalidateNumLines
   1730                  _InvalidateTextSizeX(pObj);
   \   000000B2   0x4648             MOV      R0,R9
   \   000000B4   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   000000B8   0x.... 0x....      B.W      _InvalidateTextSizeX
   1731                }
   1732              }
   1733              WM_UNLOCK();
   1734            }
   1735          }
   \                     ??MULTIEDIT_SetPrompt_0: (+1)
   \   000000BC   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   1736          
   1737          /*********************************************************************
   1738          *
   1739          *       MULTIEDIT_SetBufferSize
   1740          */

   \                                 In section .text, align 2, keep-with-next
   1741          void MULTIEDIT_SetBufferSize(MULTIEDIT_HANDLE hObj, int BufferSize) {
   \                     MULTIEDIT_SetBufferSize: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1742            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD029             BEQ.N    ??MULTIEDIT_SetBufferSize_0
   1743              MULTIEDIT_OBJ* pObj;
   1744              WM_HMEM hText;
   1745              WM_LOCK();
   1746              pObj = MULTIEDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4606             MOV      R6,R0
   1747              if ((hText = GUI_ALLOC_AllocZero(BufferSize)) == 0) {
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0xB200             SXTH     R0,R0
   \   00000016   0x.... 0x....      BL       GUI_ALLOC_AllocZero
   \   0000001A   0x0007             MOVS     R7,R0
   \   0000001C   0xD01B             BEQ.N    ??MULTIEDIT_SetBufferSize_1
   1748                GUI_DEBUG_ERROROUT("MULTIEDIT_SetBufferSize failed to alloc buffer");
   1749              } else {
   1750                GUI_ALLOC_FreePtr(&pObj->hText);
   \   0000001E   0xF106 0x0838      ADD      R8,R6,#+56
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x.... 0x....      BL       GUI_ALLOC_FreePtr
   1751                pObj->hText          = hText;
   \   00000028   0x8737             STRH     R7,[R6, #+56]
   1752                pObj->BufferSize     = BufferSize;
   \   0000002A   0xF8A8 0x500C      STRH     R5,[R8, #+12]
   1753                pObj->NumCharsPrompt = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF8A8 0x0006      STRH     R0,[R8, #+6]
   1754                _SetCursorPos(hObj, pObj, 0);
   \   00000034   0x4602             MOV      R2,R0
   \   00000036   0x4631             MOV      R1,R6
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       _SetCursorPos
   1755                _InvalidateNumChars(pObj);
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       _InvalidateNumChars
   1756                _InvalidateCursorXY(pObj);
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       _InvalidateCursorXY
   1757                _InvalidateNumLines(pObj);
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       _InvalidateNumLines
   1758                _InvalidateTextSizeX(pObj);
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       _InvalidateTextSizeX
   1759              }
   1760              _InvalidateTextArea(hObj);
   \                     ??MULTIEDIT_SetBufferSize_1: (+1)
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000005C   0x.... 0x....      B.W      _InvalidateTextArea
   1761              WM_UNLOCK();
   1762            }
   1763          }
   \                     ??MULTIEDIT_SetBufferSize_0: (+1)
   \   00000060   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1764          
   1765          /*********************************************************************
   1766          *
   1767          *       MULTIEDIT_SetMaxNumChars
   1768          */

   \                                 In section .text, align 2, keep-with-next
   1769          void MULTIEDIT_SetMaxNumChars(MULTIEDIT_HANDLE hObj, unsigned MaxNumChars) {
   \                     MULTIEDIT_SetMaxNumChars: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1770            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD028             BEQ.N    ??MULTIEDIT_SetMaxNumChars_0
   1771              MULTIEDIT_OBJ* pObj;
   1772              WM_LOCK();
   1773              pObj = MULTIEDIT_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4606             MOV      R6,R0
   1774              pObj->MaxNumChars = MaxNumChars;
   \   00000012   0xF106 0x0738      ADD      R7,R6,#+56
   \   00000016   0x807D             STRH     R5,[R7, #+2]
   1775              if (MaxNumChars < (unsigned)pObj->NumCharsPrompt) {
   \   00000018   0x88F8             LDRH     R0,[R7, #+6]
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xD200             BCS.N    ??MULTIEDIT_SetMaxNumChars_1
   1776                pObj->NumCharsPrompt = MaxNumChars;
   \   0000001E   0x80FD             STRH     R5,[R7, #+6]
   1777              }
   1778              if (pObj->hText && MaxNumChars) {
   \                     ??MULTIEDIT_SetMaxNumChars_1: (+1)
   \   00000020   0xF9B6 0x0038      LDRSH    R0,[R6, #+56]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD01A             BEQ.N    ??MULTIEDIT_SetMaxNumChars_0
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD018             BEQ.N    ??MULTIEDIT_SetMaxNumChars_0
   1779                char* pText;
   1780                int Offset;
   1781                pText = (char*) GUI_ALLOC_h2p(pObj->hText);
   \   0000002C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000030   0x4680             MOV      R8,R0
   1782                Offset = GUI_UC__NumChars2NumBytes(pText, MaxNumChars);
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000038   0x4602             MOV      R2,R0
   1783                if (Offset < pObj->BufferSize) {
   \   0000003A   0x89B8             LDRH     R0,[R7, #+12]
   \   0000003C   0x4282             CMP      R2,R0
   \   0000003E   0xDA0E             BGE.N    ??MULTIEDIT_SetMaxNumChars_0
   1784                  pText += Offset;
   1785                  *pText = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF802 0x0008      STRB     R0,[R2, R8]
   1786                  _SetCursorPos(hObj, pObj, Offset);
   \   00000046   0x4631             MOV      R1,R6
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _SetCursorPos
   1787                  _InvalidateTextArea(hObj);
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _InvalidateTextArea
   1788                  _InvalidateNumChars(pObj);
   \   00000054   0x4630             MOV      R0,R6
   \   00000056   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000005A   0x.... 0x....      B.W      _InvalidateNumChars
   1789                }
   1790              }
   1791              WM_UNLOCK();
   1792            }
   1793          }
   \                     ??MULTIEDIT_SetMaxNumChars_0: (+1)
   \   0000005E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1794          
   1795          /*********************************************************************
   1796          *
   1797          *       MULTIEDIT_GetTextSize
   1798          *
   1799          * Purpose:
   1800          *   Returns the number of bytes required to store the text.
   1801          *   It is typically used when allocating a buffer to pass to
   1802          *   MULTIEDIT_GetText().
   1803          */

   \                                 In section .text, align 2, keep-with-next
   1804          int MULTIEDIT_GetTextSize(MULTIEDIT_HANDLE hObj) {
   \                     MULTIEDIT_GetTextSize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1805            int r = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   1806            if (hObj) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD010             BEQ.N    ??MULTIEDIT_GetTextSize_0
   1807              MULTIEDIT_OBJ* pObj;
   1808              WM_LOCK();
   1809              pObj = MULTIEDIT_H2P(hObj);
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000C   0x4605             MOV      R5,R0
   1810              if (pObj->hText) {
   \   0000000E   0xF9B5 0x0038      LDRSH    R0,[R5, #+56]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD009             BEQ.N    ??MULTIEDIT_GetTextSize_0
   1811                const char* s;
   1812                s = (const char*)GUI_ALLOC_h2p(pObj->hText);
   \   00000016   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001A   0x4604             MOV      R4,R0
   1813                s += GUI_UC__NumChars2NumBytes(s, pObj->NumCharsPrompt);
   \   0000001C   0x8FE9             LDRH     R1,[R5, #+62]
   \   0000001E   0x.... 0x....      BL       GUI_UC__NumChars2NumBytes
   \   00000022   0x1900             ADDS     R0,R0,R4
   1814                r = 1 + strlen(s);
   \   00000024   0x.... 0x....      BL       strlen
   \   00000028   0x1C44             ADDS     R4,R0,#+1
   1815              }
   1816              WM_UNLOCK();
   1817            }
   1818            return r;
   \                     ??MULTIEDIT_GetTextSize_0: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1819          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     _MULTIEDIT_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     _aDefaultBkColor
   1820          
   1821          
   1822          #else /* avoid empty object files */
   1823          
   1824          void MULTIEDIT_C(void);
   1825          void MULTIEDIT_C(void){}
   1826          
   1827          #endif  /* #if GUI_WINSUPPORT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MULTIEDIT_AddKey
         0   -> _AddKey
      40   MULTIEDIT_CreateEx
        40   -> GUI_ALLOC_AllocZero
        40   -> GUI_ALLOC_h2p
        40   -> MULTIEDIT_SetText
        40   -> WIDGET__Init
        40   -> WM_CreateWindowAsChild
        40   -> WM_DeleteWindow
        40   -> WM_GetClientRectEx
        40   -> _ManageScrollers
      24   MULTIEDIT_GetPrompt
        24   -> GUI_ALLOC_h2p
        24   -> GUI_UC__NumChars2NumBytes
        24   -> memcpy
      24   MULTIEDIT_GetText
        24   -> GUI_ALLOC_h2p
        24   -> GUI_UC__NumChars2NumBytes
        24   -> memcpy
        24   -> strlen
      16   MULTIEDIT_GetTextSize
        16   -> GUI_ALLOC_h2p
        16   -> GUI_UC__NumChars2NumBytes
        16   -> strlen
       0   MULTIEDIT_SetAutoScrollH
         0   -> _SetFlag
       0   MULTIEDIT_SetAutoScrollV
         0   -> _SetFlag
      16   MULTIEDIT_SetBkColor
        16   -> GUI_ALLOC_h2p
         0   -> _InvalidateTextArea
      24   MULTIEDIT_SetBufferSize
        24   -> GUI_ALLOC_AllocZero
        24   -> GUI_ALLOC_FreePtr
        24   -> GUI_ALLOC_h2p
        24   -> _InvalidateCursorXY
        24   -> _InvalidateNumChars
        24   -> _InvalidateNumLines
         0   -> _InvalidateTextArea
        24   -> _InvalidateTextSizeX
        24   -> _SetCursorPos
      16   MULTIEDIT_SetCursorOffset
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
        16   -> _SetCursorPos
      16   MULTIEDIT_SetFont
        16   -> GUI_ALLOC_h2p
        16   -> _InvalidateCursorXY
        16   -> _InvalidateNumLines
        16   -> _InvalidateTextArea
         0   -> _InvalidateTextSizeX
      16   MULTIEDIT_SetHBorder
        16   -> GUI_ALLOC_h2p
         0   -> _Invalidate
       0   MULTIEDIT_SetInsertMode
         0   -> _SetFlag
      24   MULTIEDIT_SetMaxNumChars
        24   -> GUI_ALLOC_h2p
        24   -> GUI_UC__NumChars2NumBytes
         0   -> _InvalidateNumChars
        24   -> _InvalidateTextArea
        24   -> _SetCursorPos
      16   MULTIEDIT_SetPasswordMode
        16   -> GUI_ALLOC_h2p
        16   -> _InvalidateCursorXY
        16   -> _InvalidateNumLines
         0   -> _InvalidateTextSizeX
        16   -> _SetFlag
      40   MULTIEDIT_SetPrompt
        40   -> GUI_ALLOC_h2p
        40   -> GUI_UC__NumChars2NumBytes
        40   -> GUI__GetNumChars
        40   -> _InvalidateNumChars
        40   -> _InvalidateNumLines
        40   -> _InvalidateTextArea
         0   -> _InvalidateTextSizeX
        40   -> _IsCharsAvailable
        40   -> _IsSpaceInBuffer
        40   -> _SetCursorPos
        40   -> memcpy
        40   -> memmove
        40   -> strlen
       0   MULTIEDIT_SetReadOnly
         0   -> _SetFlag
      32   MULTIEDIT_SetText
        32   -> GUI_ALLOC_h2p
        32   -> GUI_UC__NumChars2NumBytes
        32   -> GUI__GetNumChars
        32   -> _InvalidateNumChars
        32   -> _InvalidateNumLines
        32   -> _InvalidateTextArea
         0   -> _InvalidateTextSizeX
        32   -> _IsCharsAvailable
        32   -> _IsSpaceInBuffer
        32   -> _SetCursorPos
        32   -> strcpy
      16   MULTIEDIT_SetTextColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
       0   MULTIEDIT_SetWrapChar
         0   -> _SetWrapMode
       0   MULTIEDIT_SetWrapNone
         0   -> _SetWrapMode
       0   MULTIEDIT_SetWrapWord
         0   -> _SetWrapMode
      24   _AddKey
        24   -> GUI_ALLOC_h2p
        24   -> _DeleteChar
        24   -> _InsertChar
        24   -> _InvalidateTextArea
        24   -> _IsOverwriteAtThisChar
        24   -> _MoveCursor2LineEnd
        24   -> _MoveCursor2LinePos1
        24   -> _MoveCursor2NextLine
        24   -> _MoveCursorDown
        24   -> _MoveCursorUp
        24   -> _SetCursorPos
      40   _CalcNextValidCursorPos
        40   -> GUI_ALLOC_h2p
        40   -> GUI_UC__NumBytes2NumChars
        40   -> GUI_UC__NumChars2NumBytes
        40   -> _GetCursorLine
        40   -> _GetNumChars
        40   -> _GetpLine
        40   -> _WrapGetNumCharsDisp
      16   _CalcScrollParas
        16   -> GUI_ALLOC_h2p
         0   -> _CalcScrollPos
        16   -> _GetNumLines
        16   -> _GetNumVisLines
        16   -> _GetTextSizeX
        16   -> _GetXSize
      24   _CalcScrollPos
        24   -> GUI_GetYDistOfFont
        24   -> WM_CheckScrollPos
        24   -> _GetCursorXY
        24   -> _SetScrollState
       0   _ClearCache
      32   _DeleteChar
        32   -> GUI_ALLOC_h2p
        32   -> GUI_UC_GetCharSize
        32   -> GUI_UC__NumBytes2NumChars
        32   -> GUI_UC__NumChars2NumBytes
        32   -> WM_NotifyParent
        32   -> _ClearCache
        32   -> _GetCursorLine
        32   -> _GetpLine
        32   -> _InvalidateCursorXY
        32   -> _InvalidateNumLines
        32   -> _InvalidateTextSizeX
        32   -> _WrapGetNumBytesToNextLine
        32   -> _WrapGetNumCharsDisp
        32   -> strcpy
        32   -> strlen
      24   _DispString
        24   -> GUI_DispCharAt
         0   -> GUI_DispChars
         0   -> GUI_DispStringInRectMax
        24   -> GUI_DispStringInRectMax
        24   -> _GetNumCharsInPrompt
        24   -> _NumChars2XSize
        24   -> _WrapGetNumCharsDisp
       8   _GetCharDistX
         0   -> GUI_GetCharDistX
         8   -> GUI_UC_GetCharCode
         8   -> _GetNumCharsInPrompt
      32   _GetCursorLine
        32   -> GUI_UC__NumChars2NumBytes
        32   -> _WrapGetNumBytesToNextLine
        32   -> _WrapGetNumCharsDisp
       8   _GetCursorSizeX
         8   -> GUI_ALLOC_h2p
         0   -> _GetCharDistX
         8   -> _IsOverwriteAtThisChar
      40   _GetCursorXY
        40   -> GUI_ALLOC_h2p
        40   -> GUI_GetFontDistY
        40   -> GUI_SetFont
        40   -> GUI_UC_GetCharSize
        40   -> _GetCharDistX
        40   -> _GetpLine
      16   _GetNumChars
        16   -> GUI_ALLOC_h2p
        16   -> GUI__GetNumChars
      24   _GetNumCharsInPrompt
        24   -> GUI_ALLOC_h2p
        24   -> GUI_UC__NumBytes2NumChars
        24   -> GUI_UC__NumChars2NumBytes
      32   _GetNumLines
        32   -> GUI_ALLOC_h2p
        32   -> GUI_SetFont
        32   -> GUI_UC_GetCharCode
        32   -> GUI_UC__NumChars2NumBytes
        32   -> _WrapGetNumBytesToNextLine
        32   -> _WrapGetNumCharsDisp
      16   _GetNumVisLines
        16   -> GUI_GetYDistOfFont
        16   -> WM_GetInsideRectExScrollbar
      32   _GetTextSizeX
        32   -> GUI_ALLOC_h2p
        32   -> GUI_SetFont
        32   -> GUI_UC_GetCharSize
        32   -> _GetCharDistX
        32   -> _WrapGetNumBytesToNextLine
        32   -> _WrapGetNumCharsDisp
      16   _GetXSize
        16   -> WM_GetInsideRectExScrollbar
      32   _GetpLine
        32   -> GUI_ALLOC_h2p
        32   -> _WrapGetNumBytesToNextLine
      24   _IncrementBuffer
        24   -> GUI_ALLOC_Realloc
        24   -> GUI_ALLOC_h2p
      32   _InsertChar
        32   -> GUI_ALLOC_h2p
        32   -> GUI_UC_Encode
        32   -> GUI_UC__CalcSizeOfChar
        32   -> WM_NotifyParent
        32   -> _ClearCache
        32   -> _InvalidateNumLines
        32   -> _InvalidateTextSizeX
        32   -> _IsCharsAvailable
        32   -> _IsSpaceInBuffer
        32   -> memmove
        32   -> strlen
       8   _Invalidate
         0   -> WM_InvalidateWindow
         8   -> _ManageScrollers
       0   _InvalidateCursorPos
       0   _InvalidateCursorXY
       0   _InvalidateNumChars
       0   _InvalidateNumLines
      16   _InvalidateTextArea
        16   -> WM_GetInsideRectExScrollbar
        16   -> WM_InvalidateRect
        16   -> _ManageScrollers
       0   _InvalidateTextSizeX
      16   _IsCharsAvailable
        16   -> _GetNumChars
      32   _IsOverwriteAtThisChar
        32   -> GUI_ALLOC_h2p
        32   -> GUI_UC_GetCharCode
        32   -> _CalcNextValidCursorPos
        32   -> _GetCursorLine
      16   _IsSpaceInBuffer
        16   -> GUI_ALLOC_h2p
        16   -> _IncrementBuffer
        16   -> strlen
      32   _MULTIEDIT_Callback
        32   -> GUI_ALLOC_FreePtr
        32   -> GUI_ALLOC_h2p
        32   -> WIDGET_HandleActive
        32   -> WM_DefaultProc
        32   -> WM_GetScrollState
        32   -> WM_GetScrollbarH
        32   -> WM_GetScrollbarV
        32   -> WM_InvalidateWindow
        32   -> WM_NotifyParent
        32   -> _AddKey
        32   -> _CalcScrollParas
        32   -> _ClearCache
        32   -> _Invalidate
        32   -> _InvalidateCursorXY
        32   -> _InvalidateNumLines
        32   -> _InvalidateTextSizeX
        32   -> _MULTIEDIT_Paint
        32   -> _OnTouch
        32   -> _SetScrollState
      88   _MULTIEDIT_Paint
        88   -> GUI_ALLOC_h2p
        88   -> GUI_Clear
        88   -> GUI_GetFontDistY
        88   -> GUI_InvertRect
        88   -> GUI_SetFont
        88   -> GUI_UC_GetCharCode
        88   -> LCD_SetBkColor
        88   -> LCD_SetColor
        88   -> WIDGET__EFFECT_DrawDown
        88   -> WM_GetWindowSizeX
        88   -> WM_GetWindowSizeY
        88   -> WM_HasFocus
        88   -> WM_SetUserClipRect
        88   -> _DispString
        88   -> _GetCursorSizeX
        88   -> _GetCursorXY
        88   -> _GetNumVisLines
        88   -> _GetXSize
        88   -> _WrapGetNumBytesToNextLine
      16   _ManageAutoScrollV
        16   -> WM_SetScrollbarV
         0   -> _ClearCache
        16   -> _GetNumLines
        16   -> _GetNumVisLines
        16   -> _InvalidateCursorXY
        16   -> _InvalidateNumLines
        16   -> _InvalidateTextSizeX
      16   _ManageScrollers
        16   -> GUI_ALLOC_h2p
        16   -> WM_SetScrollbarH
         0   -> _CalcScrollParas
        16   -> _GetTextSizeX
        16   -> _GetXSize
        16   -> _ManageAutoScrollV
      24   _MoveCursor2LineEnd
        24   -> _GetCursorXY
        24   -> _SetCursorXY
      24   _MoveCursor2LinePos1
        24   -> _GetCursorXY
        24   -> _SetCursorXY
      24   _MoveCursor2NextLine
        24   -> GUI_GetYDistOfFont
        24   -> _GetCursorXY
        24   -> _SetCursorXY
      24   _MoveCursorDown
        24   -> GUI_GetYDistOfFont
        24   -> _GetCursorXY
        24   -> _SetCursorXY
      24   _MoveCursorUp
        24   -> GUI_GetYDistOfFont
        24   -> _GetCursorXY
        24   -> _SetCursorXY
      16   _NumChars2XSize
        16   -> GUI_GetCharDistX
        16   -> GUI_UC__GetCharCodeInc
      32   _OnTouch
        32   -> GUI_GetYDistOfFont
         0   -> WM_NotifyParent
        32   -> _Invalidate
        32   -> _SetCursorXY
      24   _SetCursorPos
        24   -> _CalcNextValidCursorPos
        24   -> _CalcScrollPos
        24   -> _InvalidateCursorXY
      40   _SetCursorXY
        40   -- Indirect call
        40   -> GUI_ALLOC_h2p
        40   -> GUI_GetFontDistY
        40   -> GUI_SetFont
        40   -> GUI_UC_GetCharCode
        40   -> GUI_UC_GetCharSize
        40   -> GUI_UC__NumBytes2NumChars
        40   -> GUI_UC__NumChars2NumBytes
        40   -> _GetCharDistX
        40   -> _GetpLine
         0   -> _SetCursorPos
        40   -> _WrapGetNumCharsDisp
      16   _SetFlag
        16   -> GUI_ALLOC_h2p
         0   -> _InvalidateTextArea
       8   _SetScrollState
         8   -> GUI_ALLOC_h2p
         0   -> WIDGET__SetScrollState
      24   _SetWrapMode
        24   -> GUI_ALLOC_h2p
        24   -> _ClearCache
        24   -> _InvalidateCursorPos
        24   -> _InvalidateNumLines
        24   -> _InvalidateTextArea
        24   -> _InvalidateTextSizeX
        24   -> _SetCursorPos
      24   _WrapGetNumBytesToNextLine
        24   -> GUI_UC__NumChars2NumBytes
         0   -> GUI__WrapGetNumBytesToNextLine
        24   -> _GetNumCharsInPrompt
        24   -> _GetXSize
        24   -> _WrapGetNumCharsDisp
      24   _WrapGetNumCharsDisp
        24   -> GUI_GetCharDistX
        24   -> GUI_UC__GetCharCodeInc
        24   -> GUI_UC__NumChars2NumBytes
        24   -> GUI__GetNumChars
        24   -> GUI__WrapGetNumCharsDisp
        24   -> _GetNumCharsInPrompt
        24   -> _GetXSize
        24   -> _NumChars2XSize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      14  MULTIEDIT_AddKey
     214  MULTIEDIT_CreateEx
      60  MULTIEDIT_GetPrompt
      68  MULTIEDIT_GetText
      46  MULTIEDIT_GetTextSize
       6  MULTIEDIT_SetAutoScrollH
       6  MULTIEDIT_SetAutoScrollV
      38  MULTIEDIT_SetBkColor
     100  MULTIEDIT_SetBufferSize
      36  MULTIEDIT_SetCursorOffset
      54  MULTIEDIT_SetFont
      38  MULTIEDIT_SetHBorder
       6  MULTIEDIT_SetInsertMode
      98  MULTIEDIT_SetMaxNumChars
      50  MULTIEDIT_SetPasswordMode
     192  MULTIEDIT_SetPrompt
       6  MULTIEDIT_SetReadOnly
     206  MULTIEDIT_SetText
      38  MULTIEDIT_SetTextColor
       6  MULTIEDIT_SetWrapChar
       6  MULTIEDIT_SetWrapNone
       6  MULTIEDIT_SetWrapWord
     376  _AddKey
     198  _CalcNextValidCursorPos
      60  _CalcScrollParas
      66  _CalcScrollPos
      20  _ClearCache
     182  _DeleteChar
     128  _DispString
      46  _GetCharDistX
     122  _GetCursorLine
      40  _GetCursorSizeX
     142  _GetCursorXY
      46  _GetNumChars
      44  _GetNumCharsInPrompt
     116  _GetNumLines
      34  _GetNumVisLines
     144  _GetTextSizeX
      32  _GetXSize
      94  _GetpLine
      56  _IncrementBuffer
     128  _InsertChar
      18  _Invalidate
      16  _InvalidateCursorPos
      14  _InvalidateCursorXY
      14  _InvalidateNumChars
      14  _InvalidateNumLines
      26  _InvalidateTextArea
      14  _InvalidateTextSizeX
      48  _IsCharsAvailable
     124  _IsOverwriteAtThisChar
      62  _IsSpaceInBuffer
     308  _MULTIEDIT_Callback
     448  _MULTIEDIT_Paint
      80  _ManageAutoScrollV
      82  _ManageScrollers
      32  _MoveCursor2LineEnd
      30  _MoveCursor2LinePos1
      42  _MoveCursor2NextLine
      42  _MoveCursorDown
      42  _MoveCursorUp
      32  _NumChars2XSize
      98  _OnTouch
      56  _SetCursorPos
     226  _SetCursorXY
      48  _SetFlag
      26  _SetScrollState
      76  _SetWrapMode
      82  _WrapGetNumBytesToNextLine
     142  _WrapGetNumCharsDisp
      20  _aDefaultBkColor
          _aDefaultColor
          _pDefaultFont

 
    20 bytes in section .data
 5 622 bytes in section .text
 
 5 622 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
