///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       25/Feb/2020  18:23:01
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\Src\main.cpp
//    Command line =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\Src\main.cpp
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        -lA
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        --diag_suppress Pa050 -o
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../User/ui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM\..\Middlewares\GUI\
//        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\EWARM\mksRobin2/List\main.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__CPP_Language", "EC++"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN AT24CXX_Init
        EXTERN AT24CXX_Write
        EXTERN DMAx_Init
        EXTERN DRAW_LOGO
        EXTERN GUI_Clear
        EXTERN GUI_DispStringAt
        EXTERN GUI_FillRect
        EXTERN GUI_FontHZ_fontHz14
        EXTERN GUI_Init
        EXTERN GUI_SetBkColor
        EXTERN GUI_SetColor
        EXTERN GUI_SetFont
        EXTERN GUI_UC_SetEncodeUTF8
        EXTERN HAL_ADC_Start_DMA
        EXTERN HAL_Delay
        EXTERN HAL_Init
        EXTERN HAL_NVIC_DisableIRQ
        EXTERN HAL_NVIC_EnableIRQ
        EXTERN HAL_NVIC_SetPriority
        EXTERN HAL_RCCEx_PeriphCLKConfig
        EXTERN HAL_RCC_ClockConfig
        EXTERN HAL_RCC_GetHCLKFreq
        EXTERN HAL_RCC_OscConfig
        EXTERN HAL_SYSTICK_CLKSourceConfig
        EXTERN HAL_SYSTICK_Config
        EXTERN HAL_TIM_Base_Start_IT
        EXTERN HAL_TIM_PWM_Start
        EXTERN MX_ADC1_Init
        EXTERN MX_DMA_Init
        EXTERN MX_GPIO_Init
        EXTERN MX_SPI2_Init
        EXTERN MX_TIM1_Init
        EXTERN MX_TIM2_Init
        EXTERN MX_TIM3_Init
        EXTERN MX_TIM4_Init
        EXTERN MX_USART3_UART_Init
        EXTERN NVIC_SetVectorTable
        EXTERN SD_Init
        EXTERN SD_Path
        EXTERN SPI_Cmd
        EXTERN SPI_FLASH_BufferRead
        EXTERN STMFLASH_Write
        EXTERN Serial3
        EXTERN _Z17serial_echopair_PPKci
        EXTERN _Z18disp_language_initv
        EXTERN _Z9wifi_initv
        EXTERN _ZN10CardReader12pauseSDPrintEv
        EXTERN _ZN10CardReader16mksConfigurationEv
        EXTERN _ZN10CardReader6initsdEv
        EXTERN _ZN10USARTClass5beginEj
        EXTERN _ZN10USARTClass5writeEh
        EXTERN _ZN9Stopwatch5pauseEv
        EXTERN __aeabi_d2iz
        EXTERN __aeabi_d2uiz
        EXTERN __aeabi_dadd
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_f2d
        EXTERN __aeabi_f2iz
        EXTERN __aeabi_fdiv
        EXTERN __aeabi_fmul
        EXTERN __aeabi_memclr4
        EXTERN __aeabi_ui2d
        EXTERN __aeabi_ui2f
        EXTERN card
        EXTERN clear_cur_ui
        EXTERN common_menu
        EXTERN default_preview_flg
        EXTERN disp_state
        EXTERN draw_Hardwaretest
        EXTERN draw_printing
        EXTERN echomagic
        EXTERN f_close
        EXTERN f_open
        EXTERN f_read
        EXTERN f_rename
        EXTERN f_unlink
        EXTERN flash_preview_begin
        EXTERN from_flash_pic
        EXTERN gCfgItems
        EXTERN getTick
        EXTERN gui_view_init
        EXTERN hadc1
        EXTERN htim1
        EXTERN htim2
        EXTERN htim3
        EXTERN htim4
        EXTERN init_win_id
        EXTERN loop
        EXTERN mksCfg
        EXTERN mksHardwareTest
        EXTERN mksReprint
        EXTERN mksTmp
        EXTERN mks_initPrint
        EXTERN mks_rePrintCheck
        EXTERN mkstft_ui_init
        EXTERN print_job_timer
        EXTERN setTouchBound
        EXTERN setup
        EXTERN stop_print_time
        EXTERN strcat
        EXTERN uhADCxConvertedValue

        PUBLIC Address
        PUBLIC BeeperCnt
        PUBLIC BeeperFreq
        PUBLIC `Data`
        PUBLIC EraseCounter
        PUBLIC Error_Handler
        PUBLIC NbrOfPage
        PUBLIC _Z10mksProgramv
        PUBLIC _Z14mksBeeperAlarmv
        PUBLIC _Z14serialprintPGMPKc
        PUBLIC _Z17check_sd_firmwarev
        PUBLIC _Z18SystemClock_Configv
        PUBLIC _Z20testAllStepAndMosFETv
        PUBLIC _Z21Close_machine_displayv
        PUBLIC _Z23PowerOff_Filament_Checkv
        PUBLIC _Z9BufferSetPhht
        PUBLIC _ZTI5Print
        PUBLIC barString
        PUBLIC beep_mtdet1
        PUBLIC beep_mtdet2
        PUBLIC beep_pwdet
        PUBLIC beeper_flg
        PUBLIC br
        PUBLIC bufCmp
        PUBLIC buffer
        PUBLIC bw
        PUBLIC delaycnt
        PUBLIC fdst
        PUBLIC filament_det1_check
        PUBLIC filament_det1_cnt
        PUBLIC filament_det1_flg
        PUBLIC filament_det1_high_cnt
        PUBLIC filament_det1_high_flg
        PUBLIC filament_det1_low_cnt
        PUBLIC filament_det1_low_flg
        PUBLIC filament_det2_check
        PUBLIC filament_det2_cnt
        PUBLIC filament_det2_flg
        PUBLIC filament_det2_high_cnt
        PUBLIC filament_det2_high_flg
        PUBLIC filament_det2_low_cnt
        PUBLIC filament_det2_low_flg
        PUBLIC fileSize
        PUBLIC firmware_file
        PUBLIC firmware_old
        PUBLIC first_time
        PUBLIC fsrc
        PUBLIC hlfP
        PUBLIC key
        PUBLIC logo_tick1
        PUBLIC logo_tick2
        PUBLIC main
        PUBLIC mksBpAlrmEn
        PUBLIC msp
        PUBLIC pause_from_high_level
        PUBLIC percentBar
        PUBLIC poweroff_det_cnt
        PUBLIC poweroff_det_flg
        PUBLIC poweroff_det_high_cnt
        PUBLIC poweroff_det_high_flg
        PUBLIC poweroff_det_low_cnt
        PUBLIC poweroff_det_low_flg
        PUBLIC progCnt
        PUBLIC progressBar
        PUBLIC res
        PUBLIC reset
        PUBLIC tms
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_嘉禾三维\mksRobin_Nano_code\Src\main.cpp
//    1 /**
//    2   ******************************************************************************
//    3   * File Name          : main.c
//    4   * Description        : Main program body
//    5   ******************************************************************************
//    6   *
//    7   * COPYRIGHT(c) 2017 STMicroelectronics
//    8   *
//    9   * Redistribution and use in source and binary forms, with or without modification,
//   10   * are permitted provided that the following conditions are met:
//   11   *   1. Redistributions of source code must retain the above copyright notice,
//   12   *      this list of conditions and the following disclaimer.
//   13   *   2. Redistributions in binary form must reproduce the above copyright notice,
//   14   *      this list of conditions and the following disclaimer in the documentation
//   15   *      and/or other materials provided with the distribution.
//   16   *   3. Neither the name of STMicroelectronics nor the names of its contributors
//   17   *      may be used to endorse or promote products derived from this software
//   18   *      without specific prior written permission.
//   19   *
//   20   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   21   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   22   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   23   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//   24   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   25   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   26   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//   27   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//   28   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   29   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   30   *
//   31   ******************************************************************************
//   32   */
//   33 /* Includes ------------------------------------------------------------------*/
//   34 //#include "Arduino.h"
//   35 
//   36 #include "main.h"
//   37 #include "stm32f1xx_hal.h"
//   38 #include "adc.h"
//   39 #include "dma.h"
//   40 #include "fatfs.h"
//   41 #include "i2c.h"
//   42 #include "rtc.h"
//   43 #include "sdio.h"
//   44 #include "spi.h"
//   45 #include "tim.h"
//   46 #include "usart.h"
//   47 #include "usb_host.h"
//   48 #include "gpio.h"
//   49 #include "fsmc.h"
//   50 //#include "iwdg.h"
//   51 #include "misc.h"
//   52 /* USER CODE BEGIN Includes */
//   53 #include "Marlin.h"

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14serialprintPGMPKc
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function _Z14serialprintPGMPKc
        THUMB
// __interwork __softfp void serialprintPGM(char const *)
_Z14serialprintPGMPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        B.N      ??serialprintPGM_0
??serialprintPGM_1:
        UXTB     R1,R1
        LDR.N    R0,??serialprintPGM_2
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??serialprintPGM_0:
        LDRSB    R1,[R4], #+1
        MOVS     R0,R1
        BNE.N    ??serialprintPGM_1
        POP      {R4,PC}          ;; return
        DATA
??serialprintPGM_2:
        DC32     Serial3
          CFI EndBlock cfiBlock0
//   54 #include "Marlin_export.h"
//   55 #include "mks_test.h"
//   56 #include "mks_reprint.h"
//   57     
//   58 #include "spi_flash.h"
//   59 #include "cardreader.h"
//   60 //#ifdef USE_MKS_WIFI
//   61 #include "wifi_module.h"
//   62 //#endif    
//   63 #include "serial.h"  
//   64 
//   65 #include "gui.h"
//   66 #include "ili9320.h"
//   67 #include "draw_ui.h"
//   68 #include "draw_ready_print.h"
//   69 #include "draw_printing.h"
//   70 #include "sdio_sdcard.h"
//   71 #include "draw_pause_ui.h"
//   72 #include "pic_manager.h"
//   73 #include "stmflash.h"
//   74 extern "C"void setTouchBound(int32_t x0, int32_t x1, int32_t y0, int32_t y1 );
//   75 
//   76 
//   77 /* USER CODE END Includes */
//   78 /* Private variables ---------------------------------------------------------*/
//   79 /* USER CODE BEGIN PV */
//   80 /* Private variables ---------------------------------------------------------*/
//   81 void testAllStepAndMosFET();
//   82 /* USER CODE END PV */
//   83 
//   84 /* Private function prototypes -----------------------------------------------*/
//   85 void SystemClock_Config(void);
//   86 void Error_Handler(void);
//   87 static void MX_NVIC_Init(void);
//   88 //void MX_USB_HOST_Process(void);
//   89 
//   90 /* USER CODE BEGIN PFP */
//   91 /* Private function prototypes -----------------------------------------------*/
//   92 
//   93 /* USER CODE END PFP */
//   94 /* USER CODE BEGIN 0 */
//   95 /* USER CODE END 0 */
//   96 extern "C" u16 DeviceCode;
//   97 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   98 uint32_t logo_tick1,logo_tick2;
logo_tick1:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
logo_tick2:
        DS8 4
//   99 
//  100 extern void draw_Hardwaretest();
//  101 
//  102 volatile uint8_t pause_from_high_level=0;
//  103 
//  104 extern void check_sd_firmware(void);
//  105 
//  106 

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function main
        THUMB
//  107 int main(void)
//  108 {
main:
        PUSH     {R2-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+40
//  109 
//  110   /* USER CODE BEGIN 1 */
//  111         //中断向量设置
//  112         //SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
//  113         //SCB->VTOR = 0x08000000 | (0x7000 & (uint32_t)0x1FFFFF80);  /* Vector Table Relocation in Internal FLASH */
//  114                                                                 //有bootloader时，设置为0x5000, Options ->Linker ->Edit...-> 0x08005000
//  115                                                                  //无bootloader时，设置为0x0000, Options ->Linker ->Edit...-> 0x08000000 
//  116 
//  117   /* USER CODE END 1 */
//  118 
//  119   /* MCU Configuration----------------------------------------------------------*/
//  120   
//  121 
//  122   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
//  123   HAL_Init();
          CFI FunCall HAL_Init
        BL       HAL_Init
//  124   //有bootloader时，设置为0x7000, Options ->Linker ->Edit...-> Vector Table ->0x08007000
//  125   //另外注意的是：当BootLoader跳转不正常时，ROM需要设置为 0x8007000, Options ->Linker ->Edit...-> Memony Regions ->Rom ->0x08007000
//  126   NVIC_SetVectorTable(NVIC_VectTab_FLASH, (uint32_t)0x7000);
        MOV      R1,#+28672
        MOV      R0,#+134217728
          CFI FunCall NVIC_SetVectorTable
        BL       NVIC_SetVectorTable
//  127                                                             
//  128   /* Configure the system clock */
//  129   SystemClock_Config();
          CFI FunCall _Z18SystemClock_Configv
        BL       _Z18SystemClock_Configv
//  130   
//  131 
//  132   /* Initialize all configured peripherals */
//  133   MX_GPIO_Init();
          CFI FunCall MX_GPIO_Init
        BL       MX_GPIO_Init
//  134   MX_DMA_Init();
          CFI FunCall MX_DMA_Init
        BL       MX_DMA_Init
//  135  // MX_FSMC_Init();
//  136   //MX_FATFS_Init();
//  137   //MX_RTC_Init();
//  138   //MX_I2C1_Init();
//  139   AT24CXX_Init();
          CFI FunCall AT24CXX_Init
        BL       AT24CXX_Init
//  140   //MX_SDIO_SD_Init();
//  141   SD_Init();
          CFI FunCall SD_Init
        BL       SD_Init
//  142   MX_SPI2_Init();
          CFI FunCall MX_SPI2_Init
        BL       MX_SPI2_Init
//  143   DMAx_Init();
          CFI FunCall DMAx_Init
        BL       DMAx_Init
//  144   MX_TIM1_Init();
          CFI FunCall MX_TIM1_Init
        BL       MX_TIM1_Init
//  145   MX_TIM2_Init();
          CFI FunCall MX_TIM2_Init
        BL       MX_TIM2_Init
//  146   MX_TIM3_Init();
          CFI FunCall MX_TIM3_Init
        BL       MX_TIM3_Init
//  147   MX_TIM4_Init();
          CFI FunCall MX_TIM4_Init
        BL       MX_TIM4_Init
//  148   //MX_TIM5_Init();
//  149   MX_ADC1_Init();
          CFI FunCall MX_ADC1_Init
        BL       MX_ADC1_Init
//  150   
//  151 #if defined(MKS_ROBINPRO) 
//  152   MX_USART6_UART_Init();
//  153 #elif defined(MKS_ROBIN) || defined(MKS_ROBIN2) || defined(MKS_ROBIN_NANO)
//  154    //MX_USART1_UART_Init(3);
//  155 #endif
//  156 
//  157   MX_USART3_UART_Init();
          CFI FunCall MX_USART3_UART_Init
        BL       MX_USART3_UART_Init
//  158 
//  159 #if unused
//  160   MX_USB_HOST_Init();
//  161 #endif
//  162   //MX_DAC_Init();
//  163   //MX_SPI1_Init();
//  164   //MX_IWDG_Init();     //喂狗
//  165   /* Initialize interrupts */
//  166   MX_NVIC_Init();
          CFI FunCall _Z12MX_NVIC_Initv
        BL       _Z12MX_NVIC_Initv
//  167 
//  168   /* USER CODE BEGIN 2 */
//  169 
//  170     MYSERIAL.begin(BAUDRATE);
        LDR.W    R4,??DataTable15
        MOV      R1,#+115200
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5beginEj
        BL       _ZN10USARTClass5beginEj
//  171     SERIAL_PROTOCOLLNPGM("mksRobinNano start");
        ADR.W    R0,`?<Constant "mksRobinNano start\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
//  172     SERIAL_PROTOCOLPAIR("EPR_END_ADDR:",EPR_END_ADDR);
        MOVW     R1,#+1854
        ADR.W    R0,`?<Constant "EPR_END_ADDR:">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
//  173     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
//  174     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable15_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
//  175     
//  176 #ifdef USE_MKS_WIFI  
//  177 	WIFISERIAL.begin(115200);   
//  178 #endif
//  179 
//  180   //使能SPI外设
//  181   SPI_Cmd(SPI2, ENABLE); 
        MOVS     R1,#+1
        LDR.W    R0,??DataTable15_2  ;; 0x40003800
          CFI FunCall SPI_Cmd
        BL       SPI_Cmd
//  182   GUI_Init();
          CFI FunCall GUI_Init
        BL       GUI_Init
//  183   Lcd_Light_ON;
        LDR.W    R4,??DataTable15_3  ;; 0x422281b4
        MOVS     R0,#+1
        STR      R0,[R4, #+0]
//  184   DRAW_LOGO();
          CFI FunCall DRAW_LOGO
        BL       DRAW_LOGO
//  185   Lcd_Light_ON; 
        MOVS     R0,#+1
        STR      R0,[R4, #+0]
//  186   logo_tick1 = getTick();
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable15_4
        STR      R0,[R1, #+0]
//  187   gui_view_init();
          CFI FunCall gui_view_init
        BL       gui_view_init
//  188   init_win_id();
          CFI FunCall init_win_id
        BL       init_win_id
//  189   /*---------test begin-----------*/
//  190  //LCD_Init();
//  191  //mksEeprom_test();
//  192  //mksW25Q64Test();
//  193  //mksSdCardTest();
//  194  //mksUSBTest();
//  195     /*---------test end-------------*/
//  196 	//启动PWM
//  197 #if defined(MKS_ROBINPRO) || defined(MKS_ROBIN_NANO)
//  198     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);
        MOVS     R1,#+12
        LDR.W    R0,??DataTable15_5
          CFI FunCall HAL_TIM_PWM_Start
        BL       HAL_TIM_PWM_Start
//  199 #elif defined(MKS_ROBIN) || defined(MKS_ROBIN2) 
//  200     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
//  201 #endif  	
//  202 
//  203 #if defined(MKS_ROBIN2) 
//  204 	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
//  205 	MKS_TOUCH_TIM = 0;
//  206 #endif 
//  207 
//  208 #if defined(MKS_ROBIN_NANO) 
//  209         HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
        MOVS     R1,#+0
        LDR.W    R0,??DataTable15_6
          CFI FunCall HAL_TIM_PWM_Start
        BL       HAL_TIM_PWM_Start
//  210         MKS_TOUCH_TIM = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_7  ;; 0x40012c34
        STR      R0,[R1, #+0]
//  211 #endif 
//  212 
//  213 	
//  214 
//  215     MKS_FAN_TIM = 0;
        LDR.W    R1,??DataTable15_8  ;; 0x40000440
        STR      R0,[R1, #+0]
//  216 
//  217     //启动TIMER
//  218     HAL_TIM_Base_Start_IT(&htim2);
        LDR.W    R0,??DataTable15_9
          CFI FunCall HAL_TIM_Base_Start_IT
        BL       HAL_TIM_Base_Start_IT
//  219     HAL_TIM_Base_Start_IT(&htim4);
        LDR.W    R0,??DataTable15_10
          CFI FunCall HAL_TIM_Base_Start_IT
        BL       HAL_TIM_Base_Start_IT
//  220     //启动ADC DMA
//  221     HAL_NVIC_DisableIRQ(DMA1_Channel1_IRQn);//关闭DMA1_Channel1_IRQHandler中断
        MOVS     R0,#+11
          CFI FunCall HAL_NVIC_DisableIRQ
        BL       HAL_NVIC_DisableIRQ
//  222     if(HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&uhADCxConvertedValue,3)!=HAL_OK)    
        MOVS     R2,#+3
        LDR.W    R1,??DataTable15_11
        LDR.W    R0,??DataTable15_12
          CFI FunCall HAL_ADC_Start_DMA
        BL       HAL_ADC_Start_DMA
        CMP      R0,#+0
        BEQ.N    ??main_1
//  223       Error_Handler();
          CFI FunCall Error_Handler
        BL       Error_Handler
//  224     HAL_NVIC_DisableIRQ(DMA1_Channel1_IRQn);//关闭DMA1_Channel1_IRQn中断
??main_1:
        MOVS     R0,#+11
          CFI FunCall HAL_NVIC_DisableIRQ
        BL       HAL_NVIC_DisableIRQ
//  225  
//  226     //启动PWM
//  227     /*
//  228     HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
//  229     TIM1->CCR1 = 0;
//  230     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
//  231     TIM3->CCR1 = 0;
//  232     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
//  233     TIM3->CCR2 = 0;
//  234 
//  235     HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
//  236     TIM3->CCR3 = 0;
//  237   */
//  238   
//  239  mkstft_ui_init();
          CFI FunCall mkstft_ui_init
        BL       mkstft_ui_init
//  240     
//  241  setTouchBound(gCfgItems.touch_adj_xMin, gCfgItems.touch_adj_xMax, gCfgItems.touch_adj_yMax, gCfgItems.touch_adj_yMin);
        LDR.W    R6,??DataTable15_13
        ADD      R7,R6,#+184
        LDR      R3,[R7, #+12]
        LDR      R2,[R7, #+16]
        LDR      R1,[R7, #+8]
        LDR      R0,[R7, #+4]
          CFI FunCall setTouchBound
        BL       setTouchBound
//  242 #if 1
//  243 
//  244  mksTmp.cfg_hardware_test_enable = 0;
        LDR.W    R10,??DataTable15_14
        MOVS     R0,#+0
        STRB     R0,[R10, #+19]
//  245 
//  246   if(SD_DET_IP == 0)
        LDR.W    R0,??DataTable15_15  ;; 0x42228130
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??main_2
//  247   {
//  248   	card.initsd();
        LDR.W    R4,??DataTable15_16
        MOV      R0,R4
          CFI FunCall _ZN10CardReader6initsdEv
        BL       _ZN10CardReader6initsdEv
//  249   	card.mksConfiguration();
        MOV      R0,R4
          CFI FunCall _ZN10CardReader16mksConfigurationEv
        BL       _ZN10CardReader16mksConfigurationEv
//  250   }
//  251 
//  252   //刷写图片总数
//  253   SPI_FLASH_BufferRead((u8*)&gCfgItems.total_pic,PIC_COUNTER_ADDR,1);
??main_2:
        MOVS     R2,#+1
        MOV      R1,#+32768
        ADDW     R0,R6,#+287
          CFI FunCall SPI_FLASH_BufferRead
        BL       SPI_FLASH_BufferRead
//  254   #if 0//tan_mask
//  255   else
//  256   {
//  257     FATFS_UnLinkDriver(SD_Path); 
//  258   }
//  259   #endif
//  260 
//  261   switch(gCfgItems.language_bak)
        LDRB     R0,[R6, #+285]
        SUBS     R0,R0,#+1
        CMP      R0,#+6
        BHI.N    ??main_3
        TBB      [PC, R0]
        DATA
??main_0:
        DC8      0x4,0x8,0xC,0x10
        DC8      0x14,0x18,0x1C,0x0
        THUMB
//  262   {
//  263   	case 1:
//  264 		gCfgItems.language_bak= LANG_SIMPLE_CHINESE;
??main_4:
        MOVS     R0,#+1
        STRB     R0,[R6, #+285]
//  265 		break;
        B.N      ??main_3
//  266 	case 2:
//  267 		gCfgItems.language_bak= LANG_COMPLEX_CHINESE;
??main_5:
        MOVS     R0,#+2
        STRB     R0,[R6, #+285]
//  268 		break;
        B.N      ??main_3
//  269 	case 3:
//  270 		gCfgItems.language_bak= LANG_ENGLISH;
??main_6:
        MOVS     R0,#+3
        STRB     R0,[R6, #+285]
//  271 		break;
        B.N      ??main_3
//  272 	case 4:
//  273 		gCfgItems.language_bak= LANG_RUSSIAN;
??main_7:
        MOVS     R0,#+7
        STRB     R0,[R6, #+285]
//  274 		break;
        B.N      ??main_3
//  275 	case 5:
//  276 		gCfgItems.language_bak= LANG_SPANISH;
??main_8:
        MOVS     R0,#+10
        STRB     R0,[R6, #+285]
//  277 		break;
        B.N      ??main_3
//  278 	case 6:
//  279 		gCfgItems.language_bak= LANG_FRENCH;
??main_9:
        MOVS     R0,#+6
        STRB     R0,[R6, #+285]
//  280 		break;
        B.N      ??main_3
//  281 	case 7:
//  282 		gCfgItems.language_bak= LANG_ITALY;
??main_10:
        MOVS     R0,#+12
        STRB     R0,[R6, #+285]
//  283 		break;
//  284   }
//  285   
//  286   if(gCfgItems.multiple_language == 0)
??main_3:
        LDRB     R0,[R6, #+447]
        CMP      R0,#+0
        BNE.N    ??main_11
//  287   {
//  288 	if(gCfgItems.language_bak != 0)
        LDRB     R0,[R6, #+285]
        CMP      R0,#+0
        BEQ.N    ??main_11
//  289 	{
//  290 		gCfgItems.language = gCfgItems.language_bak;
        LDRSB    R0,[R6, #+285]
        STRB     R0,[R6, #+184]
//  291 		AT24CXX_Write(EPR_LANGUAGE,(uint8_t *)&gCfgItems.language,1);	
        MOVS     R2,#+1
        MOV      R1,R7
        MOVW     R0,#+1759
          CFI FunCall AT24CXX_Write
        BL       AT24CXX_Write
//  292 	}
//  293   }
//  294   GUI_SetFont(&FONT_TITLE);
??main_11:
        LDR.W    R0,??DataTable15_17
          CFI FunCall GUI_SetFont
        BL       GUI_SetFont
//  295 
//  296   setup();
          CFI FunCall setup
        BL       setup
//  297 #endif  
//  298   disp_language_init();	
          CFI FunCall _Z18disp_language_initv
        BL       _Z18disp_language_initv
//  299   GUI_UC_SetEncodeUTF8();
          CFI FunCall GUI_UC_SetEncodeUTF8
        BL       GUI_UC_SetEncodeUTF8
//  300   check_sd_firmware();
          CFI FunCall _Z17check_sd_firmwarev
        BL       _Z17check_sd_firmwarev
//  301   /*
//  302   if(DeviceCode==0x9488)
//  303   {
//  304 	TFT_screen.display_style = gCfgItems.display_style;// 1:简约版；0:经典版；
//  305 	TFT_screen.firstpage_gap = 32;
//  306 	TFT_screen.gap_h = 2;
//  307 	TFT_screen.gap_v = 2;
//  308 	TFT_screen.width = 480;
//  309 	TFT_screen.high = 320;
//  310 	TFT_screen.btn_x_pixel = 117;
//  311 	TFT_screen.btn_y_pixel = 140;
//  312 	TFT_screen.title_xpos = 3;
//  313 	TFT_screen.title_ypos = 5;
//  314 	TFT_screen.title_high = 36;		
//  315   }
//  316   else //if(DeviceCode==0x1505)
//  317   {
//  318 	TFT_screen.display_style = 0;//gCfgItems.display_style;// 1:简约版；0:经典版；
//  319 	TFT_screen.firstpage_gap = 32;
//  320 	TFT_screen.gap_h = 2;
//  321 	TFT_screen.gap_v = 2;
//  322 	TFT_screen.width = 320;
//  323 	TFT_screen.high = 240;
//  324 	TFT_screen.btn_x_pixel = 78;
//  325 	TFT_screen.btn_y_pixel = 104;
//  326 	TFT_screen.title_xpos = 0;
//  327 	TFT_screen.title_ypos = 0;
//  328 	TFT_screen.title_high = 30;    
//  329   }
//  330   */
//  331 #if 1	
//  332   gCfgItems.filament_loading_time = (uint32_t)((gCfgItems.filamentchange_load_length*60.0/gCfgItems.filamentchange_load_speed)+0.5);
        MOV      R8,#+0
        LDR.W    R9,??DataTable15_18  ;; 0x3fe00000
        MOV      R4,R8
        LDR.W    R5,??DataTable15_19  ;; 0x404e0000
        LDR      R0,[R7, #+44]
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        STRD     R0,R1,[SP, #+0]
        LDR      R0,[R7, #+36]
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R2,R0
        MOV      R3,R1
        LDRD     R0,R1,[SP, #+0]
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R7, #+60]
//  333   gCfgItems.filament_unloading_time = (uint32_t)((gCfgItems.filamentchange_unload_length*60.0/gCfgItems.filamentchange_unload_speed)+0.5);
        LDR      R0,[R7, #+48]
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+40]
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R7, #+64]
//  334 
//  335   if(gCfgItems.pwroff_save_mode == 1)
        LDRB     R0,[R6, #+415]
        CMP      R0,#+1
        BNE.N    ??main_12
//  336   {
//  337   	FALA_CTRL = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_20  ;; 0x422381a8
        STR      R0,[R1, #+0]
//  338 	//
//  339   }
//  340 
//  341   mks_initPrint();
??main_12:
          CFI FunCall mks_initPrint
        BL       mks_initPrint
//  342 #if 1
//  343     
//  344       //mksTmp.cfg_hardware_test_enable = 1;  //for test
//  345     
//  346       if(mksTmp.cfg_hardware_test_enable)   //生产硬件测试
        LDRB     R0,[R10, #+19]
        CMP      R0,#+0
        BEQ.N    ??main_13
//  347       {
//  348        /*
//  349         GUI_SetBkColor(gCfgItems.background_color);
//  350         GUI_SetColor(gCfgItems.title_color);
//  351         GUI_Clear();
//  352         GUI_UC_SetEncodeNone();
//  353         GUI_SetFont(&GUI_FontHZ16);
//  354         GUI_DispStringAt("硬件测试-(软件内部版本V1.0.0_000)", 20, 0);
//  355         mksHardwareTest();
//  356         */
//  357         mksCfg.extruders=2;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable15_21
        STRB     R0,[R1, #+247]
//  358         draw_Hardwaretest();
          CFI FunCall draw_Hardwaretest
        BL       draw_Hardwaretest
//  359       }
//  360   #endif
//  361   
//  362 /*
//  363   if(gCfgItems.fileSysType == FILE_SYS_USB)
//  364   {
//  365   	card.initusb();
//  366   }
//  367   else
//  368 */
//  369   {
//  370   	card.initsd();
??main_13:
        LDR.W    R0,??DataTable15_16
          CFI FunCall _ZN10CardReader6initsdEv
        BL       _ZN10CardReader6initsdEv
//  371   }
//  372   mks_rePrintCheck();
          CFI FunCall mks_rePrintCheck
        BL       mks_rePrintCheck
//  373 
//  374 /*
//  375   if(SD_DET_IP == 0)
//  376   {
//  377   	mks_rePrintCheck();
//  378   }
//  379   else//没有断电续打
//  380   {
//  381 	  while(1)
//  382 	  {
//  383 		  logo_tick2 = getTick();
//  384 		  if(getTickDiff(logo_tick2, logo_tick1)>=3000)
//  385 		  {
//  386 			  draw_ready_print();
//  387 			  break;
//  388 		  }
//  389 	  }  
//  390   }
//  391   */
//  392 
//  393 
//  394   if(gCfgItems.wifi_type == ESP_WIFI)
        LDRB     R0,[R6, #+556]
        CMP      R0,#+2
        BNE.N    ??main_14
//  395   {
//  396 	wifi_init();
          CFI FunCall _Z9wifi_initv
        BL       _Z9wifi_initv
//  397   }
//  398   /* USER CODE END 2 */
//  399 #endif
//  400 
//  401 
//  402   /* Infinite loop */
//  403   /* USER CODE BEGIN WHILE */
//  404   while (1)
//  405   {
//  406       if(mksTmp.cfg_hardware_test_enable==1)
??main_14:
        LDRB     R0,[R10, #+19]
        CMP      R0,#+1
        BNE.N    ??main_15
//  407       {
//  408         mksHardwareTest();
          CFI FunCall mksHardwareTest
        BL       mksHardwareTest
//  409       }
//  410       /* USER CODE END WHILE */
//  411       //IsrTemperatureHandler();
//  412       /* USER CODE BEGIN 3 */
//  413       loop();
??main_15:
          CFI FunCall loop
        BL       loop
        B.N      ??main_14
          CFI EndBlock cfiBlock1
//  414       #if unused  
//  415       MX_USB_HOST_Process();
//  416       #endif
//  417      // mksEeprom_test();
//  418   }
//  419   /* USER CODE END 3 */
//  420 
//  421 }

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
pause_from_high_level:
        DS8 1
//  422 
//  423 uint8_t poweroff_det_flg;
poweroff_det_flg:
        DS8 1
//  424 uint32_t poweroff_det_cnt;
//  425 uint8_t poweroff_det_low_flg;
poweroff_det_low_flg:
        DS8 1
//  426 uint32_t poweroff_det_low_cnt;
//  427 uint8_t poweroff_det_high_flg;
poweroff_det_high_flg:
        DS8 1
//  428 uint32_t poweroff_det_high_cnt;
//  429 
//  430 uint8_t filament_det1_flg;
filament_det1_flg:
        DS8 1
//  431 uint32_t filament_det1_cnt;
//  432 uint8_t filament_det1_low_flg;
filament_det1_low_flg:
        DS8 1
//  433 uint32_t filament_det1_low_cnt;
//  434 uint8_t filament_det1_high_flg;
filament_det1_high_flg:
        DS8 1
//  435 uint32_t filament_det1_high_cnt;
//  436 uint8_t filament_det1_check;
filament_det1_check:
        DS8 1
//  437 
//  438 uint8_t filament_det2_flg;
filament_det2_flg:
        DS8 1
//  439 uint32_t filament_det2_cnt;
//  440 uint8_t filament_det2_low_flg;
filament_det2_low_flg:
        DS8 1
//  441 uint32_t filament_det2_low_cnt;
//  442 uint8_t filament_det2_high_flg;
filament_det2_high_flg:
        DS8 1
//  443 uint32_t filament_det2_high_cnt;
//  444 uint8_t filament_det2_check;
filament_det2_check:
        DS8 1
//  445 
//  446 volatile unsigned long BeeperFreq=0;
//  447 volatile unsigned char BeeperCnt=0;
BeeperCnt:
        DS8 1
//  448 volatile unsigned char mksBpAlrmEn=0;
mksBpAlrmEn:
        DS8 1
//  449 
//  450 
//  451 static uint8_t beeper_cnt;
//  452 static uint8_t check_beeper_cnt;
//  453 
//  454 extern uint8_t from_flash_pic;
//  455 __IO uint32_t delaycnt = 0;
//  456 __IO uint8_t beeper_flg = 0;
//  457 
//  458 uint8_t beep_pwdet=0;
beep_pwdet:
        DS8 1
//  459 uint8_t beep_mtdet1=0;
beep_mtdet1:
        DS8 1
//  460 uint8_t beep_mtdet2=0;
beep_mtdet2:
        DS8 1
        DS8 3
poweroff_det_cnt:
        DS8 4
poweroff_det_low_cnt:
        DS8 4
poweroff_det_high_cnt:
        DS8 4
filament_det1_cnt:
        DS8 4
filament_det1_low_cnt:
        DS8 4
filament_det1_high_cnt:
        DS8 4
filament_det2_cnt:
        DS8 4
filament_det2_low_cnt:
        DS8 4
filament_det2_high_cnt:
        DS8 4
delaycnt:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
BeeperFreq:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
beeper_flg:
        DS8 1
//  461 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function _Z14mksBeeperAlarmv
          CFI NoCalls
        THUMB
//  462 void mksBeeperAlarm(void)
//  463 {
//  464 #if 0
//  465 		if((gCfgItems.filament_det1_level_flg==1)||(gCfgItems.filament_det2_level_flg==1))
//  466 		{
//  467 			//由于高电平触发时，
//  468 			//比较难通过管脚电平来判断
//  469 			//信号脚的电平使其立即停止鸣响，
//  470 			//所以默认每次断料鸣响5次。
//  471 			beeper_cnt = 10;
//  472 		}
//  473 		else
//  474 		{
//  475 			if((MKS_PWRDN == 1) && (MKS_MTRDN == 1))
//  476 			{
//  477 				check_beeper_cnt++;
//  478 			}
//  479 			if(check_beeper_cnt >=5)
//  480 			{
//  481 					mksBpAlrmEn = 0;
//  482 					BeeperFreq = 0;
//  483 					BeeperCnt = 0;	
//  484 					SPEAKER = 0;
//  485 					check_beeper_cnt = 0;
//  486 			}
//  487 			beeper_cnt = 20;
//  488 		}
//  489 
//  490 		if(mksBpAlrmEn)
//  491 		{
//  492 			BeeperFreq++;
//  493 			
//  494 			
//  495 			if(BeeperFreq%3000 == 0)
//  496 			{
//  497 				BeeperCnt++;
//  498 				SPEAKER = BeeperCnt%2;
//  499 				//HAL_Delay(3000);
//  500 			}
//  501 		
//  502 			if(BeeperCnt > beeper_cnt)	
//  503 			{	
//  504 				SPEAKER = 0;
//  505 				mksBpAlrmEn=0;
//  506 				BeeperCnt=0;
//  507 				BeeperFreq = 0;
//  508 			}
//  509 		}
//  510 		#endif
//  511         
//  512         if(beep_pwdet)
_Z14mksBeeperAlarmv:
        LDR.W    R0,??DataTable15_22
        LDRB     R1,[R0, #+14]
        CMP      R1,#+0
        BEQ.N    ??mksBeeperAlarm_0
//  513         {
//  514             if(MKS_PW_DET_OP== 1)
        LDR.W    R1,??DataTable15_23  ;; 0x42210108
        LDR      R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??mksBeeperAlarm_0
//  515             {
//  516                 beep_pwdet=0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+14]
//  517                 BeeperCnt = 0;
        STRB     R1,[R0, #+12]
//  518                 delaycnt = 0;
        STR      R1,[R0, #+56]
//  519                 mksBpAlrmEn = 0;    
        STRB     R1,[R0, #+13]
//  520                 BEEPER_OP = 0;
        LDR.W    R2,??DataTable15_24  ;; 0x42220194
        STR      R1,[R2, #+0]
//  521             }
//  522         }
//  523 
//  524         if(beep_mtdet1)
??mksBeeperAlarm_0:
        LDRB     R1,[R0, #+15]
        CMP      R1,#+0
        BEQ.N    ??mksBeeperAlarm_1
//  525         {
//  526             if(MKS_MT_DET1_OP== 1)
        LDR.W    R1,??DataTable15_23  ;; 0x42210108
        LDR      R1,[R1, #+8]
        CMP      R1,#+1
        BNE.N    ??mksBeeperAlarm_1
//  527             {
//  528                 beep_mtdet1=0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+15]
//  529                 BeeperCnt = 0;
        STRB     R1,[R0, #+12]
//  530                 delaycnt = 0;
        STR      R1,[R0, #+56]
//  531                 mksBpAlrmEn = 0;    
        STRB     R1,[R0, #+13]
//  532                 BEEPER_OP = 0;
        LDR.W    R2,??DataTable15_24  ;; 0x42220194
        STR      R1,[R2, #+0]
//  533             }
//  534         }
//  535         
//  536         if(beep_mtdet2)
??mksBeeperAlarm_1:
        LDRB     R1,[R0, #+16]
        CMP      R1,#+0
        BEQ.N    ??mksBeeperAlarm_2
//  537         {
//  538             if(MKS_MT_DET2_OP== 1)
        LDR.W    R1,??DataTable15_25  ;; 0x42230118
        LDR      R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??mksBeeperAlarm_2
//  539             {
//  540                 beep_mtdet2=0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+16]
//  541                 BeeperCnt = 0;
        STRB     R1,[R0, #+12]
//  542                 delaycnt = 0;
        STR      R1,[R0, #+56]
//  543                 mksBpAlrmEn = 0;    
        STRB     R1,[R0, #+13]
//  544                 BEEPER_OP = 0;
        LDR.W    R2,??DataTable15_24  ;; 0x42220194
        STR      R1,[R2, #+0]
//  545             }
//  546         }
//  547         
//  548 		if(mksBpAlrmEn)
??mksBeeperAlarm_2:
        LDRB     R1,[R0, #+13]
        CMP      R1,#+0
        BEQ.N    ??mksBeeperAlarm_3
//  549 		{
//  550 			delaycnt++;
        LDR      R1,[R0, #+56]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+56]
//  551 			if(delaycnt >= 1000)
        LDR      R1,[R0, #+56]
        CMP      R1,#+1000
        BCC.N    ??mksBeeperAlarm_4
//  552 			{
//  553 				BeeperCnt++;
        LDRB     R1,[R0, #+12]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+12]
//  554 				delaycnt = 0;
        MOVS     R1,#+0
        STR      R1,[R0, #+56]
//  555 				BEEPER_OP = BeeperCnt%2;
        LDRB     R1,[R0, #+12]
        AND      R1,R1,#0x1
        LDR.W    R2,??DataTable15_24  ;; 0x42220194
        STR      R1,[R2, #+0]
//  556 			}
//  557 			if(BeeperCnt>=20)
??mksBeeperAlarm_4:
        LDRB     R1,[R0, #+12]
        CMP      R1,#+20
        BLT.N    ??mksBeeperAlarm_3
//  558 			{
//  559 				BeeperCnt = 0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+12]
//  560 				delaycnt = 0;
        STR      R1,[R0, #+56]
//  561 				mksBpAlrmEn = 0;	
        STRB     R1,[R0, #+13]
//  562 				BEEPER_OP = 0;
        MOV      R0,R1
        LDR.W    R1,??DataTable15_24  ;; 0x42220194
        STR      R0,[R1, #+0]
//  563 			}
//  564 		}
//  565 }
??mksBeeperAlarm_3:
        BX       LR               ;; return
          CFI EndBlock cfiBlock2
//  566 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function _Z21Close_machine_displayv
        THUMB
//  567 void Close_machine_display()
//  568 {
_Z21Close_machine_displayv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  569 	clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
//  570 	disp_state = PRINT_READY_UI;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_26
        STRB     R0,[R1, #+0]
//  571 	GUI_SetBkColor(gCfgItems.background_color);
        LDR.W    R4,??DataTable15_13
        LDR      R0,[R4, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
//  572 	GUI_SetColor(gCfgItems.title_color);
        LDR      R0,[R4, #+8]
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
//  573 	GUI_Clear();
          CFI FunCall GUI_Clear
        BL       GUI_Clear
//  574 	GUI_DispStringAt(common_menu.close_machine_tips, 190, 140);
        MOVS     R2,#+140
        MOVS     R1,#+190
        LDR.W    R0,??DataTable15_27
        LDR      R0,[R0, #+8]
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
//  575 	MKS_PW_OFF_OP = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable15_28  ;; 0x42218188
        STR      R0,[R1, #+0]
//  576 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock3
//  577 
//  578 //断电断料检测
//  579 //断电:PB0断电检测，可以作为第二喷头的断料检测接口。
//  580 //断料:PB1断料检测，
//  581 //关机模块检测管脚:
//  582 //PB4，可以通过配置文件来选择接220DET模块或接PWC模块;
//  583 //默认接PWC模块。

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function _Z23PowerOff_Filament_Checkv
        THUMB
//  584 void PowerOff_Filament_Check()
//  585 {
_Z23PowerOff_Filament_Checkv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
//  586 	volatile uint8_t i;
//  587 
//  588 	//断电检测
//  589 	if(gCfgItems.insert_det_module == 1)//接220det模块，断电检测
        LDR.W    R4,??DataTable15_22
        LDR.W    R0,??DataTable15_13
        LDRB     R1,[R0, #+444]
        CMP      R1,#+1
        BNE.N    ??PowerOff_Filament_Check_0
//  590 	{
//  591 		if((mksReprint.mks_printer_state == MKS_WORKING)&&(gCfgItems.mask_det_Function!=1))//打印中则进入暂停界面
        LDR.W    R5,??DataTable15_29
        LDRB     R1,[R5, #+180]
        CMP      R1,#+167
        BNE.W    ??PowerOff_Filament_Check_1
        ADD      R1,R0,#+444
        LDRB     R1,[R1, #+14]
        CMP      R1,#+1
        BEQ.W    ??PowerOff_Filament_Check_1
//  592 		{
//  593 			if(MKS_PW_DET_OP== 0)
        LDR.W    R1,??DataTable15_23  ;; 0x42210108
        LDR      R2,[R1, #+0]
        CMP      R2,#+0
        BNE.N    ??PowerOff_Filament_Check_2
//  594 			{
//  595 				poweroff_det_flg = 1;
        MOVS     R2,#+1
        STRB     R2,[R4, #+1]
//  596 				if(poweroff_det_cnt >= 1000)
        LDR      R2,[R4, #+20]
        CMP      R2,#+1000
        BCC.W    ??PowerOff_Filament_Check_1
//  597 				{
//  598 					if((MKS_PW_DET_OP==0)&&(gCfgItems.have_ups==1))//有UPS则先暂停
        LDR      R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??PowerOff_Filament_Check_3
        LDRB     R0,[R0, #+205]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_3
//  599 					{
//  600 						poweroff_det_flg = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+1]
//  601 						poweroff_det_cnt= 0;
        STR      R0,[R4, #+20]
//  602 						
//  603 						clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
//  604 						stop_print_time();
          CFI FunCall stop_print_time
        BL       stop_print_time
//  605       					card.pauseSDPrint();
        LDR.W    R0,??DataTable15_16
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
//  606       					print_job_timer.pause();
        LDR.W    R0,??DataTable15_30
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
//  607 						mksReprint.mks_printer_state = MKS_PAUSING;
        MOVS     R0,#+169
        STRB     R0,[R5, #+180]
//  608                         
//  609                         #if defined(TFT35)
//  610 					if(from_flash_pic==1)
        LDR.W    R0,??DataTable15_31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_4
//  611 						flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_32
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_5
//  612 					else
//  613 						default_preview_flg = 1;						
??PowerOff_Filament_Check_4:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_33
        STRB     R0,[R1, #+0]
//  614 					draw_printing();
??PowerOff_Filament_Check_5:
          CFI FunCall draw_printing
        BL       draw_printing
//  615 			#else
//  616 					draw_pause();
//  617 			#endif
//  618 						mksBpAlrmEn = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+13]
//  619                         beep_pwdet=1;
        STRB     R0,[R4, #+14]
//  620 						delaycnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+56]
//  621 
//  622 						return;				
        POP      {R0,R4,R5,PC}
//  623 					}
//  624 					//无UPS直接关机
//  625 					poweroff_det_flg = 0;
??PowerOff_Filament_Check_3:
        MOVS     R0,#+0
        STRB     R0,[R4, #+1]
//  626 					poweroff_det_cnt= 0;
        STR      R0,[R4, #+20]
//  627 
//  628 					//Close_machine_display();
//  629 
//  630 					return;
        POP      {R0,R4,R5,PC}
//  631 				}
//  632 			}
//  633 			else
//  634 			{
//  635 				poweroff_det_flg = 0;
??PowerOff_Filament_Check_2:
        MOVS     R1,#+0
        STRB     R1,[R4, #+1]
//  636 				poweroff_det_cnt= 0;
        STR      R1,[R4, #+20]
        B.N      ??PowerOff_Filament_Check_1
//  637 			}
//  638 		}		
//  639 	}
//  640 	else//接PWC关机模块
//  641 	{
//  642 		if(MKS_PW_DET_OP == 0)//
??PowerOff_Filament_Check_0:
        LDR.W    R1,??DataTable15_23  ;; 0x42210108
        LDR      R2,[R1, #+0]
        CMP      R2,#+0
        BNE.N    ??PowerOff_Filament_Check_6
//  643 		{
//  644 			poweroff_det_low_flg = 1;//启动计时
        MOVS     R2,#+1
        STRB     R2,[R4, #+2]
//  645 		}
//  646 		
//  647 		if(poweroff_det_low_cnt >= 80)// 1s跳变为高电平
??PowerOff_Filament_Check_6:
        LDR      R2,[R4, #+24]
        CMP      R2,#+80
        BCC.N    ??PowerOff_Filament_Check_7
//  648 		{
//  649 			if(MKS_PW_DET_OP == 1)
        LDR      R2,[R1, #+0]
        CMP      R2,#+1
        BNE.N    ??PowerOff_Filament_Check_8
//  650 			{
//  651 				poweroff_det_low_flg = 0;
        MOVS     R2,#+0
        STRB     R2,[R4, #+2]
//  652 				poweroff_det_low_cnt = 0;
        STR      R2,[R4, #+24]
//  653 				poweroff_det_flg=1;
        MOVS     R2,#+1
        STRB     R2,[R4, #+1]
        B.N      ??PowerOff_Filament_Check_7
//  654 			}
//  655 			else
//  656 			{
//  657 				poweroff_det_low_flg = 0;
??PowerOff_Filament_Check_8:
        MOVS     R2,#+0
        STRB     R2,[R4, #+2]
//  658 				poweroff_det_low_cnt = 0;
        STR      R2,[R4, #+24]
//  659 			}
//  660 		}
//  661 		
//  662 		if(poweroff_det_flg==1)
??PowerOff_Filament_Check_7:
        LDRB     R2,[R4, #+1]
        CMP      R2,#+1
        BNE.N    ??PowerOff_Filament_Check_1
//  663 		{
//  664 			poweroff_det_high_flg = 1;
        MOVS     R2,#+1
        STRB     R2,[R4, #+3]
//  665 			if(poweroff_det_high_cnt >= 80)
        LDR      R2,[R4, #+28]
        CMP      R2,#+80
        BCC.N    ??PowerOff_Filament_Check_1
//  666 			{
//  667 				if(MKS_PW_DET_OP == 1)
        LDR      R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??PowerOff_Filament_Check_9
//  668 				{
//  669 					if((mksReprint.mks_printer_state == MKS_WORKING)&&(gCfgItems.have_ups==1))//打印中且有UPS后备电源，则进入暂停界面
        LDR.W    R5,??DataTable15_29
        LDRB     R1,[R5, #+180]
        CMP      R1,#+167
        BNE.N    ??PowerOff_Filament_Check_10
        LDRB     R0,[R0, #+205]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_10
//  670 					{
//  671 						poweroff_det_high_flg = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+3]
//  672 						poweroff_det_high_cnt = 0;
        STR      R0,[R4, #+28]
//  673 						poweroff_det_flg=0;
        STRB     R0,[R4, #+1]
//  674 
//  675 						clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
//  676 						stop_print_time();
          CFI FunCall stop_print_time
        BL       stop_print_time
//  677       					card.pauseSDPrint();
        LDR.W    R0,??DataTable15_16
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
//  678       					print_job_timer.pause();
        LDR.W    R0,??DataTable15_30
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
//  679 						mksReprint.mks_printer_state = MKS_PAUSING;
        MOVS     R0,#+169
        STRB     R0,[R5, #+180]
//  680 
//  681 						
//  682 						#if defined(TFT35)
//  683 						if(from_flash_pic==1)
        LDR.W    R0,??DataTable15_31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_11
//  684 							flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_32
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_12
//  685 						else
//  686 							default_preview_flg = 1;						
??PowerOff_Filament_Check_11:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_33
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_12
//  687 						draw_printing();
//  688 						#else
//  689 						draw_pause();
//  690 						#endif
//  691 						mksBpAlrmEn = 1;
//  692 						delaycnt = 0;
//  693 
//  694 						return;
//  695 					}
//  696 					//没UPS电源或没在打印，直接关机。
//  697 					poweroff_det_high_flg = 0;
??PowerOff_Filament_Check_10:
        MOVS     R0,#+0
        STRB     R0,[R4, #+3]
//  698 					poweroff_det_high_cnt = 0;
        STR      R0,[R4, #+28]
//  699 					poweroff_det_flg=0;
        STRB     R0,[R4, #+1]
//  700 					Close_machine_display();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z21Close_machine_displayv
        B.N      _Z21Close_machine_displayv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
//  701 					return;					
//  702 				}
//  703 				else
//  704 				{
//  705 					poweroff_det_low_flg = 0;
??PowerOff_Filament_Check_9:
        MOVS     R1,#+0
        STRB     R1,[R4, #+2]
//  706 					poweroff_det_low_cnt = 0;
        STR      R1,[R4, #+24]
//  707 					poweroff_det_high_flg = 0;
        STRB     R1,[R4, #+3]
//  708 					poweroff_det_high_cnt = 0;
        STR      R1,[R4, #+28]
//  709 					poweroff_det_flg = 0;
        STRB     R1,[R4, #+1]
//  710 				}
//  711 			}
//  712 		}
//  713 	}
//  714 	//断料检测2
//  715 	if((mksCfg.extruders == 2)&&(mksReprint.mks_printer_state == MKS_WORKING)&&(gCfgItems.mask_det_Function!=1))//打印中则进入暂停界面
??PowerOff_Filament_Check_1:
        LDR.W    R5,??DataTable15_29
        LDR.W    R1,??DataTable15_21
        LDRB     R1,[R1, #+247]
        CMP      R1,#+2
        BNE.W    ??PowerOff_Filament_Check_13
        LDRB     R1,[R5, #+180]
        CMP      R1,#+167
        BNE.W    ??PowerOff_Filament_Check_13
        ADD      R2,R0,#+444
        LDRB     R1,[R2, #+14]
        CMP      R1,#+1
        BEQ.W    ??PowerOff_Filament_Check_13
//  716 	{
//  717 		if(gCfgItems.filament_det1_level_flg == 1)//断料接口接入电平为高电平触发时的处理
        LDR.W    R1,??DataTable15_25  ;; 0x42230118
        LDRB     R2,[R2, #+2]
        CMP      R2,#+1
        LDR      R2,[R1, #+0]
        BNE.N    ??PowerOff_Filament_Check_14
//  718 		{
//  719 			//高电平触发时，是检测2s低电平和2s高电平
//  720       		if(MKS_MT_DET2_OP == 0)
        CMP      R2,#+0
        BNE.N    ??PowerOff_Filament_Check_15
//  721 			{
//  722 				filament_det2_low_flg = 1;//启动计时
        MOVS     R2,#+1
        STRB     R2,[R4, #+9]
//  723 			}
//  724 			
//  725 			if(filament_det2_low_cnt >= 2000)// 2s
??PowerOff_Filament_Check_15:
        LDR      R2,[R4, #+48]
        CMP      R2,#+2000
        BCC.N    ??PowerOff_Filament_Check_16
//  726 			{
//  727         		if(MKS_MT_DET2_OP == 1)
        LDR      R2,[R1, #+0]
        CMP      R2,#+1
        BNE.N    ??PowerOff_Filament_Check_17
//  728 				{
//  729 					filament_det2_high_flg = 1;
        MOVS     R2,#+1
        STRB     R2,[R4, #+10]
//  730 					filament_det2_check=1;
        STRB     R2,[R4, #+11]
//  731 
//  732 					filament_det2_low_flg = 0;
        MOVS     R2,#+0
        STRB     R2,[R4, #+9]
//  733 					filament_det2_low_cnt = 0;
        STR      R2,[R4, #+48]
        B.N      ??PowerOff_Filament_Check_16
//  734 				}
//  735 				else
//  736 				{
//  737 					filament_det2_low_flg = 0;
??PowerOff_Filament_Check_17:
        MOVS     R2,#+0
        STRB     R2,[R4, #+9]
//  738 					filament_det2_low_cnt = 0;
        STR      R2,[R4, #+48]
//  739 				}
//  740 			}
//  741 				
//  742 			if(filament_det2_check ==1)
??PowerOff_Filament_Check_16:
        LDRB     R2,[R4, #+11]
        CMP      R2,#+1
        BNE.N    ??PowerOff_Filament_Check_13
//  743 			{
//  744 				if(filament_det2_high_cnt >= 2000)
        LDR      R2,[R4, #+52]
        CMP      R2,#+2000
        BCC.N    ??PowerOff_Filament_Check_13
//  745 				{
//  746 					if(MKS_MT_DET2_OP == 1)
        LDR      R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??PowerOff_Filament_Check_18
//  747 					{
//  748 						filament_det2_high_flg= 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+10]
//  749 						filament_det2_high_cnt= 0;
        STR      R0,[R4, #+52]
//  750 						filament_det2_check=0;
        STRB     R0,[R4, #+11]
//  751 						
//  752 						clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
//  753 						stop_print_time();
          CFI FunCall stop_print_time
        BL       stop_print_time
//  754       					card.pauseSDPrint();
        LDR.W    R0,??DataTable15_16
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
//  755       					print_job_timer.pause();
        LDR.W    R0,??DataTable15_30
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
//  756 						mksReprint.mks_printer_state = MKS_PAUSING;
        MOVS     R0,#+169
        STRB     R0,[R5, #+180]
//  757                         
//  758                         pause_from_high_level=1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
//  759 
//  760 						
//  761 						#if defined(TFT35)
//  762 						if(from_flash_pic==1)
        LDR.W    R0,??DataTable15_31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_19
//  763 							flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_32
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_12
//  764 						else
//  765 							default_preview_flg = 1;						
??PowerOff_Filament_Check_19:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_33
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_12
//  766 						draw_printing();
//  767 						#else
//  768 						draw_pause();
//  769 						#endif
//  770 						mksBpAlrmEn = 1;
//  771 						delaycnt = 0;
//  772 
//  773 						return;		
//  774 					}
//  775 					else
//  776 					{
//  777 						filament_det2_low_flg = 0;
??PowerOff_Filament_Check_18:
        MOVS     R1,#+0
        STRB     R1,[R4, #+9]
//  778 						filament_det2_low_cnt = 0;
        STR      R1,[R4, #+48]
//  779 						filament_det2_high_flg= 0;
        STRB     R1,[R4, #+10]
//  780 						filament_det2_high_cnt= 0;
        STR      R1,[R4, #+52]
//  781 						filament_det2_check=0;
        STRB     R1,[R4, #+11]
        B.N      ??PowerOff_Filament_Check_13
//  782 					}
//  783 				}
//  784 			}
//  785 		}
//  786 		else//断料接口接入电平为低电平触发时处理
//  787 		{
//  788 			if(MKS_MT_DET2_OP == 0)
??PowerOff_Filament_Check_14:
        CMP      R2,#+0
        BNE.N    ??PowerOff_Filament_Check_20
//  789 			{
//  790 				filament_det2_flg = 1;
        MOVS     R2,#+1
        STRB     R2,[R4, #+8]
//  791 				if(filament_det2_cnt >= 1000)
        LDR      R2,[R4, #+44]
        CMP      R2,#+1000
        BCC.N    ??PowerOff_Filament_Check_13
//  792 				{
//  793 					if(MKS_MT_DET2_OP == 0)
        LDR      R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??PowerOff_Filament_Check_13
//  794 					{
//  795 						filament_det2_flg = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+8]
//  796 						filament_det2_cnt= 0;
        STR      R0,[R4, #+44]
//  797 
//  798 						clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
//  799 						stop_print_time();
          CFI FunCall stop_print_time
        BL       stop_print_time
//  800       					card.pauseSDPrint();
        LDR.W    R0,??DataTable15_16
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
//  801       					print_job_timer.pause();
        LDR.W    R0,??DataTable15_30
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
//  802 						mksReprint.mks_printer_state = MKS_PAUSING;
        MOVS     R0,#+169
        STRB     R0,[R5, #+180]
//  803                         
//  804                         			#if defined(TFT35)
//  805 						if(from_flash_pic==1)
        LDR.W    R0,??DataTable15_31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_21
//  806 							flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_32
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_22
//  807 						else
//  808 							default_preview_flg = 1;						
??PowerOff_Filament_Check_21:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_33
        STRB     R0,[R1, #+0]
//  809 						draw_printing();
??PowerOff_Filament_Check_22:
          CFI FunCall draw_printing
        BL       draw_printing
//  810 						#else
//  811 						draw_pause();
//  812 						#endif
//  813 						mksBpAlrmEn = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+13]
//  814                         beep_mtdet2=1;
        STRB     R0,[R4, #+16]
//  815 						delaycnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+56]
//  816 
//  817 						return;				
        POP      {R0,R4,R5,PC}
//  818 					}
//  819 				}
//  820 			}
//  821 			else
//  822 			{
//  823 				filament_det2_flg = 0;
??PowerOff_Filament_Check_20:
        MOVS     R1,#+0
        STRB     R1,[R4, #+8]
//  824                 filament_det2_cnt = 0;
        STR      R1,[R4, #+44]
//  825 			}
//  826 		}
//  827 	}	
//  828 	//断料检测1
//  829 	if((mksReprint.mks_printer_state == MKS_WORKING)&&(gCfgItems.mask_det_Function!=1))//打印中则进入暂停界面
??PowerOff_Filament_Check_13:
        LDRB     R1,[R5, #+180]
        CMP      R1,#+167
        BNE.W    ??PowerOff_Filament_Check_23
        ADD      R2,R0,#+444
        LDRB     R0,[R2, #+14]
        CMP      R0,#+1
        BEQ.W    ??PowerOff_Filament_Check_23
//  830 	{
//  831 		if(gCfgItems.filament_det0_level_flg == 1)//断料接口接入电平为高电平触发时的处理
        LDR.W    R1,??DataTable15_23  ;; 0x42210108
        LDRB     R0,[R2, #+1]
        CMP      R0,#+1
        LDR      R0,[R1, #+8]
        BNE.N    ??PowerOff_Filament_Check_24
//  832 		{
//  833 			//高电平触发时，是检测2s低电平和2s高电平
//  834       		if(MKS_MT_DET1_OP == 0)
        CMP      R0,#+0
        BNE.N    ??PowerOff_Filament_Check_25
//  835 			{
//  836 				filament_det1_low_flg = 1;//启动计时
        MOVS     R0,#+1
        STRB     R0,[R4, #+5]
//  837 			}
//  838 			
//  839 			if(filament_det1_low_cnt >= 2000)// 2s
??PowerOff_Filament_Check_25:
        LDR      R0,[R4, #+36]
        CMP      R0,#+2000
        BCC.N    ??PowerOff_Filament_Check_26
//  840 			{
//  841         		if(MKS_MT_DET1_OP == 1)
        LDR      R0,[R1, #+8]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_27
//  842 				{
//  843 					filament_det1_high_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+6]
//  844 					filament_det1_check=1;
        STRB     R0,[R4, #+7]
//  845 
//  846 					filament_det1_low_flg = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
//  847 					filament_det1_low_cnt = 0;
        STR      R0,[R4, #+36]
        B.N      ??PowerOff_Filament_Check_26
//  848 				}
//  849 				else
//  850 				{
//  851 					filament_det1_low_flg = 0;
??PowerOff_Filament_Check_27:
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
//  852 					filament_det1_low_cnt = 0;
        STR      R0,[R4, #+36]
//  853 				}
//  854 			}
//  855 				
//  856 			if(filament_det1_check ==1)
??PowerOff_Filament_Check_26:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_23
//  857 			{
//  858 				if(filament_det1_high_cnt >= 2000)
        LDR      R0,[R4, #+40]
        CMP      R0,#+2000
        BCC.N    ??PowerOff_Filament_Check_23
//  859 				{
//  860 					if(MKS_MT_DET1_OP == 1)
        LDR      R0,[R1, #+8]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_28
//  861 					{
//  862 						filament_det1_high_flg= 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
//  863 						filament_det1_high_cnt= 0;
        STR      R0,[R4, #+40]
//  864 						filament_det1_check=0;
        STRB     R0,[R4, #+7]
//  865 
//  866 						clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
//  867 						stop_print_time();
          CFI FunCall stop_print_time
        BL       stop_print_time
//  868       					card.pauseSDPrint();
        LDR.W    R0,??DataTable15_16
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
//  869       					print_job_timer.pause();
        LDR.W    R0,??DataTable15_30
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
//  870 						mksReprint.mks_printer_state = MKS_PAUSING;
        MOVS     R0,#+169
        STRB     R0,[R5, #+180]
//  871                         
//  872                         pause_from_high_level=1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
//  873 
//  874                         
//  875                         			#if defined(TFT35)
//  876 						if(from_flash_pic==1)
        LDR.W    R0,??DataTable15_31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_29
//  877 							flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_32
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_12
//  878 						else
//  879 							default_preview_flg = 1;						
??PowerOff_Filament_Check_29:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_33
        STRB     R0,[R1, #+0]
//  880 						draw_printing();
??PowerOff_Filament_Check_12:
          CFI FunCall draw_printing
        BL       draw_printing
//  881 						#else
//  882 						draw_pause();
//  883 						#endif
//  884 						mksBpAlrmEn = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+13]
//  885 						delaycnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+56]
//  886 
//  887 						return;		
        POP      {R0,R4,R5,PC}
//  888 					}
//  889 					else
//  890 					{
//  891 						filament_det1_low_flg = 0;
??PowerOff_Filament_Check_28:
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
//  892 						filament_det1_low_cnt = 0;
        STR      R0,[R4, #+36]
//  893 						filament_det1_high_flg= 0;
        STRB     R0,[R4, #+6]
//  894 						filament_det1_high_cnt= 0;
        STR      R0,[R4, #+40]
//  895 						filament_det1_check=0;
        STRB     R0,[R4, #+7]
        POP      {R0,R4,R5,PC}
//  896 					}
//  897 				}
//  898 			}
//  899 		}
//  900 		else//断料接口接入电平为低电平触发时处理
//  901 		{
//  902 			if(MKS_MT_DET1_OP == 0)
??PowerOff_Filament_Check_24:
        CMP      R0,#+0
        BNE.N    ??PowerOff_Filament_Check_30
//  903 			{
//  904 				filament_det1_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
//  905 				if(filament_det1_cnt >= 1000)
        LDR      R0,[R4, #+32]
        CMP      R0,#+1000
        BCC.N    ??PowerOff_Filament_Check_23
//  906 				{
//  907 					if(MKS_MT_DET1_OP == 0)
        LDR      R0,[R1, #+8]
        CMP      R0,#+0
        BNE.N    ??PowerOff_Filament_Check_23
//  908 					{
//  909 						filament_det1_flg = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
//  910 						filament_det1_cnt= 0;
        STR      R0,[R4, #+32]
//  911 
//  912 						clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
//  913 						stop_print_time();
          CFI FunCall stop_print_time
        BL       stop_print_time
//  914       					card.pauseSDPrint();
        LDR.W    R0,??DataTable15_16
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
//  915       					print_job_timer.pause();
        LDR.W    R0,??DataTable15_30
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
//  916 						mksReprint.mks_printer_state = MKS_PAUSING;
        MOVS     R0,#+169
        STRB     R0,[R5, #+180]
//  917                         			#if defined(TFT35)
//  918 						if(from_flash_pic==1)
        LDR.W    R0,??DataTable15_31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PowerOff_Filament_Check_31
//  919 							flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_32
        STRB     R0,[R1, #+0]
        B.N      ??PowerOff_Filament_Check_32
//  920 						else
//  921 							default_preview_flg = 1;						
??PowerOff_Filament_Check_31:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable15_33
        STRB     R0,[R1, #+0]
//  922 						draw_printing();
??PowerOff_Filament_Check_32:
          CFI FunCall draw_printing
        BL       draw_printing
//  923 						#else
//  924 						draw_pause();
//  925 						#endif
//  926 						mksBpAlrmEn = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+13]
//  927                         beep_mtdet1=1;
        STRB     R0,[R4, #+15]
//  928 						delaycnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+56]
//  929 
//  930 						return;				
        POP      {R0,R4,R5,PC}
//  931 					}
//  932 				}
//  933 			}
//  934 			else
//  935 			{
//  936 				filament_det1_flg = 0;
??PowerOff_Filament_Check_30:
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
//  937                 filament_det1_cnt = 0;
        STR      R0,[R4, #+32]
//  938 			}
//  939 		}
//  940 	}
//  941 }
??PowerOff_Filament_Check_23:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock4
//  942 
//  943 //sean 19.7.24
//  944 //start
//  945 //no filament :return 0;
//  946 //have filament:return 1;
//  947 #if 0
//  948 uint8_t no_filament_print=0;
//  949 uint8_t Filament_Check()
//  950 {
//  951 	//断料检测2
//  952 	if((mksCfg.extruders == 2)&&(gCfgItems.mask_det_Function!=1))//打印中则进入暂停界面
//  953 	{
//  954 		if(gCfgItems.filament_det1_level_flg == 1)//断料接口接入电平为高电平触发时的处理
//  955 		{
//  956 			//高电平触发时，是检测2s低电平和2s高电平
//  957       			if(MKS_MT_DET2_OP == 0)
//  958 			{
//  959 				HAL_Delay(100);
//  960 				if(MKS_MT_DET2_OP == 0)
//  961 				{
//  962 					//have filament
//  963 					clear_cur_ui();
//  964 					mksReprint.mks_printer_state = MKS_PAUSED;
//  965 					no_filament_print = 1;
//  966                     
//  967 					#if defined(TFT35)
//  968 					if(from_flash_pic==1)
//  969 						flash_preview_begin = 1;
//  970 					else
//  971 						default_preview_flg = 1;						
//  972 					draw_printing();
//  973 					#else
//  974 					draw_pause();
//  975 					#endif
//  976 					mksBpAlrmEn = 1;
//  977 					delaycnt = 0;
//  978 					return 0;
//  979 				}
//  980 			}
//  981 			return 1;
//  982 		}
//  983 		else//断料接口接入电平为低电平触发时处理
//  984 		{
//  985 			if(MKS_MT_DET2_OP == 0)
//  986 			{
//  987 				HAL_Delay(100);
//  988 				if(MKS_MT_DET2_OP == 0)
//  989 				{
//  990 					clear_cur_ui();
//  991 					mksReprint.mks_printer_state = MKS_PAUSED;
//  992 					no_filament_print = 1;
//  993                     
//  994                     			#if defined(TFT35)
//  995 					if(from_flash_pic==1)
//  996 						flash_preview_begin = 1;
//  997 					else
//  998 						default_preview_flg = 1;						
//  999 					draw_printing();
// 1000 					#else
// 1001 					draw_pause();
// 1002 					#endif
// 1003 					mksBpAlrmEn = 1;
// 1004                     			beep_mtdet2=1;
// 1005 					delaycnt = 0;
// 1006 
// 1007 					return 0;				
// 1008 				}
// 1009 			}
// 1010 			return 1;	
// 1011 		}
// 1012 	}	
// 1013 	//断料检测1
// 1014 	if(gCfgItems.mask_det_Function!=1)//打印中则进入暂停界面
// 1015 	{
// 1016 		if(gCfgItems.filament_det0_level_flg == 1)//断料接口接入电平为高电平触发时的处理
// 1017 		{
// 1018 			//高电平触发时，是检测2s低电平和2s高电平
// 1019       			if(MKS_MT_DET1_OP == 0)
// 1020 			{
// 1021 				HAL_Delay(100);
// 1022 				if(MKS_MT_DET1_OP == 0)
// 1023 				{
// 1024 					//have filament
// 1025 					clear_cur_ui();
// 1026 					mksReprint.mks_printer_state = MKS_PAUSED;
// 1027 					no_filament_print = 1;
// 1028                     
// 1029 					#if defined(TFT35)
// 1030 					if(from_flash_pic==1)
// 1031 						flash_preview_begin = 1;
// 1032 					else
// 1033 						default_preview_flg = 1;						
// 1034 					draw_printing();
// 1035 					#else
// 1036 					draw_pause();
// 1037 					#endif
// 1038 					mksBpAlrmEn = 1;
// 1039 					delaycnt = 0;
// 1040 					return 0;
// 1041 				}
// 1042 			}
// 1043 			return 1;	
// 1044 			
// 1045 		}
// 1046 		else//断料接口接入电平为低电平触发时处理
// 1047 		{
// 1048 			if(MKS_MT_DET1_OP == 0)
// 1049 			{
// 1050 				HAL_Delay(100);
// 1051 				if(MKS_MT_DET1_OP == 0)
// 1052 				{
// 1053 					clear_cur_ui();
// 1054 					mksReprint.mks_printer_state = MKS_PAUSED;
// 1055 					no_filament_print = 1;
// 1056                     
// 1057                     			#if defined(TFT35)
// 1058 					if(from_flash_pic==1)
// 1059 						flash_preview_begin = 1;
// 1060 					else
// 1061 						default_preview_flg = 1;						
// 1062 					draw_printing();
// 1063 					#else
// 1064 					draw_pause();
// 1065 					#endif
// 1066 					mksBpAlrmEn = 1;
// 1067                     			beep_mtdet2=1;
// 1068 					delaycnt = 0;
// 1069 
// 1070 					return 0;				
// 1071 				}
// 1072 			}
// 1073 			return 1;	
// 1074 		}
// 1075 	}
// 1076 }
// 1077 #endif
// 1078 //end
// 1079 #if 0
// 1080 /** System Clock Configuration
// 1081 */
// 1082 void SystemClock_Config(void)
// 1083 {
// 1084 
// 1085   RCC_OscInitTypeDef RCC_OscInitStruct;
// 1086   RCC_ClkInitTypeDef RCC_ClkInitStruct;
// 1087   RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
// 1088 
// 1089     /**Configure the main internal regulator output voltage 
// 1090     */
// 1091   __HAL_RCC_PWR_CLK_ENABLE();
// 1092 
// 1093   __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
// 1094 
// 1095     /**Initializes the CPU, AHB and APB busses clocks 
// 1096     */
// 1097   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
// 1098   RCC_OscInitStruct.HSEState = RCC_HSE_ON;
// 1099   RCC_OscInitStruct.LSIState = RCC_LSI_ON;
// 1100   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
// 1101   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
// 1102   RCC_OscInitStruct.PLL.PLLM = 4;
// 1103   RCC_OscInitStruct.PLL.PLLN = 168;
// 1104   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
// 1105   RCC_OscInitStruct.PLL.PLLQ = 7;
// 1106   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
// 1107   {
// 1108     Error_Handler();
// 1109   }
// 1110 
// 1111     /**Initializes the CPU, AHB and APB busses clocks 
// 1112     */
// 1113   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
// 1114                               |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
// 1115   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
// 1116   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
// 1117   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
// 1118   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
// 1119 
// 1120   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
// 1121   {
// 1122     Error_Handler();
// 1123   }
// 1124   
// 1125 
// 1126   PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
// 1127   PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
// 1128   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
// 1129   {
// 1130     Error_Handler();
// 1131   }
// 1132 
// 1133     /**Configure the Systick interrupt time 
// 1134     */
// 1135   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
// 1136 
// 1137     /**Configure the Systick 
// 1138     */
// 1139   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
// 1140 
// 1141   /* SysTick_IRQn interrupt configuration */
// 1142   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
// 1143 }
// 1144 #endif
// 1145 /** System Clock Configuration
// 1146 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function _Z18SystemClock_Configv
        THUMB
// 1147 void SystemClock_Config(void)
// 1148 {
_Z18SystemClock_Configv:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+84
          CFI CFA R13+88
// 1149 
// 1150   RCC_OscInitTypeDef RCC_OscInitStruct;
// 1151   RCC_ClkInitTypeDef RCC_ClkInitStruct;
// 1152   RCC_PeriphCLKInitTypeDef PeriphClkInit;
// 1153 
// 1154     /**Initializes the CPU, AHB and APB busses clocks 
// 1155     */
// 1156   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
        MOVS     R0,#+9
        STR      R0,[SP, #+20]
// 1157   RCC_OscInitStruct.HSEState = RCC_HSE_ON;
        MOV      R0,#+65536
        STR      R0,[SP, #+24]
// 1158   RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
        MOVS     R1,#+0
        STR      R1,[SP, #+28]
// 1159   RCC_OscInitStruct.HSIState = RCC_HSI_ON;
        MOVS     R1,#+1
        STR      R1,[SP, #+36]
// 1160   RCC_OscInitStruct.LSIState = RCC_LSI_ON;
        STR      R1,[SP, #+44]
// 1161   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
        MOVS     R1,#+2
        STR      R1,[SP, #+48]
// 1162   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
        STR      R0,[SP, #+52]
// 1163   RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
        MOV      R0,#+1835008
        STR      R0,[SP, #+56]
// 1164   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
        ADD      R0,SP,#+20
          CFI FunCall HAL_RCC_OscConfig
        BL       HAL_RCC_OscConfig
        CMP      R0,#+0
        BEQ.N    ??SystemClock_Config_0
// 1165   {
// 1166     Error_Handler();
          CFI FunCall Error_Handler
        BL       Error_Handler
// 1167   }
// 1168 
// 1169     /**Initializes the CPU, AHB and APB busses clocks 
// 1170     */
// 1171   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
// 1172                               |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
??SystemClock_Config_0:
        MOVS     R0,#+15
        STR      R0,[SP, #+0]
// 1173   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
        MOVS     R0,#+2
        STR      R0,[SP, #+4]
// 1174   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1175   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
        MOV      R0,#+1024
        STR      R0,[SP, #+12]
// 1176   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
        MOVS     R0,#+0
        STR      R0,[SP, #+16]
// 1177 
// 1178   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
        MOVS     R1,#+2
        ADD      R0,SP,#+0
          CFI FunCall HAL_RCC_ClockConfig
        BL       HAL_RCC_ClockConfig
        CMP      R0,#+0
        BEQ.N    ??SystemClock_Config_1
// 1179   {
// 1180     Error_Handler();
          CFI FunCall Error_Handler
        BL       Error_Handler
// 1181   }
// 1182 
// 1183   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_ADC;
??SystemClock_Config_1:
        MOVS     R0,#+3
        STR      R0,[SP, #+60]
// 1184   PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
        MOV      R0,#+512
        STR      R0,[SP, #+64]
// 1185   PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;
        MOV      R0,#+32768
        STR      R0,[SP, #+68]
// 1186   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
        ADD      R0,SP,#+60
          CFI FunCall HAL_RCCEx_PeriphCLKConfig
        BL       HAL_RCCEx_PeriphCLKConfig
        CMP      R0,#+0
        BEQ.N    ??SystemClock_Config_2
// 1187   {
// 1188     Error_Handler();
          CFI FunCall Error_Handler
        BL       Error_Handler
// 1189   }
// 1190 
// 1191     /**Configure the Systick interrupt time 
// 1192     */
// 1193   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
??SystemClock_Config_2:
          CFI FunCall HAL_RCC_GetHCLKFreq
        BL       HAL_RCC_GetHCLKFreq
        MOV      R1,#+1000
        UDIV     R0,R0,R1
          CFI FunCall HAL_SYSTICK_Config
        BL       HAL_SYSTICK_Config
// 1194 
// 1195     /**Configure the Systick 
// 1196     */
// 1197   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
        MOVS     R0,#+4
          CFI FunCall HAL_SYSTICK_CLKSourceConfig
        BL       HAL_SYSTICK_CLKSourceConfig
// 1198 
// 1199   /* SysTick_IRQn interrupt configuration */
// 1200   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
        MOVS     R2,#+0
        MOV      R1,R2
        MOV      R0,#-1
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
// 1201 }
        ADD      SP,SP,#+84
          CFI CFA R13+4
        POP      {PC}             ;; return
          CFI EndBlock cfiBlock5
// 1202 
// 1203 /** NVIC Configuration
// 1204 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function _Z12MX_NVIC_Initv
        THUMB
// 1205 static void MX_NVIC_Init(void)
// 1206 {
_Z12MX_NVIC_Initv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1207   /* TIM2_IRQn interrupt configuration */
// 1208   HAL_NVIC_SetPriority(TIM2_IRQn, 2, 0);
        MOVS     R2,#+0
        MOVS     R1,#+2
        MOVS     R0,#+28
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
// 1209   HAL_NVIC_EnableIRQ(TIM2_IRQn);
        MOVS     R0,#+28
          CFI FunCall HAL_NVIC_EnableIRQ
        BL       HAL_NVIC_EnableIRQ
// 1210   /* TIM3_IRQn interrupt configuration */
// 1211   HAL_NVIC_SetPriority(TIM3_IRQn, 2, 0);
        MOVS     R2,#+0
        MOVS     R1,#+2
        MOVS     R0,#+29
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
// 1212   HAL_NVIC_EnableIRQ(TIM3_IRQn);
        MOVS     R0,#+29
          CFI FunCall HAL_NVIC_EnableIRQ
        BL       HAL_NVIC_EnableIRQ
// 1213   /* TIM4_IRQn interrupt configuration */
// 1214   HAL_NVIC_SetPriority(TIM4_IRQn, 2, 0);
        MOVS     R2,#+0
        MOVS     R1,#+2
        MOVS     R0,#+30
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
// 1215   HAL_NVIC_EnableIRQ(TIM4_IRQn);
        MOVS     R0,#+30
          CFI FunCall HAL_NVIC_EnableIRQ
        BL       HAL_NVIC_EnableIRQ
// 1216   /* TIM5_IRQn interrupt configuration */
// 1217   HAL_NVIC_SetPriority(TIM5_IRQn, 2, 0);
        MOVS     R2,#+0
        MOVS     R1,#+2
        MOVS     R0,#+50
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
// 1218   HAL_NVIC_EnableIRQ(TIM5_IRQn);
        MOVS     R0,#+50
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_NVIC_EnableIRQ
        B.W      HAL_NVIC_EnableIRQ
          CFI EndBlock cfiBlock6
// 1219 }
// 1220 /* USER CODE BEGIN 4 */
// 1221 
// 1222 /* USER CODE END 4 */
// 1223 
// 1224 /**
// 1225   * @brief  This function is executed in case of error occurrence.
// 1226   * @param  None
// 1227   * @retval None
// 1228   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function Error_Handler
          CFI NoCalls
        THUMB
// 1229 void Error_Handler(void)
// 1230 {
// 1231   /* USER CODE BEGIN Error_Handler */
// 1232   /* User can add his own implementation to report the HAL error return state */
// 1233   while(1) 
Error_Handler:
??Error_Handler_0:
        B.N      ??Error_Handler_0
          CFI EndBlock cfiBlock7
// 1234   {
// 1235   }
// 1236   /* USER CODE END Error_Handler */ 
// 1237 }
// 1238 
// 1239 #ifdef USE_FULL_ASSERT
// 1240 
// 1241 /**
// 1242    * @brief Reports the name of the source file and the source line number
// 1243    * where the assert_param error has occurred.
// 1244    * @param file: pointer to the source file name
// 1245    * @param line: assert_param error line source number
// 1246    * @retval None
// 1247    */
// 1248 void assert_failed(uint8_t* file, uint32_t line)
// 1249 {
// 1250   /* USER CODE BEGIN 6 */
// 1251   /* User can add his own implementation to report the file name and line number,
// 1252     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
// 1253   /* USER CODE END 6 */
// 1254 
// 1255 }
// 1256 
// 1257 #endif
// 1258 
// 1259 /**
// 1260   * @}
// 1261   */ 
// 1262 
// 1263 /**
// 1264   * @}
// 1265 */ 
// 1266 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function _Z20testAllStepAndMosFETv
          CFI NoCalls
        THUMB
// 1267 void testAllStepAndMosFET()
// 1268 {
_Z20testAllStepAndMosFETv:
        PUSH     {R3-R7}
          CFI R7 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+20
// 1269 
// 1270   XENA_OP = 0;YENA_OP = 0;ZENA_OP = 0;E0ENA_OP = 0;
        LDR.N    R0,??DataTable15_34  ;; 0x42230180
        MOVS     R1,#+0
        STR      R1,[R0, #+16]
        STR      R1,[R0, #+4]
        LDR.N    R1,??DataTable15_35  ;; 0x42218184
        MOVS     R2,#+0
        STR      R2,[R1, #+28]
        STR      R2,[R1, #+8]
// 1271 
// 1272 
// 1273   uint32_t testCnt=0;
// 1274   volatile uint32_t delayCnt=0;
        MOV      R3,R2
        STR      R3,[SP, #+0]
        MOVW     R5,#+2501
        LDR.N    R7,??DataTable15_36  ;; 0x42210180
// 1275   
// 1276   while(1)
// 1277   {
// 1278     testCnt++;
??testAllStepAndMosFET_0:
        ADDS     R2,R2,#+1
// 1279     if(testCnt % 5000 > 2500)
        MOVW     R3,#+5000
        UDIV     R3,R2,R3
        MOVW     R4,#+5000
        MLS      R4,R4,R3,R2
        LDR.N    R3,??DataTable15_37  ;; 0x4222818c
        CMP      R4,R5
        BCC.N    ??testAllStepAndMosFET_1
// 1280       {XDIR_OP = 0;YDIR_OP = 0;ZDIR_OP = 0;E0DIR_OP = 0;}
        MOVS     R6,#+0
        STR      R6,[R0, #+8]
        STR      R6,[R1, #+32]
        STR      R6,[R1, #+12]
        STR      R6,[R3, #+0]
        B.N      ??testAllStepAndMosFET_2
// 1281     else
// 1282     	{XDIR_OP = 1;YDIR_OP = 1;ZDIR_OP = 1;E0DIR_OP = 1;}
??testAllStepAndMosFET_1:
        MOVS     R6,#+1
        STR      R6,[R0, #+8]
        STR      R6,[R1, #+32]
        STR      R6,[R1, #+12]
        STR      R6,[R3, #+0]
// 1283     
// 1284     if(testCnt % 5000 > 2500)   //MOS
??testAllStepAndMosFET_2:
        LDR.N    R6,??DataTable15_38  ;; 0x4222018c
        CMP      R4,R5
        BCC.N    ??testAllStepAndMosFET_3
// 1285       {BED_OP=1;HEATER1_OP=1;FAN_OP=1;}
        MOVS     R4,#+1
        STR      R4,[R7, #+0]
        STR      R4,[R6, #+0]
        STR      R4,[R1, #+0]
        B.N      ??testAllStepAndMosFET_4
// 1286     else
// 1287       {BED_OP=0;HEATER1_OP=0;FAN_OP=0;}
??testAllStepAndMosFET_3:
        MOVS     R4,#+0
        STR      R4,[R7, #+0]
        STR      R4,[R6, #+0]
        STR      R4,[R1, #+0]
// 1288 	
// 1289     XSTEP_OP =0;YSTEP_OP =0;ZSTEP_OP =0;E0STEP_OP =0;
??testAllStepAndMosFET_4:
        MOVS     R4,#+0
        STR      R4,[R0, #+12]
        STR      R4,[R0, #+0]
        STR      R4,[R1, #+16]
        STR      R4,[R3, #+12]
// 1290     delayCnt = 0; while(delayCnt < 2000) delayCnt++;
        STR      R4,[SP, #+0]
        B.N      ??testAllStepAndMosFET_5
??testAllStepAndMosFET_6:
        LDR      R4,[SP, #+0]
        ADDS     R4,R4,#+1
        STR      R4,[SP, #+0]
??testAllStepAndMosFET_5:
        LDR      R4,[SP, #+0]
        CMP      R4,#+2000
        BCC.N    ??testAllStepAndMosFET_6
// 1291     XSTEP_OP =1;YSTEP_OP =1;ZSTEP_OP =1;E0STEP_OP =1;
        MOVS     R4,#+1
        STR      R4,[R0, #+12]
        STR      R4,[R0, #+0]
        STR      R4,[R1, #+16]
        STR      R4,[R3, #+12]
// 1292     delayCnt = 0; while(delayCnt < 2000) delayCnt++;
        MOVS     R3,#+0
        STR      R3,[SP, #+0]
??testAllStepAndMosFET_7:
        LDR      R3,[SP, #+0]
        CMP      R3,#+2000
        BCS.N    ??testAllStepAndMosFET_0
        LDR      R3,[SP, #+0]
        ADDS     R3,R3,#+1
        STR      R3,[SP, #+0]
        B.N      ??testAllStepAndMosFET_7
          CFI EndBlock cfiBlock8
// 1293   }
// 1294   
// 1295   
// 1296 }
// 1297 
// 1298 #if 1
// 1299 #define FLASH_PAGE_SIZE    ((u16)0x400) //一页的大小为1K
// 1300 #define USER_FLASH_START   ((u32)0x08000000)//写入的起始地址		//bootloader占用48K
// 1301 #define USER_FLASH_END     ((uint32_t)0x08006FFF )//写入的结束地址
// 1302 #define USER_FLASH_SIZE  ((USER_FLASH_END - USER_FLASH_START) + 1)
// 1303 
// 1304 uint8_t barString[20]="0%\0";
// 1305 uint16_t progressBar=0;		
// 1306 uint16_t percentBar = 0;
// 1307 unsigned int progCnt = 0; 
// 1308 uint8_t bufCmp = 0;
// 1309 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// 1310 uint32_t EraseCounter = 0x00, Address = 0x00;//擦除计数，擦除地址
EraseCounter:
        DS8 4
// 1311 uint32_t Data = 0x3210ABCD;

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// 1312 uint32_t NbrOfPage = 0x00;
NbrOfPage:
        DS8 4
// 1313 
// 1314 //BYTE buffer_st[FLASH_PAGE_SIZE]; 
// 1315 #define BUFSIZE2 1024//FLASH_PAGE_SIZE
// 1316 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function _Z9BufferSetPhht
          CFI NoCalls
        THUMB
// 1317 void BufferSet(u8* pBuffer, u8 data, u16 BufferLength)
// 1318 {
// 1319   u16 i;
// 1320   for(i = 0; i<BufferLength; i++)
_Z9BufferSetPhht:
        MOVS     R3,#+0
        B.N      ??BufferSet_0
// 1321   {
// 1322     pBuffer[i] = data;
??BufferSet_1:
        STRB     R1,[R3, R0]
// 1323   }
        ADDS     R3,R3,#+1
??BufferSet_0:
        UXTH     R3,R3
        CMP      R3,R2
        BCC.N    ??BufferSet_1
// 1324 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock9
// 1325 #if 0
// 1326 void mksFlashErase(void)
// 1327 {
// 1328 /*-----------------FLASH--------------------*/
// 1329 	HAL_FLASH_Unlock();//FLASH_Unlock();
// 1330 #if 0        
// 1331 	NbrOfPage = (USER_FLASH_END - USER_FLASH_START + 1) / FLASH_PAGE_SIZE;
// 1332 	//FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR); //清除标志位
// 1333         
// 1334 	for(EraseCounter = 0; (EraseCounter < NbrOfPage) && (FLASHStatus == FLASH_COMPLETE); EraseCounter++)	
// 1335 	{
// 1336 		FLASHStatus = FLASH_ErasePage(USER_FLASH_START + (FLASH_PAGE_SIZE * EraseCounter));
// 1337 	}
// 1338 #endif
// 1339   //擦除bootloader 之后的所有扇区
// 1340     //GUI_Exec();
// 1341     //GUI_SetFont(&FONT_TITLE);
// 1342     //GUI_SetBkColor(GUI_BLACK);
// 1343     //GUI_SetBkColor(gCfgItems.background_color);
// 1344 	//GUI_SetColor(gCfgItems.title_color);
// 1345 //GUI_Clear();
// 1346     //GUI_SetColor(GUI_GREEN);
// 1347     GUI_Clear();GUI_DispStringAt("Erase Sector 0",160,140);
// 1348     FLASH_Erase_Sector(FLASH_SECTOR_0,FLASH_VOLTAGE_RANGE_3);
// 1349     GUI_Clear();GUI_DispStringAt("Erase Sector 1",160,140);
// 1350     FLASH_Erase_Sector(FLASH_SECTOR_1,FLASH_VOLTAGE_RANGE_3);
// 1351     GUI_Clear(); GUI_DispStringAt("Erase Sector 2",160,140);
// 1352     FLASH_Erase_Sector(FLASH_SECTOR_2,FLASH_VOLTAGE_RANGE_3);
// 1353     //GUI_Clear(); GUI_DispStringAt("Erase Sector 3",160,140);
// 1354     //FLASH_Erase_Sector(FLASH_SECTOR_3,FLASH_VOLTAGE_RANGE_3);
// 1355     /*LCD_Clear(BLACK); LCD_ShowString(160,140,200,24,24,"Erase Sector 5");
// 1356     FLASH_Erase_Sector(FLASH_SECTOR_5,FLASH_VOLTAGE_RANGE_3);
// 1357     LCD_Clear(BLACK); LCD_ShowString(160,140,200,24,24,"Erase Sector 6");
// 1358     FLASH_Erase_Sector(FLASH_SECTOR_6,FLASH_VOLTAGE_RANGE_3);
// 1359     LCD_Clear(BLACK); LCD_ShowString(160,140,200,24,24,"Erase Sector 7");
// 1360     FLASH_Erase_Sector(FLASH_SECTOR_7,FLASH_VOLTAGE_RANGE_3);*/
// 1361     GUI_Clear();GUI_DispStringAt("Erase Finish!",160,140);
// 1362     HAL_Delay(500);
// 1363 /*-----------------FLASH--------------------*/
// 1364 	
// 1365 }
// 1366 #endif
// 1367 //unsigned long tms=0;
// 1368 //unsigned char first_time = 1;
// 1369 #define NO_ENCRYPTION_SIZE 320 //
// 1370 #define	ENCRYPTION_SIZE (30*1024)
// 1371 BYTE buffer[1024]; 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// 1372 FIL fsrc, fdst;      // file objects
fsrc:
        DS8 556

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
fdst:
        DS8 556
// 1373 FRESULT res;         // FatFs function common result code

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// 1374 UINT br, bw;         // File R/W count
bw:
        DS8 4

        SECTION `.data`:DATA:REORDER:NOROOT(2)
barString:
        DATA
        DC8 30H, 25H, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
bufCmp:
        DC8 0
res:
        DC8 0
progressBar:
        DC16 0
percentBar:
        DC16 0
        DC8 0, 0
buffer:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
progCnt:
        DC32 0
Address:
        DC32 0
br:
        DC8 0, 0, 0, 0
// 1375 uint32_t fileSize = 0;
// 1376 uint32_t msp = 0;
msp:
        DC32 0
// 1377 uint32_t reset = 0;
reset:
        DC32 0
// 1378 uint16_t *hlfP = (uint16_t *)buffer;
hlfP:
        DC32 buffer

        SECTION `.data`:DATA:REORDER:NOROOT(2)
`Data`:
        DATA
        DC32 839953357
// 1379 //解码秘钥：a3bdad0d4111bb8ddc802dd0d2c49b1e26ebe3334a15e40ab3b13c93bbaff73e
// 1380 uint8_t key[32] = {0xa3,0xbd,0xad,0x0d,0x41,0x11,0xbb,0x8d,0xdc,0x80,
// 1381 													0x2d,0xd0,0xd2,0xc4,0x9b,0x1e,0x26,0xeb,0xe3,0x33,
// 1382 													0x4a,0x15,0xe4,0x0a,0xb3,0xb1,0x3c,0x93,0xbb,0xaf,0xf7,0x3e};

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// 1383 unsigned long tms=0;
tms:
        DS8 4
// 1384 unsigned char first_time = 1;

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function _Z10mksProgramv
        THUMB
// 1385 void mksProgram(void)
// 1386 {
_Z10mksProgramv:
        PUSH     {R2-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+32
// 1387 		unsigned int i;
// 1388 		unsigned long k=0;
// 1389 		unsigned long j=0;
// 1390 		volatile long filesize= 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
// 1391 		volatile long filesize_end= 0;
        STR      R0,[SP, #+0]
// 1392 		//FLASH_Unlock();
// 1393 		//FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
// 1394 		//mksFlashErase();
// 1395 
// 1396 		/*LCD_Clear(BLACK);
// 1397 		LCD_ShowString(180,100,200,24,24,"Updating");	
// 1398 		LCD_ShowString(200,160,200,24,24,barString);	*/
// 1399 		GUI_Clear();
          CFI FunCall GUI_Clear
        BL       GUI_Clear
// 1400 		GUI_DispStringAt("Updating",180,100);
        MOVS     R2,#+100
        MOVS     R1,#+180
        ADR.W    R0,`?<Constant "Updating">`
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1401 		GUI_DispStringAt((const char*)barString,200,160);
        LDR.N    R4,??DataTable15_39
        MOVS     R2,#+160
        MOVS     R1,#+200
        MOV      R0,R4
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1402                 
// 1403 		Address = USER_FLASH_START;
        MOV      R0,#+134217728
        STR      R0,[R4, #+1056]
// 1404 		progCnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+1052]
// 1405 		bufCmp = 0;
        STRB     R0,[R4, #+20]
// 1406 		filesize = fsrc.fsize;
        LDR.N    R5,??DataTable15_40
        LDR      R0,[R5, #+524]
        STR      R0,[SP, #+4]
        LDR.N    R6,??DataTable15_41
// 1407 		while(1)
// 1408 		{
// 1409 			BufferSet(buffer, 0xff, BUFSIZE2);
??mksProgram_0:
        MOV      R2,#+1024
        MOVS     R1,#+255
        ADD      R0,R4,#+28
          CFI FunCall _Z9BufferSetPhht
        BL       _Z9BufferSetPhht
// 1410 			res = f_read(&fsrc, buffer, BUFSIZE2, &br);
        ADDW     R3,R4,#+1060
        MOV      R2,#+1024
        ADD      R1,R4,#+28
        MOV      R0,R5
          CFI FunCall f_read
        BL       f_read
        STRB     R0,[R4, #+21]
// 1411 		#if 0	
// 1412 		/*****************解密过程*************************/
// 1413 		if(tms < (ENCRYPTION_SIZE)/32)
// 1414 		{
// 1415 			if(first_time==1)
// 1416 			{
// 1417 				k=0;
// 1418 				for(j=0;j<(1024-NO_ENCRYPTION_SIZE)/32;j++)
// 1419 				{
// 1420 					for(i=0;i<32;i++)
// 1421 					{
// 1422 						buffer[320+k] = buffer[320+k]^key[i]; 
// 1423 						k++;
// 1424 					}
// 1425 					tms++;
// 1426 				}
// 1427 				first_time = 0;
// 1428 			}
// 1429 			else
// 1430 			{
// 1431 					k=0;
// 1432 					for(j=0;j<1024/32;j++)
// 1433 					{
// 1434 						for(i=0;i<32;i++)
// 1435 						{
// 1436 							buffer[k] = buffer[k]^key[i];
// 1437 							k++;
// 1438 						}
// 1439 						tms++;
// 1440 						if(tms >= (ENCRYPTION_SIZE)/32)
// 1441 						{
// 1442 							
// 1443 							break;
// 1444 						}
// 1445 					}				
// 1446 				}
// 1447 			}
// 1448 		/*******************************************************/
// 1449 		#else
// 1450 		/*
// 1451 			if(tms < (ENCRYPTION_SIZE)/32)
// 1452 			{
// 1453 				if(first_time==1)
// 1454 				{
// 1455 					first_time=0;
// 1456 				}
// 1457 				else
// 1458 				{
// 1459 					k=0;
// 1460 					for(j=0;j<(1024)/32;j++)
// 1461 					{
// 1462 						for(i=0;i<32;i++)
// 1463 						{
// 1464 							buffer[k] = buffer[k]^key[i]; 
// 1465 							k++;
// 1466 						}
// 1467 						tms++;
// 1468 					}
// 1469 				}
// 1470 			}
// 1471 			*/
// 1472 		#endif
// 1473 		#if 0
// 1474 			if(bufBak == buffer[0])	bufCmp++;
// 1475 			else	bufCmp=0;
// 1476 			
// 1477 			if(bufCmp > 5)	break;
// 1478 				
// 1479 			bufBak = buffer[0];
// 1480 			
// 1481 		#endif
// 1482 			if(msp == 0 && reset == 0)
        LDR      R0,[R4, #+1064]
        LDR      R1,[R4, #+1068]
        ORRS     R0,R1,R0
        BNE.N    ??mksProgram_1
// 1483 			{
// 1484 					msp = *((uint32_t *)(buffer));
        LDR      R0,[R4, #+28]
        STR      R0,[R4, #+1064]
// 1485 					reset = *((uint32_t *)(buffer+4));
        LDR      R0,[R4, #+32]
        STR      R0,[R4, #+1068]
// 1486 			}
// 1487 			
// 1488 			//bufP=(uint32_t *)buffer;
// 1489 			hlfP = (uint16_t *)buffer;
??mksProgram_1:
        ADD      R0,R4,#+28
        STR      R0,[R4, #+1072]
// 1490 			
// 1491 			STMFLASH_Write(Address,hlfP,BUFSIZE2/2);
        MOV      R2,#+512
        ADD      R1,R4,#+28
        LDR      R0,[R4, #+1056]
          CFI FunCall STMFLASH_Write
        BL       STMFLASH_Write
// 1492 			Address += BUFSIZE2;
        LDR      R0,[R4, #+1056]
        ADD      R0,R0,#+1024
        STR      R0,[R4, #+1056]
// 1493 			
// 1494 			progCnt++;
        LDR      R0,[R4, #+1052]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+1052]
// 1495 			progressBar = percentBar;
        LDRH     R1,[R4, #+24]
        STRH     R1,[R4, #+22]
// 1496 			percentBar = (uint16_t )(4.8 * ((float )(progCnt*BUFSIZE2)*100/(float )fileSize));
        LDR.N    R7,??DataTable15_42  ;; 0x42c80000
        LSLS     R0,R0,#+10
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,#+858993459
        LDR.N    R3,??DataTable15_43  ;; 0x40133333
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R2,R0
        STRH     R2,[R4, #+24]
// 1497 			if(percentBar < 480 )
        UXTH     R2,R2
        CMP      R2,#+480
        BGE.N    ??mksProgram_2
// 1498 			{
// 1499 				//for(i=progressBar;i<percentBar;i++)
// 1500 					//LCD_DrawFullRect(110,i,20,1);			//320
// 1501 					//LCD_Fill(20,i,110,1,GREEN);
// 1502 					//void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color);
// 1503 					//LCD_Fill2(0,130,percentBar,155,GUI_GREEN);
// 1504 					GUI_FillRect(0,130,percentBar,155);
        MOVS     R3,#+155
        MOVS     R1,#+130
        MOVS     R0,#+0
          CFI FunCall GUI_FillRect
        BL       GUI_FillRect
// 1505 			}
// 1506 			
// 1507 			percentBar= (uint16_t )(((float )(progCnt*BUFSIZE2)*100/(float )fileSize));
??mksProgram_2:
        LDR      R0,[R4, #+1052]
        LSLS     R0,R0,#+10
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRH     R0,[R4, #+24]
// 1508 			if(percentBar > 99)	percentBar=99;
        UXTH     R0,R0
        CMP      R0,#+100
        BLT.N    ??mksProgram_3
        MOVS     R0,#+99
        STRH     R0,[R4, #+24]
??mksProgram_3:
        LDRH     R0,[R4, #+24]
        MOVS     R1,#+10
        SDIV     R1,R0,R1
        MOVS     R2,#+10
        CMP      R0,#+10
        BGE.N    ??mksProgram_4
// 1509 			
// 1510 			if(percentBar < 10)
// 1511 			{
// 1512 				barString[0] = percentBar%10 + 0x30;
        MLS      R0,R2,R1,R0
        ADDS     R0,R0,#+48
        STRB     R0,[R4, #+0]
// 1513 				barString[1] = '%';
        MOVS     R0,#+37
        STRB     R0,[R4, #+1]
// 1514 				barString[2] = '\0';
        MOVS     R0,#+0
        STRB     R0,[R4, #+2]
        B.N      ??mksProgram_5
// 1515 			}
// 1516 			else
// 1517 			{
// 1518 				barString[0] = percentBar/10 + 0x30;
??mksProgram_4:
        ADD      R3,R1,#+48
        STRB     R3,[R4, #+0]
// 1519 				barString[1] = percentBar%10 + 0x30;
        MLS      R0,R2,R1,R0
        ADDS     R0,R0,#+48
        STRB     R0,[R4, #+1]
// 1520 				barString[2] = '%';
        MOVS     R0,#+37
        STRB     R0,[R4, #+2]
// 1521 				barString[3] = '\0';
        MOVS     R0,#+0
        STRB     R0,[R4, #+3]
// 1522 			}
// 1523 			//LCD_DisplayString(140,130,barString);
// 1524 			//LCD_ShowString(200,160,200,24,24,barString);
// 1525 			GUI_DispStringAt((const char*)barString,200,160);
??mksProgram_5:
        MOVS     R2,#+160
        MOVS     R1,#+200
        MOV      R0,R4
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1526 			//LCD_DrawFullRect(110,20,20,50);
// 1527 //for(i=0;i<32;i++)				LCD_DrawFullRect(110,i*10,20,10);			//32
// 1528 //for(i=0;i<64;i++)				LCD_DrawFullRect(110,i*5,20,5);			//64
// 1529 //for(i=0;i<160;i++)				LCD_DrawFullRect(110,i*2,20,2);			//160
// 1530 
// 1531 			filesize_end += br;			
        LDR      R0,[R4, #+1060]
        LDR      R1,[SP, #+0]
        ADDS     R1,R0,R1
        STR      R1,[SP, #+0]
// 1532 			if(br < BUFSIZE2)	break;	//文件结束
        CMP      R0,#+1024
        BCS.W    ??mksProgram_0
// 1533 		}
// 1534 		
// 1535 		//if(bufCmp > 5)
// 1536 		if(filesize_end < filesize)
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+4]
        CMP      R0,R1
        BGE.N    ??mksProgram_6
// 1537 		{
// 1538 			//LCD_DisplayString(80,100,"SD ERR");
// 1539 			//LCD_ShowString(120,80,200,24,24,"Update");
// 1540 			//LCD_ShowString(180,100,200,24,24,"SD ERR");
// 1541 			GUI_DispStringAt("SD ERR",180,100);
        MOVS     R2,#+100
        MOVS     R1,#+180
        ADR.W    R0,`?<Constant "SD ERR">`
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1542 			while(1);
??mksProgram_7:
        B.N      ??mksProgram_7
// 1543 		}
// 1544 		//LCD_DisplayString(140,130,"100%");
// 1545 		//LCD_ShowString(200,160,200,24,24,"100%");
// 1546 		GUI_DispStringAt("100%",200,160);
??mksProgram_6:
        MOVS     R2,#+160
        MOVS     R1,#+200
        ADR.W    R0,`?<Constant "100%">`
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1547 		//RESET_E2PROM();//清除E2PROM数据。
// 1548 		//delay(0xfffff);
// 1549                 HAL_Delay(1000);
        MOV      R0,#+1000
        POP      {R1,R2,R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_Delay
        B.W      HAL_Delay
          CFI EndBlock cfiBlock10
// 1550 		//FLASH_Lock();
// 1551 }

        SECTION `.data`:DATA:REORDER:NOROOT(2)
fileSize:
        DATA
        DC32 0
// 1552 const char *firmware_file = "Robin_nano_boot.bin";
firmware_file:
        DC32 `?<Constant "Robin_nano_boot.bin">`
// 1553 const char *firmware_old  = "ROBIN_NANO_BOOT.CUR";
firmware_old:
        DC32 `?<Constant "ROBIN_NANO_BOOT.CUR">`

        SECTION `.data`:DATA:REORDER:NOROOT(2)
key:
        DATA
        DC8 163, 189, 173, 13, 65, 17, 187, 141, 220, 128, 45, 208, 210, 196
        DC8 155, 30, 38, 235, 227, 51, 74, 21, 228, 10, 179, 177, 60, 147, 187
        DC8 175, 247, 62

        SECTION `.data`:DATA:REORDER:NOROOT(0)
first_time:
        DATA
        DC8 1
// 1554 extern FATFS fs;            // Work area (file system object) for logical drive
// 1555 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function _Z17check_sd_firmwarev
        THUMB
// 1556 void check_sd_firmware(void)
// 1557 {
_Z17check_sd_firmwarev:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+72
          CFI CFA R13+88
// 1558 	int r;
// 1559 	char oldname[30]={0};
        ADD      R0,SP,#+36
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 1560 	char newname[30]={0};
        ADD      R0,SP,#+4
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 1561 
// 1562 	volatile unsigned long cnt=0;
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
// 1563 	unsigned long counter = 0,counter2 = 0;
// 1564 	
// 1565 //	printf("Check SD\n");
// 1566 	//f_mount(0, &fs);	
// 1567 	strcat(oldname,SD_Path);
        LDR.N    R4,??DataTable15_44
        MOV      R1,R4
        ADD      R0,SP,#+36
          CFI FunCall strcat
        BL       strcat
// 1568 	strcat(oldname,firmware_file);
        LDR.N    R5,??DataTable15_41
        LDR      R1,[R5, #+4]
          CFI FunCall strcat
        BL       strcat
// 1569 	//f_mount(&fs,(TCHAR const*)SD_Path, 0);	
// 1570 	if ((r = f_open(&fsrc, oldname, FA_READ|FA_WRITE)) == FR_OK)
        LDR.N    R6,??DataTable15_40
        MOVS     R2,#+3
        ADD      R1,SP,#+36
        MOV      R0,R6
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.N    ??check_sd_firmware_0
// 1571 	{
// 1572 		fileSize = fsrc.fsize;
        LDR      R0,[R6, #+524]
        STR      R0,[R5, #+0]
// 1573 		
// 1574 		mksProgram();
          CFI FunCall _Z10mksProgramv
        BL       _Z10mksProgramv
// 1575 		f_close(&fsrc);
        MOV      R0,R6
          CFI FunCall f_close
        BL       f_close
// 1576 		//if(SDPROTECT == SD_UNLOCK)	//写保护
// 1577 		{
// 1578 			strcat(newname,SD_Path);
        MOV      R1,R4
        ADD      R0,SP,#+4
          CFI FunCall strcat
        BL       strcat
// 1579 			strcat(newname,firmware_old);
        LDR      R1,[R5, #+8]
          CFI FunCall strcat
        BL       strcat
// 1580 			r = f_unlink(newname);
        ADD      R0,SP,#+4
          CFI FunCall f_unlink
        BL       f_unlink
// 1581 			r = f_rename(oldname, newname);
        ADD      R1,SP,#+4
        ADD      R0,SP,#+36
          CFI FunCall f_rename
        BL       f_rename
// 1582 		}
// 1583 		//BootLoaderJump(USER_FLASH_START,msp,reset);
// 1584 			
// 1585 	}
// 1586 	else
// 1587 	{
// 1588 		//msp = *((uint32_t *)(USER_FLASH_START));
// 1589 		//reset = *((uint32_t *)(USER_FLASH_START+4));
// 1590 		//BootLoaderJump(USER_FLASH_START,msp,reset);
// 1591 	}
// 1592 }
??check_sd_firmware_0:
        ADD      SP,SP,#+72
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock11

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_1:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_2:
        DC32     0x40003800

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_3:
        DC32     0x422281b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_4:
        DC32     logo_tick1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_5:
        DC32     htim3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_6:
        DC32     htim1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_7:
        DC32     0x40012c34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_8:
        DC32     0x40000440

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_9:
        DC32     htim2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_10:
        DC32     htim4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_11:
        DC32     uhADCxConvertedValue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_12:
        DC32     hadc1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_13:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_14:
        DC32     mksTmp

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_15:
        DC32     0x42228130

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_16:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_17:
        DC32     GUI_FontHZ_fontHz14

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_18:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_19:
        DC32     0x404e0000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_20:
        DC32     0x422381a8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_21:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_22:
        DC32     pause_from_high_level

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_23:
        DC32     0x42210108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_24:
        DC32     0x42220194

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_25:
        DC32     0x42230118

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_26:
        DC32     disp_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_27:
        DC32     common_menu

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_28:
        DC32     0x42218188

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_29:
        DC32     mksReprint

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_30:
        DC32     print_job_timer

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_31:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_32:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_33:
        DC32     default_preview_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_34:
        DC32     0x42230180

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_35:
        DC32     0x42218184

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_36:
        DC32     0x42210180

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_37:
        DC32     0x4222818c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_38:
        DC32     0x4222018c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_39:
        DC32     barString

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_40:
        DC32     fsrc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_41:
        DC32     fileSize

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_42:
        DC32     0x42c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_43:
        DC32     0x40133333

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_44:
        DC32     SD_Path

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "mksRobinNano start\\n">`:
        DC8 "mksRobinNano start\012"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "EPR_END_ADDR:">`:
        DC8 "EPR_END_ADDR:"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Updating">`:
        DC8 "Updating"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "SD ERR">`:
        DC8 "SD ERR"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "100%">`:
        DC8 "100%"
        DC8 0, 0, 0

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        SECTION_GROUP _ZTI5Print
// __absolute char const <Typeinfo for Print>
_ZTI5Print:
        DATA
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Robin_nano_boot.bin">`:
        DC8 "Robin_nano_boot.bin"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "ROBIN_NANO_BOOT.CUR">`:
        DC8 "ROBIN_NANO_BOOT.CUR"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_1`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        END
// 1593 #endif
// 1594 
// 1595 
// 1596 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// 
// 1 201 bytes in section .bss
// 1 125 bytes in section .data
//   105 bytes in section .rodata
// 3 056 bytes in section .text
// 
// 3 028 bytes of CODE  memory (+ 28 bytes shared)
//   104 bytes of CONST memory (+  1 byte  shared)
// 2 326 bytes of DATA  memory
//
//Errors: none
//Warnings: 121
