###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  16:59:45
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUI_FillPolygon.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUI_FillPolygon.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\GUI_FillPolygon.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\GUI_FillPolygon.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUI_FillPolygon.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUI_FillPolygon.C
     16          Purpose     : Fill polygon routine
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include "GUI_Protected.h"
     22          #include "GUIDebug.h"
     23          
     24          /*********************************************************************
     25          *
     26          *       defines, Configs
     27          *
     28          **********************************************************************
     29          */
     30          
     31          #define GUI_FP_MAXCOUNT 12
     32          
     33          /*********************************************************************
     34          *
     35          *       static data
     36          *
     37          **********************************************************************
     38          */
     39          

   \                                 In section .bss, align 4
     40          static int GL_FP_Cnt;
     41          static I16 _aX[GUI_FP_MAXCOUNT];
   \                     _aX:
   \   00000000                      DS8 24
   \   00000018                      DS8 4
     42          
     43          /*********************************************************************
     44          *
     45          *       static code
     46          *
     47          **********************************************************************
     48          */
     49          /*********************************************************************
     50          *
     51          *       _DrawHLine
     52          */

   \                                 In section .text, align 2, keep-with-next
     53          static void _DrawHLine(int x0, int y, int x1) {
   \                     _DrawHLine: (+1)
   \   00000000   0x4613             MOV      R3,R2
     54            if (x0 < x1) {
   \   00000002   0x4298             CMP      R0,R3
   \   00000004   0xDA01             BGE.N    ??_DrawHLine_0
     55              LCD_HL_DrawHLine(x0, y, x1);
   \   00000006   0x.... 0x....      B.W      LCD_DrawHLine
     56            } else {
     57              LCD_HL_DrawHLine(x1, y, x0);
   \                     ??_DrawHLine_0: (+1)
   \   0000000A   0x4602             MOV      R2,R0
   \   0000000C   0x4618             MOV      R0,R3
   \   0000000E   0x.... 0x....      B.W      LCD_DrawHLine
     58            }
     59          }
     60          
     61          /*********************************************************************
     62          *
     63          *       _CheckYInterSect
     64          *
     65          *  This function returns the x-coordinate of the intersection
     66          *  of the given line at the given y-coordinate.
     67          *  If there is no intersection, GUI_XMAX is returned.
     68          *  This routine does not work for horizontal lines, as there
     69          *  would be more than a single point as intersection. This situation
     70          *  needs to be checked prior to calling the routine.
     71          *  Returns:
     72          *    0 if no intersection
     73          *    1 if we have an intersection
     74          */

   \                                 In section .text, align 2, keep-with-next
     75          static int _CheckYInterSect(int y, int* px, const GUI_POINT*paPoint0, const GUI_POINT*paPoint1) {
   \                     _CheckYInterSect: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     76            int x0, y0, x1, y1;
     77            if (paPoint0->y <= (paPoint1)->y) {
   \   00000002   0xF9B2 0x5002      LDRSH    R5,[R2, #+2]
   \   00000006   0xF9B3 0x4002      LDRSH    R4,[R3, #+2]
   \   0000000A   0x42AC             CMP      R4,R5
   \   0000000C   0xDB0A             BLT.N    ??_CheckYInterSect_0
     78              y0 = paPoint0->y;
   \   0000000E   0x462E             MOV      R6,R5
     79              if (y0 > y)      /* Check if there is an intersection ... (early out) */
   \   00000010   0x42B0             CMP      R0,R6
   \   00000012   0xDB0C             BLT.N    ??_CheckYInterSect_1
     80                return 0;
     81              y1 = paPoint1->y;
   \   00000014   0x4625             MOV      R5,R4
     82              if (y1 < y)      /* Check if there is an intersection ... (early out) */
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xDB09             BLT.N    ??_CheckYInterSect_1
     83                return 0;
     84              x0 = paPoint0->x;
   \   0000001A   0xF9B2 0x4000      LDRSH    R4,[R2, #+0]
     85              x1 = paPoint1->x;
   \   0000001E   0xF9B3 0x2000      LDRSH    R2,[R3, #+0]
   \   00000022   0xE00A             B.N      ??_CheckYInterSect_2
     86            } else {
     87              y0 = paPoint1->y;
   \                     ??_CheckYInterSect_0: (+1)
   \   00000024   0x4626             MOV      R6,R4
     88              if (y0 > y)      /* Check if there is an intersection ... (early out) */
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xDB01             BLT.N    ??_CheckYInterSect_1
     89                return 0;
     90              y1 = paPoint0->y;
     91              if (y1 < y)      /* Check if there is an intersection ... (early out) */
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xDA01             BGE.N    ??_CheckYInterSect_3
     92                return 0;
   \                     ??_CheckYInterSect_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE014             B.N      ??_CheckYInterSect_4
     93              x0 = paPoint1->x;
   \                     ??_CheckYInterSect_3: (+1)
   \   00000032   0xF9B3 0x4000      LDRSH    R4,[R3, #+0]
     94              x1 = paPoint0->x;
   \   00000036   0xF9B2 0x2000      LDRSH    R2,[R2, #+0]
     95            }
     96          /* Calculate intersection */
     97            {
     98              I32 Mul = (I32)(x1 - x0) * (I32)(y - y0);
   \                     ??_CheckYInterSect_2: (+1)
   \   0000003A   0x1B12             SUBS     R2,R2,R4
   \   0000003C   0x1B80             SUBS     R0,R0,R6
   \   0000003E   0x4350             MULS     R0,R0,R2
     99              if (Mul > 0) {
   \   00000040   0x1BAA             SUBS     R2,R5,R6
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xDB02             BLT.N    ??_CheckYInterSect_5
    100                Mul += (y1 - y0) >> 1;	          /* for proper rounding */
   \   00000046   0xEB10 0x0062      ADDS     R0,R0,R2, ASR #+1
   \   0000004A   0xE002             B.N      ??_CheckYInterSect_6
    101              } else {
    102                Mul -= ((y1 - y0) >> 1) - 1;	    /* for proper rounding */
   \                     ??_CheckYInterSect_5: (+1)
   \   0000004C   0xEBB0 0x0062      SUBS     R0,R0,R2, ASR #+1
   \   00000050   0x1C40             ADDS     R0,R0,#+1
    103              }
    104              x0 += Mul / (y1 - y0);
    105            }
    106            *px = x0;
   \                     ??_CheckYInterSect_6: (+1)
   \   00000052   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \   00000056   0x1900             ADDS     R0,R0,R4
   \   00000058   0x6008             STR      R0,[R1, #+0]
    107            return 1;
   \   0000005A   0x2001             MOVS     R0,#+1
   \                     ??_CheckYInterSect_4: (+1)
   \   0000005C   0xBC70             POP      {R4-R6}
   \   0000005E   0x4770             BX       LR               ;; return
    108          } 
    109          
    110          /*********************************************************************
    111          *
    112          *       _Add
    113          *
    114          *  This function adds a point into the sorted array
    115          */

   \                                 In section .text, align 2, keep-with-next
    116          static void _Add(int x) {
    117            if (GL_FP_Cnt < GUI_FP_MAXCOUNT) {
   \                     _Add: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4
   \   00000002   0x698A             LDR      R2,[R1, #+24]
   \   00000004   0x2A0C             CMP      R2,#+12
   \   00000006   0xDB00             BLT.N    ??_Add_0
   \   00000008   0x4770             BX       LR
    118              int i;
    119              /* Move all entries to the right (bigger x-value) */
    120              for (i=GL_FP_Cnt; i ; i--) {
   \                     ??_Add_0: (+1)
   \   0000000A   0xB410             PUSH     {R4}
   \   0000000C   0x4613             MOV      R3,R2
   \   0000000E   0xE002             B.N      ??_Add_1
    121                if (_aX[i-1] < x)
    122                  break;
    123                _aX[i] = _aX[i-1];
   \                     ??_Add_2: (+1)
   \   00000010   0xF821 0x4013      STRH     R4,[R1, R3, LSL #+1]
   \   00000014   0x1E5B             SUBS     R3,R3,#+1
   \                     ??_Add_1: (+1)
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD005             BEQ.N    ??_Add_3
   \   0000001A   0xEB01 0x0443      ADD      R4,R1,R3, LSL #+1
   \   0000001E   0xF934 0x4C02      LDRSH    R4,[R4, #-2]
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xDAF4             BGE.N    ??_Add_2
    124              }
    125              /* Insert new entry */
    126              _aX[i]    = x;
   \                     ??_Add_3: (+1)
   \   00000026   0xF821 0x0013      STRH     R0,[R1, R3, LSL #+1]
    127              GL_FP_Cnt++;
   \   0000002A   0x1C50             ADDS     R0,R2,#+1
   \   0000002C   0x6188             STR      R0,[R1, #+24]
    128            }
    129          }
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    130          
    131          /*********************************************************************
    132          *
    133          *       _Init
    134          *
    135          *  This function initialise the sorted array
    136          */

   \                                 In section .text, align 2, keep-with-next
    137          static void _Init(void) {
    138            GL_FP_Cnt = 0;
   \                     _Init: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable4
   \   00000004   0x6188             STR      R0,[R1, #+24]
    139          }
   \   00000006   0x4770             BX       LR               ;; return
    140          
    141          /*********************************************************************
    142          *
    143          *       _Flush
    144          *
    145          *  This function draw lines between points in the array
    146          */

   \                                 In section .text, align 2, keep-with-next
    147          static void _Flush(int x0, int y) {
   \                     _Flush: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    148            int i, x = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    149            char On=0;
   \   0000000A   0x4606             MOV      R6,R0
    150            for (i=0; i<GL_FP_Cnt; i++) {
   \   0000000C   0x4607             MOV      R7,R0
   \   0000000E   0xE00F             B.N      ??_Flush_0
    151              int xNew = _aX[i];
   \                     ??_Flush_1: (+1)
   \   00000010   0xF931 0x8017      LDRSH    R8,[R1, R7, LSL #+1]
    152              if (On) {
   \   00000014   0x4631             MOV      R1,R6
   \   00000016   0xB249             SXTB     R1,R1
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD005             BEQ.N    ??_Flush_2
    153                LCD_HL_DrawHLine(x0 + x, y, x0 + xNew);
   \   0000001C   0xEB08 0x0204      ADD      R2,R8,R4
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x1900             ADDS     R0,R0,R4
   \   00000024   0x.... 0x....      BL       LCD_DrawHLine
    154              }
    155              On ^= 1;
   \                     ??_Flush_2: (+1)
   \   00000028   0xF086 0x0601      EOR      R6,R6,#0x1
    156              x = xNew;
   \   0000002C   0x4640             MOV      R0,R8
    157            }
   \   0000002E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??_Flush_0: (+1)
   \   00000030   0x....             LDR.N    R1,??DataTable4
   \   00000032   0x698A             LDR      R2,[R1, #+24]
   \   00000034   0x4297             CMP      R7,R2
   \   00000036   0xDBEB             BLT.N    ??_Flush_1
    158          }
   \   00000038   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    159          
    160          /*********************************************************************
    161          *
    162          *       _AddPoint
    163          *
    164          *  This function decides either if there a V-point or a
    165          *  X-point. An X-point is added to the array, a V-point
    166          *  is drawn.
    167          */

   \                                 In section .text, align 2, keep-with-next
    168          static void _AddPoint(int x, int y, int y0, int y1, int xOff, int yOff) {
   \                     _AddPoint: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
    169            if ((y0 ^ y1) >= 0) {
   \   00000002   0x405A             EORS     R2,R3,R2
   \   00000004   0xD407             BMI.N    ??_AddPoint_0
    170              x += xOff;
   \   00000006   0x9A02             LDR      R2,[SP, #+8]
   \   00000008   0x1810             ADDS     R0,R2,R0
    171              LCD_HL_DrawHLine(x, y + yOff, x);    /* V-point, not crossing the polygon */
   \   0000000A   0x4602             MOV      R2,R0
   \   0000000C   0x9B03             LDR      R3,[SP, #+12]
   \   0000000E   0x1859             ADDS     R1,R3,R1
   \   00000010   0xB002             ADD      SP,SP,#+8
   \   00000012   0x.... 0x....      B.W      LCD_DrawHLine
    172            } else {
    173              _Add(x);
   \                     ??_AddPoint_0: (+1)
   \   00000016   0xB002             ADD      SP,SP,#+8
   \   00000018   0x....             B.N      _Add
    174            }
    175          }
    176          
    177          /*********************************************************************
    178          *
    179          *       _GetPrevPointDiffy
    180          *
    181          *  Find previous point which is not on the same height
    182          */

   \                                 In section .text, align 2, keep-with-next
    183          static int _GetPrevPointDiffy(const GUI_POINT* paPoint, int i,
    184                                        const int NumPoints, const int y0) {
   \                     _GetPrevPointDiffy: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    185            int j, y1;
    186            for (j = 0; j < (NumPoints - 1) ; j++) {
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0xE000             B.N      ??_GetPrevPointDiffy_0
   \                     ??_GetPrevPointDiffy_1: (+1)
   \   00000006   0x1C6D             ADDS     R5,R5,#+1
   \                     ??_GetPrevPointDiffy_0: (+1)
   \   00000008   0x1E54             SUBS     R4,R2,#+1
   \   0000000A   0x42A5             CMP      R5,R4
   \   0000000C   0xDA0C             BGE.N    ??_GetPrevPointDiffy_2
    187              i = (i != 0) ? i - 1 : NumPoints - 1;
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD001             BEQ.N    ??_GetPrevPointDiffy_3
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0xE000             B.N      ??_GetPrevPointDiffy_4
   \                     ??_GetPrevPointDiffy_3: (+1)
   \   00000016   0x4621             MOV      R1,R4
    188              y1 = (paPoint + i)->y;
   \                     ??_GetPrevPointDiffy_4: (+1)
   \   00000018   0xEB00 0x0481      ADD      R4,R0,R1, LSL #+2
   \   0000001C   0xF9B4 0x4002      LDRSH    R4,[R4, #+2]
    189              if (y1 != y0) {
   \   00000020   0x429C             CMP      R4,R3
   \   00000022   0xD0F0             BEQ.N    ??_GetPrevPointDiffy_1
    190                return y1;
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xE000             B.N      ??_GetPrevPointDiffy_5
    191              }
    192            }
    193            return y0;
   \                     ??_GetPrevPointDiffy_2: (+1)
   \   00000028   0x4618             MOV      R0,R3
   \                     ??_GetPrevPointDiffy_5: (+1)
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
    194          }
    195          
    196          /*********************************************************************
    197          *
    198          *       Public code
    199          *
    200          **********************************************************************
    201          */
    202          /*********************************************************************
    203          *
    204          *       GL_FillPolygon
    205          *
    206          *  This function calculates the polygon
    207          */

   \                                 In section .text, align 2, keep-with-next
    208          void GL_FillPolygon  (const GUI_POINT*paPoint, int NumPoints, int xOff, int yOff) {
   \                     GL_FillPolygon: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    209            int i, y;
    210            int yMin = GUI_YMAX;
   \   0000000E   0xF640 0x78FF      MOVW     R8,#+4095
    211            int yMax = GUI_YMIN;
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable4_1  ;; 0xfffff001
    212          /* First step : find uppermost and lowermost coordinates */
    213            for (i=0; i<NumPoints; i++) {
   \   00000016   0xF04F 0x0A00      MOV      R10,#+0
   \   0000001A   0xE00B             B.N      ??GL_FillPolygon_0
    214              y = (paPoint + i)->y;
   \                     ??GL_FillPolygon_1: (+1)
   \   0000001C   0xEB04 0x008A      ADD      R0,R4,R10, LSL #+2
   \   00000020   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
    215              if (y < yMin)
   \   00000024   0x4540             CMP      R0,R8
   \   00000026   0xDC00             BGT.N    ??GL_FillPolygon_2
   \   00000028   0x4680             MOV      R8,R0
    216                yMin = y;
    217              if (y > yMax)
   \                     ??GL_FillPolygon_2: (+1)
   \   0000002A   0x4581             CMP      R9,R0
   \   0000002C   0xDA00             BGE.N    ??GL_FillPolygon_3
   \   0000002E   0x4681             MOV      R9,R0
    218                yMax = y;
    219            }
   \                     ??GL_FillPolygon_3: (+1)
   \   00000030   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??GL_FillPolygon_0: (+1)
   \   00000034   0x45AA             CMP      R10,R5
   \   00000036   0xDBF1             BLT.N    ??GL_FillPolygon_1
   \   00000038   0x....             LDR.N    R0,??DataTable4_2
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD013             BEQ.N    ??GL_FillPolygon_4
    220          /* Use Clipping rect to reduce calculation (if possible) */
    221            if (GUI_Context.pClipRect_HL) {
    222              if (yMax > (GUI_Context.pClipRect_HL->y1 - yOff))
   \   00000040   0xF9B0 0x1006      LDRSH    R1,[R0, #+6]
   \   00000044   0x1BC9             SUBS     R1,R1,R7
   \   00000046   0x4549             CMP      R1,R9
   \   00000048   0xDA00             BGE.N    ??GL_FillPolygon_5
    223                yMax = (GUI_Context.pClipRect_HL->y1 - yOff);
   \   0000004A   0x4689             MOV      R9,R1
    224              if (yMin < (GUI_Context.pClipRect_HL->y0 - yOff))
   \                     ??GL_FillPolygon_5: (+1)
   \   0000004C   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000050   0x1BC0             SUBS     R0,R0,R7
   \   00000052   0x4580             CMP      R8,R0
   \   00000054   0xDA08             BGE.N    ??GL_FillPolygon_4
    225                yMin = (GUI_Context.pClipRect_HL->y0 - yOff);
   \   00000056   0x4680             MOV      R8,R0
    226            }
    227          /* Second step: Calculate and draw horizontal lines */
    228            for (y=yMin; y<=yMax; y++) {
   \   00000058   0xE006             B.N      ??GL_FillPolygon_4
    229              _Init();
    230              /* find next intersection and count lines*/
    231              for (i=0; i<NumPoints; i++) {
    232                int i1 = (i < (NumPoints - 1)) ? i + 1 : 0;
    233                int y0 = (paPoint + i )->y;
    234                int y1 = (paPoint + i1)->y;
    235                /* Check if starting point is on line */
    236                if (y0 == y) {
    237                  if (y1 == y) {  /* Add the entire line */
    238                    _DrawHLine((paPoint + i )->x + xOff , y + yOff, (paPoint + i1)->x + xOff);
    239                  } else {        /* Add only one point */
    240                    int yPrev = _GetPrevPointDiffy(paPoint, i, NumPoints, y);
    241                    if (yPrev != y) {
    242                      _AddPoint((paPoint + i)->x, y, yPrev - y, y1 - y, xOff, yOff);
    243                    } 
    244                  }
    245                } else if (y1 != y) {  /* Ignore if end-point is on the line */
    246                  if (((y1 >= y) && (y0 <= y)) || ((y0 >= y) && (y1 <= y))) {
    247                    int xIntersect;
    248                    if (_CheckYInterSect(y, &xIntersect, paPoint + i, paPoint + i1)) {
    249                      _Add(xIntersect);
    250                    }
    251                  }
    252                }
    253              }
    254              _Flush(xOff, y + yOff);
   \                     ??GL_FillPolygon_6: (+1)
   \   0000005A   0xEB07 0x0108      ADD      R1,R7,R8
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       _Flush
   \   00000064   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??GL_FillPolygon_4: (+1)
   \   00000068   0x45C1             CMP      R9,R8
   \   0000006A   0xDB4D             BLT.N    ??GL_FillPolygon_7
   \   0000006C   0x.... 0x....      BL       _Init
   \   00000070   0xF04F 0x0A00      MOV      R10,#+0
   \   00000074   0xE014             B.N      ??GL_FillPolygon_8
   \                     ??GL_FillPolygon_9: (+1)
   \   00000076   0x45C3             CMP      R11,R8
   \   00000078   0xD010             BEQ.N    ??GL_FillPolygon_10
   \   0000007A   0x45C3             CMP      R11,R8
   \   0000007C   0xDB01             BLT.N    ??GL_FillPolygon_11
   \   0000007E   0x4580             CMP      R8,R0
   \   00000080   0xDA03             BGE.N    ??GL_FillPolygon_12
   \                     ??GL_FillPolygon_11: (+1)
   \   00000082   0x4540             CMP      R0,R8
   \   00000084   0xDB0A             BLT.N    ??GL_FillPolygon_10
   \   00000086   0x45D8             CMP      R8,R11
   \   00000088   0xDB08             BLT.N    ??GL_FillPolygon_10
   \                     ??GL_FillPolygon_12: (+1)
   \   0000008A   0xA900             ADD      R1,SP,#+0
   \   0000008C   0x4640             MOV      R0,R8
   \   0000008E   0x.... 0x....      BL       _CheckYInterSect
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??GL_FillPolygon_10
   \   00000096   0x9800             LDR      R0,[SP, #+0]
   \   00000098   0x.... 0x....      BL       _Add
   \                     ??GL_FillPolygon_10: (+1)
   \   0000009C   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??GL_FillPolygon_8: (+1)
   \   000000A0   0x45AA             CMP      R10,R5
   \   000000A2   0xDADA             BGE.N    ??GL_FillPolygon_6
   \   000000A4   0x1E68             SUBS     R0,R5,#+1
   \   000000A6   0x4582             CMP      R10,R0
   \   000000A8   0xDA02             BGE.N    ??GL_FillPolygon_13
   \   000000AA   0xF10A 0x0101      ADD      R1,R10,#+1
   \   000000AE   0xE000             B.N      ??GL_FillPolygon_14
   \                     ??GL_FillPolygon_13: (+1)
   \   000000B0   0x2100             MOVS     R1,#+0
   \                     ??GL_FillPolygon_14: (+1)
   \   000000B2   0xEB04 0x028A      ADD      R2,R4,R10, LSL #+2
   \   000000B6   0xF9B2 0x0002      LDRSH    R0,[R2, #+2]
   \   000000BA   0xEB04 0x0381      ADD      R3,R4,R1, LSL #+2
   \   000000BE   0xF9B3 0xB002      LDRSH    R11,[R3, #+2]
   \   000000C2   0x4540             CMP      R0,R8
   \   000000C4   0xD1D7             BNE.N    ??GL_FillPolygon_9
   \   000000C6   0x45C3             CMP      R11,R8
   \   000000C8   0xD10A             BNE.N    ??GL_FillPolygon_15
   \   000000CA   0xF934 0x0021      LDRSH    R0,[R4, R1, LSL #+2]
   \   000000CE   0x1832             ADDS     R2,R6,R0
   \   000000D0   0xEB07 0x0108      ADD      R1,R7,R8
   \   000000D4   0xF934 0x002A      LDRSH    R0,[R4, R10, LSL #+2]
   \   000000D8   0x1830             ADDS     R0,R6,R0
   \   000000DA   0x.... 0x....      BL       _DrawHLine
   \   000000DE   0xE7DD             B.N      ??GL_FillPolygon_10
   \                     ??GL_FillPolygon_15: (+1)
   \   000000E0   0x4643             MOV      R3,R8
   \   000000E2   0x462A             MOV      R2,R5
   \   000000E4   0x4651             MOV      R1,R10
   \   000000E6   0x4620             MOV      R0,R4
   \   000000E8   0x.... 0x....      BL       _GetPrevPointDiffy
   \   000000EC   0x4540             CMP      R0,R8
   \   000000EE   0xD0D5             BEQ.N    ??GL_FillPolygon_10
   \   000000F0   0x9701             STR      R7,[SP, #+4]
   \   000000F2   0x9600             STR      R6,[SP, #+0]
   \   000000F4   0xEBAB 0x0308      SUB      R3,R11,R8
   \   000000F8   0xEBA0 0x0208      SUB      R2,R0,R8
   \   000000FC   0x4641             MOV      R1,R8
   \   000000FE   0xF934 0x002A      LDRSH    R0,[R4, R10, LSL #+2]
   \   00000102   0x.... 0x....      BL       _AddPoint
   \   00000106   0xE7C9             B.N      ??GL_FillPolygon_10
    255            }  
    256          }
   \                     ??GL_FillPolygon_7: (+1)
   \   00000108   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    257          
    258          /*********************************************************************
    259          *
    260          *       GUI_FillPolygon
    261          */

   \                                 In section .text, align 2, keep-with-next
    262          void GUI_FillPolygon(const GUI_POINT* pPoints, int NumPoints, int x0, int y0) {
   \                     GUI_FillPolygon: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    263            GUI_LOCK();
    264            #if (GUI_WINSUPPORT)
    265              WM_ADDORG(x0, y0);
   \   00000006   0x....             LDR.N    R0,??DataTable4_2
   \   00000008   0x6C01             LDR      R1,[R0, #+64]
   \   0000000A   0x188E             ADDS     R6,R1,R2
   \   0000000C   0x6C40             LDR      R0,[R0, #+68]
   \   0000000E   0x18C7             ADDS     R7,R0,R3
    266              WM_ITERATE_START(NULL); {
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD009             BEQ.N    ??GUI_FillPolygon_0
    267            #endif
    268            GL_FillPolygon (pPoints, NumPoints, x0, y0);
   \                     ??GUI_FillPolygon_1: (+1)
   \   0000001A   0x463B             MOV      R3,R7
   \   0000001C   0x4632             MOV      R2,R6
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       GL_FillPolygon
    269            #if (GUI_WINSUPPORT)
    270              } WM_ITERATE_END();
   \   00000026   0x.... 0x....      BL       WM__GetNextIVR
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1F5             BNE.N    ??GUI_FillPolygon_1
    271            #endif
    272            GUI_UNLOCK();
    273          }
   \                     ??GUI_FillPolygon_0: (+1)
   \   0000002E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     _aX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xFFFFF001         DC32     0xfffff001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     GUI_Context
    274          
    275          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   GL_FillPolygon
        48   -> _Add
        48   -> _AddPoint
        48   -> _CheckYInterSect
        48   -> _DrawHLine
        48   -> _Flush
        48   -> _GetPrevPointDiffy
        48   -> _Init
      24   GUI_FillPolygon
        24   -> GL_FillPolygon
        24   -> WM__GetNextIVR
        24   -> WM__InitIVRSearch
       4   _Add
       8   _AddPoint
         0   -> LCD_DrawHLine
         0   -> _Add
      12   _CheckYInterSect
       0   _DrawHLine
         0   -> LCD_DrawHLine
      24   _Flush
        24   -> LCD_DrawHLine
       8   _GetPrevPointDiffy
       0   _Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
     268  GL_FillPolygon
      48  GUI_FillPolygon
      50  _Add
      26  _AddPoint
      96  _CheckYInterSect
      18  _DrawHLine
      60  _Flush
      46  _GetPrevPointDiffy
       8  _Init
      28  _aX
          GL_FP_Cnt

 
  28 bytes in section .bss
 632 bytes in section .text
 
 632 bytes of CODE memory
  28 bytes of DATA memory

Errors: none
Warnings: none
