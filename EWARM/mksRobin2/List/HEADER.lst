###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  17:00:02
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\HEADER.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\HEADER.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\HEADER.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\HEADER.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\HEADER.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : HEADER.c
     16          Purpose     : Implementation of header widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          
     23          #include "HEADER_Private.h"
     24          #include "SCROLLBAR.h"
     25          #include "GUI.h"
     26          
     27          #if GUI_WINSUPPORT
     28          
     29          /*********************************************************************
     30          *
     31          *       Private config defaults
     32          *
     33          **********************************************************************
     34          */
     35          
     36          #ifndef HEADER_SUPPORT_DRAG
     37            #define HEADER_SUPPORT_DRAG 1
     38          #endif
     39          
     40          #ifndef HEADER_BORDER_V_DEFAULT
     41            #define HEADER_BORDER_V_DEFAULT 0
     42          #endif
     43          
     44          #ifndef HEADER_BORDER_H_DEFAULT
     45            #define HEADER_BORDER_H_DEFAULT 2
     46          #endif
     47          
     48          /* Define default fonts */
     49          #ifndef HEADER_FONT_DEFAULT
     50            #define HEADER_FONT_DEFAULT &GUI_Font13_1
     51          #endif
     52          
     53          /* Define colors */
     54          #ifndef HEADER_BKCOLOR_DEFAULT
     55            #define HEADER_BKCOLOR_DEFAULT 0xAAAAAA
     56          #endif
     57          
     58          #ifndef HEADER_TEXTCOLOR_DEFAULT
     59            #define HEADER_TEXTCOLOR_DEFAULT GUI_BLACK
     60          #endif
     61          
     62          /* Define cursors */
     63          #ifndef HEADER_CURSOR_DEFAULT
     64            #define HEADER_CURSOR_DEFAULT &GUI_CursorHeaderM
     65          #endif
     66          
     67          /*********************************************************************
     68          *
     69          *       Static data
     70          *
     71          **********************************************************************
     72          */
     73          
     74          /* Remember the old cursor */

   \                                 In section .data, align 4
     75          static const GUI_CURSOR GUI_UNI_PTR * _pOldCursor;
   \                     _pOldCursor:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 GUI_CursorHeaderM
     76          
     77          /* Default values */
     78          static const GUI_CURSOR GUI_UNI_PTR * _pDefaultCursor   = HEADER_CURSOR_DEFAULT;

   \                                 In section .data, align 4
     79          static GUI_COLOR          _DefaultBkColor   = HEADER_BKCOLOR_DEFAULT;
   \                     _DefaultBkColor:
   \   00000000   0x00AAAAAA         DC32 11184810
   \   00000004   0x00000000         DC32 0
   \   00000008   0x00000002         DC32 2
   \   0000000C   0x00000000         DC32 0
   \   00000010   0x........         DC32 GUI_Font13_1
     80          static GUI_COLOR          _DefaultTextColor = HEADER_TEXTCOLOR_DEFAULT;
     81          static int                _DefaultBorderH   = HEADER_BORDER_H_DEFAULT;
     82          static int                _DefaultBorderV   = HEADER_BORDER_V_DEFAULT;
     83          static const GUI_FONT GUI_UNI_PTR *   _pDefaultFont     = HEADER_FONT_DEFAULT;
     84          
     85          /*********************************************************************
     86          *
     87          *       static routines
     88          *
     89          **********************************************************************
     90          */
     91          /*********************************************************************
     92          *
     93          *       _Paint
     94          */

   \                                 In section .text, align 2, keep-with-next
     95          static void _Paint(/*HEADER_Handle hObj, */HEADER_Obj* pObj) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
     96            GUI_RECT Rect;
     97            int i, xPos = -pObj->ScrollPos;
   \   00000008   0x6BE0             LDR      R0,[R4, #+60]
   \   0000000A   0x4247             RSBS     R7,R0,#+0
     98            int NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
   \   0000000C   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000010   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   00000014   0x4605             MOV      R5,R0
     99            int EffectSize = pObj->Widget.pEffect->EffectSize;
   \   00000016   0x6A20             LDR      R0,[R4, #+32]
   \   00000018   0x6946             LDR      R6,[R0, #+20]
    100            LCD_SetBkColor(pObj->BkColor);
   \   0000001A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001C   0x.... 0x....      BL       LCD_SetBkColor
    101            GUI_SetFont(pObj->pFont);
   \   00000020   0x6C20             LDR      R0,[R4, #+64]
   \   00000022   0x.... 0x....      BL       GUI_SetFont
    102            GUI_Clear();
   \   00000026   0x.... 0x....      BL       GUI_Clear
    103            for (i = 0; i < NumItems; i++) {
   \   0000002A   0xF04F 0x0800      MOV      R8,#+0
   \   0000002E   0xE04C             B.N      ??_Paint_0
    104              HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
    105              GUI_GetClientRect(&Rect);
    106              Rect.x0 = xPos;
    107              Rect.x1 = Rect.x0 + pColumn->Width;
    108              if (pColumn->hDrawObj) {
    109                int xOff = 0, yOff = 0;
    110                switch (pColumn->Align & GUI_TA_HORIZONTAL) {
    111                  case GUI_TA_RIGHT:
    112                    xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj));
    113                    break;
    114                  case GUI_TA_HCENTER:
    115                    xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj)) / 2;
    116                    break;
    117                }
    118                switch (pColumn->Align & GUI_TA_VERTICAL) {
    119          	      case GUI_TA_BOTTOM:
    120                    yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj));
    121                    break;
    122          	      case GUI_TA_VCENTER:
    123                    yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj)) / 2;
   \                     ??_Paint_1: (+1)
   \   00000030   0xF9B9 0x0006      LDRSH    R0,[R9, #+6]
   \   00000034   0x.... 0x....      BL       GUI_DRAW__GetYSize
   \   00000038   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   0000003C   0xF9BD 0x2002      LDRSH    R2,[SP, #+2]
   \   00000040   0x1A89             SUBS     R1,R1,R2
   \   00000042   0x1C49             ADDS     R1,R1,#+1
   \   00000044   0x1A08             SUBS     R0,R1,R0
   \   00000046   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000004A   0xEA4F 0x0B60      ASR      R11,R0,#+1
    124                    break;
    125                }
    126                WM_SetUserClipRect(&Rect);
   \                     ??_Paint_2: (+1)
   \   0000004E   0xA800             ADD      R0,SP,#+0
   \   00000050   0x.... 0x....      BL       WM_SetUserClipRect
    127                GUI_DRAW__Draw(pColumn->hDrawObj, xPos + xOff, yOff);
   \   00000054   0x465A             MOV      R2,R11
   \   00000056   0xEB0A 0x0107      ADD      R1,R10,R7
   \   0000005A   0xF9B9 0x0006      LDRSH    R0,[R9, #+6]
   \   0000005E   0x.... 0x....      BL       GUI_DRAW__Draw
    128                WM_SetUserClipRect(NULL);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       WM_SetUserClipRect
    129              }
    130              WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
   \                     ??_Paint_3: (+1)
   \   00000068   0xA900             ADD      R1,SP,#+0
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    131              xPos += Rect.x1 - Rect.x0;
   \   00000070   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000074   0x19C1             ADDS     R1,R0,R7
   \   00000076   0xF9BD 0x2000      LDRSH    R2,[SP, #+0]
   \   0000007A   0x1A8F             SUBS     R7,R1,R2
    132              Rect.x0 += EffectSize + _DefaultBorderH;
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000080   0x688A             LDR      R2,[R1, #+8]
   \   00000082   0xF8BD 0x3000      LDRH     R3,[SP, #+0]
   \   00000086   0xEB02 0x0C06      ADD      R12,R2,R6
   \   0000008A   0x4463             ADD      R3,R12,R3
   \   0000008C   0xF8AD 0x3000      STRH     R3,[SP, #+0]
    133              Rect.x1 -= EffectSize + _DefaultBorderH;
   \   00000090   0x1B80             SUBS     R0,R0,R6
   \   00000092   0x1A80             SUBS     R0,R0,R2
   \   00000094   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    134              Rect.y0 += EffectSize + _DefaultBorderV;
   \   00000098   0x68C8             LDR      R0,[R1, #+12]
   \   0000009A   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \   0000009E   0x1982             ADDS     R2,R0,R6
   \   000000A0   0x1851             ADDS     R1,R2,R1
   \   000000A2   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    135              Rect.y1 -= EffectSize + _DefaultBorderV;
   \   000000A6   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \   000000AA   0x1B89             SUBS     R1,R1,R6
   \   000000AC   0x1A08             SUBS     R0,R1,R0
   \   000000AE   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    136              LCD_SetColor(pObj->TextColor);
   \   000000B2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B4   0x.... 0x....      BL       LCD_SetColor
    137              GUI_DispStringInRect(pColumn->acText, &Rect, pColumn->Align);
   \   000000B8   0xF9B9 0x2004      LDRSH    R2,[R9, #+4]
   \   000000BC   0xA900             ADD      R1,SP,#+0
   \   000000BE   0xF109 0x0008      ADD      R0,R9,#+8
   \   000000C2   0x.... 0x....      BL       GUI_DispStringInRect
   \   000000C6   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_Paint_0: (+1)
   \   000000CA   0x45A8             CMP      R8,R5
   \   000000CC   0xDA49             BGE.N    ??_Paint_4
   \   000000CE   0x4641             MOV      R1,R8
   \   000000D0   0xF104 0x0030      ADD      R0,R4,#+48
   \   000000D4   0x.... 0x....      BL       GUI_ARRAY_GetpItem
   \   000000D8   0x4681             MOV      R9,R0
   \   000000DA   0xA800             ADD      R0,SP,#+0
   \   000000DC   0x.... 0x....      BL       GUI_GetClientRect
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000000E6   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000EA   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   000000EE   0x1808             ADDS     R0,R1,R0
   \   000000F0   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   000000F4   0xF9B9 0x0006      LDRSH    R0,[R9, #+6]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD0B5             BEQ.N    ??_Paint_3
   \   000000FC   0xF04F 0x0A00      MOV      R10,#+0
   \   00000100   0x46D3             MOV      R11,R10
   \   00000102   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   00000106   0xF001 0x0113      AND      R1,R1,#0x13
   \   0000010A   0x2901             CMP      R1,#+1
   \   0000010C   0xD002             BEQ.N    ??_Paint_5
   \   0000010E   0x2902             CMP      R1,#+2
   \   00000110   0xD007             BEQ.N    ??_Paint_6
   \   00000112   0xE00F             B.N      ??_Paint_7
   \                     ??_Paint_5: (+1)
   \   00000114   0x.... 0x....      BL       GUI_DRAW__GetXSize
   \   00000118   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   0000011C   0xEBA1 0x0A00      SUB      R10,R1,R0
   \   00000120   0xE008             B.N      ??_Paint_7
   \                     ??_Paint_6: (+1)
   \   00000122   0x.... 0x....      BL       GUI_DRAW__GetXSize
   \   00000126   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   0000012A   0x1A08             SUBS     R0,R1,R0
   \   0000012C   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000130   0xEA4F 0x0A60      ASR      R10,R0,#+1
   \                     ??_Paint_7: (+1)
   \   00000134   0xF899 0x0004      LDRB     R0,[R9, #+4]
   \   00000138   0xF000 0x000C      AND      R0,R0,#0xC
   \   0000013C   0x2804             CMP      R0,#+4
   \   0000013E   0xD003             BEQ.N    ??_Paint_8
   \   00000140   0x280C             CMP      R0,#+12
   \   00000142   0xF43F 0xAF75      BEQ.W    ??_Paint_1
   \   00000146   0xE782             B.N      ??_Paint_2
   \                     ??_Paint_8: (+1)
   \   00000148   0xF9B9 0x0006      LDRSH    R0,[R9, #+6]
   \   0000014C   0x.... 0x....      BL       GUI_DRAW__GetYSize
   \   00000150   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000154   0xF9BD 0x2002      LDRSH    R2,[SP, #+2]
   \   00000158   0x1A89             SUBS     R1,R1,R2
   \   0000015A   0x1C49             ADDS     R1,R1,#+1
   \   0000015C   0xEBA1 0x0B00      SUB      R11,R1,R0
   \   00000160   0xE775             B.N      ??_Paint_2
    138            }
    139            GUI_GetClientRect(&Rect);
   \                     ??_Paint_4: (+1)
   \   00000162   0xA800             ADD      R0,SP,#+0
   \   00000164   0x.... 0x....      BL       GUI_GetClientRect
    140            Rect.x0 = xPos;
   \   00000168   0xF8AD 0x7000      STRH     R7,[SP, #+0]
    141            Rect.x1 = 0xfff;
   \   0000016C   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000170   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    142            WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
   \   00000174   0xA900             ADD      R1,SP,#+0
   \   00000176   0x4620             MOV      R0,R4
   \   00000178   0x.... 0x....      BL       WIDGET__EFFECT_DrawUpRect
    143          }
   \   0000017C   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    144          
    145          /*********************************************************************
    146          *
    147          *       _RestoreOldCursor
    148          */

   \                                 In section .text, align 2, keep-with-next
    149          static void _RestoreOldCursor(void) {
   \                     _RestoreOldCursor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    150            if (_pOldCursor) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable16_1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??_RestoreOldCursor_0
    151              #if GUI_SUPPORT_CURSOR
    152                GUI_CURSOR_Select(_pOldCursor);
   \   0000000C   0x.... 0x....      BL       GUI_CURSOR_Select
    153              #endif
    154              _pOldCursor = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6020             STR      R0,[R4, #+0]
    155            }
    156          }
   \                     ??_RestoreOldCursor_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    157          
    158          /*********************************************************************
    159          *
    160          *       _FreeAttached
    161          *
    162          * Delete attached objects (if any)
    163          */

   \                                 In section .text, align 2, keep-with-next
    164          static void _FreeAttached(HEADER_Obj * pObj) {
   \                     _FreeAttached: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    165            int i, NumItems;
    166            NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
   \   00000004   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000008   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000000C   0x4605             MOV      R5,R0
    167            for (i = 0; i < NumItems; i++) {
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0xE00B             B.N      ??_FreeAttached_0
    168              HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
   \                     ??_FreeAttached_1: (+1)
   \   00000012   0x4631             MOV      R1,R6
   \   00000014   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000018   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    169              if (pColumn->hDrawObj) {
   \   0000001C   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??_FreeAttached_2
    170                GUI_ALLOC_Free(pColumn->hDrawObj);
   \   00000024   0x.... 0x....      BL       GUI_ALLOC_Free
    171              }
    172            }
   \                     ??_FreeAttached_2: (+1)
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   \                     ??_FreeAttached_0: (+1)
   \   0000002A   0x42AE             CMP      R6,R5
   \   0000002C   0xDBF1             BLT.N    ??_FreeAttached_1
    173            /* Delete attached objects (if any) */
    174            GUI_ARRAY_Delete(&pObj->Columns);
   \   0000002E   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000032   0x.... 0x....      BL       GUI_ARRAY_Delete
    175            _RestoreOldCursor();
   \   00000036   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003A   0x....             B.N      _RestoreOldCursor
    176          }
    177          
    178          /*********************************************************************
    179          *
    180          *       _GetItemIndex
    181          */
    182          #if (HEADER_SUPPORT_DRAG)

   \                                 In section .text, align 2, keep-with-next
    183          static int _GetItemIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
   \                     _GetItemIndex: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x4698             MOV      R8,R3
    184            int Item = -1;
   \   0000000C   0xF04F 0x36FF      MOV      R6,#-1
    185            if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
   \   00000010   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000014   0xD42E             BMI.N    ??_GetItemIndex_0
   \   00000016   0x.... 0x....      BL       WM_GetWindowSizeY
   \   0000001A   0x4580             CMP      R8,R0
   \   0000001C   0xDA2A             BGE.N    ??_GetItemIndex_0
    186              if (hObj) {
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD028             BEQ.N    ??_GetItemIndex_0
    187                int Index, xPos = 0, NumColumns;
   \   00000022   0xF04F 0x0900      MOV      R9,#+0
    188                NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
   \   00000026   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000002A   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000002E   0x4607             MOV      R7,R0
    189                for (Index = 0; Index < NumColumns; Index++) {
   \   00000030   0x46C8             MOV      R8,R9
   \   00000032   0xE001             B.N      ??_GetItemIndex_1
   \                     ??_GetItemIndex_2: (+1)
   \   00000034   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_GetItemIndex_1: (+1)
   \   00000038   0x45B8             CMP      R8,R7
   \   0000003A   0xDA1B             BGE.N    ??_GetItemIndex_0
    190                  HEADER_COLUMN * pColumn;
    191                  pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
   \   0000003C   0x4641             MOV      R1,R8
   \   0000003E   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000042   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    192                  xPos += pColumn->Width;
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x4481             ADD      R9,R0,R9
    193                  if ((xPos >= (x - 4)) && (xPos <= (x + 4))) {
   \   0000004A   0x1F28             SUBS     R0,R5,#+4
   \   0000004C   0x4581             CMP      R9,R0
   \   0000004E   0xDBF1             BLT.N    ??_GetItemIndex_2
   \   00000050   0x1D28             ADDS     R0,R5,#+4
   \   00000052   0x4548             CMP      R0,R9
   \   00000054   0xDBEE             BLT.N    ??_GetItemIndex_2
    194                    Item = Index;
   \   00000056   0x4646             MOV      R6,R8
    195                    if ((Index < (NumColumns - 1)) && (x < xPos)) {
   \   00000058   0x1E78             SUBS     R0,R7,#+1
   \   0000005A   0x4580             CMP      R8,R0
   \   0000005C   0xDAEA             BGE.N    ??_GetItemIndex_2
   \   0000005E   0x454D             CMP      R5,R9
   \   00000060   0xDAE8             BGE.N    ??_GetItemIndex_2
    196                      pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index + 1);
   \   00000062   0xF108 0x0101      ADD      R1,R8,#+1
   \   00000066   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000006A   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    197                      if (pColumn->Width == 0) {
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD1DF             BNE.N    ??_GetItemIndex_2
    198                        break;
    199                      }
    200                    }
    201                  }
    202                }
    203              }
    204            }
    205            return Item;
   \                     ??_GetItemIndex_0: (+1)
   \   00000074   0x4630             MOV      R0,R6
   \   00000076   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    206          }
    207          #endif
    208          
    209          /*********************************************************************
    210          *
    211          *       _HandlePID
    212          */
    213          #if (HEADER_SUPPORT_DRAG)

   \                                 In section .text, align 2, keep-with-next
    214          static void _HandlePID(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y, int Pressed) {
   \                     _HandlePID: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    215            int Hit = _GetItemIndex(hObj, pObj, x, y);
   \   0000000A   0x.... 0x....      BL       _GetItemIndex
   \   0000000E   0x9F06             LDR      R7,[SP, #+24]
    216            /* set capture position () */
    217            if ((Pressed == 1) && (Hit >= 0) && (pObj->CapturePosX == -1)) {
   \   00000010   0x2F01             CMP      R7,#+1
   \   00000012   0xD107             BNE.N    ??_HandlePID_0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD405             BMI.N    ??_HandlePID_0
   \   00000018   0x6B69             LDR      R1,[R5, #+52]
   \   0000001A   0xF111 0x0F01      CMN      R1,#+1
   \   0000001E   0xD101             BNE.N    ??_HandlePID_0
    218              pObj->CapturePosX = x;
   \   00000020   0x636E             STR      R6,[R5, #+52]
    219              pObj->CaptureItem = Hit;
   \   00000022   0x63A8             STR      R0,[R5, #+56]
    220            }
    221            /* set mouse cursor and capture () */
    222            if (Hit >= 0) {
   \                     ??_HandlePID_0: (+1)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD40F             BMI.N    ??_HandlePID_1
    223              WM_SetCapture(hObj, 1);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       WM_SetCapture
    224              #if GUI_SUPPORT_CURSOR
    225                if (!_pOldCursor) {
   \   00000030   0x.... 0x....      LDR.W    R8,??DataTable16_1
   \   00000034   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD105             BNE.N    ??_HandlePID_1
    226                  _pOldCursor = GUI_CURSOR_Select(_pDefaultCursor);
   \   0000003C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000040   0x.... 0x....      BL       GUI_CURSOR_Select
   \   00000044   0xF8C8 0x0000      STR      R0,[R8, #+0]
    227                }
    228              #endif
    229            }
    230            /* modify header */
    231            if ((pObj->CapturePosX >= 0) && (x != pObj->CapturePosX) && (Pressed == 1)) {
   \                     ??_HandlePID_1: (+1)
   \   00000048   0x6B68             LDR      R0,[R5, #+52]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD410             BMI.N    ??_HandlePID_2
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xD00E             BEQ.N    ??_HandlePID_2
   \   00000052   0x2F01             CMP      R7,#+1
   \   00000054   0xD10C             BNE.N    ??_HandlePID_2
    232              int NewSize = HEADER_GetItemWidth(hObj, pObj->CaptureItem) + x - pObj->CapturePosX;
   \   00000056   0x6BA9             LDR      R1,[R5, #+56]
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       HEADER_GetItemWidth
   \   0000005E   0x1830             ADDS     R0,R6,R0
   \   00000060   0x6B69             LDR      R1,[R5, #+52]
   \   00000062   0x1A42             SUBS     R2,R0,R1
    233              if (NewSize >= 0) {
   \   00000064   0xD404             BMI.N    ??_HandlePID_2
    234                HEADER_SetItemWidth(hObj, pObj->CaptureItem, NewSize);
   \   00000066   0x6BA9             LDR      R1,[R5, #+56]
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       HEADER_SetItemWidth
    235                pObj->CapturePosX = x;
   \   0000006E   0x636E             STR      R6,[R5, #+52]
    236              }
    237            }
    238            /* release capture & restore cursor */
    239            if (Pressed <= 0) {
   \                     ??_HandlePID_2: (+1)
   \   00000070   0x2F01             CMP      R7,#+1
   \   00000072   0xDA08             BGE.N    ??_HandlePID_3
    240              #if (GUI_SUPPORT_MOUSE)
    241              if (Hit == -1)
    242              #endif
    243              {
    244                _RestoreOldCursor();
   \   00000074   0x.... 0x....      BL       _RestoreOldCursor
    245                pObj->CapturePosX = -1;
   \   00000078   0xF04F 0x30FF      MOV      R0,#-1
   \   0000007C   0x6368             STR      R0,[R5, #+52]
    246                WM_ReleaseCapture();
   \   0000007E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000082   0x.... 0x....      B.W      WM_ReleaseCapture
    247              }
    248            }
    249          }
   \                     ??_HandlePID_3: (+1)
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    250          #endif
    251          
    252          /*********************************************************************
    253          *
    254          *       _OnMouseOver
    255          */
    256          #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
    257          static void _OnMouseOver(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
    258            const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
    259            if (pState) {
    260              _HandlePID(hObj, pObj, pState->x + pObj->ScrollPos, pState->y, -1);
    261            }
    262          }
    263          #endif
    264          
    265          /*********************************************************************
    266          *
    267          *       _OnTouch
    268          */
    269          #if (HEADER_SUPPORT_DRAG)

   \                                 In section .text, align 2, keep-with-next
    270          static void _OnTouch(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
    271            int Notification;
    272            const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
   \   00000008   0x68AE             LDR      R6,[R5, #+8]
    273            if (pState) {
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD008             BEQ.N    ??_OnTouch_0
    274              _HandlePID(hObj, pObj, pState->x + pObj->ScrollPos, pState->y, pState->Pressed);
   \   0000000E   0x7A30             LDRB     R0,[R6, #+8]
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x6873             LDR      R3,[R6, #+4]
   \   00000014   0x6830             LDR      R0,[R6, #+0]
   \   00000016   0x6BCA             LDR      R2,[R1, #+60]
   \   00000018   0x1812             ADDS     R2,R2,R0
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _HandlePID
    275            }
    276            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \                     ??_OnTouch_0: (+1)
   \   00000020   0x68A8             LDR      R0,[R5, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD006             BEQ.N    ??_OnTouch_1
    277              if (pState->Pressed) {
   \   00000026   0x7A30             LDRB     R0,[R6, #+8]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ.N    ??_OnTouch_2
    278                Notification = WM_NOTIFICATION_CLICKED;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xE002             B.N      ??_OnTouch_3
    279              } else {
    280                Notification = WM_NOTIFICATION_RELEASED;
   \                     ??_OnTouch_2: (+1)
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0xE000             B.N      ??_OnTouch_3
    281              }
    282            } else {
    283              Notification = WM_NOTIFICATION_MOVED_OUT;
   \                     ??_OnTouch_1: (+1)
   \   00000034   0x2103             MOVS     R1,#+3
    284            }
    285            WM_NotifyParent(hObj, Notification);
   \                     ??_OnTouch_3: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   0000003C   0x.... 0x....      B.W      WM_NotifyParent
    286          }
    287          #endif
    288          
    289          /*********************************************************************
    290          *
    291          *       _HEADER_Callback
    292          */

   \                                 In section .text, align 2, keep-with-next
    293          static void _HEADER_Callback (WM_MESSAGE *pMsg) {
   \                     _HEADER_Callback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    294            HEADER_Handle hObj;
    295            HEADER_Obj * pObj;
    296            hObj = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    297            /* Let widget handle the standard messages */
    298            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000008   0x4621             MOV      R1,R4
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD019             BEQ.N    ??_HEADER_Callback_0
    299              return;
    300            }
    301            WM_LOCK();
    302            pObj = HEADER_H2P(hObj);
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       GUI_ALLOC_h2p
    303            switch (pMsg->MsgId) {
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x290B             CMP      R1,#+11
   \   0000001E   0xD00C             BEQ.N    ??_HEADER_Callback_1
   \   00000020   0x290C             CMP      R1,#+12
   \   00000022   0xD004             BEQ.N    ??_HEADER_Callback_2
   \   00000024   0x290F             CMP      R1,#+15
   \   00000026   0xD10A             BNE.N    ??_HEADER_Callback_3
    304              case WM_PAINT:
    305                _Paint(/*hObj, */pObj);
   \   00000028   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002C   0x....             B.N      _Paint
    306                break;
    307          #if (HEADER_SUPPORT_DRAG)
    308              case WM_TOUCH:
    309                _OnTouch(hObj, pObj, pMsg);
   \                     ??_HEADER_Callback_2: (+1)
   \   0000002E   0x4622             MOV      R2,R4
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000038   0x....             B.N      _OnTouch
    310                break;
    311          #endif
    312          #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
    313              case WM_MOUSEOVER:
    314                _OnMouseOver(hObj, pObj, pMsg);
    315                break;
    316          #endif
    317              case WM_DELETE:
    318                _FreeAttached(pObj); /* No return here ... WM_DefaultProc needs to be called */
   \                     ??_HEADER_Callback_1: (+1)
   \   0000003A   0x.... 0x....      BL       _FreeAttached
    319              default:
    320                WM_DefaultProc(pMsg);
   \                     ??_HEADER_Callback_3: (+1)
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000044   0x.... 0x....      B.W      WM_DefaultProc
    321            }
    322            WM_UNLOCK();
    323          }
   \                     ??_HEADER_Callback_0: (+1)
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    324          
    325          /*********************************************************************
    326          *
    327          *       Exported routines:  Create
    328          *
    329          **********************************************************************
    330          */
    331          /*********************************************************************
    332          *
    333          *       HEADER_Create
    334          */

   \                                 In section .text, align 2, keep-with-next
    335          HEADER_Handle HEADER_Create(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int ExFlags) {
   \                     HEADER_Create: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    336            return HEADER_CreateEx(x0, y0, xsize, ysize, hParent, Flags, ExFlags, Id);
   \   00000002   0x9C07             LDR      R4,[SP, #+28]
   \   00000004   0x9403             STR      R4,[SP, #+12]
   \   00000006   0x9C09             LDR      R4,[SP, #+36]
   \   00000008   0x9402             STR      R4,[SP, #+8]
   \   0000000A   0x9C08             LDR      R4,[SP, #+32]
   \   0000000C   0x9401             STR      R4,[SP, #+4]
   \   0000000E   0xF9BD 0x4018      LDRSH    R4,[SP, #+24]
   \   00000012   0x9400             STR      R4,[SP, #+0]
   \   00000014   0x.... 0x....      BL       HEADER_CreateEx
   \   00000018   0xB004             ADD      SP,SP,#+16
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    337          }
    338          
    339          /*********************************************************************
    340          *
    341          *       HEADER_CreateEx
    342          */

   \                                 In section .text, align 2, keep-with-next
    343          HEADER_Handle HEADER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    344                                        int WinFlags, int ExFlags, int Id)
    345          {
   \                     HEADER_CreateEx: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0xF9BD 0x7030      LDRSH    R7,[SP, #+48]
    346            HEADER_Handle hObj;
    347            GUI_USE_PARA(ExFlags);
    348            /* Create the window */
    349            WM_LOCK();
    350            if ((xsize == 0) && (x0 == 0) && (y0 == 0)) {
   \   00000012   0xEA44 0x0006      ORR      R0,R4,R6
   \   00000016   0x4328             ORRS     R0,R5,R0
   \   00000018   0xD10B             BNE.N    ??HEADER_CreateEx_0
    351              GUI_RECT Rect;
    352              WM_GetInsideRectEx(hParent, &Rect);
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x4638             MOV      R0,R7
   \   0000001E   0x.... 0x....      BL       WM_GetInsideRectEx
    353              xsize = Rect.x1 - Rect.x0 + 1;
   \   00000022   0xF9BD 0x4000      LDRSH    R4,[SP, #+0]
   \   00000026   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   0000002A   0x1B00             SUBS     R0,R0,R4
   \   0000002C   0x1C46             ADDS     R6,R0,#+1
    354              x0    = Rect.x0;
    355              y0    = Rect.y0;
   \   0000002E   0xF9BD 0x5002      LDRSH    R5,[SP, #+2]
    356            }
    357            if (ysize == 0) {
   \                     ??HEADER_CreateEx_0: (+1)
   \   00000032   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000036   0xD10F             BNE.N    ??HEADER_CreateEx_1
    358              const WIDGET_EFFECT* pEffect = WIDGET_GetDefaultEffect();
   \   00000038   0x.... 0x....      BL       WIDGET_GetDefaultEffect
   \   0000003C   0x4681             MOV      R9,R0
    359              ysize  = GUI_GetYDistOfFont(_pDefaultFont);
   \   0000003E   0x.... 0x....      LDR.W    R8,??DataTable16
   \   00000042   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000046   0x.... 0x....      BL       GUI_GetYDistOfFont
    360              ysize += 2 * _DefaultBorderV;
    361              ysize += 2 * (unsigned)pEffect->EffectSize;
   \   0000004A   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \   0000004E   0xF8D9 0x2014      LDR      R2,[R9, #+20]
   \   00000052   0x1851             ADDS     R1,R2,R1
   \   00000054   0xEB00 0x0841      ADD      R8,R0,R1, LSL #+1
    362            }
    363            WinFlags |= WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT;
    364            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &_HEADER_Callback,
    365                                          sizeof(HEADER_Obj) - sizeof(WM_Obj));
   \                     ??HEADER_CreateEx_1: (+1)
   \   00000058   0x2024             MOVS     R0,#+36
   \   0000005A   0x9003             STR      R0,[SP, #+12]
   \   0000005C   0x....             LDR.N    R0,??DataTable16_2
   \   0000005E   0x9002             STR      R0,[SP, #+8]
   \   00000060   0x980D             LDR      R0,[SP, #+52]
   \   00000062   0xF440 0x7020      ORR      R0,R0,#0x280
   \   00000066   0xB280             UXTH     R0,R0
   \   00000068   0x9001             STR      R0,[SP, #+4]
   \   0000006A   0x9700             STR      R7,[SP, #+0]
   \   0000006C   0x4643             MOV      R3,R8
   \   0000006E   0x4632             MOV      R2,R6
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   00000078   0x0004             MOVS     R4,R0
    366            if (hObj) {
   \   0000007A   0xD017             BEQ.N    ??HEADER_CreateEx_2
    367              HEADER_Obj* pObj = HEADER_H2P(hObj);
   \   0000007C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000080   0x4605             MOV      R5,R0
    368              /* Init sub-classes */
    369              GUI_ARRAY_CREATE(&pObj->Columns);
    370              /* init widget specific variables */
    371              WIDGET__Init(&pObj->Widget, Id, 0);
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x990F             LDR      R1,[SP, #+60]
   \   00000086   0x.... 0x....      BL       WIDGET__Init
    372              /* init member variables */
    373              HEADER_INIT_ID(pObj);
    374              pObj->BkColor     = _DefaultBkColor;
   \   0000008A   0x.... 0x....      LDR.W    R8,??DataTable16
   \   0000008E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000092   0x62A8             STR      R0,[R5, #+40]
    375              pObj->TextColor   = _DefaultTextColor;
   \   00000094   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000098   0x62E8             STR      R0,[R5, #+44]
    376              pObj->pFont       = _pDefaultFont;
   \   0000009A   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   0000009E   0x6428             STR      R0,[R5, #+64]
    377              pObj->CapturePosX = -1;
   \   000000A0   0xF04F 0x30FF      MOV      R0,#-1
   \   000000A4   0x6368             STR      R0,[R5, #+52]
    378              pObj->CaptureItem = -1;
   \   000000A6   0x63A8             STR      R0,[R5, #+56]
    379              pObj->ScrollPos   = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x63E8             STR      R0,[R5, #+60]
    380            } else {
    381              GUI_DEBUG_ERROROUT_IF(hObj==0, "HEADER_Create failed")
    382            }
    383            WM_UNLOCK();
    384            return hObj;
   \                     ??HEADER_CreateEx_2: (+1)
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0xB005             ADD      SP,SP,#+20
   \   000000B0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    385          }
    386          
    387          /*********************************************************************
    388          *
    389          *       Exported routines: Global functions
    390          *
    391          **********************************************************************
    392          */
    393          /*********************************************************************
    394          *
    395          *       HEADER_SetDefautCursor
    396          */

   \                                 In section .text, align 2, keep-with-next
    397          const GUI_CURSOR GUI_UNI_PTR * HEADER_SetDefaultCursor(const GUI_CURSOR * pCursor) {
    398            const GUI_CURSOR GUI_UNI_PTR * pOldCursor = _pDefaultCursor;
   \                     HEADER_SetDefaultCursor: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16_1
   \   00000002   0x6851             LDR      R1,[R2, #+4]
    399            _pDefaultCursor = pCursor;
   \   00000004   0x6050             STR      R0,[R2, #+4]
    400            return pOldCursor;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    401          }
    402          
    403          /*********************************************************************
    404          *
    405          *       HEADER_SetDefaultBkColor
    406          */

   \                                 In section .text, align 2, keep-with-next
    407          GUI_COLOR HEADER_SetDefaultBkColor(GUI_COLOR Color) {
    408            GUI_COLOR OldColor = _DefaultBkColor;
   \                     HEADER_SetDefaultBkColor: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16
   \   00000002   0x6811             LDR      R1,[R2, #+0]
    409            _DefaultBkColor = Color;
   \   00000004   0x6010             STR      R0,[R2, #+0]
    410            return OldColor;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    411          }
    412          
    413          /*********************************************************************
    414          *
    415          *       HEADER_SetDefaultTextColor
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          GUI_COLOR HEADER_SetDefaultTextColor(GUI_COLOR Color) {
    418            GUI_COLOR OldColor = _DefaultTextColor;
   \                     HEADER_SetDefaultTextColor: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16
   \   00000002   0x6851             LDR      R1,[R2, #+4]
    419            _DefaultTextColor = Color;
   \   00000004   0x6050             STR      R0,[R2, #+4]
    420            return OldColor;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    421          }
    422          
    423          /*********************************************************************
    424          *
    425          *       HEADER_SetDefaultBorderH
    426          */

   \                                 In section .text, align 2, keep-with-next
    427          int HEADER_SetDefaultBorderH(int Spacing) {
    428            int OldSpacing = _DefaultBorderH;
   \                     HEADER_SetDefaultBorderH: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16
   \   00000002   0x6891             LDR      R1,[R2, #+8]
    429            _DefaultBorderH = Spacing;
   \   00000004   0x6090             STR      R0,[R2, #+8]
    430            return OldSpacing;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    431          }
    432          
    433          /*********************************************************************
    434          *
    435          *       HEADER_SetDefaultBorderV
    436          */

   \                                 In section .text, align 2, keep-with-next
    437          int HEADER_SetDefaultBorderV(int Spacing) {
    438            int OldSpacing = _DefaultBorderV;
   \                     HEADER_SetDefaultBorderV: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16
   \   00000002   0x68D1             LDR      R1,[R2, #+12]
    439            _DefaultBorderV = Spacing;
   \   00000004   0x60D0             STR      R0,[R2, #+12]
    440            return OldSpacing;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    441          }
    442          
    443          /*********************************************************************
    444          *
    445          *       HEADER_SetDefaultFont
    446          */

   \                                 In section .text, align 2, keep-with-next
    447          const GUI_FONT GUI_UNI_PTR * HEADER_SetDefaultFont(const GUI_FONT GUI_UNI_PTR * pFont) {
    448            const GUI_FONT GUI_UNI_PTR * pOldFont = _pDefaultFont;
   \                     HEADER_SetDefaultFont: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16
   \   00000002   0x6911             LDR      R1,[R2, #+16]
    449            _pDefaultFont = pFont;
   \   00000004   0x6110             STR      R0,[R2, #+16]
    450            return pOldFont;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    451          }
    452          
    453          /*********************************************************************
    454          *
    455          *       HEADER_GetDefault...
    456          */

   \                                 In section .text, align 2, keep-with-next
    457          const GUI_CURSOR GUI_UNI_PTR *  HEADER_GetDefaultCursor(void)    { return _pDefaultCursor; }
   \                     HEADER_GetDefaultCursor: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_1
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    458          GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
   \                     HEADER_GetDefaultBkColor: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    459          GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
   \                     HEADER_GetDefaultTextColor: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    460          int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
   \                     HEADER_GetDefaultBorderH: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    461          int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
   \                     HEADER_GetDefaultBorderV: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    462          const GUI_FONT GUI_UNI_PTR *    HEADER_GetDefaultFont(void)      { return _pDefaultFont; }
   \                     HEADER_GetDefaultFont: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0x4770             BX       LR               ;; return
    463          
    464          /*********************************************************************
    465          *
    466          *       Exported routines: Member functions
    467          *
    468          **********************************************************************
    469          */
    470          /*********************************************************************
    471          *
    472          *       HEADER_SetFont
    473          */

   \                                 In section .text, align 2, keep-with-next
    474          void HEADER_SetFont(HEADER_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
   \                     HEADER_SetFont: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    475            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??HEADER_SetFont_0
    476              HEADER_Obj * pObj;
    477              WM_LOCK();
    478              pObj = HEADER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    479              pObj->pFont = pFont;
   \   0000000E   0x6405             STR      R5,[R0, #+64]
    480              WM_InvalidateWindow(hObj);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000016   0x.... 0x....      B.W      WM_InvalidateWindow
    481              WM_UNLOCK();
    482            }
    483          }
   \                     ??HEADER_SetFont_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    484          
    485          /*********************************************************************
    486          *
    487          *       HEADER_SetHeight
    488          */

   \                                 In section .text, align 2, keep-with-next
    489          void HEADER_SetHeight(HEADER_Handle hObj, int Height) {
   \                     HEADER_SetHeight: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    490            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD011             BEQ.N    ??HEADER_SetHeight_0
    491              GUI_RECT Rect;
    492              WM_GetClientRectEx(hObj, &Rect);
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x.... 0x....      BL       WM_GetClientRectEx
    493              WM_SetSize(hObj, Rect.x1 - Rect.x0 + 1, Height);
   \   00000012   0x462A             MOV      R2,R5
   \   00000014   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000018   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   0000001C   0x1A40             SUBS     R0,R0,R1
   \   0000001E   0x1C41             ADDS     R1,R0,#+1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       WM_SetSize
    494              WM_InvalidateWindow(WM_GetParent(hObj));
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       WM_GetParent
   \   0000002C   0x.... 0x....      BL       WM_InvalidateWindow
    495            }
    496          }
   \                     ??HEADER_SetHeight_0: (+1)
   \   00000030   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    497          
    498          /*********************************************************************
    499          *
    500          *       HEADER_SetTextColor
    501          */

   \                                 In section .text, align 2, keep-with-next
    502          void HEADER_SetTextColor(HEADER_Handle hObj, GUI_COLOR Color) {
   \                     HEADER_SetTextColor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    503            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??HEADER_SetTextColor_0
    504              HEADER_Obj * pObj;
    505              WM_LOCK();
    506              pObj = HEADER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    507              pObj->TextColor = Color;
   \   0000000E   0x62C5             STR      R5,[R0, #+44]
    508              WM_InvalidateWindow(hObj);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000016   0x.... 0x....      B.W      WM_InvalidateWindow
    509              WM_UNLOCK();
    510            }
    511          }
   \                     ??HEADER_SetTextColor_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    512          
    513          /*********************************************************************
    514          *
    515          *       HEADER_SetBkColor
    516          */

   \                                 In section .text, align 2, keep-with-next
    517          void HEADER_SetBkColor(HEADER_Handle hObj, GUI_COLOR Color) {
   \                     HEADER_SetBkColor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    518            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??HEADER_SetBkColor_0
    519              HEADER_Obj * pObj;
    520              WM_LOCK();
    521              pObj = HEADER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    522              pObj->BkColor = Color;
   \   0000000E   0x6285             STR      R5,[R0, #+40]
    523              WM_InvalidateWindow(hObj);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000016   0x.... 0x....      B.W      WM_InvalidateWindow
    524              WM_UNLOCK();
    525            }
    526          }
   \                     ??HEADER_SetBkColor_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    527          
    528          /*********************************************************************
    529          *
    530          *       HEADER_SetTextAlign
    531          */

   \                                 In section .text, align 2, keep-with-next
    532          void HEADER_SetTextAlign(HEADER_Handle hObj, unsigned int Index, int Align) {
   \                     HEADER_SetTextAlign: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    533            if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD013             BEQ.N    ??HEADER_SetTextAlign_0
    534              HEADER_Obj * pObj;
    535              WM_LOCK();
    536              pObj = HEADER_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4607             MOV      R7,R0
    537              if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
   \   00000012   0xF107 0x0030      ADD      R0,R7,#+48
   \   00000016   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000001A   0x42A8             CMP      R0,R5
   \   0000001C   0xD30A             BCC.N    ??HEADER_SetTextAlign_0
    538                HEADER_COLUMN * pColumn;
    539                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0xF107 0x0030      ADD      R0,R7,#+48
   \   00000024   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    540                pColumn->Align = Align;
   \   00000028   0x8086             STRH     R6,[R0, #+4]
    541                WM_InvalidateWindow(hObj);
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000030   0x.... 0x....      B.W      WM_InvalidateWindow
    542              }
    543              WM_UNLOCK();
    544            }
    545          }
   \                     ??HEADER_SetTextAlign_0: (+1)
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    546          
    547          /*********************************************************************
    548          *
    549          *       HEADER_SetScrollPos
    550          */

   \                                 In section .text, align 2, keep-with-next
    551          void HEADER_SetScrollPos(HEADER_Handle hObj, int ScrollPos) {
   \                     HEADER_SetScrollPos: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    552            if (hObj && (ScrollPos >= 0)) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD011             BEQ.N    ??HEADER_SetScrollPos_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD40F             BMI.N    ??HEADER_SetScrollPos_0
    553              HEADER_Obj* pObj;
    554              WM_LOCK();
    555              pObj = HEADER_H2P(hObj);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    556              if (ScrollPos != pObj->ScrollPos) {
   \   00000012   0x6BC1             LDR      R1,[R0, #+60]
   \   00000014   0x428D             CMP      R5,R1
   \   00000016   0xD00A             BEQ.N    ??HEADER_SetScrollPos_0
    557                pObj->ScrollPos = ScrollPos;
   \   00000018   0x63C5             STR      R5,[R0, #+60]
    558                WM_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       WM_InvalidateWindow
    559                WM_InvalidateWindow(WM_GetParent(hObj));
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       WM_GetParent
   \   00000026   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002A   0x.... 0x....      B.W      WM_InvalidateWindow
    560              }
    561              WM_UNLOCK();
    562            }
    563          }
   \                     ??HEADER_SetScrollPos_0: (+1)
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    564          
    565          /*********************************************************************
    566          *
    567          *       HEADER_AddItem
    568          */

   \                                 In section .text, align 2, keep-with-next
    569          void HEADER_AddItem(HEADER_Handle hObj, int Width, const char * s, int Align) {
   \                     HEADER_AddItem: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461F             MOV      R7,R3
    570            if (hObj) {
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD043             BEQ.N    ??HEADER_AddItem_0
    571              HEADER_Obj * pObj;
    572              HEADER_COLUMN Column;
    573              int Index;
    574              WM_LOCK();
    575              pObj = HEADER_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4606             MOV      R6,R0
    576              if (!Width) {
   \   00000016   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001A   0xD110             BNE.N    ??HEADER_AddItem_1
    577                const GUI_FONT GUI_UNI_PTR * pFont = GUI_SetFont(pObj->pFont);
   \   0000001C   0x6C30             LDR      R0,[R6, #+64]
   \   0000001E   0x.... 0x....      BL       GUI_SetFont
   \   00000022   0x4680             MOV      R8,R0
    578                Width = GUI_GetStringDistX(s) + 2 * (pObj->Widget.pEffect->EffectSize + _DefaultBorderH);
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       GUI_GetStringDistX
   \   0000002A   0x6A31             LDR      R1,[R6, #+32]
   \   0000002C   0x6949             LDR      R1,[R1, #+20]
   \   0000002E   0x....             LDR.N    R2,??DataTable16
   \   00000030   0x6892             LDR      R2,[R2, #+8]
   \   00000032   0x1851             ADDS     R1,R2,R1
   \   00000034   0xEB00 0x0941      ADD      R9,R0,R1, LSL #+1
    579                GUI_SetFont(pFont);
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0x.... 0x....      BL       GUI_SetFont
    580              }
    581              Column.Width    = Width;
   \                     ??HEADER_AddItem_1: (+1)
   \   0000003E   0xF8CD 0x9000      STR      R9,[SP, #+0]
    582              Column.Align    = Align;
   \   00000042   0xF8AD 0x7004      STRH     R7,[SP, #+4]
    583              Column.hDrawObj = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    584              Index = GUI_ARRAY_GetNumItems(&pObj->Columns);
   \   0000004C   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000050   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   00000054   0x4607             MOV      R7,R0
    585              if (GUI_ARRAY_AddItem(&pObj->Columns, &Column, sizeof(HEADER_COLUMN) + strlen(s) + 1) == 0) {
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       strlen
   \   0000005C   0xF100 0x020D      ADD      R2,R0,#+13
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000066   0x.... 0x....      BL       GUI_ARRAY_AddItem
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD114             BNE.N    ??HEADER_AddItem_0
    586                HEADER_COLUMN * pColumn;
    587                pObj = HEADER_H2P(hObj);
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000074   0x4606             MOV      R6,R0
    588                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
   \   00000076   0x4639             MOV      R1,R7
   \   00000078   0xF106 0x0030      ADD      R0,R6,#+48
   \   0000007C   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    589                strcpy(pColumn->acText, s);
   \   00000080   0x4629             MOV      R1,R5
   \   00000082   0x3008             ADDS     R0,R0,#+8
   \   00000084   0x.... 0x....      BL       strcpy
    590                WM_InvalidateWindow(hObj);
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       WM_InvalidateWindow
    591                WM_InvalidateWindow(WM_GetParent(hObj));
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       WM_GetParent
   \   00000094   0x.... 0x....      BL       WM_InvalidateWindow
    592              }
    593              WM_UNLOCK();
    594            }
    595          }
   \                     ??HEADER_AddItem_0: (+1)
   \   00000098   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    596          
    597          /*********************************************************************
    598          *
    599          *       HEADER_DeleteItem
    600          */

   \                                 In section .text, align 2, keep-with-next
    601          void HEADER_DeleteItem(HEADER_Handle hObj, unsigned Index) {
   \                     HEADER_DeleteItem: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    602            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD017             BEQ.N    ??HEADER_DeleteItem_0
    603              HEADER_Obj* pObj;
    604              WM_LOCK();
    605              pObj = HEADER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    606              if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
   \   00000010   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000014   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD20E             BCS.N    ??HEADER_DeleteItem_0
    607                GUI_ARRAY_DeleteItem(&pObj->Columns, Index);
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000022   0x.... 0x....      BL       GUI_ARRAY_DeleteItem
    608                WM_InvalidateWindow(hObj);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       WM_InvalidateWindow
    609                WM_InvalidateWindow(WM_GetParent(hObj));
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       WM_GetParent
   \   00000032   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000036   0x.... 0x....      B.W      WM_InvalidateWindow
    610              }
    611              WM_UNLOCK();
    612            }
    613          }
   \                     ??HEADER_DeleteItem_0: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    614          
    615          /*********************************************************************
    616          *
    617          *       HEADER_SetItemText
    618          */

   \                                 In section .text, align 2, keep-with-next
    619          void HEADER_SetItemText(HEADER_Handle hObj, unsigned int Index, const char* s) {
   \                     HEADER_SetItemText: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    620            if (hObj) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01A             BEQ.N    ??HEADER_SetItemText_0
    621              HEADER_Obj* pObj;
    622              WM_LOCK();
    623              pObj = HEADER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    624              if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
   \   00000010   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000014   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD211             BCS.N    ??HEADER_SetItemText_0
    625                HEADER_COLUMN* pColumn;
    626                pColumn = (HEADER_COLUMN*)GUI_ARRAY_ResizeItem(&pObj->Columns, Index, sizeof(HEADER_COLUMN) + strlen(s));
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       strlen
   \   00000022   0xF100 0x020C      ADD      R2,R0,#+12
   \   00000026   0x4621             MOV      R1,R4
   \   00000028   0xF106 0x0030      ADD      R0,R6,#+48
   \   0000002C   0x.... 0x....      BL       GUI_ARRAY_ResizeItem
    627                if (pColumn) {
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD005             BEQ.N    ??HEADER_SetItemText_0
    628                  strcpy(pColumn->acText, s);
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x3008             ADDS     R0,R0,#+8
   \   00000038   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003C   0x.... 0x....      B.W      strcpy
    629                }
    630              }
    631              WM_UNLOCK();
    632            }
    633          }
   \                     ??HEADER_SetItemText_0: (+1)
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    634          
    635          /*********************************************************************
    636          *
    637          *       HEADER_SetItemWidth
    638          */

   \                                 In section .text, align 2, keep-with-next
    639          void HEADER_SetItemWidth(HEADER_Handle hObj, unsigned int Index, int Width) {
   \                     HEADER_SetItemWidth: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    640            if (hObj && (Width >= 0)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD022             BEQ.N    ??HEADER_SetItemWidth_0
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD420             BMI.N    ??HEADER_SetItemWidth_0
    641              HEADER_Obj * pObj;
    642              WM_LOCK();
    643              pObj = HEADER_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4607             MOV      R7,R0
    644              if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
   \   00000016   0xF107 0x0030      ADD      R0,R7,#+48
   \   0000001A   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xD317             BCC.N    ??HEADER_SetItemWidth_0
    645                HEADER_COLUMN * pColumn;
    646                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xF107 0x0030      ADD      R0,R7,#+48
   \   00000028   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    647                if (pColumn) {
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD010             BEQ.N    ??HEADER_SetItemWidth_0
    648                  pColumn->Width = Width;
   \   00000030   0x6006             STR      R6,[R0, #+0]
    649                  WM_InvalidateWindow(hObj);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       WM_InvalidateWindow
    650                  WM__SendMsgNoData(WM_GetParent(hObj), WM_NOTIFY_CLIENTCHANGE);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       WM_GetParent
   \   0000003E   0x2125             MOVS     R1,#+37
   \   00000040   0x.... 0x....      BL       WM__SendMsgNoData
    651                  WM_InvalidateWindow(WM_GetParent(hObj));
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       WM_GetParent
   \   0000004A   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000004E   0x.... 0x....      B.W      WM_InvalidateWindow
    652                }
    653              }
    654              WM_UNLOCK();
    655            }
    656          }
   \                     ??HEADER_SetItemWidth_0: (+1)
   \   00000052   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    657          
    658          /*********************************************************************
    659          *
    660          *       HEADER_GetHeight
    661          */

   \                                 In section .text, align 2, keep-with-next
    662          int HEADER_GetHeight(HEADER_Handle hObj) {
   \                     HEADER_GetHeight: (+1)
   \   00000000   0x4602             MOV      R2,R0
    663            int Height = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    664            if (hObj) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD100             BNE.N    ??HEADER_GetHeight_0
   \   00000008   0x4770             BX       LR
    665              GUI_RECT Rect;
    666              WM_GetClientRectEx(hObj, &Rect);
   \                     ??HEADER_GetHeight_0: (+1)
   \   0000000A   0xB500             PUSH     {LR}
   \   0000000C   0xB083             SUB      SP,SP,#+12
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x.... 0x....      BL       WM_GetClientRectEx
    667              GUI_MoveRect(&Rect, -Rect.x0, -Rect.y0);
   \   00000016   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000001A   0x4242             RSBS     R2,R0,#+0
   \   0000001C   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000020   0x4241             RSBS     R1,R0,#+0
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       GUI_MoveRect
    668              Height = Rect.y1 - Rect.y0 + 1;
   \   00000028   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \   0000002C   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000030   0x1A40             SUBS     R0,R0,R1
   \   00000032   0x1C40             ADDS     R0,R0,#+1
    669            }
    670            return Height;
   \   00000034   0xBD0E             POP      {R1-R3,PC}       ;; return
    671          }
    672          
    673          /*********************************************************************
    674          *
    675          *       HEADER_GetItemWidth
    676          */

   \                                 In section .text, align 2, keep-with-next
    677          int HEADER_GetItemWidth(HEADER_Handle hObj, unsigned int Index) {
   \                     HEADER_GetItemWidth: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    678            int Width = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    679            if (hObj) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00E             BEQ.N    ??HEADER_GetItemWidth_0
    680              HEADER_Obj * pObj;
    681              WM_LOCK();
    682              pObj = HEADER_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    683              if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
   \   00000010   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000014   0x.... 0x....      BL       GUI_ARRAY_GetNumItems
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xD305             BCC.N    ??HEADER_GetItemWidth_0
    684                HEADER_COLUMN * pColumn;
    685                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0xF106 0x0030      ADD      R0,R6,#+48
   \   00000022   0x.... 0x....      BL       GUI_ARRAY_GetpItem
    686                Width = pColumn->Width;
   \   00000026   0x6805             LDR      R5,[R0, #+0]
    687              }
    688              WM_UNLOCK();
    689            }
    690            return Width;
   \                     ??HEADER_GetItemWidth_0: (+1)
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    691          }
    692          
    693          /*********************************************************************
    694          *
    695          *       HEADER_GetNumItems
    696          */

   \                                 In section .text, align 2, keep-with-next
    697          int  HEADER_GetNumItems(HEADER_Handle hObj) {
   \                     HEADER_GetNumItems: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4601             MOV      R1,R0
    698            int NumCols = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    699            if (hObj) {
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD007             BEQ.N    ??HEADER_GetNumItems_0
    700              HEADER_Obj * pObj;
    701              WM_LOCK();
    702              pObj = HEADER_H2P(hObj);
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    703              NumCols = GUI_ARRAY_GetNumItems(&pObj->Columns);
   \   00000010   0x3030             ADDS     R0,R0,#+48
   \   00000012   0xE8BD 0x4002      POP      {R1,LR}
   \   00000016   0x.... 0x....      B.W      GUI_ARRAY_GetNumItems
    704              WM_UNLOCK();
    705            }
    706            return NumCols;
   \                     ??HEADER_GetNumItems_0: (+1)
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    707          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     _DefaultBkColor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     _pOldCursor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     _HEADER_Callback
    708          
    709          #else /* avoid empty object files */
    710          
    711          void HEADER_C(void);
    712          void HEADER_C(void){}
    713          
    714          #endif  /* #if GUI_WINSUPPORT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   HEADER_AddItem
        40   -> GUI_ALLOC_h2p
        40   -> GUI_ARRAY_AddItem
        40   -> GUI_ARRAY_GetNumItems
        40   -> GUI_ARRAY_GetpItem
        40   -> GUI_GetStringDistX
        40   -> GUI_SetFont
        40   -> WM_GetParent
        40   -> WM_InvalidateWindow
        40   -> strcpy
        40   -> strlen
      24   HEADER_Create
        24   -> HEADER_CreateEx
      48   HEADER_CreateEx
        48   -> GUI_ALLOC_h2p
        48   -> GUI_GetYDistOfFont
        48   -> WIDGET_GetDefaultEffect
        48   -> WIDGET__Init
        48   -> WM_CreateWindowAsChild
        48   -> WM_GetInsideRectEx
      16   HEADER_DeleteItem
        16   -> GUI_ALLOC_h2p
        16   -> GUI_ARRAY_DeleteItem
        16   -> GUI_ARRAY_GetNumItems
        16   -> WM_GetParent
         0   -> WM_InvalidateWindow
        16   -> WM_InvalidateWindow
       0   HEADER_GetDefaultBkColor
       0   HEADER_GetDefaultBorderH
       0   HEADER_GetDefaultBorderV
       0   HEADER_GetDefaultCursor
       0   HEADER_GetDefaultFont
       0   HEADER_GetDefaultTextColor
      16   HEADER_GetHeight
        16   -> GUI_MoveRect
        16   -> WM_GetClientRectEx
      16   HEADER_GetItemWidth
        16   -> GUI_ALLOC_h2p
        16   -> GUI_ARRAY_GetNumItems
        16   -> GUI_ARRAY_GetpItem
       8   HEADER_GetNumItems
         8   -> GUI_ALLOC_h2p
         0   -> GUI_ARRAY_GetNumItems
      16   HEADER_SetBkColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
       0   HEADER_SetDefaultBkColor
       0   HEADER_SetDefaultBorderH
       0   HEADER_SetDefaultBorderV
       0   HEADER_SetDefaultCursor
       0   HEADER_SetDefaultFont
       0   HEADER_SetDefaultTextColor
      16   HEADER_SetFont
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      24   HEADER_SetHeight
        24   -> WM_GetClientRectEx
        24   -> WM_GetParent
        24   -> WM_InvalidateWindow
        24   -> WM_SetSize
      16   HEADER_SetItemText
        16   -> GUI_ALLOC_h2p
        16   -> GUI_ARRAY_GetNumItems
        16   -> GUI_ARRAY_ResizeItem
         0   -> strcpy
        16   -> strlen
      24   HEADER_SetItemWidth
        24   -> GUI_ALLOC_h2p
        24   -> GUI_ARRAY_GetNumItems
        24   -> GUI_ARRAY_GetpItem
        24   -> WM_GetParent
         0   -> WM_InvalidateWindow
        24   -> WM_InvalidateWindow
        24   -> WM__SendMsgNoData
      16   HEADER_SetScrollPos
        16   -> GUI_ALLOC_h2p
        16   -> WM_GetParent
         0   -> WM_InvalidateWindow
        16   -> WM_InvalidateWindow
      24   HEADER_SetTextAlign
        24   -> GUI_ALLOC_h2p
        24   -> GUI_ARRAY_GetNumItems
        24   -> GUI_ARRAY_GetpItem
         0   -> WM_InvalidateWindow
      16   HEADER_SetTextColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   _FreeAttached
        16   -> GUI_ALLOC_Free
        16   -> GUI_ARRAY_Delete
        16   -> GUI_ARRAY_GetNumItems
        16   -> GUI_ARRAY_GetpItem
         0   -> _RestoreOldCursor
      32   _GetItemIndex
        32   -> GUI_ARRAY_GetNumItems
        32   -> GUI_ARRAY_GetpItem
        32   -> WM_GetWindowSizeY
      16   _HEADER_Callback
        16   -> GUI_ALLOC_h2p
        16   -> WIDGET_HandleActive
         0   -> WM_DefaultProc
        16   -> _FreeAttached
         0   -> _OnTouch
         0   -> _Paint
      24   _HandlePID
        24   -> GUI_CURSOR_Select
        24   -> HEADER_GetItemWidth
        24   -> HEADER_SetItemWidth
         0   -> WM_ReleaseCapture
        24   -> WM_SetCapture
        24   -> _GetItemIndex
        24   -> _RestoreOldCursor
      24   _OnTouch
         0   -> WM_NotifyParent
        24   -> _HandlePID
      48   _Paint
        48   -> GUI_ARRAY_GetNumItems
        48   -> GUI_ARRAY_GetpItem
        48   -> GUI_Clear
        48   -> GUI_DRAW__Draw
        48   -> GUI_DRAW__GetXSize
        48   -> GUI_DRAW__GetYSize
        48   -> GUI_DispStringInRect
        48   -> GUI_GetClientRect
        48   -> GUI_SetFont
        48   -> LCD_SetBkColor
        48   -> LCD_SetColor
        48   -> WIDGET__EFFECT_DrawUpRect
        48   -> WM_SetUserClipRect
       8   _RestoreOldCursor
         8   -> GUI_CURSOR_Select


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
     156  HEADER_AddItem
      28  HEADER_Create
     180  HEADER_CreateEx
      60  HEADER_DeleteItem
       6  HEADER_GetDefaultBkColor
       6  HEADER_GetDefaultBorderH
       6  HEADER_GetDefaultBorderV
       6  HEADER_GetDefaultCursor
       6  HEADER_GetDefaultFont
       6  HEADER_GetDefaultTextColor
      54  HEADER_GetHeight
      44  HEADER_GetItemWidth
      28  HEADER_GetNumItems
      28  HEADER_SetBkColor
      10  HEADER_SetDefaultBkColor
      10  HEADER_SetDefaultBorderH
      10  HEADER_SetDefaultBorderV
      10  HEADER_SetDefaultCursor
      10  HEADER_SetDefaultFont
      10  HEADER_SetDefaultTextColor
      28  HEADER_SetFont
      50  HEADER_SetHeight
      66  HEADER_SetItemText
      84  HEADER_SetItemWidth
      48  HEADER_SetScrollPos
      54  HEADER_SetTextAlign
      28  HEADER_SetTextColor
      20  _DefaultBkColor
          _DefaultTextColor
          _DefaultBorderH
          _DefaultBorderV
          _pDefaultFont
      60  _FreeAttached
     122  _GetItemIndex
      74  _HEADER_Callback
     138  _HandlePID
      64  _OnTouch
     384  _Paint
      22  _RestoreOldCursor
       8  _pOldCursor
          _pDefaultCursor

 
    28 bytes in section .data
 1 908 bytes in section .text
 
 1 908 bytes of CODE memory
    28 bytes of DATA memory

Errors: none
Warnings: none
