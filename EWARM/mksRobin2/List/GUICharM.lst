###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  16:59:58
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUICharM.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUICharM.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\GUICharM.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\GUICharM.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUICharM.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUIChar.C
     16          Purpose     : Implementation of memory devices
     17          ----------------------------------------------------------------------
     18          Version-Date---Author-Explanation
     19          ----------------------------------------------------------------------
     20          */
     21          
     22          #include <stddef.h>           /* needed for definition of NULL */
     23          #include "GUI_Private.h"
     24           
     25          /*********************************************************************
     26          *
     27          *       Public code
     28          *
     29          **********************************************************************
     30          */
     31          /*********************************************************************
     32          *
     33          *       GUIMONO_DispChar
     34          *
     35          * Purpose:
     36          *   This is the routine that displays a character. It is used by all
     37          *   other routines which display characters as a subroutine.
     38          */

   \                                 In section .text, align 2, keep-with-next
     39          void GUIMONO_DispChar(U16P c) {
   \                     GUIMONO_DispChar: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
     40            int c0, c1;
     41            const unsigned char GUI_UNI_PTR * pd;
     42            int x = GUI_Context.DispPosX;
   \   00000006   0x....             LDR.N    R6,??DataTable1
   \   00000008   0xF9B6 0x1022      LDRSH    R1,[R6, #+34]
   \   0000000C   0x9107             STR      R1,[SP, #+28]
     43            int y = GUI_Context.DispPosY;
   \   0000000E   0xF9B6 0x7024      LDRSH    R7,[R6, #+36]
     44            /* do some checking if drawing is actually necessary ... */
     45            const GUI_FONT_MONO GUI_UNI_PTR * pMono = GUI_Context.pAFont->p.pMono;
   \   00000012   0x69B1             LDR      R1,[R6, #+24]
   \   00000014   0xF8D1 0x8018      LDR      R8,[R1, #+24]
     46            unsigned int FirstChar = pMono->FirstChar;
   \   00000018   0xF8B8 0x200C      LDRH     R2,[R8, #+12]
     47            /* translate character into 2 characters to display : c0,c1 */
     48            /* Check if regular character first. */
     49            if ((c >= (U16P)FirstChar) &&(c <= (U16P)pMono->LastChar)) {
   \   0000001C   0x4613             MOV      R3,R2
   \   0000001E   0x4298             CMP      R0,R3
   \   00000020   0xD309             BCC.N    ??GUIMONO_DispChar_0
   \   00000022   0xF8B8 0x300E      LDRH     R3,[R8, #+14]
   \   00000026   0x4283             CMP      R3,R0
   \   00000028   0xD305             BCC.N    ??GUIMONO_DispChar_0
     50              pd = pMono->pData;
   \   0000002A   0xF8D8 0x9000      LDR      R9,[R8, #+0]
     51              c0 = ((int)c) - FirstChar;
   \   0000002E   0x1A84             SUBS     R4,R0,R2
     52              c1 = -1;
   \   00000030   0xF04F 0x35FF      MOV      R5,#-1
   \   00000034   0xE018             B.N      ??GUIMONO_DispChar_1
     53            } else {
     54              /* Check if character is in translation table */
     55              GUI_FONT_TRANSINFO const GUI_UNI_PTR * pti = pMono->pTrans;
   \                     ??GUIMONO_DispChar_0: (+1)
   \   00000036   0xF8D8 0x2008      LDR      R2,[R8, #+8]
     56              pd = pMono->pTransData;
   \   0000003A   0xF8D8 0x9004      LDR      R9,[R8, #+4]
     57              if (pti) {
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD00F             BEQ.N    ??GUIMONO_DispChar_2
     58                FirstChar = pti->FirstChar;
     59                if ((c >= (U16P)FirstChar) && (c <= (U16P)pti->LastChar)) {
   \   00000042   0x8813             LDRH     R3,[R2, #+0]
   \   00000044   0x4298             CMP      R0,R3
   \   00000046   0xD30C             BCC.N    ??GUIMONO_DispChar_2
   \   00000048   0x8854             LDRH     R4,[R2, #+2]
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD309             BCC.N    ??GUIMONO_DispChar_2
     60                  GUI_FONT_TRANSLIST const GUI_UNI_PTR * ptl;
     61                  c -= pti->FirstChar;
     62                  ptl = pti->pList;
     63                  ptl += c;
   \   0000004E   0x1AC0             SUBS     R0,R0,R3
   \   00000050   0xB280             UXTH     R0,R0
   \   00000052   0x6852             LDR      R2,[R2, #+4]
   \   00000054   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
     64                  c0  = ptl->c0;
   \   00000058   0xF9B0 0x4000      LDRSH    R4,[R0, #+0]
     65                  c1  = ptl->c1;
   \   0000005C   0xF9B0 0x5002      LDRSH    R5,[R0, #+2]
   \   00000060   0xE002             B.N      ??GUIMONO_DispChar_1
     66                } else {
     67                  c0 = c1 = -1;
     68                }
     69              } else {
     70                c0 = c1 = -1;
   \                     ??GUIMONO_DispChar_2: (+1)
   \   00000062   0xF04F 0x34FF      MOV      R4,#-1
   \   00000066   0x4625             MOV      R5,R4
     71              }
     72            }
     73            /* Draw first character if it is valid */
     74            if (c0!=-1) {
   \                     ??GUIMONO_DispChar_1: (+1)
   \   00000068   0xF114 0x0F01      CMN      R4,#+1
   \   0000006C   0xD061             BEQ.N    ??GUIMONO_DispChar_3
   \   0000006E   0x7D08             LDRB     R0,[R1, #+20]
   \   00000070   0xF898 0x1012      LDRB     R1,[R8, #+18]
   \   00000074   0x4341             MULS     R1,R1,R0
   \   00000076   0x9109             STR      R1,[SP, #+36]
     75              int BytesPerChar = GUI_Context.pAFont->YSize*pMono->BytesPerLine;
     76              GUI_DRAWMODE DrawMode;
     77              int XSize = pMono->XSize;
   \   00000078   0xF898 0xA010      LDRB     R10,[R8, #+16]
     78              int YSize = GUI_Context.pAFont->YSize;
   \   0000007C   0x9008             STR      R0,[SP, #+32]
     79              /* Select the right drawing mode */
     80              DrawMode = GUI_Context.TextMode;
   \   0000007E   0xF9B6 0xB02A      LDRSH    R11,[R6, #+42]
     81              /* call drawing routine */
     82              {
     83                U8 OldMode = LCD_SetDrawMode(DrawMode);
   \   00000082   0x4658             MOV      R0,R11
   \   00000084   0x.... 0x....      BL       LCD_SetDrawMode
   \   00000088   0xF88D 0x0018      STRB     R0,[SP, #+24]
     84                LCD_DrawBitmap( x, y,
     85                                   XSize, YSize,
     86                                   GUI_Context.pAFont->XMag,  GUI_Context.pAFont->YMag,
     87                                   1,     /* Bits per Pixel */
     88                                   pMono->BytesPerLine,
     89                                   pd + c0* BytesPerChar,
     90                                   &LCD_BKCOLORINDEX
     91                                   );
   \   0000008C   0x69B0             LDR      R0,[R6, #+24]
   \   0000008E   0x9605             STR      R6,[SP, #+20]
   \   00000090   0x9909             LDR      R1,[SP, #+36]
   \   00000092   0xFB01 0x9104      MLA      R1,R1,R4,R9
   \   00000096   0x9104             STR      R1,[SP, #+16]
   \   00000098   0xF898 0x1012      LDRB     R1,[R8, #+18]
   \   0000009C   0x9103             STR      R1,[SP, #+12]
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x9102             STR      R1,[SP, #+8]
   \   000000A2   0xF990 0x1017      LDRSB    R1,[R0, #+23]
   \   000000A6   0x9101             STR      R1,[SP, #+4]
   \   000000A8   0xF990 0x0016      LDRSB    R0,[R0, #+22]
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0x9B08             LDR      R3,[SP, #+32]
   \   000000B0   0x4652             MOV      R2,R10
   \   000000B2   0x4639             MOV      R1,R7
   \   000000B4   0x9807             LDR      R0,[SP, #+28]
   \   000000B6   0x.... 0x....      BL       LCD_DrawBitmap
     92                if (c1 != -1) {
   \   000000BA   0xF115 0x0F01      CMN      R5,#+1
   \   000000BE   0xD01A             BEQ.N    ??GUIMONO_DispChar_4
     93                  LCD_SetDrawMode(DrawMode | LCD_DRAWMODE_TRANS);
   \   000000C0   0xF04B 0x0002      ORR      R0,R11,#0x2
   \   000000C4   0x.... 0x....      BL       LCD_SetDrawMode
     94                  LCD_DrawBitmap( x, y,
     95                                     XSize, YSize,
     96                                     GUI_Context.pAFont->XMag,  GUI_Context.pAFont->YMag,
     97                                     1,     /* Bits per Pixel */
     98                                     pMono->BytesPerLine,
     99                                     pd + c1* BytesPerChar,
    100                                     &LCD_BKCOLORINDEX
    101                                     );
   \   000000C8   0x69B0             LDR      R0,[R6, #+24]
   \   000000CA   0x9605             STR      R6,[SP, #+20]
   \   000000CC   0x9909             LDR      R1,[SP, #+36]
   \   000000CE   0xFB01 0x9105      MLA      R1,R1,R5,R9
   \   000000D2   0x9104             STR      R1,[SP, #+16]
   \   000000D4   0xF898 0x1012      LDRB     R1,[R8, #+18]
   \   000000D8   0x9103             STR      R1,[SP, #+12]
   \   000000DA   0x2101             MOVS     R1,#+1
   \   000000DC   0x9102             STR      R1,[SP, #+8]
   \   000000DE   0xF990 0x1017      LDRSB    R1,[R0, #+23]
   \   000000E2   0x9101             STR      R1,[SP, #+4]
   \   000000E4   0xF990 0x0016      LDRSB    R0,[R0, #+22]
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0x9B08             LDR      R3,[SP, #+32]
   \   000000EC   0x4652             MOV      R2,R10
   \   000000EE   0x4639             MOV      R1,R7
   \   000000F0   0x9807             LDR      R0,[SP, #+28]
   \   000000F2   0x.... 0x....      BL       LCD_DrawBitmap
    102                }
    103                /* Fill empty pixel lines */
    104                if (GUI_Context.pAFont->YDist > GUI_Context.pAFont->YSize) {
   \                     ??GUIMONO_DispChar_4: (+1)
   \   000000F6   0x69B0             LDR      R0,[R6, #+24]
   \   000000F8   0x7D01             LDRB     R1,[R0, #+20]
   \   000000FA   0x7D40             LDRB     R0,[R0, #+21]
   \   000000FC   0x4281             CMP      R1,R0
   \   000000FE   0xD214             BCS.N    ??GUIMONO_DispChar_5
    105                  if (DrawMode != LCD_DRAWMODE_TRANS) {
   \   00000100   0xF1BB 0x0F02      CMP      R11,#+2
   \   00000104   0xD011             BEQ.N    ??GUIMONO_DispChar_5
    106                    LCD_SetDrawMode(DrawMode ^ LCD_DRAWMODE_REV);  /* Reverse so we can fill with BkColor */
   \   00000106   0xF08B 0x0004      EOR      R0,R11,#0x4
   \   0000010A   0x.... 0x....      BL       LCD_SetDrawMode
    107                    LCD_FillRect(x, 
    108                                 y + GUI_Context.pAFont->YSize * GUI_Context.pAFont->YDist, 
    109                                 x + XSize * GUI_Context.pAFont->XMag, 
    110                                 y + GUI_Context.pAFont->YDist);
   \   0000010E   0x69B0             LDR      R0,[R6, #+24]
   \   00000110   0x7D41             LDRB     R1,[R0, #+21]
   \   00000112   0x19CB             ADDS     R3,R1,R7
   \   00000114   0x9A07             LDR      R2,[SP, #+28]
   \   00000116   0xF990 0x4016      LDRSB    R4,[R0, #+22]
   \   0000011A   0xFB04 0x220A      MLA      R2,R4,R10,R2
   \   0000011E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000120   0xFB01 0x7100      MLA      R1,R1,R0,R7
   \   00000124   0x9807             LDR      R0,[SP, #+28]
   \   00000126   0x.... 0x....      BL       LCD_FillRect
    111                  }
    112                }
    113                LCD_SetDrawMode(OldMode);
   \                     ??GUIMONO_DispChar_5: (+1)
   \   0000012A   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000012E   0x.... 0x....      BL       LCD_SetDrawMode
    114              } 
    115            }
    116          //houhh 20061119...
    117          //  GUI_Context.DispPosX+=pMono->XDist;
    118            GUI_Context.DispPosX+=pMono->XDist * GUI_Context.pAFont->XMag;
   \                     ??GUIMONO_DispChar_3: (+1)
   \   00000132   0xF9B6 0x0022      LDRSH    R0,[R6, #+34]
   \   00000136   0xF898 0x1011      LDRB     R1,[R8, #+17]
   \   0000013A   0x69B2             LDR      R2,[R6, #+24]
   \   0000013C   0xF992 0x2016      LDRSB    R2,[R2, #+22]
   \   00000140   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000144   0x8470             STRH     R0,[R6, #+34]
    119          
    120          }
   \   00000146   0xB00B             ADD      SP,SP,#+44
   \   00000148   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    121          
    122          /*********************************************************************
    123          *
    124          *       GUIMONO_GetCharDistX
    125          */

   \                                 In section .text, align 2, keep-with-next
    126          int GUIMONO_GetCharDistX(U16P c) {
   \                     GUIMONO_GetCharDistX: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable1
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x6981             LDR      R1,[R0, #+24]
   \   00000006   0x7C49             LDRB     R1,[R1, #+17]
   \   00000008   0xF990 0x0016      LDRSB    R0,[R0, #+22]
   \   0000000C   0x4348             MULS     R0,R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    127            const GUI_FONT_MONO GUI_UNI_PTR * pMono = GUI_Context.pAFont->p.pMono;
    128            GUI_USE_PARA(c);
    129          //  return pMono->XDist;
    130          //houhh 20061119...
    131            return pMono->XDist*GUI_Context.pAFont->XMag;
    132          
    133          }
    134          
    135          /*********************************************************************
    136          *
    137          *       GUIMONO_GetFontInfo
    138          */

   \                                 In section .text, align 2, keep-with-next
    139          void GUIMONO_GetFontInfo(const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO* pfi) {
    140            GUI_USE_PARA(pFont);
    141            pfi->Flags = GUI_FONTINFO_FLAG_MONO;
   \                     GUIMONO_GetFontInfo: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x8008             STRH     R0,[R1, #+0]
    142          }
   \   00000004   0x4770             BX       LR               ;; return
    143          
    144          /*********************************************************************
    145          *
    146          *       GUIMONO_IsInFont
    147          */

   \                                 In section .text, align 2, keep-with-next
    148          char GUIMONO_IsInFont(const GUI_FONT GUI_UNI_PTR * pFont, U16 c) {
    149            const GUI_FONT_MONO GUI_UNI_PTR * pMono = pFont->p.pMono;
   \                     GUIMONO_IsInFont: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
    150            unsigned int FirstChar = pMono->FirstChar;
    151            /* Check if regular character first. */
    152            if ((c >= (U16P)FirstChar) &&(c <= (U16P)pMono->LastChar)) {
   \   00000002   0x8982             LDRH     R2,[R0, #+12]
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0xD302             BCC.N    ??GUIMONO_IsInFont_0
   \   00000008   0x89C2             LDRH     R2,[R0, #+14]
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD208             BCS.N    ??GUIMONO_IsInFont_1
    153              return 1;  /* Yes, we have it ! */
    154            } else {
    155             /* Check if character is in translation table */
    156              GUI_FONT_TRANSINFO const GUI_UNI_PTR * pti;
    157              pti = pMono->pTrans;
   \                     ??GUIMONO_IsInFont_0: (+1)
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
    158              if (pti) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD007             BEQ.N    ??GUIMONO_IsInFont_2
    159                if ((c >= pti->FirstChar) && (c <= pti->LastChar)) {
   \   00000014   0x8802             LDRH     R2,[R0, #+0]
   \   00000016   0x4291             CMP      R1,R2
   \   00000018   0xD304             BCC.N    ??GUIMONO_IsInFont_2
   \   0000001A   0x8840             LDRH     R0,[R0, #+2]
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD301             BCC.N    ??GUIMONO_IsInFont_2
    160                  return 1;  /* Yes, we have it ! */
   \                     ??GUIMONO_IsInFont_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4770             BX       LR
    161                }
    162              }
    163            }
    164            return 0;  /* No, we can not display this character */
   \                     ??GUIMONO_IsInFont_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
    165          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     GUI_Context
    166          
    167          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      80   GUIMONO_DispChar
        80   -> LCD_DrawBitmap
        80   -> LCD_FillRect
        80   -> LCD_SetDrawMode
       0   GUIMONO_GetCharDistX
       0   GUIMONO_GetFontInfo
       0   GUIMONO_IsInFont


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
     332  GUIMONO_DispChar
      16  GUIMONO_GetCharDistX
       6  GUIMONO_GetFontInfo
      40  GUIMONO_IsInFont

 
 398 bytes in section .text
 
 398 bytes of CODE memory

Errors: none
Warnings: none
