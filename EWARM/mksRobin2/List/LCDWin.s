///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       25/Feb/2020  17:00:47
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\LCDDriver\LCDWin.c
//    Command line =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\LCDDriver\LCDWin.c
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        -lA
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        --diag_suppress Pa050 -o
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
//        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\LCDWin.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        PUBLIC LCDWin_c
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\LCDDriver\LCDWin.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/GUI
//    4 *                        Universal graphic software for embedded applications
//    5 *
//    6 *                       (c) Copyright 2002, Micrium Inc., Weston, FL
//    7 *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
//    8 *
//    9 *              µC/GUI is protected by international copyright laws. Knowledge of the
//   10 *              source code may not be used to write a similar product. This file may
//   11 *              only be used in accordance with a license and should not be redistributed
//   12 *              in any way. We appreciate your understanding and fairness.
//   13 *
//   14 ----------------------------------------------------------------------
//   15 File        : LCDWin.C
//   16 Purpose     : Driver for Simulator under Windows
//   17 ----------------------------------------------------------------------
//   18 Version-Date---Author-Explanation
//   19 ----------------------------------------------------------------------
//   20 2.00a   031007 JE     a) LCD_L0_Init changed, filling not needed at
//   21                          this point
//   22 2.00a   030613 JE     a) Parameter of SETPIXEL checked in debug version
//   23                       b) _DrawBitLine2bpp and _DrawBitLine4bpp reworked
//   24 2.00    010402 RS     a) LCD_GetDevCaps removed from driver
//   25                          (now LCD.c)
//   26 1.30c   000529 JE     a) Interface changed
//   27 1.30b   000428 RS     a) DIB class eliminated
//   28                       b) Internal cleanups, support for high color
//   29 1.30a   000417 RS     a) Major cleanup in DIB class
//   30 1.30    000309 RS     a) Interface change for emWIn V1.30
//   31                          (LCD_L0_SetLUTEntry, LCD_GetDevCap)
//   32 1.10a   000121 RS     a) RECTHEIGHT, RECTWIDTH modified in order to
//   33                          fix bug which would at some time prevent
//   34 												 displaying the first line of the display.
//   35 1.10.00 000110 RS     a) Modifications in order to make it easy to
//   36                          implement driver in any windows program
//   37 1.04.02 991118 RS     a) additional assertion added
//   38                          LCD_MAX_LOG_COLORS
//   39 1.04.01 991018 RS     a) Support for LCD_FIXEDPALETTE added
//   40                          with Anitaliasing enabled
//   41 1.04.00 991013 JE/RS  a) Support for LCD_FIXEDPALETTE added
//   42                       b) Driver now accepts the same LCDConf.h as
//   43 											   the embedded system
//   44 											c) Bugfix for ..
//   45 1.02.02 990831 RS     a) Small optimization added for 16-color bitmaps
//   46 1.02.01 990726 RS     a) Transparency support for 16-color bitmpas
//   47                          added
//   48 1.02.00 990212 RS     a) New interface version 1.02 supported
//   49 1.00    990118 RS     First release
//   50 ----------------------------------------------------------------------
//   51 Known problems or limitations with current version
//   52 ----------------------------------------------------------------------
//   53 ---------------------------END-OF-HEADER------------------------------
//   54 */
//   55 
//   56 #if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
//   57 
//   58 #include <windows.h>
//   59 #include "LCD.h"
//   60 #include "LCD_Private.h"              /* include LCDConf.h */
//   61 #include "LCDSIM.h"
//   62 #include "GUI_Private.h"
//   63 
//   64 #include "memory.h"
//   65 
//   66 /*********************************************************************
//   67 *
//   68 *       Defines
//   69 *
//   70 **********************************************************************
//   71 */
//   72 
//   73 #if LCD_BITSPERPIXEL <= 8
//   74   #define PIXELINDEX U8
//   75 #else
//   76   #define PIXELINDEX WORD
//   77 #endif
//   78 
//   79 #ifdef WIN32
//   80   #ifndef ASSERT
//   81     #define ASSERT(Val) \ 
//   82     if (!(Val)) \ 
//   83       MessageBox(NULL,"...in file "__FILE__,"Assertion failed...",MB_OK);
//   84   #endif
//   85 #endif
//   86 
//   87 #ifdef LCD_ASSERT
//   88   #undef LCD_ASSERT
//   89 #endif
//   90 #define LCD_ASSERT(v) ASSERT(v)
//   91 
//   92 #ifndef LCD_DISPLAY_INDEX
//   93   #define LCD_DISPLAY_INDEX 0
//   94 #endif
//   95 
//   96 /*********************************************************************
//   97 *
//   98 *       Macros for internal use
//   99 */
//  100 #ifdef _DEBUG
//  101 static int _CheckBound(unsigned int c) {
//  102   unsigned int NumColors = LCD_BITSPERPIXEL > 8 ? 0xffff : (1 << LCD_BITSPERPIXEL) - 1;
//  103   if (c > NumColors) {
//  104     GUI_DEBUG_ERROROUT("LCDWin::SETPIXEL: parameters out of bounds");
//  105     return 1;
//  106   }
//  107   return 0;
//  108 }
//  109 
//  110   #define SETPIXEL(x, y, c) \ 
//  111     if (!_CheckBound(c)) { \ 
//  112       LCDSIM_SetPixelIndex(x, y, c, LCD_DISPLAY_INDEX); \ 
//  113     }
//  114 #else
//  115   #define SETPIXEL(x, y, c) LCDSIM_SetPixelIndex(x, y, c, LCD_DISPLAY_INDEX)
//  116 #endif
//  117 #define XORPIXEL(x, y)    _XorPixel(x,y)
//  118 
//  119 /*********************************************************************
//  120 *
//  121 *       Static code
//  122 *
//  123 **********************************************************************
//  124 */
//  125 
//  126 /*********************************************************************
//  127 *
//  128 *       _XorPixel
//  129 */
//  130 static void _XorPixel(int x, int y) {
//  131   unsigned int Index = LCD_L0_GetPixelIndex(x,y);
//  132   LCDSIM_SetPixelIndex(x, y, LCD_NUM_COLORS-1-Index, LCD_DISPLAY_INDEX);
//  133 }
//  134 
//  135 /*********************************************************************
//  136 *
//  137 *       _DrawBitLine1BPP
//  138 */
//  139 static void _DrawBitLine1BPP(int x, int y, U8 const*p, int Diff, int xsize, const LCD_PIXELINDEX*pTrans) {
//  140   LCD_PIXELINDEX Index0 = *(pTrans+0);
//  141   LCD_PIXELINDEX Index1 = *(pTrans+1);
//  142   x+=Diff;
//  143   switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS|LCD_DRAWMODE_XOR)) {
//  144   case 0:    /* Write mode */
//  145     do {
//  146       LCDSIM_SetPixelIndex(x++,y, (*p & (0x80>>Diff)) ? Index1 : Index0, LCD_DISPLAY_INDEX);
//  147 			if (++Diff==8) {
//  148         Diff=0;
//  149 				p++;
//  150 			}
//  151 		} while (--xsize);
//  152     break;
//  153   case LCD_DRAWMODE_TRANS:
//  154     do {
//  155   		if (*p & (0x80>>Diff))
//  156         LCDSIM_SetPixelIndex(x,y, Index1, LCD_DISPLAY_INDEX);
//  157       x++;
//  158 			if (++Diff==8) {
//  159         Diff=0;
//  160 				p++;
//  161 			}
//  162 		} while (--xsize);
//  163     break;
//  164   case LCD_DRAWMODE_XOR:;
//  165     do {
//  166   		if (*p & (0x80>>Diff)) {
//  167         int Pixel = LCDSIM_GetPixelIndex(x,y, LCD_DISPLAY_INDEX);
//  168         LCDSIM_SetPixelIndex(x,y, LCD_NUM_COLORS-1-Pixel, LCD_DISPLAY_INDEX);
//  169       }
//  170       x++;
//  171 			if (++Diff==8) {
//  172         Diff=0;
//  173 				p++;
//  174 			}
//  175 		} while (--xsize);
//  176     break;
//  177 	}
//  178 }
//  179 
//  180 /*********************************************************************
//  181 *
//  182 *       _DrawBitLine2BPP
//  183 */
//  184 #if (LCD_MAX_LOG_COLORS > 2)
//  185 static void _DrawBitLine2BPP(int x, int y, U8 const * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
//  186   LCD_PIXELINDEX Pixels = *p;
//  187   int CurrentPixel = Diff;
//  188   x += Diff;
//  189   switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
//  190     case 0:
//  191       if (pTrans) {
//  192         do {
//  193           int Shift = (3 - CurrentPixel) << 1;
//  194           int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  195           LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
//  196           SETPIXEL(x++, y, PixelIndex);
//  197           if (++CurrentPixel == 4) {
//  198             CurrentPixel = 0;
//  199             Pixels = *(++p);
//  200           }
//  201 		    } while (--xsize);
//  202       } else {
//  203         do {
//  204           int Shift = (3 - CurrentPixel) << 1;
//  205           int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  206           SETPIXEL(x++, y, Index);
//  207           if (++CurrentPixel == 4) {
//  208             CurrentPixel = 0;
//  209             Pixels = *(++p);
//  210           }
//  211 		    } while (--xsize);
//  212       }
//  213       break;
//  214     case LCD_DRAWMODE_TRANS:
//  215       if (pTrans) {
//  216         do {
//  217           int Shift = (3 - CurrentPixel) << 1;
//  218           int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  219           if (Index) {
//  220             LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
//  221             SETPIXEL(x, y, PixelIndex);
//  222           }
//  223           x++;
//  224           if (++CurrentPixel == 4) {
//  225             CurrentPixel = 0;
//  226             Pixels = *(++p);
//  227           }
//  228 		    } while (--xsize);
//  229       } else {
//  230         do {
//  231           int Shift = (3 - CurrentPixel) << 1;
//  232           int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  233           if (Index) {
//  234             SETPIXEL(x, y, Index);
//  235           }
//  236           x++;
//  237           if (++CurrentPixel == 4) {
//  238             CurrentPixel = 0;
//  239             Pixels = *(++p);
//  240           }
//  241 		    } while (--xsize);
//  242       }
//  243       break;
//  244   }
//  245 }
//  246 #endif
//  247 
//  248 /*********************************************************************
//  249 *
//  250 *       _DrawBitLine4BPP
//  251 */
//  252 #if (LCD_MAX_LOG_COLORS > 4)
//  253 static void _DrawBitLine4BPP(int x, int y, U8 const * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
//  254   LCD_PIXELINDEX Pixels = *p;
//  255   int CurrentPixel = Diff;
//  256   x += Diff;
//  257   switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
//  258     case 0:
//  259       if (pTrans) {
//  260         do {
//  261           int Shift = (1 - CurrentPixel) << 2;
//  262           int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  263           LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
//  264           SETPIXEL(x++, y, PixelIndex);
//  265           if (++CurrentPixel == 2) {
//  266             CurrentPixel = 0;
//  267             Pixels = *(++p);
//  268           }
//  269 		    } while (--xsize);
//  270       } else {
//  271         do {
//  272           int Shift = (1 - CurrentPixel) << 2;
//  273           int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  274           SETPIXEL(x++, y, Index);
//  275           if (++CurrentPixel == 2) {
//  276             CurrentPixel = 0;
//  277             Pixels = *(++p);
//  278           }
//  279 		    } while (--xsize);
//  280       }
//  281       break;
//  282     case LCD_DRAWMODE_TRANS:
//  283       if (pTrans) {
//  284         do {
//  285           int Shift = (1 - CurrentPixel) << 2;
//  286           int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  287           if (Index) {
//  288             LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
//  289             SETPIXEL(x, y, PixelIndex);
//  290           }
//  291           x++;
//  292           if (++CurrentPixel == 2) {
//  293             CurrentPixel = 0;
//  294             Pixels = *(++p);
//  295           }
//  296 		    } while (--xsize);
//  297       } else {
//  298         do {
//  299           int Shift = (1 - CurrentPixel) << 2;
//  300           int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  301           if (Index) {
//  302             SETPIXEL(x, y, Index);
//  303           }
//  304           x++;
//  305           if (++CurrentPixel == 2) {
//  306             CurrentPixel = 0;
//  307             Pixels = *(++p);
//  308           }
//  309 		    } while (--xsize);
//  310       }
//  311       break;
//  312   }
//  313 }
//  314 #endif
//  315 
//  316 /*********************************************************************
//  317 *
//  318 *       _DrawBitLine8BPP
//  319 */
//  320 #if (LCD_MAX_LOG_COLORS > 16)
//  321 static void _DrawBitLine8BPP(int x, int y, U8 const*p, int xsize, const LCD_PIXELINDEX*pTrans) {
//  322   LCD_PIXELINDEX pixel;
//  323   if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS)==0) {
//  324     if (pTrans) {
//  325       for (;xsize > 0; xsize--,x++,p++) {
//  326         pixel = *p;
//  327         SETPIXEL(x, y, *(pTrans+pixel));
//  328       }
//  329     } else {
//  330       for (;xsize > 0; xsize--,x++,p++) {
//  331         SETPIXEL(x, y, *p);
//  332       }
//  333     }
//  334   } else {   /* Handle transparent bitmap */
//  335     if (pTrans) {
//  336       for (; xsize > 0; xsize--, x++, p++) {
//  337         pixel = *p;
//  338         if (pixel) {
//  339           SETPIXEL(x+0, y, *(pTrans+pixel));
//  340         }
//  341       }
//  342     } else {
//  343       for (; xsize > 0; xsize--, x++, p++) {
//  344         pixel = *p;
//  345         if (pixel) {
//  346           SETPIXEL(x+0, y, pixel);
//  347         }
//  348       }
//  349     }
//  350   }
//  351 }
//  352 #endif
//  353 
//  354 /*********************************************************************
//  355 *
//  356 *       _DrawBitLine16BPP
//  357 */
//  358 #if (LCD_BITSPERPIXEL > 8)
//  359 static void _DrawBitLine16BPP(int x, int y, U16 const*p, int xsize, const LCD_PIXELINDEX*pTrans) {
//  360   LCD_PIXELINDEX pixel;
//  361   if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS)==0) {
//  362     if (pTrans) {
//  363       for (;xsize > 0; xsize--,x++,p++) {
//  364         pixel = *p;
//  365         SETPIXEL(x, y, *(pTrans+pixel));
//  366       }
//  367     } else {
//  368       for (;xsize > 0; xsize--,x++,p++) {
//  369         SETPIXEL(x, y, *p);
//  370       }
//  371     }
//  372   } else {   /* Handle transparent bitmap */
//  373     if (pTrans) {
//  374       for (; xsize > 0; xsize--, x++, p++) {
//  375         pixel = *p;
//  376         if (pixel) {
//  377           SETPIXEL(x+0, y, *(pTrans+pixel));
//  378         }
//  379       }
//  380     } else {
//  381       for (; xsize > 0; xsize--, x++, p++) {
//  382         pixel = *p;
//  383         if (pixel) {
//  384           SETPIXEL(x+0, y, pixel);
//  385         }
//  386       }
//  387     }
//  388   }
//  389 }
//  390 #endif
//  391 
//  392 /*********************************************************************
//  393 *
//  394 *       Exported code
//  395 *
//  396 **********************************************************************
//  397 */
//  398 
//  399 /*********************************************************************
//  400 *
//  401 *       LCD_L0_DrawPixel
//  402 *
//  403 *  Purpose:  Writes 1 pixel into the display.
//  404 */
//  405 void LCD_L0_DrawPixel(int x, int y) {
//  406   if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
//  407     XORPIXEL(x, y);
//  408   } else {
//  409     SETPIXEL(x, y, LCD_COLORINDEX);
//  410   }
//  411 }
//  412 
//  413 /*********************************************************************
//  414 *
//  415 *       LCD_L0_DrawHLine
//  416 */
//  417 void LCD_L0_DrawHLine(int x0, int y,  int x1) {
//  418   if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
//  419     for (;x0 <= x1; x0++) {
//  420       XORPIXEL(x0, y);
//  421     }
//  422   } else {
//  423     for (;x0 <= x1; x0++) {
//  424       SETPIXEL(x0, y, LCD_COLORINDEX);
//  425     }
//  426   }
//  427 }
//  428 
//  429 /*********************************************************************
//  430 *
//  431 *       LCD_L0_DrawVLine
//  432 */
//  433 void LCD_L0_DrawVLine(int x, int y0,  int y1) {
//  434   if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
//  435     while (y0 <= y1) {
//  436       XORPIXEL(x, y0);
//  437       y0++;
//  438     }
//  439   } else {
//  440     while (y0 <= y1) {
//  441       SETPIXEL(x, y0, LCD_COLORINDEX);
//  442       y0++;
//  443     }
//  444   }
//  445 }
//  446 
//  447 /*********************************************************************
//  448 *
//  449 *       LCD_L0_FillRect
//  450 */
//  451 void LCD_L0_FillRect(int x0, int y0, int x1, int y1) {
//  452   for (; y0 <= y1; y0++) {
//  453     LCD_L0_DrawHLine(x0,y0, x1);
//  454   }
//  455 }
//  456 
//  457 /*********************************************************************
//  458 *
//  459 *       LCD_L0_DrawBitmap
//  460 */
//  461 void LCD_L0_DrawBitmap(int x0, int y0,
//  462                        int xsize, int ysize,
//  463                        int BitsPerPixel, 
//  464                        int BytesPerLine,
//  465                        const U8* pData, int Diff,
//  466                        const LCD_PIXELINDEX* pTrans)
//  467 {
//  468   int i;
//  469   /*
//  470      Use DrawBitLineXBPP
//  471   */
//  472   for (i=0; i<ysize; i++) {
//  473     switch (BitsPerPixel) {
//  474     case 1:
//  475       _DrawBitLine1BPP(x0, i+y0, pData, Diff, xsize, pTrans);
//  476       break;
//  477     #if (LCD_MAX_LOG_COLORS > 2)
//  478       case 2:
//  479         _DrawBitLine2BPP(x0, i+y0, pData, Diff, xsize, pTrans);
//  480         break;
//  481     #endif
//  482     #if (LCD_MAX_LOG_COLORS > 4)
//  483       case 4:
//  484         _DrawBitLine4BPP(x0, i+y0, pData, Diff, xsize, pTrans);
//  485         break;
//  486     #endif
//  487     #if (LCD_MAX_LOG_COLORS > 16)
//  488       case 8:
//  489         _DrawBitLine8BPP(x0, i+y0, pData, xsize, pTrans);
//  490         break;
//  491     #endif
//  492     #if (LCD_BITSPERPIXEL > 8)
//  493       case 16:
//  494         _DrawBitLine16BPP(x0, i+y0, (const U16 *)pData, xsize, pTrans);
//  495         break;
//  496     #endif
//  497     }
//  498     pData += BytesPerLine;
//  499   }
//  500 }
//  501 
//  502 /*********************************************************************
//  503 *
//  504 *       LCD_L0_DrawBitmap
//  505 *
//  506 *  Purpose:
//  507 *    Sets the original position of the virtual display.
//  508 *    Has no function at this point with the PC-driver.
//  509 */
//  510 void LCD_L0_SetOrg(int x, int y) {
//  511   GUI_USE_PARA(x);
//  512   GUI_USE_PARA(y);
//  513 }
//  514 
//  515 /*********************************************************************
//  516 *
//  517 *       Support for verification
//  518 *
//  519 *  Purpose:
//  520 *    The following routines are implemented, but have no functionility
//  521 *    at this point. The reason is that these functions are supposed
//  522 *    to supervise the hardware, which for obvious reasons can not be
//  523 *    done in a simulation.
//  524 */
//  525 #if LCD_VERIFY
//  526 int  LCD_GetErrStat(void) {
//  527   return 0;
//  528 }
//  529 void LCD_ClrErrStat(void) {
//  530 }
//  531 int  LCD_GetErrCnt (void) {
//  532   return 0;
//  533 }
//  534 #endif  
//  535 
//  536 /*********************************************************************
//  537 *
//  538 *       LCD_On
//  539 *       LCD_Off
//  540 *
//  541 *  (Not supported in Simulation)
//  542 */
//  543 void LCD_Off          (void) {}
//  544 void LCD_On           (void) {}
//  545 
//  546 /*********************************************************************
//  547 *
//  548 *       LCD_L0_SetLUTEntry
//  549 */
//  550 void LCD_L0_SetLUTEntry(U8 Pos, LCD_COLOR color) {
//  551   LCDSIM_SetLUTEntry(Pos, color, LCD_DISPLAY_INDEX);
//  552 }
//  553 
//  554 /*********************************************************************
//  555 *
//  556 *       LCD_L0_Init
//  557 */
//  558 int  LCD_L0_Init(void) {
//  559 	return 0;
//  560 }
//  561 
//  562 int  LCD_L0_CheckInit(void) {
//  563   return 0;
//  564 } 
//  565 
//  566 /*********************************************************************
//  567 *
//  568 *       LCD_L0_ReInit
//  569 *
//  570 *  Purpose:
//  571 *    This routine is supplied for compatibility and interchangability of
//  572 *    "C"-sources with embedded versions of the driver. It has no real
//  573 *    effect in the PC-version as there is simply no need to re-initialize
//  574 *    the LCD since it is just simulated anyhow.
//  575 */
//  576 void LCD_L0_ReInit       (void) {}
//  577 
//  578 unsigned LCD_L0_GetPixelIndex(int x, int y)  {
//  579   return LCDSIM_GetPixelIndex(x,y, LCD_DISPLAY_INDEX);
//  580 }
//  581 
//  582 /*********************************************************************
//  583 *
//  584 *       LCD_L0_XorPixel
//  585 *
//  586 *  Purpose:
//  587 *    Inverts 1 pixel of the display.
//  588 */
//  589 void LCD_L0_XorPixel(int x, int y) {
//  590   XORPIXEL(x, y);
//  591 }
//  592 
//  593 /*********************************************************************
//  594 *
//  595 *       LCD_L0_SetPixelIndex
//  596 *
//  597 *  Purpose:
//  598 *    Writes 1 pixel into the display.
//  599 */
//  600 void LCD_L0_SetPixelIndex(int x, int y, int ColorIndex) {
//  601   SETPIXEL(x, y, ColorIndex);
//  602 }
//  603 
//  604 #else
//  605   void LCDWin_c(void);

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function LCDWin_c
          CFI NoCalls
        THUMB
//  606   void LCDWin_c(void) { } /* avoid empty object files */
LCDWin_c:
        BX       LR               ;; return
          CFI EndBlock cfiBlock0

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
//  607 #endif /* defined(WIN32) && defined(LCD_USE_WINSIM) */
//  608 
//  609 
//  610 
// 
// 2 bytes in section .text
// 
// 2 bytes of CODE memory
//
//Errors: none
//Warnings: none
