///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       25/Feb/2020  18:23:05
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    Command line =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        -lA
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        --diag_suppress Pa050 -o
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\..\Middlewares\GUI\
//        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\Marlin_main.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__CPP_Language", "EC++"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__iar_require _Printf", "floats,int_specials,widths"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1
        #define SHT_INIT_ARRAY 0xe

        EXTERN AT24CXX_Read
        EXTERN BMP_PIC_X
        EXTERN BMP_PIC_Y
        EXTERN DeviceCode
        EXTERN GUI_DispStringAt
        EXTERN GUI_Exec
        EXTERN GUI_Init
        EXTERN GUI_RefreshPage
        EXTERN GUI_SetBkColor
        EXTERN GUI_SetColor
        EXTERN GUI_TOUCH_Exec
        EXTERN GUI_UC_SetEncodeUTF8
        EXTERN HAL_Delay
        EXTERN HAL_GPIO_ReadPin
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_GetTick
        EXTERN IsChooseAutoShutdown
        EXTERN SD_Init
        EXTERN SD_Path
        EXTERN Serial3
        EXTERN _Z10safe_delaym
        EXTERN _Z12wifi_loopingv
        EXTERN _Z14mksBeeperAlarmv
        EXTERN _Z17serial_echopair_PPKcS0_
        EXTERN _Z17serial_echopair_PPKcd
        EXTERN _Z17serial_echopair_PPKcf
        EXTERN _Z17serial_echopair_PPKci
        EXTERN _Z17serial_echopair_PPKcm
        EXTERN _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        EXTERN _Z21Close_machine_displayv
        EXTERN _Z22finish_incremental_LSFP15linear_fit_data
        EXTERN _Z23PowerOff_Filament_Checkv
        EXTERN _Z9gcode_G26v
        EXTERN _ZN10CardReader10removeFileEPc
        EXTERN _ZN10CardReader10reopenfileEPc
        EXTERN _ZN10CardReader11openLogFileEPc
        EXTERN _ZN10CardReader11stopSDPrintEv
        EXTERN _ZN10CardReader12checkFilesysEh
        EXTERN _ZN10CardReader12pauseSDPrintEv
        EXTERN _ZN10CardReader13write_commandEPc
        EXTERN _ZN10CardReader14checkautostartEb
        EXTERN _ZN10CardReader14startFileprintEv
        EXTERN _ZN10CardReader19printingHasFinishedEv
        EXTERN _ZN10CardReader2lsEv
        EXTERN _ZN10CardReader6initsdEv
        EXTERN _ZN10CardReader7releaseEv
        EXTERN _ZN10CardReader8getsdposEv
        EXTERN _ZN10CardReader8openFileEPcbb
        EXTERN _ZN10CardReader9closefileEb
        EXTERN _ZN10CardReader9getStatusEv
        EXTERN _ZN10CardReaderC1Ev
        EXTERN _ZN10USARTClass11MoremenuCmdEv
        EXTERN _ZN10USARTClass4readEv
        EXTERN _ZN10USARTClass5flushEv
        EXTERN _ZN10USARTClass5writeEh
        EXTERN _ZN10USARTClass9availableEv
        EXTERN _ZN10matrix_3x314create_look_atE8vector_3
        EXTERN _ZN10matrix_3x315set_to_identityEv
        EXTERN _ZN10matrix_3x35debugEPKc
        EXTERN _ZN10matrix_3x39transposeES_
        EXTERN _ZN11GCodeParser10string_argE
        EXTERN _ZN11GCodeParser11command_ptrE
        EXTERN _ZN11GCodeParser14command_letterE
        EXTERN _ZN11GCodeParser18volumetric_enabledE
        EXTERN _ZN11GCodeParser21unknown_command_errorEv
        EXTERN _ZN11GCodeParser5paramE
        EXTERN _ZN11GCodeParser5parseEPc
        EXTERN _ZN11GCodeParser7codenumE
        EXTERN _ZN11GCodeParser8codebitsE
        EXTERN _ZN11GCodeParser9value_ptrE
        EXTERN _ZN11Temperature12PID_autotuneEfaab
        EXTERN _ZN11Temperature13manage_heaterEv
        EXTERN _ZN11Temperature16extrude_min_tempE
        EXTERN _ZN11Temperature18allow_cold_extrudeE
        EXTERN _ZN11Temperature18print_heaterstatesEv
        EXTERN _ZN11Temperature18start_watching_bedEv
        EXTERN _ZN11Temperature18target_temperatureE
        EXTERN _ZN11Temperature19current_temperatureE
        EXTERN _ZN11Temperature19disable_all_heatersEv
        EXTERN _ZN11Temperature19next_temp_report_msE
        EXTERN _ZN11Temperature21start_watching_heaterEh
        EXTERN _ZN11Temperature22target_temperature_bedE
        EXTERN _ZN11Temperature23current_temperature_bedE
        EXTERN _ZN11Temperature24auto_report_temperaturesEv
        EXTERN _ZN11Temperature25auto_report_temp_intervalE
        EXTERN _ZN11Temperature2KdE
        EXTERN _ZN11Temperature2KiE
        EXTERN _ZN11Temperature2KpE
        EXTERN _ZN11Temperature4initEv
        EXTERN _ZN11Temperature5bedKdE
        EXTERN _ZN11Temperature5bedKiE
        EXTERN _ZN11Temperature5bedKpE
        EXTERN _ZN14MarlinSettings15calc_num_meshesEv
        EXTERN _ZN14MarlinSettings4loadEv
        EXTERN _ZN14MarlinSettings4saveEv
        EXTERN _ZN14MarlinSettings5resetEv
        EXTERN _ZN14MarlinSettings6reportEb
        EXTERN _ZN14MarlinSettings9load_meshEaPv
        EXTERN _ZN17mesh_bed_leveling13index_to_xposE
        EXTERN _ZN17mesh_bed_leveling13index_to_yposE
        EXTERN _ZN17mesh_bed_leveling5resetEv
        EXTERN _ZN17mesh_bed_leveling8has_meshE
        EXTERN _ZN17mesh_bed_leveling8z_offsetE
        EXTERN _ZN17mesh_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_leveling11display_mapEi
        EXTERN _ZN20unified_bed_leveling12storage_slotE
        EXTERN _ZN20unified_bed_leveling13gcode_G29_UBLEv
        EXTERN _ZN20unified_bed_leveling19_mesh_index_to_xposE
        EXTERN _ZN20unified_bed_leveling19_mesh_index_to_yposE
        EXTERN _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        EXTERN _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        EXTERN _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        EXTERN _ZN20unified_bed_leveling5resetEv
        EXTERN _ZN20unified_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_levelingC1Ev
        EXTERN _ZN5Print5printEPKc
        EXTERN _ZN5Print5printEdi
        EXTERN _ZN5Print5printEhi
        EXTERN _ZN5Print5printEii
        EXTERN _ZN5Print5printEli
        EXTERN _ZN7Planner11last_fade_zE
        EXTERN _ZN7Planner12accelerationE
        EXTERN _ZN7Planner13filament_sizeE
        EXTERN _ZN7Planner13z_fade_heightE
        EXTERN _ZN7Planner14apply_levelingERfS0_S0_
        EXTERN _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        EXTERN _ZN7Planner15flow_percentageE
        EXTERN _ZN7Planner15leveling_activeE
        EXTERN _ZN7Planner15set_position_mmE8AxisEnumRKf
        EXTERN _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        EXTERN _ZN7Planner16bed_level_matrixE
        EXTERN _ZN7Planner16unapply_levelingEPf
        EXTERN _ZN7Planner17axis_steps_per_mmE
        EXTERN _ZN7Planner17block_buffer_headE
        EXTERN _ZN7Planner17block_buffer_tailE
        EXTERN _ZN7Planner17max_feedrate_mm_sE
        EXTERN _ZN7Planner17min_feedrate_mm_sE
        EXTERN _ZN7Planner18autotemp_M104_M109Ev
        EXTERN _ZN7Planner19check_axes_activityEv
        EXTERN _ZN7Planner19min_segment_time_usE
        EXTERN _ZN7Planner19refresh_positioningEv
        EXTERN _ZN7Planner19travel_accelerationE
        EXTERN _ZN7Planner20retract_accelerationE
        EXTERN _ZN7Planner21inverse_z_fade_heightE
        EXTERN _ZN7Planner21volumetric_multiplierE
        EXTERN _ZN7Planner24min_travel_feedrate_mm_sE
        EXTERN _ZN7Planner24reset_acceleration_ratesEv
        EXTERN _ZN7Planner25set_position_mm_kinematicERA4_Kf
        EXTERN _ZN7Planner26max_acceleration_mm_per_s2E
        EXTERN _ZN7Planner29max_acceleration_steps_per_s2E
        EXTERN _ZN7Planner32calculate_volumetric_multipliersEv
        EXTERN _ZN7Planner8e_factorE
        EXTERN _ZN7Planner8max_jerkE
        EXTERN _ZN7Planner8positionE
        EXTERN _ZN7Stepper10quick_stopEv
        EXTERN _ZN7Stepper11synchronizeEv
        EXTERN _ZN7Stepper14locked_z_motorE
        EXTERN _ZN7Stepper15locked_z2_motorE
        EXTERN _ZN7Stepper16report_positionsEv
        EXTERN _ZN7Stepper17performing_homingE
        EXTERN _ZN7Stepper18finish_and_disableEv
        EXTERN _ZN7Stepper20get_axis_position_mmE8AxisEnum
        EXTERN _ZN7Stepper4initEv
        EXTERN _ZN8Endstops12report_stateEv
        EXTERN _ZN8Endstops15z_probe_enabledE
        EXTERN _ZN8Endstops16enabled_globallyE
        EXTERN _ZN8Endstops16endstop_hit_bitsE
        EXTERN _ZN8Endstops4M119Ev
        EXTERN _ZN8Endstops7enabledE
        EXTERN _ZN8vector_310get_normalEv
        EXTERN _ZN8vector_314apply_rotationE10matrix_3x3
        EXTERN _ZN8vector_35crossES_S_
        EXTERN _ZN8vector_3C1Efff
        EXTERN _ZN8vector_3miES_
        EXTERN _ZN9Stopwatch4stopEv
        EXTERN _ZN9Stopwatch5pauseEv
        EXTERN _ZN9Stopwatch5startEv
        EXTERN _ZN9Stopwatch7getTimeEPmS0_S0_
        EXTERN _ZN9Stopwatch8durationEv
        EXTERN _ZN9Stopwatch9isRunningEv
        EXTERN _ZN9StopwatchC1Ev
        EXTERN __aeabi_cdrcmple
        EXTERN __aeabi_cfcmpeq
        EXTERN __aeabi_cfcmple
        EXTERN __aeabi_cfrcmple
        EXTERN __aeabi_d2f
        EXTERN __aeabi_d2iz
        EXTERN __aeabi_d2uiz
        EXTERN __aeabi_dadd
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_dsub
        EXTERN __aeabi_f2d
        EXTERN __aeabi_f2iz
        EXTERN __aeabi_f2uiz
        EXTERN __aeabi_fadd
        EXTERN __aeabi_fdiv
        EXTERN __aeabi_fmul
        EXTERN __aeabi_fsub
        EXTERN __aeabi_i2d
        EXTERN __aeabi_i2f
        EXTERN __aeabi_memclr4
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_ui2d
        EXTERN __aeabi_ui2f
        EXTERN __iar_FDtest
        EXTERN __iar_Strchr
        EXTERN __iar_Strrchr
        EXTERN __iar_Strstr
        EXTERN abs
        EXTERN atan2f
        EXTERN atof
        EXTERN atoi
        EXTERN clear_cur_ui
        EXTERN cos
        EXTERN cosf
        EXTERN curFileName
        EXTERN default_preview_flg
        EXTERN disp_pre_gcode
        EXTERN disp_state_stack
        EXTERN draw_dialog
        EXTERN draw_printing
        EXTERN draw_ready_print
        EXTERN draw_return_ui
        EXTERN echomagic
        EXTERN epr_read_data
        EXTERN epr_write_data
        EXTERN errormagic
        EXTERN espGcodeFifo
        EXTERN f_close
        EXTERN f_lseek
        EXTERN f_open
        EXTERN f_printf
        EXTERN f_read
        EXTERN filament_det1_cnt
        EXTERN filament_det1_flg
        EXTERN filament_det1_high_cnt
        EXTERN filament_det1_high_flg
        EXTERN filament_det1_low_cnt
        EXTERN filament_det1_low_flg
        EXTERN filament_det2_cnt
        EXTERN filament_det2_flg
        EXTERN filament_det2_high_cnt
        EXTERN filament_det2_high_flg
        EXTERN filament_det2_low_cnt
        EXTERN filament_det2_low_flg
        EXTERN filament_rate
        EXTERN flash_preview_begin
        EXTERN floor
        EXTERN floorf
        EXTERN free
        EXTERN from_flash_pic
        EXTERN gArrayGpioPin
        EXTERN gArrayGpioPort
        EXTERN gCfgItems
        EXTERN getTick
        EXTERN getTickDiff
        EXTERN gui_view_init
        EXTERN ipPara
        EXTERN leveling_first_time
        EXTERN logo_tick1
        EXTERN logo_tick2
        EXTERN lroundf
        EXTERN malloc
        EXTERN memcmp
        EXTERN memcpy
        EXTERN memset
        EXTERN mksCfg
        EXTERN mksTmp
        EXTERN parser
        EXTERN pause_resum
        EXTERN poweroff_det_cnt
        EXTERN poweroff_det_flg
        EXTERN poweroff_det_high_cnt
        EXTERN poweroff_det_high_flg
        EXTERN poweroff_det_low_cnt
        EXTERN poweroff_det_low_flg
        EXTERN preview_gcode_prehandle
        EXTERN print_time
        EXTERN rand
        EXTERN reset_file_info
        EXTERN reset_print_time
        EXTERN sin
        EXTERN sinf
        EXTERN sprintf
        EXTERN sqrt
        EXTERN sqrtf
        EXTERN start_print_time
        EXTERN stop_print_time
        EXTERN strcat
        EXTERN strcmp
        EXTERN strcpy
        EXTERN strncpy
        EXTERN strtod
        EXTERN strtol
        EXTERN strtoul
        EXTERN temperature_change_frequency
        EXTERN thermalManager
        EXTERN wifiPara
        EXTERN wifi_check_time
        EXTERN wifi_link_state

        PUBLIC EXTI9_5_IRQHandler
        PUBLIC L1
        PUBLIC L2
        PUBLIC Running
        PUBLIC TimeIncrease
        PUBLIC _Z10freeMemoryv
        PUBLIC _Z10gcode_M104v
        PUBLIC _Z10gcode_M105v
        PUBLIC _Z10gcode_M106v
        PUBLIC _Z10gcode_M107v
        PUBLIC _Z10gcode_M108v
        PUBLIC _Z10gcode_M109v
        PUBLIC _Z10gcode_M110v
        PUBLIC _Z10gcode_M111v
        PUBLIC _Z10gcode_M112v
        PUBLIC _Z10gcode_M113v
        PUBLIC _Z10gcode_M114v
        PUBLIC _Z10gcode_M115v
        PUBLIC _Z10gcode_M117v
        PUBLIC _Z10gcode_M118v
        PUBLIC _Z10gcode_M119v
        PUBLIC _Z10gcode_M120v
        PUBLIC _Z10gcode_M121v
        PUBLIC _Z10gcode_M140v
        PUBLIC _Z10gcode_M155v
        PUBLIC _Z10gcode_M190v
        PUBLIC _Z10gcode_M200v
        PUBLIC _Z10gcode_M201v
        PUBLIC _Z10gcode_M203v
        PUBLIC _Z10gcode_M204v
        PUBLIC _Z10gcode_M205v
        PUBLIC _Z10gcode_M206v
        PUBLIC _Z10gcode_M211v
        PUBLIC _Z10gcode_M218v
        PUBLIC _Z10gcode_M220v
        PUBLIC _Z10gcode_M221v
        PUBLIC _Z10gcode_M226v
        PUBLIC _Z10gcode_M280v
        PUBLIC _Z10gcode_M301v
        PUBLIC _Z10gcode_M302v
        PUBLIC _Z10gcode_M303v
        PUBLIC _Z10gcode_M304v
        PUBLIC _Z10gcode_M355v
        PUBLIC _Z10gcode_M360v
        PUBLIC _Z10gcode_M361v
        PUBLIC _Z10gcode_M362v
        PUBLIC _Z10gcode_M363v
        PUBLIC _Z10gcode_M364v
        PUBLIC _Z10gcode_M400v
        PUBLIC _Z10gcode_M401v
        PUBLIC _Z10gcode_M402v
        PUBLIC _Z10gcode_M410v
        PUBLIC _Z10gcode_M420v
        PUBLIC _Z10gcode_M428v
        PUBLIC _Z10gcode_M500v
        PUBLIC _Z10gcode_M501v
        PUBLIC _Z10gcode_M502v
        PUBLIC _Z10gcode_M503v
        PUBLIC _Z10gcode_M665v
        PUBLIC _Z10gcode_M666v
        PUBLIC _Z10gcode_M851v
        PUBLIC _Z10gcode_M907v
        PUBLIC _Z10gcode_M928v
        PUBLIC _Z10gcode_M998v
        PUBLIC _Z10gcode_M999v
        PUBLIC _Z10home_deltav
        PUBLIC _Z10lcd_reInitv
        PUBLIC _Z10lcd_updatev
        PUBLIC _Z10ok_to_sendv
        PUBLIC _Z10servo_initv
        PUBLIC _Z11gcode_G0_G1v
        PUBLIC _Z11gcode_G2_G3b
        PUBLIC _Z11lcd_refreshv
        PUBLIC _Z11tool_changehfb
        PUBLIC _Z12ADJUST_DELTAPKf
        PUBLIC _Z13gcode_G29_UBLv
        PUBLIC _Z13gcode_M18_M84v
        PUBLIC _Z13home_all_axesv
        PUBLIC _Z13lcd_hasstatusv
        PUBLIC _Z13lcd_setstatusPKcb
        PUBLIC _Z13setup_killpinv
        PUBLIC _Z14do_probe_raisef
        PUBLIC _Z14host_keepalivev
        PUBLIC _Z14mks_WriteToEprv
        PUBLIC _Z14serialprintPGMPKc
        PUBLIC _Z15_commit_commandb
        PUBLIC _Z15_enqueuecommandPKcb
        PUBLIC _Z15_manual_goto_xyRKfS0_
        PUBLIC _Z15bltouch_commandi
        PUBLIC _Z15gcode_M666_dualv
        PUBLIC _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        PUBLIC _Z15mbl_mesh_reportv
        PUBLIC _Z15mks_setFeedratev
        PUBLIC _Z15reset_bed_levelv
        PUBLIC _Z15setup_powerholdv
        PUBLIC _Z16display_sd_errorv
        PUBLIC _Z16echo_not_enteredv
        PUBLIC _Z16gcode_line_errorPKcb
        PUBLIC _Z16lcd_setstatusPGMPKca
        PUBLIC _Z16mks_get_commandsv
        PUBLIC _Z17SCARA_move_to_calhh
        PUBLIC _Z17bilinear_z_offsetPKf
        PUBLIC _Z17gcode_G0_G1_SCARAb
        PUBLIC _Z17get_wifi_commandsv
        PUBLIC _Z17leveling_is_validv
        PUBLIC _Z17manage_inactivityb
        PUBLIC _Z17mkstft_ui_set_eprv
        PUBLIC _Z17quickstop_stepperv
        PUBLIC _Z17refresh_bed_levelv
        PUBLIC _Z17serial_echopair_PPKcb
        PUBLIC _Z17set_z_fade_heightfb
        PUBLIC _Z17temper_error_killv
        PUBLIC _Z18axis_unhomed_errorbbb
        PUBLIC _Z18disable_e_steppersv
        PUBLIC _Z18inverse_kinematicsPKf
        PUBLIC _Z18mks_ResetPositionZf
        PUBLIC _Z18mks_leveling_moveZf
        PUBLIC _Z18mks_moveZ_relativef
        PUBLIC _Z18mks_setTemperaturev
        PUBLIC _Z18out_of_range_errorPKc
        PUBLIC _Z18set_probe_deployedb
        PUBLIC _Z18setup_filrunoutpinv
        PUBLIC _Z18sync_plan_positionv
        PUBLIC _Z19clear_command_queuev
        PUBLIC _Z19do_blocking_move_toRKfS0_S0_S0_
        PUBLIC _Z19enable_all_steppersv
        PUBLIC _Z19get_sdcard_commandsv
        PUBLIC _Z19get_serial_commandsv
        PUBLIC _Z19mks_leveling_moveXYff
        PUBLIC _Z19refresh_cmd_timeoutv
        PUBLIC _Z20SysTick_Handler_Userv
        PUBLIC _Z20disable_all_steppersv
        PUBLIC _Z20disable_noZ_steppersv
        PUBLIC _Z20display_temper_errorv
        PUBLIC _Z20process_next_commandv
        PUBLIC _Z20set_bltouch_deployedb
        PUBLIC _Z20sync_plan_position_ev
        PUBLIC _Z21do_blocking_move_to_xRKfS0_
        PUBLIC _Z21do_blocking_move_to_zRKfS0_
        PUBLIC _Z21gcode_get_destinationv
        PUBLIC _Z21incremental_LSF_resetP15linear_fit_data
        PUBLIC _Z21lcd_reset_alert_levelv
        PUBLIC _Z21lcd_setalertstatusPGMPKc
        PUBLIC _Z21mks_WriteToEpr_pwroffv
        PUBLIC _Z21recalc_delta_settingsv
        PUBLIC _Z21soft_endstop_min_initv
        PUBLIC _Z22do_blocking_move_to_xyRKfS0_S0_
        PUBLIC _Z22get_available_commandsv
        PUBLIC _Z22handle_filament_runoutv
        PUBLIC _Z22invalid_extruder_errorh
        PUBLIC _Z22mks_ReadFromEpr_pwroffv
        PUBLIC _Z22process_parsed_commandv
        PUBLIC _Z23report_current_positionv
        PUBLIC _Z24FlushSerialRequestResendv
        PUBLIC _Z24enqueue_and_echo_commandPKcb
        PUBLIC _Z24forward_kinematics_DELTAPf
        PUBLIC _Z24forward_kinematics_DELTAfff
        PUBLIC _Z24forward_kinematics_SCARARKfS0_
        PUBLIC _Z24get_homing_bump_feedrate8AxisEnum
        PUBLIC _Z24mesh_line_to_destinationfhh
        PUBLIC _Z24set_bed_leveling_enabledb
        PUBLIC _Z24update_software_endstops8AxisEnum
        PUBLIC _Z25prepare_kinematic_move_toRA4_Kf
        PUBLIC _Z26buffer_line_to_destinationf
        PUBLIC _Z26clamp_to_software_endstopsPf
        PUBLIC _Z27enqueue_and_echo_commands_PPKc
        PUBLIC _Z27gcode_G29_MESH_BED_LEVELINGv
        PUBLIC _Z27get_cartesian_from_steppersv
        PUBLIC _Z27prepare_move_to_destinationv
        PUBLIC _Z28SYNC_PLAN_POSITION_KINEMATICv
        PUBLIC _Z28bilinear_line_to_destinationftt
        PUBLIC _Z28delta_safe_distance_from_topv
        PUBLIC _Z28gcode_M421_MESH_BED_LEVELINGv
        PUBLIC _Z28set_current_from_destinationv
        PUBLIC _Z28set_destination_from_currentv
        PUBLIC _Z28sync_plan_position_kinematicv
        PUBLIC _Z31buffer_line_to_current_positionv
        PUBLIC _Z31inverse_kinematics_MORGAN_SCARAPKf
        PUBLIC _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        PUBLIC _Z32get_target_extruder_from_commandt
        PUBLIC _Z34position_is_reachable_IS_CARTESIANRKfS0_
        PUBLIC _Z34position_is_reachable_IS_KINEMATICRKfS0_
        PUBLIC _Z34set_current_from_steppers_for_axis8AxisEnum
        PUBLIC _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        PUBLIC _Z37prepare_move_to_destination_cartesianv
        PUBLIC _Z42prepare_uninterpolated_move_to_destinationf
        PUBLIC _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        PUBLIC _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        PUBLIC _Z4idlev
        PUBLIC _Z4killPKc
        PUBLIC _Z4stopv
        PUBLIC _Z5dwellm
        PUBLIC _Z6Beeperj
        PUBLIC _Z6strchrPci
        PUBLIC _Z6strstrPcPKc
        PUBLIC _Z7gcode_Th
        PUBLIC _Z7mks_G28Pc
        PUBLIC _Z7pft_getv
        PUBLIC _Z7strrchrPci
        PUBLIC _Z7suicidev
        PUBLIC _Z8gcode_G4v
        PUBLIC _Z8lcd_initv
        PUBLIC _Z8plan_arcRA4_KfRA2_S_b
        PUBLIC _Z8probe_ptRKfS0_bhb
        PUBLIC _Z9IsRunningv
        PUBLIC _Z9IsStoppedv
        PUBLIC _Z9gcode_G28b
        PUBLIC _Z9gcode_G29v
        PUBLIC _Z9gcode_G30v
        PUBLIC _Z9gcode_G42v
        PUBLIC _Z9gcode_G92v
        PUBLIC _Z9gcode_M17v
        PUBLIC _Z9gcode_M20v
        PUBLIC _Z9gcode_M22v
        PUBLIC _Z9gcode_M23v
        PUBLIC _Z9gcode_M24v
        PUBLIC _Z9gcode_M25v
        PUBLIC _Z9gcode_M26v
        PUBLIC _Z9gcode_M27v
        PUBLIC _Z9gcode_M28v
        PUBLIC _Z9gcode_M29v
        PUBLIC _Z9gcode_M30v
        PUBLIC _Z9gcode_M31v
        PUBLIC _Z9gcode_M32v
        PUBLIC _Z9gcode_M42v
        PUBLIC _Z9gcode_M49v
        PUBLIC _Z9gcode_M75v
        PUBLIC _Z9gcode_M76v
        PUBLIC _Z9gcode_M77v
        PUBLIC _Z9gcode_M81v
        PUBLIC _Z9gcode_M82v
        PUBLIC _Z9gcode_M83v
        PUBLIC _Z9gcode_M85v
        PUBLIC _Z9gcode_M92v
        PUBLIC _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        PUBLIC _ZN10CardReader10isFileOpenEv
        PUBLIC _ZN10CardReader3eofEv
        PUBLIC _ZN10CardReader3getEv
        PUBLIC _ZN10CardReader8setIndexEl
        PUBLIC _ZN10duration_tC1ERKj
        PUBLIC _ZN11GCodeParser10celsiusvalEcf
        PUBLIC _ZN11GCodeParser10value_boolEv
        PUBLIC _ZN11GCodeParser10value_byteEv
        PUBLIC _ZN11GCodeParser10value_longEv
        PUBLIC _ZN11GCodeParser11value_floatEv
        PUBLIC _ZN11GCodeParser11value_ulongEv
        PUBLIC _ZN11GCodeParser12value_millisEv
        PUBLIC _ZN11GCodeParser12value_ushortEv
        PUBLIC _ZN11GCodeParser13value_celsiusEv
        PUBLIC _ZN11GCodeParser14value_feedrateEv
        PUBLIC _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        PUBLIC _ZN11GCodeParser18value_linear_unitsEv
        PUBLIC _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        PUBLIC _ZN11GCodeParser25value_millis_from_secondsEv
        PUBLIC _ZN11GCodeParser4seenEc
        PUBLIC _ZN11GCodeParser6intvalEcs
        PUBLIC _ZN11GCodeParser7boolvalEc
        PUBLIC _ZN11GCodeParser7bytevalEch
        PUBLIC _ZN11GCodeParser7seenvalEc
        PUBLIC _ZN11GCodeParser9has_valueEv
        PUBLIC _ZN11GCodeParser9linearvalEcf
        PUBLIC _ZN11GCodeParser9ushortvalEct
        PUBLIC _ZN11GCodeParser9value_intEv
        PUBLIC _ZN11Temperature12degTargetBedEv
        PUBLIC _ZN11Temperature12isCoolingBedEv
        PUBLIC _ZN11Temperature12setTargetBedEf
        PUBLIC _ZN11Temperature15degTargetHotendEh
        PUBLIC _ZN11Temperature15isCoolingHotendEh
        PUBLIC _ZN11Temperature15setTargetHotendEfh
        PUBLIC _ZN11Temperature16tooColdToExtrudeEh
        PUBLIC _ZN11Temperature24set_auto_report_intervalEh
        PUBLIC _ZN11Temperature6degBedEv
        PUBLIC _ZN11Temperature9degHotendEh
        PUBLIC _ZN11Temperature9updatePIDEv
        PUBLIC _ZN17mesh_bed_leveling12cell_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling12cell_index_yERKf
        PUBLIC _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_yERKf
        PUBLIC _ZN17mesh_bed_leveling5set_zEaaRKf
        PUBLIC _ZN17mesh_bed_leveling6zigzagEaRaS0_
        PUBLIC _ZN20unified_bed_leveling13mesh_is_validEv
        PUBLIC _ZN20unified_bed_leveling18mesh_index_to_xposEh
        PUBLIC _ZN20unified_bed_leveling18mesh_index_to_yposEh
        PUBLIC _ZN7Planner11buffer_lineEfffRKfS1_h
        PUBLIC _ZN7Planner13blocks_queuedEv
        PUBLIC _ZN7Planner14apply_levelingERA3_f
        PUBLIC _ZN7Planner15set_position_mmEfffRKf
        PUBLIC _ZN7Planner16refresh_e_factorEh
        PUBLIC _ZN7Planner17force_fade_recalcEv
        PUBLIC _ZN7Planner17set_e_position_mmERKf
        PUBLIC _ZN7Planner17set_filament_sizeEhRKf
        PUBLIC _ZN7Planner17set_z_fade_heightERKf
        PUBLIC _ZN7Planner20leveling_active_at_zERKf
        PUBLIC _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        PUBLIC _ZN7Stepper10set_z_lockEb
        PUBLIC _ZN7Stepper11set_z2_lockEb
        PUBLIC _ZN7Stepper17set_homing_flag_zEb
        PUBLIC _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        PUBLIC _ZN8Endstops10not_homingEv
        PUBLIC _ZN8Endstops14enable_z_probeEb
        PUBLIC _ZN8Endstops14hit_on_purposeEv
        PUBLIC _ZN8Endstops15enable_globallyEb
        PUBLIC _ZN8Endstops6enableEb
        PUBLIC _ZNK10duration_t3dayEv
        PUBLIC _ZNK10duration_t4hourEv
        PUBLIC _ZNK10duration_t4yearEv
        PUBLIC _ZNK10duration_t6minuteEv
        PUBLIC _ZNK10duration_t6secondEv
        PUBLIC _ZNK10duration_t8toStringEPc
        PUBLIC _ZTI5Print
        PUBLIC _ZZ10gcode_M104vEs
        PUBLIC _ZZ10gcode_M104vEs_0
        PUBLIC _ZZ10gcode_M104vEs_1
        PUBLIC _ZZ10gcode_M104vEs_2
        PUBLIC _ZZ10gcode_M104vEs_3
        PUBLIC _ZZ10gcode_M104vEs_4
        PUBLIC _ZZ10gcode_M105vEs
        PUBLIC _ZZ10gcode_M109vEs
        PUBLIC _ZZ10gcode_M109vEs_0
        PUBLIC _ZZ10gcode_M109vEs_1
        PUBLIC _ZZ10gcode_M109vEs_2
        PUBLIC _ZZ10gcode_M109vEs_3
        PUBLIC _ZZ10gcode_M109vEs_4
        PUBLIC _ZZ10gcode_M109vEs_5
        PUBLIC _ZZ10gcode_M109vEs_6
        PUBLIC _ZZ10gcode_M111vE11str_debug_1
        PUBLIC _ZZ10gcode_M111vE11str_debug_2
        PUBLIC _ZZ10gcode_M111vE11str_debug_4
        PUBLIC _ZZ10gcode_M111vE11str_debug_8
        PUBLIC _ZZ10gcode_M111vE12str_debug_16
        PUBLIC _ZZ10gcode_M111vE13debug_strings
        PUBLIC _ZZ10gcode_M111vEs_4
        PUBLIC _ZZ10gcode_M111vEs_5
        PUBLIC _ZZ10gcode_M112vEs
        PUBLIC _ZZ10gcode_M113vEs
        PUBLIC _ZZ10gcode_M115vEs
        PUBLIC _ZZ10gcode_M115vEs_0
        PUBLIC _ZZ10gcode_M115vEs_1
        PUBLIC _ZZ10gcode_M115vEs_2
        PUBLIC _ZZ10gcode_M115vEs_3
        PUBLIC _ZZ10gcode_M115vEs_4
        PUBLIC _ZZ10gcode_M115vEs_5
        PUBLIC _ZZ10gcode_M115vEs_6
        PUBLIC _ZZ10gcode_M115vEs_7
        PUBLIC _ZZ10gcode_M115vEs_8
        PUBLIC _ZZ10gcode_M115vEs_9
        PUBLIC _ZZ10gcode_M115vEs__10_
        PUBLIC _ZZ10gcode_M115vEs__11_
        PUBLIC _ZZ10gcode_M115vEs__12_
        PUBLIC _ZZ10gcode_M115vEs__13_
        PUBLIC _ZZ10gcode_M118vEs
        PUBLIC _ZZ10gcode_M190vEs
        PUBLIC _ZZ10gcode_M190vEs_0
        PUBLIC _ZZ10gcode_M190vEs_1
        PUBLIC _ZZ10gcode_M204vEs
        PUBLIC _ZZ10gcode_M204vEs_0
        PUBLIC _ZZ10gcode_M204vEs_1
        PUBLIC _ZZ10gcode_M204vEs_2
        PUBLIC _ZZ10gcode_M211vEs
        PUBLIC _ZZ10gcode_M211vEs_0
        PUBLIC _ZZ10gcode_M211vEs_1
        PUBLIC _ZZ10gcode_M211vEs_2
        PUBLIC _ZZ10gcode_M211vEs_3
        PUBLIC _ZZ10gcode_M211vEs_4
        PUBLIC _ZZ10gcode_M211vEs_5
        PUBLIC _ZZ10gcode_M211vEs_6
        PUBLIC _ZZ10gcode_M218vEs
        PUBLIC _ZZ10gcode_M280vEs
        PUBLIC _ZZ10gcode_M280vEs_0
        PUBLIC _ZZ10gcode_M280vEs_1
        PUBLIC _ZZ10gcode_M301vEs
        PUBLIC _ZZ10gcode_M301vEs_0
        PUBLIC _ZZ10gcode_M301vEs_1
        PUBLIC _ZZ10gcode_M301vEs_2
        PUBLIC _ZZ10gcode_M302vEs
        PUBLIC _ZZ10gcode_M302vEs_0
        PUBLIC _ZZ10gcode_M302vEs_1
        PUBLIC _ZZ10gcode_M302vEs_2
        PUBLIC _ZZ10gcode_M302vEs_3
        PUBLIC _ZZ10gcode_M303vEs
        PUBLIC _ZZ10gcode_M304vEs
        PUBLIC _ZZ10gcode_M304vEs_0
        PUBLIC _ZZ10gcode_M304vEs_1
        PUBLIC _ZZ10gcode_M355vEs
        PUBLIC _ZZ10gcode_M360vEs
        PUBLIC _ZZ10gcode_M361vEs
        PUBLIC _ZZ10gcode_M362vEs
        PUBLIC _ZZ10gcode_M363vEs
        PUBLIC _ZZ10gcode_M364vEs
        PUBLIC _ZZ10gcode_M420vEs
        PUBLIC _ZZ10gcode_M420vEs_0
        PUBLIC _ZZ10gcode_M420vEs_1
        PUBLIC _ZZ10gcode_M420vEs_2
        PUBLIC _ZZ10gcode_M420vEs_3
        PUBLIC _ZZ10gcode_M420vEs_4
        PUBLIC _ZZ10gcode_M420vEs_5
        PUBLIC _ZZ10gcode_M420vEs_6
        PUBLIC _ZZ10gcode_M420vEs_7
        PUBLIC _ZZ10gcode_M420vEs_8
        PUBLIC _ZZ10gcode_M420vEs_9
        PUBLIC _ZZ10gcode_M420vEs__10_
        PUBLIC _ZZ10gcode_M420vEs__11_
        PUBLIC _ZZ10gcode_M428vEs
        PUBLIC _ZZ10gcode_M428vEs_0
        PUBLIC _ZZ10gcode_M428vEs_1
        PUBLIC _ZZ10gcode_M851vEs
        PUBLIC _ZZ10gcode_M851vEs_0
        PUBLIC _ZZ10gcode_M851vEs_1
        PUBLIC _ZZ10home_deltavEs
        PUBLIC _ZZ10home_deltavEs_0
        PUBLIC _ZZ11gcode_G2_G3bEs
        PUBLIC _ZZ15gcode_M666_dualvEs
        PUBLIC _ZZ15gcode_M666_dualvEs_0
        PUBLIC _ZZ17get_wifi_commandsvE16wifi_line_buffer
        PUBLIC _ZZ17get_wifi_commandsvE17wifi_comment_mode
        PUBLIC _ZZ17get_wifi_commandsvEs
        PUBLIC _ZZ17get_wifi_commandsvEs_0
        PUBLIC _ZZ17get_wifi_commandsvEs_1
        PUBLIC _ZZ17get_wifi_commandsvEs_2
        PUBLIC _ZZ17get_wifi_commandsvEs_3
        PUBLIC _ZZ17get_wifi_commandsvEs_4
        PUBLIC _ZZ19get_sdcard_commandsvE14stop_buffering
        PUBLIC _ZZ19get_sdcard_commandsvE15sd_comment_mode
        PUBLIC _ZZ19get_sdcard_commandsvEs
        PUBLIC _ZZ19get_sdcard_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvE14last_wait_time
        PUBLIC _ZZ19get_serial_commandsvE18serial_line_buffer
        PUBLIC _ZZ19get_serial_commandsvE19serial_comment_mode
        PUBLIC _ZZ19get_serial_commandsvEs
        PUBLIC _ZZ19get_serial_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvEs_1
        PUBLIC _ZZ19get_serial_commandsvEs_2
        PUBLIC _ZZ19get_serial_commandsvEs_3
        PUBLIC _ZZ19get_serial_commandsvEs_4
        PUBLIC _ZZ19get_serial_commandsvEs_5
        PUBLIC _ZZ19get_serial_commandsvEs_6
        PUBLIC _ZZ19get_serial_commandsvEs_7
        PUBLIC _ZZ19get_serial_commandsvEs_8
        PUBLIC _ZZ22invalid_extruder_errorhEs
        PUBLIC _ZZ24get_homing_bump_feedrate8AxisEnumEs
        PUBLIC _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
        PUBLIC _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
        PUBLIC _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
        PUBLIC _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
        PUBLIC _ZZ8gcode_G4vEs
        PUBLIC _ZZ9gcode_G29vEs
        PUBLIC _ZZ9gcode_G29vEs_0
        PUBLIC _ZZ9gcode_G29vEs_1
        PUBLIC _ZZ9gcode_G29vEs_2
        PUBLIC _ZZ9gcode_G29vEs_3
        PUBLIC _ZZ9gcode_G29vEs_4
        PUBLIC _ZZ9gcode_G29vEs_5
        PUBLIC _ZZ9gcode_G29vEs_6
        PUBLIC _ZZ9gcode_G29vEs_7
        PUBLIC _ZZ9gcode_G29vEs_8
        PUBLIC _ZZ9gcode_G29vEs_9
        PUBLIC _ZZ9gcode_G29vEs__10_
        PUBLIC _ZZ9gcode_G29vEs__11_
        PUBLIC _ZZ9gcode_G29vEs__12_
        PUBLIC _ZZ9gcode_G29vEs__13_
        PUBLIC _ZZ9gcode_G29vEs__14_
        PUBLIC _ZZ9gcode_G29vEs__15_
        PUBLIC _ZZ9gcode_G29vEs__16_
        PUBLIC _ZZ9gcode_G29vEs__17_
        PUBLIC _ZZ9gcode_G29vEs__18_
        PUBLIC _ZZ9gcode_G30vEs
        PUBLIC _ZZ9gcode_G30vEs_0
        PUBLIC _ZZ9gcode_G30vEs_1
        PUBLIC _ZZ9gcode_G42vEs
        PUBLIC _ZZ9gcode_M17vEs
        PUBLIC _ZZ9gcode_M20vEs
        PUBLIC _ZZ9gcode_M20vEs_0
        PUBLIC _ZZ9gcode_M31vEs
        PUBLIC _ZZ9gcode_M42vEs
        PUBLIC _ZZ9gcode_M49vEs
        PUBLIC _ZZ9gcode_M49vEs_0
        PUBLIC _ZZ9gcode_M49vEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs_0
        PUBLIC _ZZNK10duration_t8toStringEPcEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs_2
        PUBLIC _ZZNK10duration_t8toStringEPcEs_3
        PUBLIC active_extruder
        PUBLIC axis_homed
        PUBLIC axis_known_position
        PUBLIC axis_relative_modes
        PUBLIC base_home_pos_P
        PUBLIC base_max_pos_P
        PUBLIC base_min_pos_P
        PUBLIC beep_cnt
        PUBLIC beep_flg
        PUBLIC bilinear_grid_factor
        PUBLIC bilinear_grid_spacing
        PUBLIC bilinear_start
        PUBLIC busy_state
        PUBLIC button_disp_pause_state
        PUBLIC card
        PUBLIC cartes
        PUBLIC cloud_refresh_flg
        PUBLIC commands_in_queue
        PUBLIC continue_print_error_flg
        PUBLIC current_position
        PUBLIC delta
        PUBLIC delta_calibration_radius
        PUBLIC delta_clip_start_height
        PUBLIC delta_diagonal_rod
        PUBLIC delta_diagonal_rod_2_tower
        PUBLIC delta_endstop_adj
        PUBLIC delta_height
        PUBLIC delta_radius
        PUBLIC delta_segments_per_second
        PUBLIC delta_tower
        PUBLIC delta_tower_angle_trim
        PUBLIC destination
        PUBLIC display_hold
        PUBLIC display_hold_cnt
        PUBLIC display_hold_release
        PUBLIC fanSpeeds
        PUBLIC feedrate_mm_s
        PUBLIC feedrate_percentage
        PUBLIC filament_heat_completed_load
        PUBLIC filament_heat_completed_unload
        PUBLIC filament_loading_completed
        PUBLIC filament_loading_time_cnt
        PUBLIC filament_loading_time_flg
        PUBLIC filament_unloading_completed
        PUBLIC filament_unloading_time_cnt
        PUBLIC filament_unloading_time_flg
        PUBLIC from_wifi_flag
        PUBLIC g26_debug_flag
        PUBLIC home_bump_mm_P
        PUBLIC home_dir_P
        PUBLIC home_offset
        PUBLIC homing_feedrate_mm_s
        PUBLIC host_keepalive_interval
        PUBLIC hotend_offset
        PUBLIC kill_c
        PUBLIC lcd_wait_for_move
        PUBLIC loop
        PUBLIC loop_start
        PUBLIC marlin_debug_flags
        PUBLIC max_length_P
        PUBLIC mksReprint
        PUBLIC mks_PrintStatePolling
        PUBLIC mks_ReadFromEpr
        PUBLIC mks_ReadFromFile
        PUBLIC mks_WriteToFile
        PUBLIC mks_clearDir
        PUBLIC mks_clearFile
        PUBLIC mks_contiuePrintDelta
        PUBLIC mks_contiuePrintPause
        PUBLIC mks_contiuePrintPwdwn
        PUBLIC mks_contiuePrint_UI
        PUBLIC mks_getPositionXYZE
        PUBLIC mks_heating_busy
        PUBLIC mks_home_moveXY
        PUBLIC mks_home_moveZ
        PUBLIC mks_initPrint
        PUBLIC mks_manual_leveling
        PUBLIC mks_moveXY
        PUBLIC mks_moveZ
        PUBLIC mks_pausePrint
        PUBLIC mks_pft_name
        PUBLIC mks_preExtrude
        PUBLIC mks_rePrintCheck
        PUBLIC mks_resumePrint
        PUBLIC mks_saveFileName
        PUBLIC mks_setPositionZ
        PUBLIC mkstft_ui_init
        PUBLIC mkstft_ui_load
        PUBLIC position_shift
        PUBLIC preview_no_display
        PUBLIC previous_cmd_ms
        PUBLIC print_finish_close_machine
        PUBLIC print_finish_start_timer
        PUBLIC print_finish_timer_count
        PUBLIC print_job_timer
        PUBLIC printing_rate_update_flag
        PUBLIC saved_feedrate_percentage
        PUBLIC sd_read_cnt
        PUBLIC sd_read_error_flg
        PUBLIC serial_wait_tick
        PUBLIC setup
        PUBLIC soft_endstop_max
        PUBLIC soft_endstop_min
        PUBLIC soft_endstop_radius
        PUBLIC soft_endstop_radius_2
        PUBLIC soft_endstops_enabled
        PUBLIC t1
        PUBLIC t12
        PUBLIC t2
        PUBLIC target_extruder
        PUBLIC temper_error_flg
        PUBLIC temper_error_type
        PUBLIC ubl
        PUBLIC wait_for_heatup
        PUBLIC waiting_wifi_time
        PUBLIC wifi_init_flg
        PUBLIC wifi_init_state
        PUBLIC wifi_loop_cycle
        PUBLIC wifi_refresh_flg
        PUBLIC workspace_offset
        PUBLIC xy_probe_feedrate_mm_s
        PUBLIC z_endstop_adj
        PUBLIC z_high_count
        PUBLIC z_values
        PUBLIC zprobe_zoffset
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    1 /**
//    2  * Marlin 3D Printer Firmware
//    3  * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
//    4  *
//    5  * Based on Sprinter and grbl.
//    6  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
//    7  *
//    8  * This program is free software: you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation, either version 3 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License
//   19  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
//   20  *
//   21  */
//   22 
//   23 /**
//   24  * About Marlin
//   25  *
//   26  * This firmware is a mashup between Sprinter and grbl.
//   27  *  - https://github.com/kliment/Sprinter
//   28  *  - https://github.com/simen/grbl/tree
//   29  */
//   30 
//   31 /**
//   32  * -----------------
//   33  * G-Codes in Marlin
//   34  * -----------------
//   35  *
//   36  * Helpful G-code references:
//   37  *  - http://linuxcnc.org/handbook/gcode/g-code.html
//   38  *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
//   39  *
//   40  * Help to document Marlin's G-codes online:
//   41  *  - http://reprap.org/wiki/G-code
//   42  *  - https://github.com/MarlinFirmware/MarlinDocumentation
//   43  *
//   44  * -----------------
//   45  *
//   46  * "G" Codes
//   47  *
//   48  * G0   -> G1
//   49  * G1   - Coordinated Movement X Y Z E
//   50  * G2   - CW ARC
//   51  * G3   - CCW ARC
//   52  * G4   - Dwell S<seconds> or P<milliseconds>
//   53  * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
//   54  * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
//   55  * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
//   56  * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
//   57  * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
//   58  * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
//   59  * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
//   60  * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
//   61  * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
//   62  * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
//   63  * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
//   64  * G28  - Home one or more axes
//   65  * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
//   66  * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
//   67  * G31  - Dock sled (Z_PROBE_SLED only)
//   68  * G32  - Undock sled (Z_PROBE_SLED only)
//   69  * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
//   70  * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
//   71  * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
//   72  * G90  - Use Absolute Coordinates
//   73  * G91  - Use Relative Coordinates
//   74  * G92  - Set current position to coordinates given
//   75  *
//   76  * "M" Codes
//   77  *
//   78  * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
//   79  * M1   -> M0
//   80  * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
//   81  * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
//   82  * M5   - Turn laser/spindle off
//   83  * M17  - Enable/Power all stepper motors
//   84  * M18  - Disable all stepper motors; same as M84
//   85  * M20  - List SD card. (Requires SDSUPPORT)
//   86  * M21  - Init SD card. (Requires SDSUPPORT)
//   87  * M22  - Release SD card. (Requires SDSUPPORT)
//   88  * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
//   89  * M24  - Start/resume SD print. (Requires SDSUPPORT)
//   90  * M25  - Pause SD print. (Requires SDSUPPORT)
//   91  * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
//   92  * M27  - Report SD print status. (Requires SDSUPPORT)
//   93  * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
//   94  * M29  - Stop SD write. (Requires SDSUPPORT)
//   95  * M30  - Delete file from SD: "M30 /path/file.gco"
//   96  * M31  - Report time since last M109 or SD card start to serial.
//   97  * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
//   98  *        Use P to run other files as sub-programs: "M32 P !filename#"
//   99  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
//  100  * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
//  101  * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
//  102  * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
//  103  * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
//  104  * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
//  105  * M75  - Start the print job timer.
//  106  * M76  - Pause the print job timer.
//  107  * M77  - Stop the print job timer.
//  108  * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
//  109  * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
//  110  * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
//  111  * M82  - Set E codes absolute (default).
//  112  * M83  - Set E codes relative while in Absolute (G90) mode.
//  113  * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
//  114  *        duration after which steppers should turn off. S0 disables the timeout.
//  115  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
//  116  * M92  - Set planner.axis_steps_per_mm for one or more axes.
//  117  * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
//  118  * M104 - Set extruder target temp.
//  119  * M105 - Report current temperatures.
//  120  * M106 - Set print fan speed.
//  121  * M107 - Print fan off.
//  122  * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
//  123  * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
//  124  *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
//  125  *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
//  126  * M110 - Set the current line number. (Used by host printing)
//  127  * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
//  128  * M112 - Emergency stop.
//  129  * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
//  130  * M114 - Report current position.
//  131  * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
//  132  * M117 - Display a message on the controller screen. (Requires an LCD)
//  133  * M118 - Display a message in the host console.
//  134  * M119 - Report endstops status.
//  135  * M120 - Enable endstops detection.
//  136  * M121 - Disable endstops detection.
//  137  * M122 - Debug stepper (Requires HAVE_TMC2130)
//  138  * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
//  139  * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
//  140  * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
//  141  * M128 - EtoP Open. (Requires BARICUDA)
//  142  * M129 - EtoP Closed. (Requires BARICUDA)
//  143  * M140 - Set bed target temp. S<temp>
//  144  * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
//  145  * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
//  146  * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
//  147  * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
//  148  * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
//  149  * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
//  150  * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
//  151  * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
//  152  *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
//  153  * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
//  154  * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
//  155  * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
//  156  * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
//  157  * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
//  158  * M205 - Set advanced settings. Current units apply:
//  159             S<print> T<travel> minimum speeds
//  160             B<minimum segment time>
//  161             X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
//  162  * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  163  * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
//  164  * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
//  165  * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
//  166           Every normal extrude-only move will be classified as retract depending on the direction.
//  167  * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
//  168  * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
//  169  * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
//  170  * M221 - Set Flow Percentage: "M221 S<percent>"
//  171  * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
//  172  * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
//  173  * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
//  174  * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
//  175  * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
//  176  * M280 - Set servo position absolute: "M280 P<index> S<angle|¬µs>". (Requires servos)
//  177  * M290 - Babystepping (Requires BABYSTEPPING)
//  178  * M300 - Play beep sound S<frequency Hz> P<duration ms>
//  179  * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
//  180  * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
//  181  * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
//  182  * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
//  183  * M350 - Set microstepping mode. (Requires digital microstepping pins.)
//  184  * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
//  185  * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
//  186  * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
//  187  * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
//  188  * M400 - Finish all moves.
//  189  * M401 - Lower Z probe. (Requires a probe)
//  190  * M402 - Raise Z probe. (Requires a probe)
//  191  * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
//  192  * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
//  193  * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
//  194  * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
//  195  * M410 - Quickstop. Abort all planned moves.
//  196  * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
//  197  * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
//  198  * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  199  * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
//  200  * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
//  201  * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
//  202  * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
//  203  * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
//  204  * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
//  205  * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
//  206  * M666 - Set delta endstop adjustment. (Requires DELTA)
//  207  * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
//  208  * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
//  209  * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
//  210  * M860 - Report the position of position encoder modules.
//  211  * M861 - Report the status of position encoder modules.
//  212  * M862 - Perform an axis continuity test for position encoder modules.
//  213  * M863 - Perform steps-per-mm calibration for position encoder modules.
//  214  * M864 - Change position encoder module I2C address.
//  215  * M865 - Check position encoder module firmware version.
//  216  * M866 - Report or reset position encoder module error count.
//  217  * M867 - Enable/disable or toggle error correction for position encoder modules.
//  218  * M868 - Report or set position encoder module error correction threshold.
//  219  * M869 - Report position encoder module error.
//  220  * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
//  221  * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  222  * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
//  223  * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
//  224  * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
//  225  * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
//  226  * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  227  * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  228  * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
//  229  * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
//  230  *
//  231  * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
//  232  * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
//  233  * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
//  234  * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
//  235  * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
//  236  *
//  237  * ************ Custom codes - This can change to suit future G-code regulations
//  238  * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
//  239  * M998	- Stop SD print. (Requires SDSUPPORT)
//  240  * M999 - Restart after being stopped by error
//  241  *
//  242  * "T" Codes
//  243  *
//  244  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
//  245  *
//  246  */
//  247 
//  248 #include "Marlin.h"
//  249 
//  250 #include "ultralcd.h"
//  251 #include "planner.h"
//  252 #include "stepper.h"
//  253 #include "endstops.h"
//  254 #include "temperature.h"
//  255 #include "cardreader.h"
//  256 #include "configuration_store.h"
//  257 #include "language.h"
//  258 //#include "pins_arduino.h"
//  259 #include "math.h"
//  260 #include "nozzle.h"
//  261 #include "duration_t.h"
//  262 //#include "types.h"
//  263 #include "tim.h"
//  264 #include "gcode.h"
//  265 
//  266 #include "least_squares_fit.h"
//  267 #include "ubl.h"
//  268 
//  269 #include "mks_cfg.h"
//  270 #include "mks_reprint.h"
//  271 
//  272 #if 1
//  273 
//  274 #include "wifi_module.h"
//  275 
//  276 #include "gui.h"
//  277 
//  278 #include "draw_ready_print.h"
//  279 
//  280 #include "draw_ui.h"
//  281 #include "wifi_module.h"
//  282 #include "draw_printing.h"
//  283 #include "draw_pause_ui.h"
//  284 #include "sdio_sdcard.h"
//  285 #include "ili9320.h"
//  286 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  287 volatile uint8_t temper_error_flg = 0;
temper_error_flg:
        DS8 1
//  288 volatile uint8_t temper_error_type = 0;
temper_error_type:
        DS8 1
//  289 
//  290 volatile uint8_t mks_heating_busy = 0;
//  291 
//  292 extern void PowerOff_Filament_Check();
//  293 extern void display_temper_error();
//  294 extern void Close_machine_display();
//  295 
//  296 extern uint8_t IsChooseAutoShutdown;
//  297 
//  298 extern uint8_t temperature_change_frequency;
//  299 
//  300 static uint32_t temperature_change_frequency_cnt = 0;
//  301 static uint32_t After_finish_print_time = 0;
//  302 
//  303 uint8_t filament_loading_time_flg;
//  304 uint32_t filament_loading_time_cnt;
//  305 uint8_t filament_loading_completed;
//  306 uint8_t filament_unloading_time_flg;
//  307 uint32_t filament_unloading_time_cnt;
//  308 uint8_t filament_unloading_completed;
//  309 
//  310 uint8_t filament_heat_completed_load;
//  311 uint8_t filament_heat_completed_unload;
//  312 
//  313 extern uint32_t filament_rate;
//  314 
//  315 
//  316 volatile uint32_t TimeIncrease;
//  317 uint8_t volatile printing_rate_update_flag;
//  318 uint8_t preview_no_display;
//  319 extern PRINT_TIME  print_time;
//  320 
//  321 extern uint8_t from_flash_pic;
//  322 
//  323 volatile uint8_t loop_start=0;
//  324 #endif
//  325 
//  326 
//  327 #if 0
//  328 #if HAS_ABL
//  329   #include "vector_3.h"
//  330   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
//  331     #include "least_squares_fit.h"
//  332   #endif
//  333 #elif ENABLED(MESH_BED_LEVELING)
//  334   #include "mesh_bed_leveling.h"
//  335 #endif
//  336 #endif
//  337 #include "vector_3.h"
//  338 //#include "qr_solve.h"
//  339 #include "mesh_bed_leveling.h"
//  340 
//  341 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  342   #include "planner_bezier.h"
//  343 #endif
//  344 
//  345 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
//  346   #include "buzzer.h"
//  347 #endif
//  348 
//  349 #if ENABLED(USE_WATCHDOG)
//  350   #include "watchdog.h"
//  351 #endif
//  352 
//  353 #if ENABLED(MAX7219_DEBUG)
//  354   #include "Max7219_Debug_LEDs.h"
//  355 #endif
//  356 
//  357 #if HAS_COLOR_LEDS
//  358   #include "leds.h"
//  359 #endif
//  360 
//  361 #if HAS_SERVOS
//  362   #include "servo.h"
//  363 #endif
//  364 
//  365 #if HAS_DIGIPOTSS
//  366   #include <SPI.h>
//  367 #endif
//  368 
//  369 #if ENABLED(DAC_STEPPER_CURRENT)
//  370   #include "stepper_dac.h"
//  371 #endif
//  372 
//  373 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  374   #include "twibus.h"
//  375 #endif
//  376 
//  377 #if ENABLED(I2C_POSITION_ENCODERS)
//  378   #include "I2CPositionEncoder.h"
//  379 #endif
//  380 
//  381 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
//  382   #include "endstop_interrupts.h"
//  383 #endif
//  384 
//  385 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  386   void gcode_M100();
//  387   void M100_dump_routine(const char * const title, const char *start, const char *end);
//  388 #endif
//  389 
//  390 #if ENABLED(G26_MESH_VALIDATION)
//  391   bool g26_debug_flag; // =false
//  392   void gcode_G26();
//  393 #endif
//  394 
//  395 #if ENABLED(SDSUPPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function __sti__routine
        THUMB
// static __intrinsic __interwork __softfp void __sti__routine()
__sti__routine:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
//  396   CardReader card;
        LDR.W    R5,??DataTable136_3
        MOV      R0,R5
          CFI FunCall _ZN10CardReaderC1Ev
        BL       _ZN10CardReaderC1Ev
//  397 #endif
//  398 
//  399 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  400   TWIBus i2c;
//  401 #endif
//  402 
//  403 #if ENABLED(G38_PROBE_TARGET)
//  404   bool G38_move = false,
//  405        G38_endstop_hit = false;
//  406 #endif
//  407 
//  408 #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
//  409   #include "ubl.h"
//  410   extern bool defer_return_to_status;
//  411   unified_bed_leveling ubl;
        LDR.W    R4,??DataTable136_4
        ADD      R0,R4,#+132
          CFI FunCall _ZN20unified_bed_levelingC1Ev
        BL       _ZN20unified_bed_levelingC1Ev
        ADDW     R0,R5,#+2792
          CFI FunCall _ZN9StopwatchC1Ev
        BL       _ZN9StopwatchC1Ev
        LDR.W    R5,??DataTable136_5
        LDR      R0,[R5, #+116]
        LDR.W    R1,??DataTable136_6  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, #+116]
        LDR      R0,[R5, #+28]
        STR      R0,[R4, #+124]
        LDR.W    R7,??DataTable136_7  ;; 0x43160000
        MOV      R9,R7
        MOV      R10,#+2
        MOV      R6,#+1065353216
        MOV      R8,R6
        B.N      ??__sti__routine_0
??__sti__routine_1:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??__sti__routine_0:
        LSLS     R0,R10,#+31
        BPL.N    ??__sti__routine_2
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??__sti__routine_2:
        LSRS     R10,R10,#+1
        BNE.N    ??__sti__routine_1
        LDR.W    R9,??DataTable136_8
        STR      R8,[R9, #+52]
        MOV      R1,R8
        MOV      R0,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+128]
        MOVS     R4,#+2
        B.N      ??__sti__routine_3
??__sti__routine_4:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??__sti__routine_3:
        LSLS     R0,R4,#+31
        BPL.N    ??__sti__routine_5
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??__sti__routine_5:
        LSRS     R4,R4,#+1
        BNE.N    ??__sti__routine_4
        STR      R6,[R9, #+56]
        LDR      R0,[R5, #+8]
        STR      R0,[R9, #+4]
        LDR      R0,[R5, #+12]
        STR      R0,[R9, #+8]
        LDR      R0,[R5, #+16]
        STR      R0,[R9, #+12]
        LDR      R0,[R5, #+20]
        STR      R0,[R9, #+16]
        LDR      R0,[R5, #+24]
        STR      R0,[R9, #+20]
        LDR      R0,[R5, #+28]
        STR      R0,[R9, #+24]
        LDR      R0,[R5, #+80]
        STR      R0,[R9, #+36]
        LDR      R0,[R5, #+20]
        LDR      R1,[R5, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+40]
        LDR      R0,[R5, #+24]
        LDR      R1,[R5, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+44]
        LDR      R0,[R5, #+28]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+48]
        LDRB     R0,[R5, #+5]
        STRB     R0,[R9, #+0]
        LDRB     R0,[R5, #+6]
        STRB     R0,[R9, #+1]
        LDRB     R0,[R5, #+7]
        STRB     R0,[R9, #+2]
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock0
//  412 #endif
//  413 
//  414 #if ENABLED(CNC_COORDINATE_SYSTEMS)
//  415   int8_t active_coordinate_system = -1; // machine space
//  416   float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
//  417 #endif
//  418 
//  419 bool Running = true;
//  420 
//  421 uint8_t marlin_debug_flags = DEBUG_NONE;
//  422 
//  423 /**
//  424  * Cartesian Current Position
//  425  *   Used to track the native machine position as moves are queued.
//  426  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
//  427  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
//  428  */
//  429 float current_position[XYZE] = { 0.0 };
//  430 
//  431 /**
//  432  * Cartesian Destination
//  433  *   The destination for a move, filled in by G-code movement commands,
//  434  *   and expected by functions like 'prepare_move_to_destination'.
//  435  *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
//  436  */
//  437 float destination[XYZE] = { 0.0 };
//  438 
//  439 /**
//  440  * axis_homed
//  441  *   Flags that each linear axis was homed.
//  442  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
//  443  *
//  444  * axis_known_position
//  445  *   Flags that the position is known in each linear axis. Set when homed.
//  446  *   Cleared whenever a stepper powers off, potentially losing its position.
//  447  */
//  448 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
//  449 
//  450 /**
//  451  * GCode line number handling. Hosts may opt to include line numbers when
//  452  * sending commands to Marlin, and lines will be checked for sequentiality.
//  453  * M110 N<int> sets the current line number.
//  454  */
//  455 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
//  456 
//  457 /**
//  458  * GCode Command Queue
//  459  * A simple ring buffer of BUFSIZE command strings.
//  460  *
//  461  * Commands are copied into this buffer by the command injectors
//  462  * (immediate, serial, sd card) and they are processed sequentially by
//  463  * the main loop. The process_next_command function parses the next
//  464  * command and hands off execution to individual handler functions.
//  465  */
//  466 uint8_t commands_in_queue = 0; // Count of commands in the queue
//  467 static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
//  468                cmd_queue_index_w = 0; // Ring buffer write position
//  469 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  470   char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
//  471 #else                                         // This can be collapsed back to the way it was soon.
//  472 static char command_queue[BUFSIZE][MAX_CMD_SIZE];
//  473 #endif
//  474 
//  475 /**
//  476  * Next Injected Command pointer. NULL if no commands are being injected.
//  477  * Used by Marlin internally to ensure that commands initiated from within
//  478  * are enqueued ahead of any pending serial or sd card commands.
//  479  */
//  480 static const char *injected_commands_P = NULL;
//  481 
//  482 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
//  483   TempUnit input_temp_units = TEMPUNIT_C;
//  484 #endif
//  485 
//  486 /**
//  487  * Feed rates are often configured with mm/m
//  488  * but the planner and stepper like mm/s units.
//  489  */
//  490  /*
//  491 static const float homing_feedrate_mm_s[] PROGMEM = {
//  492   #if ENABLED(DELTA)
//  493     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
//  494   #else
//  495     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
//  496   #endif
//  497   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
//  498 };
//  499 
//  500 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
//  501 */
//  502 
//  503 float  homing_feedrate_mm_s[4];
//  504 
//  505 float feedrate_mm_s = MMM_TO_MMS(1500.0);
//  506 static float saved_feedrate_mm_s;
//  507 int16_t feedrate_percentage = 100, saved_feedrate_percentage;
//  508 
//  509 // Initialized by settings.load()
//  510 bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
//  511 
//  512 #if HAS_WORKSPACE_OFFSET
//  513   #if HAS_POSITION_SHIFT
//  514     // The distance that XYZ has been offset by G92. Reset by G28.
//  515     float position_shift[XYZ] = { 0 };
//  516   #endif
//  517   #if HAS_HOME_OFFSET
//  518     // This offset is added to the configured home position.
//  519     // Set by M206, M428, or menu item. Saved to EEPROM.
//  520     float home_offset[XYZ] = { 0 };
//  521   #endif
//  522   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
//  523     // The above two are combined to save on computes
//  524     float workspace_offset[XYZ] = { 0 };
//  525   #endif
//  526 #endif
//  527 
//  528 // Software Endstops are based on the configured limits.
//  529 /*
//  530 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
//  531       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
//  532 */
//  533 float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function _Z21soft_endstop_min_initv
        THUMB
//  534 void soft_endstop_min_init()
//  535 {
_Z21soft_endstop_min_initv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
//  536     if(MACHINETPYE & IS_KINEMATIC)
        LDR.W    R4,??DataTable136_5
        LDR      R0,[R4, #+20]
        LDR.W    R5,??DataTable136_9
        MOV      R6,#+1056964608
        LDR.W    R7,??DataTable136_4
        LDRH     R1,[R4, #+88]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??soft_endstop_min_init_0
//  537     {
//  538         soft_endstop_min[0]= X_MIN_BED_IS_KINEMATIC;
        MOV      R8,#-1090519040
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R7, #+68]
//  539         soft_endstop_min[1]= Y_MIN_BED_IS_KINEMATIC;
        LDR      R0,[R4, #+24]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R7, #+72]
//  540         soft_endstop_min[2]= Z_MIN_POS;
        LDR      R0,[R4, #+16]
        STR      R0,[R7, #+76]
//  541 
//  542         soft_endstop_max[0] = X_MAX_BED_IS_KINEMATIC;
        LDR      R0,[R4, #+20]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+36]
//  543         soft_endstop_max[1] = Y_MAX_BED_IS_KINEMATIC;
        LDR      R0,[R4, #+24]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+40]
//  544         soft_endstop_max[2] = Z_MAX_POS;
        LDR      R0,[R4, #+28]
        STR      R0,[R5, #+44]
        B.N      ??soft_endstop_min_init_1
//  545     }
//  546     else
//  547     {
//  548         soft_endstop_min[0]= X_MIN_BED_IS_CARTESIAN;
??soft_endstop_min_init_0:
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+68]
//  549         soft_endstop_min[1]= Y_MIN_BED_IS_CARTESIAN;
        LDR      R0,[R4, #+24]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+72]
//  550         soft_endstop_min[2]= Z_MIN_POS;
        LDR      R0,[R4, #+16]
        STR      R0,[R7, #+76]
//  551 
//  552         soft_endstop_max[0] = X_MAX_BED_IS_CARTESIAN;
        MOV      R7,#+1073741824
        LDR      R0,[R4, #+20]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+36]
//  553         soft_endstop_max[1] = Y_MAX_BED_IS_CARTESIAN;
        LDR      R0,[R4, #+24]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+40]
//  554         soft_endstop_max[2] = Z_MAX_POS;
        LDR      R0,[R4, #+28]
        STR      R0,[R5, #+44]
//  555     }        
//  556 }
??soft_endstop_min_init_1:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock1
//  557 
//  558 #if HAS_SOFTWARE_ENDSTOPS
//  559   bool soft_endstops_enabled = true;
//  560   #if 1// IS_KINEMATIC
//  561     float soft_endstop_radius, soft_endstop_radius_2;
//  562   #endif
//  563 #endif
//  564 
//  565 #if FAN_COUNT > 0
//  566   int fanSpeeds[FAN_COUNT] = { 0 };
//  567   #if ENABLED(EXTRA_FAN_SPEED)
//  568     int16_t old_fanSpeeds[FAN_COUNT],
//  569             new_fanSpeeds[FAN_COUNT];
//  570   #endif
//  571   #if ENABLED(PROBING_FANS_OFF)
//  572     bool fans_paused = false;
//  573     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
//  574   #endif
//  575 #endif
//  576 
//  577 // The active extruder (tool). Set with T<extruder> command.
//  578 uint8_t active_extruder = 0;
//  579 
//  580 // Relative Mode. Enable with G91, disable with G90.
//  581 static bool relative_mode = false;
//  582 
//  583 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
//  584 volatile bool wait_for_heatup = true;
//  585 
//  586 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
//  587 #if HAS_RESUME_CONTINUE
//  588   volatile bool wait_for_user = false;
//  589 #endif
//  590 
//  591 const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
//  592 
//  593 // Number of characters read in the current line of serial input
//  594 static int serial_count = 0;
//  595 static int wifi_read_count = 0;
//  596 
//  597 // Inactivity shutdown
//  598 millis_t previous_cmd_ms = 0;
//  599 static millis_t max_inactive_time = 0;
//  600 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
//  601 
//  602 // Print Job Timer
//  603 #if ENABLED(PRINTCOUNTER)
//  604   PrintCounter print_job_timer = PrintCounter();
//  605 #else
//  606   Stopwatch print_job_timer = Stopwatch();
//  607 #endif
//  608 
//  609 // Buzzer - I2C on the LCD or a BEEPER_PIN
//  610 #if ENABLED(LCD_USE_I2C_BUZZER)
//  611   #define BUZZ(d,f) lcd_buzz(d, f)
//  612 #elif PIN_EXISTS(BEEPER)
//  613   Buzzer buzzer;
//  614   #define BUZZ(d,f) buzzer.tone(d, f)
//  615 #else
//  616   #define BUZZ(d,f) NOOP
//  617 #endif
//  618 
//  619 uint8_t target_extruder;
//  620 
//  621 #if HAS_BED_PROBE
//  622   float zprobe_zoffset; // Initialized by settings.load()
//  623 #endif
//  624 
//  625 #if 1//HAS_ABL
//  626   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
//  627   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
//  628 #elif defined(XY_PROBE_SPEED)
//  629   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
//  630 #else
//  631   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
//  632 #endif
//  633 
//  634 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  635 /*
//  636   #if ENABLED(DELTA)
//  637     #define ADJUST_DELTA(V) \ 
//  638       if (planner.leveling_active) { \ 
//  639         const float zadj = bilinear_z_offset(V); \ 
//  640         delta[A_AXIS] += zadj; \ 
//  641         delta[B_AXIS] += zadj; \ 
//  642         delta[C_AXIS] += zadj; \ 
//  643       }
//  644   #else
//  645     #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
//  646   #endif
//  647   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function _Z12ADJUST_DELTAPKf
        THUMB
//  648 void  ADJUST_DELTA(const float logical[XYZ])
//  649 {
_Z12ADJUST_DELTAPKf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
//  650 	float zadj;
//  651 
//  652 	if(MACHINETPYE == DELTA)
        LDR.W    R1,??DataTable137
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable136_5
        LDRSH    R2,[R2, #+88]
        CMP      R2,#+2
        BNE.N    ??ADJUST_DELTA_0
//  653 		{
//  654       	if (planner.leveling_active) { 
        CMP      R1,#+0
        BEQ.N    ??ADJUST_DELTA_1
//  655        	 	zadj = bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        MOV      R4,R0
//  656         	delta[A_AXIS] += zadj; 
        LDR.W    R5,??DataTable136_4
        LDR      R0,[R5, #+80]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+80]
//  657        		delta[B_AXIS] += zadj; 
        LDR      R0,[R5, #+84]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+84]
//  658         	delta[C_AXIS] += zadj; 
        LDR      R0,[R5, #+88]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+88]
        POP      {R0,R4,R5,PC}
//  659       		}
//  660 		}
//  661 		else
//  662 			{
//  663 			if (planner.leveling_active) 
??ADJUST_DELTA_0:
        CMP      R1,#+0
        BEQ.N    ??ADJUST_DELTA_1
//  664 				 delta[Z_AXIS] += bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        LDR.W    R5,??DataTable136_4
        LDR      R1,[R5, #+88]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+88]
//  665 			}
//  666 }  
??ADJUST_DELTA_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock2

        SECTION `.data`:DATA:REORDER:NOROOT(2)
mks_heating_busy:
        DATA
        DC8 0
marlin_debug_flags:
        DC8 0
commands_in_queue:
        DC8 0
active_extruder:
        DC8 0
wait_for_heatup:
        DC8 1
target_extruder:
        DC8 0
feedrate_percentage:
        DC16 100
current_position:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
destination:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
homing_feedrate_mm_s:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
workspace_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_min:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  667 //#elif IS_KINEMATIC
//  668 //  #define ADJUST_DELTA(V) NOOP
//  669 #endif
//  670 
//  671 #if ENABLED(X_DUAL_ENDSTOPS)
//  672   float x_endstop_adj;                // Initialized by settings.load()
//  673 #endif
//  674 #if ENABLED(Y_DUAL_ENDSTOPS)
//  675   float y_endstop_adj;                // Initialized by settings.load()
//  676 #endif
//  677 #if 1//ENABLED(Z_DUAL_ENDSTOPS)
//  678   float z_endstop_adj;                // Initialized by settings.load()
//  679 #endif
//  680 
//  681 // Extruder offsets
//  682 #if HOTENDS > 1
//  683   float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
//  684 #endif
//  685 
//  686 #if HAS_Z_SERVO_ENDSTOP
//  687   const int z_servo_angle[2] = Z_SERVO_ANGLES;
//  688 #endif
//  689 
//  690 #if ENABLED(BARICUDA)
//  691   uint8_t baricuda_valve_pressure = 0,
//  692           baricuda_e_to_p_pressure = 0;
//  693 #endif
//  694 
//  695 #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
//  696   bool autoretract_enabled,                 // M209 S - Autoretract switch
//  697        retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
//  698   float retract_length,                     // M207 S - G10 Retract length
//  699         retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
//  700         retract_zlift,                      // M207 Z - G10 Retract hop size
//  701         retract_recover_length,             // M208 S - G11 Recover length
//  702         retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
//  703         swap_retract_length,                // M207 W - G10 Swap Retract length
//  704         swap_retract_recover_length,        // M208 W - G11 Swap Recover length
//  705         swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
//  706   #if EXTRUDERS > 1
//  707     bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
//  708   #else
//  709     constexpr bool retracted_swap[1] = { false };
//  710   #endif
//  711 #endif // FWRETRACT
//  712 
//  713 #if HAS_POWER_SWITCH
//  714   bool powersupply_on =
//  715     #if ENABLED(PS_DEFAULT_OFF)
//  716       false
//  717     #else
//  718       true
//  719     #endif
//  720   ;
//  721 #endif
//  722 
//  723 #if 1//ENABLED(DELTA)
//  724 
//  725   float delta[ABC];
delta:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
feedrate_mm_s:
        DC32 41C80000H
position_shift:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
fanSpeeds:
        DC32 0
zprobe_zoffset:
        DC8 0, 0, 0, 0
xy_probe_feedrate_mm_s:
        DC8 0, 0, 0, 0
//  726 
//  727   // Initialized by settings.load()
//  728   float delta_height,
delta_height:
        DC8 0, 0, 0, 0
//  729         delta_endstop_adj[ABC] = { 0 },
//  730         delta_radius,
//  731         delta_tower_angle_trim[ABC],
//  732         delta_tower[ABC][2],
//  733         delta_diagonal_rod,
//  734         delta_calibration_radius,
//  735         delta_diagonal_rod_2_tower[ABC],
//  736         delta_segments_per_second,
//  737         delta_clip_start_height = Z_MAX_POS;
delta_clip_start_height:
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
ubl:
        DC8 0, 0, 0, 0
//  738 
//  739   float delta_safe_distance_from_top();
//  740 
//  741 #endif
//  742 
//  743 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  744   int bilinear_grid_spacing[2], bilinear_start[2];
//  745   float bilinear_grid_factor[2],
//  746         //z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
//  747         z_values[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
//  748 #endif
//  749 
//  750 #if 1//IS_SCARA
//  751   // Float constants for SCARA calculations
//  752   const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
//  753               L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
//  754               L2_2 = sq(float(L2));
//  755 
//  756   //float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
//  757   //      delta[ABC];
//  758 #endif
//  759 
//  760 float cartes[XYZ] = { 0 };
//  761 
//  762 #if ENABLED(FILAMENT_WIDTH_SENSOR)
//  763   bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
//  764   float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
//  765         filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
//  766   uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
//  767   int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
//  768          filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
//  769 #endif
//  770 
//  771 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  772   static bool filament_ran_out = false;
//  773 #endif
//  774 
//  775 #if ENABLED(ADVANCED_PAUSE_FEATURE)
//  776   AdvancedPauseMenuResponse advanced_pause_menu_response;
//  777 #endif
//  778 
//  779 #if ENABLED(MIXING_EXTRUDER)
//  780   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
//  781   #if MIXING_VIRTUAL_TOOLS > 1
//  782     float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
//  783   #endif
//  784 #endif
//  785 
//  786 static bool send_ok[BUFSIZE];
//  787 
//  788 #if HAS_SERVOS
//  789   Servo servo[NUM_SERVOS];
//  790   #define MOVE_SERVO(I, P) servo[I].move(P)
//  791   #if HAS_Z_SERVO_ENDSTOP
//  792     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
//  793     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
//  794   #endif
//  795 #endif
//  796 
//  797 #ifdef CHDK
//  798   millis_t chdkHigh = 0;
//  799   bool chdkActive = false;
//  800 #endif
//  801 
//  802 #if ENABLED(PID_EXTRUSION_SCALING)
//  803   int lpq_len = 20;
//  804 #endif
//  805 
//  806 #if ENABLED(HOST_KEEPALIVE_FEATURE)
//  807   MarlinBusyState busy_state = NOT_BUSY;
//  808   static millis_t next_busy_signal_ms = 0;
//  809   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
//  810 #else
//  811   #define host_keepalive() NOOP
//  812 #endif
//  813 
//  814 #if ENABLED(I2C_POSITION_ENCODERS)
//  815   I2CPositionEncodersMgr I2CPEM;
//  816   uint8_t blockBufferIndexRef = 0;
//  817   millis_t lastUpdateMillis;
//  818 #endif
//  819 
//  820 #if ENABLED(CNC_WORKSPACE_PLANES)
//  821   static WorkspacePlane workspace_plane = PLANE_XY;
//  822 #endif
//  823 
//  824 //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
//  825 //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
//  826 static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
//  827 static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
//  828 /*P
//  829 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  830   static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  831   static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \ 
//  832   typedef void __void_##CONFIG##__
//  833 */
//  834 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  835 	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  836 	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
//  837 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function _Z12base_min_pos8AxisEnum
          CFI NoCalls
        THUMB
//  838 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
_Z12base_min_pos8AxisEnum:
        LDR.W    R1,??DataTable136_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+4]
        BX       LR               ;; return
          CFI EndBlock cfiBlock3

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function _Z12base_max_pos8AxisEnum
          CFI NoCalls
        THUMB
//  839 XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
_Z12base_max_pos8AxisEnum:
        LDR.W    R1,??DataTable136_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+16]
        BX       LR               ;; return
          CFI EndBlock cfiBlock4

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function _Z13base_home_pos8AxisEnum
          CFI NoCalls
        THUMB
//  840 XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
_Z13base_home_pos8AxisEnum:
        LDR.W    R1,??DataTable136_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+28]
        BX       LR               ;; return
          CFI EndBlock cfiBlock5

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function _Z10max_length8AxisEnum
          CFI NoCalls
        THUMB
//  841 XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
_Z10max_length8AxisEnum:
        LDR.W    R1,??DataTable136_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+40]
        BX       LR               ;; return
          CFI EndBlock cfiBlock6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function _Z12home_bump_mm8AxisEnum
          CFI NoCalls
        THUMB
//  842 XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
_Z12home_bump_mm8AxisEnum:
        LDR.W    R1,??DataTable139
        LDR      R0,[R1, R0, LSL #+2]
        BX       LR               ;; return
          CFI EndBlock cfiBlock7

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function _Z8home_dir8AxisEnum
          CFI NoCalls
        THUMB
//  843 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
_Z8home_dir8AxisEnum:
        LDR.W    R1,??DataTable136_8
        LDRSB    R0,[R0, R1]
        BX       LR               ;; return
          CFI EndBlock cfiBlock8
//  844 
//  845 /**
//  846  * ***************************************************************************
//  847  * ******************************** FUNCTIONS ********************************
//  848  * ***************************************************************************
//  849  */
//  850 
//  851 void stop();
//  852 
//  853 void get_available_commands();
//  854 void process_next_command();
//  855 void process_parsed_command();
//  856 
//  857 void get_cartesian_from_steppers();
//  858 void set_current_from_steppers_for_axis(const AxisEnum axis);
//  859 
//  860 #if ENABLED(ARC_SUPPORT)
//  861   void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
//  862 #endif
//  863 
//  864 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  865   void plan_cubic_move(const float (&offset)[4]);
//  866 #endif
//  867 
//  868 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
//  869 void report_current_position();
//  870 void report_current_position_detail();
//  871 
//  872 #if ENABLED(DEBUG_LEVELING_FEATURE)
//  873   void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
//  874     serialprintPGM(prefix);
//  875     SERIAL_CHAR('(');
//  876     SERIAL_ECHO(x);
//  877     SERIAL_ECHOPAIR(", ", y);
//  878     SERIAL_ECHOPAIR(", ", z);
//  879     SERIAL_CHAR(')');
//  880     if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
//  881   }
//  882 
//  883   void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
//  884     print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
//  885   }
//  886 
//  887   #if 1//HAS_ABL
//  888     void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
//  889       print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
//  890     }
//  891   #endif
//  892 
//  893   #define DEBUG_POS(SUFFIX,VAR) do { \ 
//  894     print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
//  895 #endif
//  896 
//  897 /**
//  898  * sync_plan_position
//  899  *
//  900  * Set the planner/stepper positions directly from current_position with
//  901  * no kinematic translation. Used for homing axes and cartesian/core syncing.
//  902  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function _Z18sync_plan_positionv
        THUMB
//  903 void sync_plan_position() {
//  904   #if ENABLED(DEBUG_LEVELING_FEATURE)
//  905     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
//  906   #endif
//  907   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
_Z18sync_plan_positionv:
        LDR.W    R0,??DataTable136_4
        ADD      R3,R0,#+20
        LDR      R2,[R0, #+16]
        LDR      R1,[R0, #+12]
        LDR      R0,[R0, #+8]
          CFI FunCall _ZN7Planner15set_position_mmEfffRKf
        B.W      _ZN7Planner15set_position_mmEfffRKf
          CFI EndBlock cfiBlock9
//  908 }
//  909 inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
//  910 
//  911 //#if IS_KINEMATIC
//  912 
//  913   inline void sync_plan_position_kinematic() {
//  914     #if ENABLED(DEBUG_LEVELING_FEATURE)
//  915       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
//  916     #endif
//  917     planner.set_position_mm_kinematic(current_position);
//  918   }
//  919 //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
//  920 
//  921 //#else
//  922 
//  923 //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
//  924 
//  925 //#endif
//  926 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function _Z28SYNC_PLAN_POSITION_KINEMATICv
        THUMB
//  927 void SYNC_PLAN_POSITION_KINEMATIC()
//  928 {
//  929 	if(MACHINETPYE & IS_KINEMATIC)
_Z28SYNC_PLAN_POSITION_KINEMATICv:
        LDR.W    R0,??DataTable136_5
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??SYNC_PLAN_POSITION_KINEMATIC_0
//  930 		sync_plan_position_kinematic();
          CFI FunCall _Z28sync_plan_position_kinematicv
        B.W      _Z28sync_plan_position_kinematicv
//  931 	else
//  932 		sync_plan_position();
??SYNC_PLAN_POSITION_KINEMATIC_0:
          CFI FunCall _Z18sync_plan_positionv
        B.N      _Z18sync_plan_positionv
          CFI EndBlock cfiBlock10
//  933 }
//  934 
//  935 #if 0//ENABLED(SDSUPPORT)
//  936   #include "SdFatUtil.h"
//  937   int freeMemory() { return SdFatUtil::FreeRam(); }
//  938 #else
//  939 /*
//  940 extern "C" {
//  941   extern char __bss_end;
//  942   extern char __heap_start;
//  943   extern void* __brkval;
//  944 
//  945   int freeMemory() {
//  946     int free_memory;
//  947     if ((int)__brkval == 0)
//  948       free_memory = ((int)&free_memory) - ((int)&__bss_end);
//  949     else
//  950       free_memory = ((int)&free_memory) - ((int)__brkval);
//  951     return free_memory;
//  952   }
//  953 }
//  954 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function _Z10freeMemoryv
          CFI NoCalls
        THUMB
//  955 	int freeMemory() { return 4396; }	//No free ram management
_Z10freeMemoryv:
        MOVW     R0,#+4396
        BX       LR               ;; return
          CFI EndBlock cfiBlock11
//  956 
//  957 #endif // !SDSUPPORT
//  958 
//  959 #if ENABLED(DIGIPOT_I2C)
//  960   extern void digipot_i2c_set_current(uint8_t channel, float current);
//  961   extern void digipot_i2c_init();
//  962 #endif
//  963 
//  964 /**
//  965  * Inject the next "immediate" command, when possible, onto the front of the queue.
//  966  * Return true if any immediate commands remain to inject.
//  967  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function _Z25drain_injected_commands_Pv
        THUMB
//  968 static bool drain_injected_commands_P() {
_Z25drain_injected_commands_Pv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
//  969   if (injected_commands_P != NULL) {
        LDR.W    R4,??DataTable139_1
        LDR      R1,[R4, #+0]
        CMP      R1,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  970     size_t i = 0;
        MOVS     R5,#+0
//  971     char c, cmd[30];
//  972     //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
//  973     strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
        MOVS     R2,#+29
        ADD      R0,SP,#+0
          CFI FunCall strncpy
        BL       strncpy
//  974     cmd[sizeof(cmd) - 1] = '\0';
        ADD      R0,SP,#+0
        MOV      R1,R5
        STRB     R1,[R0, #+29]
        B.N      ??drain_injected_commands_P_1
//  975     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
??drain_injected_commands_P_2:
        ADDS     R5,R5,#+1
??drain_injected_commands_P_1:
        LDRSB    R6,[R5, R0]
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_3
        CMP      R6,#+10
        BNE.N    ??drain_injected_commands_P_2
//  976     cmd[i] = '\0';
??drain_injected_commands_P_3:
        STRB     R1,[R5, R0]
//  977     if (enqueue_and_echo_command(cmd))     // success?
          CFI FunCall _Z24enqueue_and_echo_commandPKcb
        BL       _Z24enqueue_and_echo_commandPKcb
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  978       injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_4
        LDR      R0,[R4, #+0]
        ADDS     R0,R5,R0
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+0]
        B.N      ??drain_injected_commands_P_0
??drain_injected_commands_P_4:
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
//  979   }
//  980   return (injected_commands_P != NULL);    // return whether any more remain
??drain_injected_commands_P_0:
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_5
        MOVS     R0,#+1
        B.N      ??drain_injected_commands_P_6
??drain_injected_commands_P_5:
        MOVS     R0,#+0
??drain_injected_commands_P_6:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock12
//  981 }
//  982 
//  983 /**
//  984  * Record one or many commands to run from program memory.
//  985  * Aborts the current queue, if any.
//  986  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
//  987  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function _Z27enqueue_and_echo_commands_PPKc
        THUMB
//  988 void enqueue_and_echo_commands_P(const char * const pgcode) {
//  989   injected_commands_P = pgcode;
_Z27enqueue_and_echo_commands_PPKc:
        LDR.W    R1,??DataTable139_1
        STR      R0,[R1, #+0]
//  990   drain_injected_commands_P(); // first command executed asap (when possible)
          CFI FunCall _Z25drain_injected_commands_Pv
        B.N      _Z25drain_injected_commands_Pv
          CFI EndBlock cfiBlock13
//  991 }
//  992 
//  993 /**
//  994  * Clear the Marlin command queue
//  995  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function _Z19clear_command_queuev
          CFI NoCalls
        THUMB
//  996 void clear_command_queue() {
//  997   cmd_queue_index_r = cmd_queue_index_w;
_Z19clear_command_queuev:
        LDR.W    R0,??DataTable139_2
        LDRB     R1,[R0, #+8]
        STRB     R1,[R0, #+7]
//  998   commands_in_queue = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable136_4
        STRB     R0,[R1, #+2]
//  999 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock14
// 1000 
// 1001 /**
// 1002  * Once a new command is in the ring buffer, call this to commit it
// 1003  */
// 1004 inline void _commit_command(bool say_ok) {
// 1005   send_ok[cmd_queue_index_w] = say_ok;
// 1006   if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
// 1007   commands_in_queue++;
// 1008 }
// 1009 
// 1010 /**
// 1011  * Copy a command from RAM into the main command buffer.
// 1012  * Return true if the command was successfully added.
// 1013  * Return false for a full buffer, or if the 'command' is a comment.
// 1014  */
// 1015 inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
// 1016   if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
// 1017   strcpy(command_queue[cmd_queue_index_w], cmd);
// 1018   _commit_command(say_ok);
// 1019   return true;
// 1020 }
// 1021 
// 1022 /**
// 1023  * Enqueue with Serial Echo
// 1024  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function _Z24enqueue_and_echo_commandPKcb
        THUMB
// 1025 bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
_Z24enqueue_and_echo_commandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1026   if (_enqueuecommand(cmd, say_ok)) {
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
        CMP      R0,#+0
        BEQ.N    ??enqueue_and_echo_command_0
// 1027     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable139_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1028     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
        MOV      R1,R4
        ADR.W    R0,`?<Constant "enqueueing \\"">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
// 1029     SERIAL_CHAR('"');
        LDR.W    R4,??DataTable139_4
        MOVS     R1,#+34
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1030     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1031     return true;
        MOVS     R0,#+1
        POP      {R4,PC}
// 1032   }
// 1033   return false;
??enqueue_and_echo_command_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock15
// 1034 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "enqueueing \\"">`:
        DC8 "enqueueing \""
        DC8 0, 0, 0
// 1035 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function _Z13setup_killpinv
          CFI NoCalls
        THUMB
// 1036 void setup_killpin() {
// 1037   #if HAS_KILL
// 1038     SET_INPUT_PULLUP(KILL_PIN);
// 1039   #endif
// 1040 }
_Z13setup_killpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock16
// 1041 
// 1042 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 1043 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function _Z18setup_filrunoutpinv
          CFI NoCalls
        THUMB
// 1044   void setup_filrunoutpin() {
// 1045     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
// 1046       SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
// 1047     #else
// 1048       SET_INPUT(FIL_RUNOUT_PIN);
// 1049     #endif
// 1050   }
_Z18setup_filrunoutpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock17
// 1051 
// 1052 #endif
// 1053 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function _Z15setup_powerholdv
          CFI NoCalls
        THUMB
// 1054 void setup_powerhold() {
// 1055   #if HAS_SUICIDE
// 1056     OUT_WRITE(SUICIDE_PIN, HIGH);
// 1057   #endif
// 1058   #if HAS_POWER_SWITCH
// 1059     #if ENABLED(PS_DEFAULT_OFF)
// 1060       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 1061     #else
// 1062       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
// 1063     #endif
// 1064   #endif
// 1065 }
_Z15setup_powerholdv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock18
// 1066 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function _Z7suicidev
          CFI NoCalls
        THUMB
// 1067 void suicide() {
// 1068   #if HAS_SUICIDE
// 1069     OUT_WRITE(SUICIDE_PIN, LOW);
// 1070   #endif
// 1071 }
_Z7suicidev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock19
// 1072 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function _Z10servo_initv
          CFI NoCalls
        THUMB
// 1073 void servo_init() {
// 1074   #if NUM_SERVOS >= 1 && HAS_SERVO_0
// 1075     servo[0].attach(SERVO0_PIN);
// 1076     servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
// 1077   #endif
// 1078   #if NUM_SERVOS >= 2 && HAS_SERVO_1
// 1079     servo[1].attach(SERVO1_PIN);
// 1080     servo[1].detach();
// 1081   #endif
// 1082   #if NUM_SERVOS >= 3 && HAS_SERVO_2
// 1083     servo[2].attach(SERVO2_PIN);
// 1084     servo[2].detach();
// 1085   #endif
// 1086   #if NUM_SERVOS >= 4 && HAS_SERVO_3
// 1087     servo[3].attach(SERVO3_PIN);
// 1088     servo[3].detach();
// 1089   #endif
// 1090 
// 1091   #if HAS_Z_SERVO_ENDSTOP
// 1092     /**
// 1093      * Set position of Z Servo Endstop
// 1094      *
// 1095      * The servo might be deployed and positioned too low to stow
// 1096      * when starting up the machine or rebooting the board.
// 1097      * There's no way to know where the nozzle is positioned until
// 1098      * homing has been done - no homing with z-probe without init!
// 1099      *
// 1100      */
// 1101     STOW_Z_SERVO();
// 1102   #endif
// 1103 }
_Z10servo_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock20
// 1104 
// 1105 /**
// 1106  * Stepper Reset (RigidBoard, et.al.)
// 1107  */
// 1108 #if HAS_STEPPER_RESET
// 1109   void disableStepperDrivers() {
// 1110     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
// 1111   }
// 1112   void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
// 1113 #endif
// 1114 
// 1115 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 1116 
// 1117   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
// 1118     i2c.receive(bytes);
// 1119   }
// 1120 
// 1121   void i2c_on_request() {          // just send dummy data for now
// 1122     i2c.reply("Hello World!\n");
// 1123   }
// 1124 
// 1125 #endif
// 1126 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function _Z16gcode_line_errorPKcb
        THUMB
// 1127 void gcode_line_error(const char* err, bool doFlush = true) {
_Z16gcode_line_errorPKcb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1128   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable139_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1129   serialprintPGM(err);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1130   SERIAL_ERRORLN(gcode_LastN);
        LDR.W    R4,??DataTable139_4
        LDR.W    R6,??DataTable141
        MOVS     R2,#+10
        LDR      R1,[R6, #+44]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1131   //Serial.println(gcode_N);
// 1132   if (doFlush) FlushSerialRequestResend();
        CMP      R5,#+0
        BEQ.N    ??gcode_line_error_0
          CFI FunCall _Z24FlushSerialRequestResendv
        BL       _Z24FlushSerialRequestResendv
// 1133   serial_count = 0;
??gcode_line_error_0:
        MOVS     R0,#+0
        STR      R0,[R6, #+52]
// 1134 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock21
// 1135 
// 1136 uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
// 1137 
// 1138 uint8_t from_wifi_flag = 0; // whether data comes from wifi model
// 1139 
// 1140 /**
// 1141  * Get all commands waiting on the serial port and queue them.
// 1142  * Exit when the buffer is full or when no more characters are
// 1143  * left on the serial port.
// 1144  */
// 1145 inline void get_serial_commands() {
// 1146   static char serial_line_buffer[MAX_CMD_SIZE];
// 1147   static bool serial_comment_mode = false;
// 1148   static millis_t last_wait_time = 0;
// 1149   const millis_t wait_ms = millis();
// 1150 
// 1151   // If the command buffer is empty for too long,
// 1152   // send "wait" to indicate Marlin is still waiting.
// 1153   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1154     static millis_t last_command_time = 0;
// 1155     const millis_t ms = millis();
// 1156     if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
// 1157       SERIAL_ECHOLNPGM(MSG_WAIT);
// 1158       last_command_time = ms;
// 1159     }
// 1160   #endif
// 1161 #if 1
// 1162   
// 1163 	  /*5s?°ß?2a2?|®¨?????°ß2°ßoy?Y?°ß°„°ß°ß??a??°ß?D°ß°Èa?°ß2?????®∫??°ß|°ßo1°ß??wifi*/
// 1164 	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
// 1165 		if(serial_wait_tick <= 5)
// 1166 	  {
// 1167 		  serial_wait_tick ++;
// 1168 	  }
// 1169 		last_wait_time = wait_ms;
// 1170 	  }
// 1171 #endif
// 1172 
// 1173   /**
// 1174    * Loop while serial characters are incoming and the queue is not full
// 1175    */
// 1176   int c;
// 1177   while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
// 1178 
// 1179     char serial_char = c;
// 1180 	
// 1181 	serial_wait_tick = 0;
// 1182 	from_wifi_flag = 0;
// 1183 
// 1184     /**
// 1185      * If the character ends the line
// 1186      */
// 1187     if (serial_char == '\n' || serial_char == '\r') {
// 1188 
// 1189       serial_comment_mode = false;                      // end of line == end of comment
// 1190 
// 1191       if (!serial_count) continue;                      // Skip empty lines
// 1192 
// 1193       serial_line_buffer[serial_count] = 0;             // Terminate string
// 1194       serial_count = 0;                                 // Reset buffer
// 1195 
// 1196       char* command = serial_line_buffer;
// 1197 
// 1198       while (*command == ' ') command++;                // Skip leading spaces
// 1199       char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
// 1200 
// 1201       if (npos) {
// 1202 
// 1203         bool M110 = strstr_P(command, PSTR("M110")) != NULL;
// 1204 
// 1205         if (M110) {
// 1206           char* n2pos = strchr(command + 4, 'N');
// 1207           if (n2pos) npos = n2pos;
// 1208         }
// 1209 
// 1210         gcode_N = strtol(npos + 1, NULL, 10);
// 1211 
// 1212         if (gcode_N != gcode_LastN + 1 && !M110) {
// 1213           gcode_line_error(PSTR(MSG_ERR_LINE_NO));
// 1214           return;
// 1215         }
// 1216 
// 1217         char *apos = strrchr(command, '*');
// 1218         if (apos) {
// 1219           uint8_t checksum = 0, count = uint8_t(apos - command);
// 1220           while (count) checksum ^= command[--count];
// 1221           if (strtol(apos + 1, NULL, 10) != checksum) {
// 1222             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
// 1223             return;
// 1224           }
// 1225         }
// 1226         else {
// 1227           gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
// 1228           return;
// 1229         }
// 1230 
// 1231         gcode_LastN = gcode_N;
// 1232       }
// 1233 
// 1234       // Movement commands alert when stopped
// 1235       if (IsStopped()) {
// 1236         char* gpos = strchr(command, 'G');
// 1237         if (gpos) {
// 1238           const int codenum = strtol(gpos + 1, NULL, 10);
// 1239           switch (codenum) {
// 1240             case 0:
// 1241             case 1:
// 1242             case 2:
// 1243             case 3:
// 1244               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1245               LCD_MESSAGEPGM(MSG_STOPPED);
// 1246               break;
// 1247           }
// 1248         }
// 1249       }
// 1250 
// 1251       #if DISABLED(EMERGENCY_PARSER)
// 1252         // If command was e-stop process now
// 1253         if (strcmp(command, "M108") == 0) {
// 1254           wait_for_heatup = false;
// 1255           #if ENABLED(ULTIPANEL)
// 1256             wait_for_user = false;
// 1257           #endif
// 1258         }
// 1259         if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1260         if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1261       #endif
// 1262 
// 1263       #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1264         last_command_time = ms;
// 1265       #endif
// 1266 
// 1267       // Add the command to the queue
// 1268       _enqueuecommand(serial_line_buffer, true);
// 1269     }
// 1270     else if (serial_count >= MAX_CMD_SIZE - 1) {
// 1271       // Keep fetching, but ignore normal characters beyond the max length
// 1272       // The command will be injected when EOL is reached
// 1273     }
// 1274     else if (serial_char == '\\') {  // Handle escapes
// 1275       if ((c = MYSERIAL.read()) >= 0) {
// 1276         // if we have one more character, copy it over
// 1277         serial_char = c;
// 1278         if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1279       }
// 1280       // otherwise do nothing
// 1281     }
// 1282     else { // it's not a newline, carriage return or escape char
// 1283       if (serial_char == ';') serial_comment_mode = true;
// 1284       if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1285     }
// 1286 
// 1287   } // queue has space, serial has data
// 1288 }
// 1289 
// 1290 #if ENABLED(SDSUPPORT)
// 1291 
// 1292 uint8_t sd_read_error_flg=0;
// 1293 uint8_t sd_read_cnt=0;
// 1294 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function _Z16display_sd_errorv
        THUMB
// 1295 void display_sd_error()
// 1296 {
_Z16display_sd_errorv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
// 1297   char buf_sd_err[30]={0};
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 1298   
// 1299   if(sd_read_error_flg == 1)
        LDR.W    R4,??DataTable139_2
        LDRB     R0,[R4, #+9]
        CMP      R0,#+1
        BNE.N    ??display_sd_error_0
// 1300   {
// 1301       GUI_SetBkColor(gCfgItems.background_color);
        LDR.W    R5,??DataTable141_1
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 1302       GUI_SetColor(0X0000ff);//   o®¨®¶?°¡?®¨?
        MOVS     R0,#+255
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 1303       //memset(buf_sd_err,' ',sizeof(buf_sd_err)-1);
// 1304       //GUI_DispStringAt(buf_sd_err,250, TITLE_YPOS);
// 1305       sprintf(buf_sd_err,"sd:%d",sd_read_cnt);
        LDRB     R2,[R4, #+10]
        ADR.W    R1,`?<Constant "sd:%d">`
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
// 1306       GUI_DispStringAt(buf_sd_err,400, TITLE_YPOS);
        MOVS     R2,#+5
        MOV      R1,#+400
        ADD      R0,SP,#+0
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1307       GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 1308       GUI_SetColor(gCfgItems.title_color);            
        LDR      R0,[R5, #+8]
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 1309   }
// 1310 }
??display_sd_error_0:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock22

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "sd:%d">`:
        DC8 "sd:%d"
        DC8 0, 0
// 1311 
// 1312 
// 1313   /**
// 1314    * Get commands from the SD Card until the command buffer is full
// 1315    * or until the end of the file is reached. The special character '#'
// 1316    * can also interrupt buffering.
// 1317    */
// 1318   inline void get_sdcard_commands() {
// 1319     static bool stop_buffering = false,
// 1320                 sd_comment_mode = false;
// 1321 
// 1322     if (!card.sdprinting) return;
// 1323 
// 1324     /**
// 1325      * '#' stops reading from SD to the buffer prematurely, so procedural
// 1326      * macro calls are possible. If it occurs, stop_buffering is triggered
// 1327      * and the buffer is run dry; this character _can_ occur in serial com
// 1328      * due to checksums, however, no checksums are used in SD printing.
// 1329      */
// 1330 
// 1331     if (commands_in_queue == 0) stop_buffering = false;
// 1332 
// 1333     uint16_t sd_count = 0;
// 1334     bool card_eof = card.eof();
// 1335     while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
// 1336       const int16_t n = card.get();
// 1337       char sd_char = (char)n;//^0x08;
// 1338       card_eof = card.eof();
// 1339       if (card_eof || n == -1
// 1340           || sd_char == '\n' || sd_char == '\r'
// 1341           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
// 1342       ) {
// 1343         if (card_eof) {
// 1344           gCfgItems.breakpoint_reprint_flg = 0;
// 1345           gCfgItems.breakpoint_z_pos = 0;
// 1346           gCfgItems.breakpoint_flg=0;
// 1347 
// 1348           card.printingHasFinished();
// 1349 
// 1350           if (card.sdprinting)
// 1351             sd_count = 0; // If a sub-file was printing, continue from call point
// 1352           else {
// 1353             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
// 1354             #if ENABLED(PRINTER_EVENT_LEDS)
// 1355               LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
// 1356               leds.set_green();
// 1357               #if HAS_RESUME_CONTINUE
// 1358                 enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
// 1359               #else
// 1360                 safe_delay(1000);
// 1361               #endif
// 1362               leds.set_off();
// 1363             #endif
// 1364             card.checkautostart(true);
// 1365 			
// 1366 			#if 1
// 1367 			
// 1368 			
// 1369 			//°‰®∞®™®∫1??®≤?°Í
// 1370 			//if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
// 1371 			//    Close_machine_display();
// 1372 
// 1373             #endif 				
// 1374           }
// 1375         }
// 1376         else if (n == -1) {
// 1377           SERIAL_ERROR_START();
// 1378           SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
// 1379           //sd_count++;
// 1380           //card.cardOK=false;
// 1381           //commands_in_queue+=1;
// 1382           //sdpos_bak=card.sdpos;
// 1383           //card.sdprinting=false;
// 1384           SD_Init();
// 1385           card.initsd();
// 1386           if(card.reopenfile(curFileName))
// 1387           {
// 1388             card.setIndex(card.sdpos);
// 1389           }
// 1390           memset(command_queue[cmd_queue_index_w],0,sizeof(command_queue[cmd_queue_index_w]));
// 1391           //GUI_TOUCH_Exec(); 	  
// 1392           //GUI_Exec();
// 1393           	  #if 1
// 1394 		  thermalManager.manage_heater();
// 1395 		  
// 1396 		  display_temper_error();
// 1397 		  
// 1398 		  //wifi_looping();
// 1399 		  
// 1400 		  if(wifi_link_state != WIFI_TRANS_FILE)
// 1401 		  {
// 1402 			  GUI_RefreshPage();
// 1403 		  }
// 1404 		  #if defined(TFT70)
// 1405 		  disp_pre_gcode(3,40);
// 1406 		  #elif defined(TFT35)
// 1407 		  //#if defined(MKS_ROBIN2)
// 1408 		  if(preview_no_display != 1)
// 1409 		  {
// 1410 			  disp_pre_gcode(2,36);
// 1411 		  }
// 1412 		  //#endif
// 1413 		  #endif
// 1414 		  
// 1415 		  GUI_TOUCH_Exec(); 	  
// 1416 		  GUI_Exec(); 
// 1417 
// 1418 		#endif
// 1419 
// 1420           sd_read_error_flg=1;
// 1421           sd_read_cnt++;
// 1422         }
// 1423         if (sd_char == '#') stop_buffering = true;
// 1424 
// 1425         sd_comment_mode = false; // for new command
// 1426 
// 1427         if (!sd_count) continue; // skip empty lines (and comment lines)
// 1428 
// 1429         command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
// 1430         sd_count = 0; // clear sd line buffer
// 1431 
// 1432         _commit_command(false);
// 1433       }
// 1434       else if (sd_count >= MAX_CMD_SIZE - 1) {
// 1435         /**
// 1436          * Keep fetching, but ignore normal characters beyond the max length
// 1437          * The command will be injected when EOL is reached
// 1438          */
// 1439       }
// 1440       else {
// 1441         if (sd_char == ';') sd_comment_mode = true;
// 1442         //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1443         if (!sd_comment_mode) 
// 1444         {
// 1445 			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1446 			if(sd_char == 0x5a ) //"Z"
// 1447 			{
// 1448 				mksReprint.sdpos = card.getsdpos()-3;	//"°§?2?????"
// 1449 				#if 1
// 1450 				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bak¶Ã?®®Y??¶Ã?°Í????°‰®∫1®Æ?
// 1451 				if(gCfgItems.pwroff_save_mode != 1)//sd?°ß°¿°Í°‰???¶Ã?®∫y?Y
// 1452                 #endif
// 1453 					mksReprint.refresh = true;
// 1454 			}
// 1455         }        
// 1456       }
// 1457     }
// 1458   }
// 1459 
// 1460 #endif // SDSUPPORT
// 1461 #if 1
// 1462 inline void get_wifi_commands() {
// 1463   static char wifi_line_buffer[MAX_CMD_SIZE];
// 1464   static bool wifi_comment_mode = false;
// 1465 
// 1466   if(serial_wait_tick > 5)
// 1467   {
// 1468   	from_wifi_flag = 1;
// 1469 
// 1470 /**
// 1471 	   * Loop while serial characters are incoming and the queue is not full
// 1472 	   */
// 1473 	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
// 1474 
// 1475 	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
// 1476 
// 1477 	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
// 1478 
// 1479 	    /**
// 1480 	     * If the character ends the line
// 1481 	     */
// 1482 	    if (wifi_char == '\n' || wifi_char == '\r') {
// 1483 
// 1484 	      wifi_comment_mode = false; // end of line == end of comment
// 1485 
// 1486 	      if (!wifi_read_count) continue; // skip empty lines
// 1487 
// 1488 	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
// 1489 	      wifi_read_count = 0; //reset buffer
// 1490 
// 1491 	      char* command = wifi_line_buffer;
// 1492 
// 1493 	      while (*command == ' ') command++; // skip any leading spaces	    
// 1494 
// 1495 	      // Movement commands alert when stopped
// 1496 	      if (IsStopped()) {
// 1497 	        char* gpos = strchr(command, 'G');
// 1498 	        if (gpos) {
// 1499 	          const int codenum = strtol(gpos + 1, NULL, 10);
// 1500 	          switch (codenum) {
// 1501 	            case 0:
// 1502 	            case 1:
// 1503 	            case 2:
// 1504 	            case 3:
// 1505 	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1506 	              LCD_MESSAGEPGM(MSG_STOPPED);
// 1507 	              break;
// 1508 	          }
// 1509 	        }
// 1510 	      }
// 1511 
// 1512 	      #if DISABLED(EMERGENCY_PARSER)
// 1513 	        // If command was e-stop process now
// 1514 	        if (strcmp(command, "M108") == 0) {
// 1515 	          wait_for_heatup = false;
// 1516 	          #if ENABLED(ULTIPANEL)
// 1517 	            wait_for_user = false;
// 1518 	          #endif
// 1519 	        }
// 1520 	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1521 	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1522 	      #endif
// 1523 
// 1524 	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1525 	        last_command_time = ms;
// 1526 	      #endif
// 1527 
// 1528 	      // Add the command to the queue
// 1529 	      _enqueuecommand(wifi_line_buffer, true);
// 1530 	    }
// 1531 	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
// 1532 	      // Keep fetching, but ignore normal characters beyond the max length
// 1533 	      // The command will be injected when EOL is reached
// 1534 	    }
// 1535 		/*
// 1536 	    else if (wifi_char == '\\') {  // Handle escapes
// 1537 	      if (MYSERIAL.available() > 0) {
// 1538 	        // if we have one more character, copy it over
// 1539 	        wifi_char = MYSERIAL.read();
// 1540 	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1541 	      }
// 1542 	      // otherwise do nothing
// 1543 	    }*/
// 1544 	    else { // it's not a newline, carriage return or escape char
// 1545 	      if (wifi_char == ';') wifi_comment_mode = true;
// 1546 	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
// 1547 	    }
// 1548 
// 1549 	  }
// 1550     }// queue has space, serial has data
// 1551     else
// 1552     {
// 1553     	from_wifi_flag = 0;
// 1554     }
// 1555 }
// 1556 #endif
// 1557 
// 1558 /**
// 1559  * Add to the circular command queue the next command from:
// 1560  *  - The command-injection queue (injected_commands_P)
// 1561  *  - The active serial input (usually USB)
// 1562  *  - The SD card file being actively printed
// 1563  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function _Z22get_available_commandsv
        THUMB
// 1564 void get_available_commands() {
_Z22get_available_commandsv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1565 
// 1566   // if any immediate commands remain, don't get other commands yet
// 1567   if (drain_injected_commands_P()) return;
          CFI FunCall _Z25drain_injected_commands_Pv
        BL       _Z25drain_injected_commands_Pv
        CMP      R0,#+0
        BNE.N    ??get_available_commands_0
// 1568 
// 1569   get_serial_commands();
          CFI FunCall _Z19get_serial_commandsv
        BL       _Z19get_serial_commandsv
// 1570   
// 1571 #if 1
// 1572 	get_wifi_commands();
          CFI FunCall _Z17get_wifi_commandsv
        BL       _Z17get_wifi_commandsv
// 1573 #endif
// 1574 
// 1575   #if ENABLED(SDSUPPORT)
// 1576     get_sdcard_commands();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19get_sdcard_commandsv
        B.W      _Z19get_sdcard_commandsv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_commands_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock23
// 1577   #endif
// 1578 }
// 1579 
// 1580 /**
// 1581  * Set target_extruder from the T parameter or the active_extruder
// 1582  *
// 1583  * Returns TRUE if the target is invalid
// 1584  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function _Z32get_target_extruder_from_commandt
        THUMB
// 1585 bool get_target_extruder_from_command(const uint16_t code) {
_Z32get_target_extruder_from_commandt:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 1586   if (parser.seenval('T')) {
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??get_target_extruder_from_command_0
// 1587     const int8_t e = parser.value_byte();
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R5,R0
        SXTB     R5,R5
// 1588     if (e >= EXTRUDERS) {
        CMP      R5,#+2
        BLT.N    ??get_target_extruder_from_command_1
// 1589       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable139_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1590       SERIAL_CHAR('M');
        LDR.W    R6,??DataTable139_4
        MOVS     R1,#+77
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1591       SERIAL_ECHO(code);
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R6
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 1592       SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
        MOV      R1,R5
        ADR.W    R0,`?<Constant " Invalid extruder ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1593       return true;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
// 1594     }
// 1595     target_extruder = e;
??get_target_extruder_from_command_1:
        LDR.W    R0,??DataTable136_4
        STRB     R5,[R0, #+5]
        B.N      ??get_target_extruder_from_command_2
// 1596   }
// 1597   else
// 1598     target_extruder = active_extruder;
??get_target_extruder_from_command_0:
        LDR.W    R0,??DataTable136_4
        LDRB     R1,[R0, #+3]
        STRB     R1,[R0, #+5]
// 1599 
// 1600   return false;
??get_target_extruder_from_command_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock24
// 1601 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Invalid extruder ">`:
        DC8 " Invalid extruder "
        DC8 0
// 1602 
// 1603 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 1604   bool extruder_duplication_enabled = false; // Used in Dual X mode 2
// 1605 #endif
// 1606 
// 1607 #if ENABLED(DUAL_X_CARRIAGE)
// 1608 
// 1609   static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 1610 
// 1611   static float x_home_pos(const int extruder) {
// 1612     if (extruder == 0)
// 1613       return base_home_pos(X_AXIS);
// 1614     else
// 1615       /**
// 1616        * In dual carriage mode the extruder offset provides an override of the
// 1617        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
// 1618        * This allows soft recalibration of the second extruder home position
// 1619        * without firmware reflash (through the M218 command).
// 1620        */
// 1621       return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
// 1622   }
// 1623 
// 1624   static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
// 1625 
// 1626   static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
// 1627   static bool active_extruder_parked = false;        // used in mode 1 & 2
// 1628   static float raised_parked_position[XYZE];         // used in mode 1
// 1629   static millis_t delayed_move_time = 0;             // used in mode 1
// 1630   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
// 1631   static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
// 1632 
// 1633 #endif // DUAL_X_CARRIAGE
// 1634 
// 1635 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
// 1636 
// 1637   /**
// 1638    * Software endstops can be used to monitor the open end of
// 1639    * an axis that has a hardware endstop on the other end. Or
// 1640    * they can prevent axes from moving past endstops and grinding.
// 1641    *
// 1642    * To keep doing their job as the coordinate system changes,
// 1643    * the software endstop positions must be refreshed to remain
// 1644    * at the same positions relative to the machine.
// 1645    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function _Z24update_software_endstops8AxisEnum
        THUMB
// 1646   void update_software_endstops(const AxisEnum axis) {
_Z24update_software_endstops8AxisEnum:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R6,R0
// 1647     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
// 1648       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
        MOV      R7,R6
        LDR.W    R4,??DataTable136_4
        ADD      R8,R4,R7, LSL #+2
        LDR.W    R0,??DataTable139_2
        ADD      R0,R0,R7, LSL #+2
        LDR      R1,[R0, #+44]
        LDR      R0,[R8, #+96]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R8, #+56]
// 1649     #endif
// 1650 
// 1651     #if ENABLED(DUAL_X_CARRIAGE)
// 1652       if (axis == X_AXIS) {
// 1653 
// 1654         // In Dual X mode hotend_offset[X] is T1's home position
// 1655         float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
// 1656 
// 1657         if (active_extruder != 0) {
// 1658           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
// 1659           soft_endstop_min[X_AXIS] = X2_MIN_POS;
// 1660           soft_endstop_max[X_AXIS] = dual_max_x;
// 1661         }
// 1662         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
// 1663           // In Duplication Mode, T0 can move as far left as X_MIN_POS
// 1664           // but not so far to the right that T1 would move past the end
// 1665           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
// 1666           soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
// 1667         }
// 1668         else {
// 1669           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
// 1670           soft_endstop_min[axis] = base_min_pos(axis);
// 1671           soft_endstop_max[axis] = base_max_pos(axis);
// 1672         }
// 1673       }
// 1674 	#else
// 1675     if (MACHINETPYE == DELTA)//ENABLED(DELTA)
        LDR.W    R5,??DataTable136_9
        LDR.W    R9,??DataTable136_5
        LDRSH    R0,[R9, #+88]
        CMP      R0,#+2
        MOV      R0,R6
        BNE.N    ??update_software_endstops_0
// 1676     {
// 1677       soft_endstop_min[axis] = base_min_pos(axis);
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        STR      R0,[R8, #+68]
// 1678       soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
        CMP      R7,#+2
        BNE.N    ??update_software_endstops_1
        LDR      R0,[R4, #+120]
        B.N      ??update_software_endstops_2
??update_software_endstops_1:
        MOV      R0,R6
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
??update_software_endstops_2:
        ADD      R1,R5,R7, LSL #+2
        STR      R0,[R1, #+36]
        B.N      ??update_software_endstops_3
// 1679     }
// 1680     else
// 1681     {
// 1682       soft_endstop_min[axis] = base_min_pos(axis);
??update_software_endstops_0:
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        STR      R0,[R8, #+68]
// 1683       soft_endstop_max[axis] = base_max_pos(axis);
        MOV      R0,R6
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
        ADD      R1,R5,R7, LSL #+2
        STR      R0,[R1, #+36]
// 1684     }
// 1685     #endif
// 1686 
// 1687     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1688       if (DEBUGGING(LEVELING)) {
// 1689         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
// 1690         #if HAS_HOME_OFFSET
// 1691           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
// 1692         #endif
// 1693         #if HAS_POSITION_SHIFT
// 1694           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
// 1695         #endif
// 1696         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
// 1697         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
// 1698       }
// 1699     #endif
// 1700 
// 1701     //#if ENABLED(DELTA)
// 1702     if(MACHINETPYE == DELTA)
??update_software_endstops_3:
        LDRSH    R0,[R9, #+88]
        CMP      R0,#+2
        BNE.N    ??update_software_endstops_4
// 1703     {
// 1704       switch(axis) {
        CMP      R6,#+0
        BEQ.N    ??update_software_endstops_5
        CMP      R6,#+2
        BEQ.N    ??update_software_endstops_6
        BCS.N    ??update_software_endstops_4
// 1705         case X_AXIS:
// 1706         case Y_AXIS:
// 1707           // Get a minimum radius for clamping
// 1708           soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
??update_software_endstops_5:
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_7
        MOV      R1,R0
??update_software_endstops_7:
        BIC      R0,R1,#0x80000000
        LDR      R2,[R5, #+36]
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_8
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_9
        MOV      R1,R0
??update_software_endstops_9:
        BIC      R2,R1,#0x80000000
??update_software_endstops_8:
        LDR      R1,[R5, #+40]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_10
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_11
        MOV      R1,R0
??update_software_endstops_11:
        BIC      R0,R1,#0x80000000
        LDR      R1,[R5, #+36]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_12
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_13
        MOV      R1,R0
??update_software_endstops_13:
        BIC      R0,R1,#0x80000000
        STR      R0,[R5, #+84]
        B.N      ??update_software_endstops_14
??update_software_endstops_12:
        STR      R1,[R5, #+84]
        B.N      ??update_software_endstops_14
??update_software_endstops_10:
        STR      R1,[R5, #+84]
// 1709           soft_endstop_radius_2 = sq(soft_endstop_radius);
??update_software_endstops_14:
        LDR      R4,[R5, #+84]
        MOVS     R6,#+2
        MOV      R7,#+1065353216
        B.N      ??update_software_endstops_15
??update_software_endstops_16:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??update_software_endstops_15:
        LSLS     R0,R6,#+31
        BPL.N    ??update_software_endstops_17
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??update_software_endstops_17:
        LSRS     R6,R6,#+1
        BNE.N    ??update_software_endstops_16
        STR      R7,[R5, #+88]
// 1710           break;
        B.N      ??update_software_endstops_4
// 1711         case Z_AXIS:
// 1712           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
??update_software_endstops_6:
          CFI FunCall _Z28delta_safe_distance_from_topv
        BL       _Z28delta_safe_distance_from_topv
        MOV      R1,R0
        LDR      R0,[R5, #+44]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+124]
// 1713         default: break;
// 1714       }
// 1715     }
// 1716     //#endif
// 1717   }
??update_software_endstops_4:
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock25
// 1718 
// 1719 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
// 1720 
// 1721 #if 1//HAS_M206_COMMAND
// 1722   /**
// 1723    * Change the home offset for an axis, update the current
// 1724    * position and the software endstops to retain the same
// 1725    * relative distance to the new home.
// 1726    *
// 1727    * Since this changes the current_position, code should
// 1728    * call sync_plan_position soon after this.
// 1729    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function _Z15set_home_offset8AxisEnumf
        THUMB
// 1730   static void set_home_offset(const AxisEnum axis, const float v) {
// 1731 
// 1732   	if(MACHINETPYE == DELTA)	return;
_Z15set_home_offset8AxisEnumf:
        LDR.W    R2,??DataTable136_5
        LDRSH    R2,[R2, #+88]
        CMP      R2,#+2
        BEQ.N    ??set_home_offset_0
// 1733 	
// 1734     home_offset[axis] = v;
        LDR.W    R2,??DataTable139_2
        ADD      R2,R2,R0, LSL #+2
        STR      R1,[R2, #+44]
// 1735     update_software_endstops(axis);
          CFI FunCall _Z24update_software_endstops8AxisEnum
        B.N      _Z24update_software_endstops8AxisEnum
??set_home_offset_0:
        BX       LR               ;; return
          CFI EndBlock cfiBlock26
// 1736   }
// 1737 #endif // HAS_M206_COMMAND
// 1738 
// 1739 /**
// 1740  * Set an axis' current position to its home position (after homing).
// 1741  *
// 1742  * For Core and Cartesian robots this applies one-to-one when an
// 1743  * individual axis has been homed.
// 1744  *
// 1745  * DELTA should wait until all homing is done before setting the XYZ
// 1746  * current_position to home, because homing is a single operation.
// 1747  * In the case where the axis positions are already known and previously
// 1748  * homed, DELTA could home to X or Y individually by moving either one
// 1749  * to the center. However, homing Z always homes XY and Z.
// 1750  *
// 1751  * SCARA should wait until all XY homing is done before setting the XY
// 1752  * current_position to home, because neither X nor Y is at home until
// 1753  * both are at home. Z can however be homed individually.
// 1754  *
// 1755  * Callers must sync the planner position after calling this!
// 1756  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function _Z19set_axis_is_at_home8AxisEnum
        THUMB
// 1757 static void set_axis_is_at_home(const AxisEnum axis) {
_Z19set_axis_is_at_home8AxisEnum:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R4,R0
// 1758   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1759     if (DEBUGGING(LEVELING)) {
// 1760       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
// 1761       SERIAL_CHAR(')');
// 1762       SERIAL_EOL();
// 1763     }
// 1764   #endif
// 1765 
// 1766   axis_known_position[axis] = axis_homed[axis] = true;
        MOV      R5,R4
        LDR.W    R6,??DataTable136_9
        MOVS     R0,#+1
        STRB     R0,[R5, R6]
        ADDS     R1,R5,R6
        STRB     R0,[R1, #+4]
// 1767 
// 1768   #if HAS_POSITION_SHIFT
// 1769     position_shift[axis] = 0;
        LDR.W    R7,??DataTable136_4
        ADD      R8,R7,R5, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R8, #+96]
// 1770     update_software_endstops(axis);
        MOV      R0,R4
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 1771   #endif
// 1772 
// 1773   #if ENABLED(DUAL_X_CARRIAGE)
// 1774     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
// 1775       current_position[X_AXIS] = x_home_pos(active_extruder);
// 1776       return;
// 1777     }
// 1778   #endif
// 1779 
// 1780   //#if ENABLED(MORGAN_SCARA)
// 1781   if(MACHINETPYE&MORGAN_SCARA)
        LDR.W    R9,??DataTable136_5
        LDRSH    R0,[R9, #+88]
        LSLS     R1,R0,#+23
        BPL.N    ??set_axis_is_at_home_0
// 1782   	{
// 1783     /**
// 1784      * Morgan SCARA homes XY at the same time
// 1785      */
// 1786     if (axis == X_AXIS || axis == Y_AXIS) {
        CMP      R4,#+0
        BEQ.N    ??set_axis_is_at_home_1
        CMP      R5,#+1
        BNE.N    ??set_axis_is_at_home_2
// 1787 
// 1788       float homeposition[XYZ] = {
??set_axis_is_at_home_1:
        MOVS     R0,#+0
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[SP, #+0]
        ADD      R10,SP,#+0
        MOVS     R0,#+1
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R10, #+4]
        MOVS     R0,#+2
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R10, #+8]
// 1789         base_home_pos(X_AXIS),
// 1790         base_home_pos(Y_AXIS),
// 1791         base_home_pos(Z_AXIS)
// 1792       };
// 1793 
// 1794       // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
// 1795       // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
// 1796 
// 1797       /**
// 1798        * Get Home position SCARA arm angles using inverse kinematics,
// 1799        * and calculate homing offset using forward kinematics
// 1800        */
// 1801       inverse_kinematics_MORGAN_SCARA(homeposition);
        ADD      R0,SP,#+0
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
// 1802       forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
        ADD      R1,R7,#+84
        ADD      R0,R7,#+80
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 1803 
// 1804       // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
// 1805       // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
// 1806 
// 1807       current_position[axis] = cartes[axis];
        ADD      R6,R6,R5, LSL #+2
        LDR      R0,[R6, #+72]
        STR      R0,[R8, #+8]
// 1808 
// 1809       /**
// 1810        * SCARA home positions are based on configuration since the actual
// 1811        * limits are determined by the inverse kinematic transform.
// 1812        */
// 1813       soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
        MOV      R0,R4
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        STR      R0,[R8, #+68]
// 1814       soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
        MOV      R0,R4
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
        STR      R0,[R6, #+36]
        B.N      ??set_axis_is_at_home_3
// 1815     }
// 1816     else
// 1817 	{
// 1818 	    current_position[axis] = base_home_pos(axis);
??set_axis_is_at_home_2:
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R8, #+8]
        B.N      ??set_axis_is_at_home_3
// 1819 	}		
// 1820   	}
// 1821   //#elif ENABLED(DELTA)
// 1822   else if(MACHINETPYE&DELTA)
??set_axis_is_at_home_0:
        LSLS     R0,R0,#+30
        BPL.N    ??set_axis_is_at_home_4
// 1823   {
// 1824     if (axis == Z_AXIS)
        CMP      R5,#+2
        BNE.N    ??set_axis_is_at_home_5
// 1825       current_position[axis] = delta_height;
        LDR      R0,[R7, #+120]
        STR      R0,[R8, #+8]
        B.N      ??set_axis_is_at_home_3
// 1826     else
// 1827   //#endif
// 1828   	{
// 1829     	current_position[axis] = base_home_pos(axis);
??set_axis_is_at_home_5:
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R8, #+8]
        B.N      ??set_axis_is_at_home_3
// 1830   	}
// 1831   }
// 1832   else
// 1833   {
// 1834     	current_position[axis] = base_home_pos(axis);
??set_axis_is_at_home_4:
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R8, #+8]
// 1835   }    
// 1836   /**
// 1837    * Z Probe Z Homing? Account for the probe's Z offset.
// 1838    */
// 1839   #if HAS_BED_PROBE //&& Z_HOME_DIR < 0
// 1840   if(Z_HOME_DIR < 0)
??set_axis_is_at_home_3:
        LDRSB    R0,[R9, #+7]
        CMP      R0,#+0
        BPL.N    ??set_axis_is_at_home_6
// 1841   {
// 1842     if (axis == Z_AXIS) {
        CMP      R5,#+2
        BNE.N    ??set_axis_is_at_home_6
// 1843       #if HOMING_Z_WITH_PROBE
// 1844 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
        LDRB     R0,[R9, #+153]
        CMP      R0,#+1
        BNE.N    ??set_axis_is_at_home_7
// 1845 	  {
// 1846         current_position[Z_AXIS] -= zprobe_zoffset;
        LDR      R0,[R7, #+16]
        LDR      R1,[R7, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+16]
        B.N      ??set_axis_is_at_home_6
// 1847 
// 1848         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1849           if (DEBUGGING(LEVELING)) {
// 1850             SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
// 1851             SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
// 1852           }
// 1853         #endif
// 1854 	  }
// 1855 	  else
// 1856 	  {
// 1857 		  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");	  
??set_axis_is_at_home_7:
        LDRB     R0,[R7, #+1]
        LSLS     R0,R0,#+26
        BPL.N    ??set_axis_is_at_home_6
        ADR.W    R0,`?<Constant "*** Z HOMED TO ENDSTO...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1858 	  }
// 1859       #elif ENABLED(DEBUG_LEVELING_FEATURE)
// 1860 
// 1861         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
// 1862 
// 1863       #endif
// 1864     }
// 1865   }
// 1866   #endif
// 1867 
// 1868   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1869     if (DEBUGGING(LEVELING)) {
// 1870       #if HAS_HOME_OFFSET
// 1871         SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
// 1872         SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
// 1873       #endif
// 1874       DEBUG_POS("", current_position);
// 1875       SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
// 1876       SERIAL_CHAR(')');
// 1877       SERIAL_EOL();
// 1878     }
// 1879   #endif
// 1880 
// 1881   #if ENABLED(I2C_POSITION_ENCODERS)
// 1882     I2CPEM.homed(axis);
// 1883   #endif
// 1884 }
??set_axis_is_at_home_6:
        POP      {R0-R10,PC}      ;; return
          CFI EndBlock cfiBlock27

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "*** Z HOMED TO ENDSTO...">`:
        DC8 "*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***\012"
        DC8 0, 0
// 1885 
// 1886 /**
// 1887  * Some planner shorthand inline functions
// 1888  */
// 1889 inline float get_homing_bump_feedrate(const AxisEnum axis) {
// 1890   //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
// 1891 	int  homing_bump_divisor[4];
// 1892 	if(MACHINETPYE == DELTA)
// 1893 	{
// 1894 		homing_bump_divisor[0] = 10;
// 1895 		homing_bump_divisor[1] = 10;
// 1896 		homing_bump_divisor[2] = 10;
// 1897 	}
// 1898 	else
// 1899 	{
// 1900 		homing_bump_divisor[0] = 2;
// 1901 		homing_bump_divisor[1] = 2;
// 1902 		homing_bump_divisor[2] = 4;
// 1903 	}  
// 1904   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
// 1905   if (hbd < 1) {
// 1906     hbd = 10;
// 1907     SERIAL_ECHO_START();
// 1908     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
// 1909   }
// 1910   //return homing_feedrate(axis) / hbd;
// 1911   return homing_feedrate_mm_s[axis] / hbd;
// 1912 }
// 1913 
// 1914 /**
// 1915  * Move the planner to the current position from wherever it last moved
// 1916  * (or from wherever it has been told it is located).
// 1917  */
// 1918 inline void buffer_line_to_current_position() {
// 1919   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
// 1920 }
// 1921 
// 1922 /**
// 1923  * Move the planner to the position stored in the destination array, which is
// 1924  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
// 1925  */
// 1926 inline void buffer_line_to_destination(const float fr_mm_s) {
// 1927   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
// 1928 }
// 1929 
// 1930 #if 1//IS_KINEMATIC
// 1931   /**
// 1932    * Calculate delta, start a line, and set current_position to destination
// 1933    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function _Z42prepare_uninterpolated_move_to_destinationf
        THUMB
// 1934   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
_Z42prepare_uninterpolated_move_to_destinationf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 1935     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1936       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
// 1937     #endif
// 1938 
// 1939     refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 1940 
// 1941     #if UBL_SEGMENTED
// 1942       // ubl segmented line will do z-only moves in single segment
// 1943       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
// 1944     #else
// 1945       if ( current_position[X_AXIS] == destination[X_AXIS]
// 1946         && current_position[Y_AXIS] == destination[Y_AXIS]
// 1947         && current_position[Z_AXIS] == destination[Z_AXIS]
// 1948         && current_position[E_AXIS] == destination[E_AXIS]
// 1949       ) return;
        LDR.W    R5,??DataTable136_4
        LDR      R0,[R5, #+8]
        LDR      R1,[R5, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+12]
        LDR      R1,[R5, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+16]
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+20]
        LDR      R1,[R5, #+36]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_uninterpolated_move_to_destination_1
// 1950 
// 1951       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
??prepare_uninterpolated_move_to_destination_0:
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_2
        LDR      R4,[R5, #+92]
??prepare_uninterpolated_move_to_destination_2:
        LDRSH    R0,[R5, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145  ;; 0x47ae147b
        LDR.W    R3,??DataTable146  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        LDRB     R2,[R5, #+3]
        ADD      R1,SP,#+0
        ADD      R0,R5,#+24
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 1952     #endif
// 1953 
// 1954     set_current_from_destination();
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 1955   }
??prepare_uninterpolated_move_to_destination_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock28
// 1956 #endif // IS_KINEMATIC
// 1957 
// 1958 /**
// 1959  *  Plan a move to (X, Y, Z) and set the current_position
// 1960  *  The final current_position may not be the one that was requested
// 1961  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function _Z19do_blocking_move_toRKfS0_S0_S0_
        THUMB
// 1962 void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z19do_blocking_move_toRKfS0_S0_S0_:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R7,R0
        MOV      R8,R1
        MOV      R4,R2
        MOV      R9,R3
// 1963   const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R5,??DataTable136_4
        LDR      R6,[R5, #+92]
// 1964 
// 1965   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1966     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
// 1967   #endif
// 1968 
// 1969   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        LDR      R10,[R9, #+0]
        MOV      R0,R10
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??do_blocking_move_to_0
        LDR      R10,[R5, #+48]
??do_blocking_move_to_0:
        LDR.W    R0,??DataTable136_5
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??do_blocking_move_to_1
// 1970 
// 1971   //#if ENABLED(DELTA)
// 1972   if(MACHINETPYE == DELTA)
// 1973   {
// 1974     if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
        MOV      R1,R8
        MOV      R0,R7
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.W    ??do_blocking_move_to_2
// 1975 
// 1976     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_3
        STR      R2,[R5, #+92]
        B.N      ??do_blocking_move_to_4
??do_blocking_move_to_3:
        LDR      R0,[R5, #+116]
        STR      R0,[R5, #+92]
// 1977 
// 1978     set_destination_from_current();          // sync destination at the start
??do_blocking_move_to_4:
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
// 1979 
// 1980     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1981       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
// 1982     #endif
// 1983 
// 1984     // when in the danger zone
// 1985     if (current_position[Z_AXIS] > delta_clip_start_height) {
        LDR      R0,[R5, #+124]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_5
// 1986       if (rz > delta_clip_start_height) {   // staying in the danger zone
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_6
// 1987         destination[X_AXIS] = rx;           // move directly (uninterpolated)
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+24]
// 1988         destination[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+28]
// 1989         destination[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+32]
// 1990         prepare_uninterpolated_move_to_destination(); // set_current_from_destination
        MOVS     R0,#+0
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.N      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
// 1991         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1992           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1993         #endif
// 1994         return;
// 1995       }
// 1996       destination[Z_AXIS] = delta_clip_start_height;
??do_blocking_move_to_6:
        STR      R0,[R5, #+32]
// 1997       prepare_uninterpolated_move_to_destination(); // set_current_from_destination
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 1998       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1999         if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 2000       #endif
// 2001     }
// 2002 
// 2003     if (rz > current_position[Z_AXIS]) {    // raising?
??do_blocking_move_to_5:
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_7
// 2004       destination[Z_AXIS] = rz;
        STR      R1,[R5, #+32]
// 2005       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2006       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2007         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 2008       #endif
// 2009     }
// 2010 
// 2011     destination[X_AXIS] = rx;
??do_blocking_move_to_7:
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+24]
// 2012     destination[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+28]
// 2013     prepare_move_to_destination();         // set_current_from_destination
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 2014     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2015       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 2016     #endif
// 2017 
// 2018     if (rz < current_position[Z_AXIS]) {    // lowering?
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
        B.N      ??do_blocking_move_to_9
// 2019       destination[Z_AXIS] = rz;
// 2020       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 2021       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2022         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 2023       #endif
// 2024     }
// 2025   }
// 2026   //#elif IS_SCARA
// 2027   else if(MACHINETPYE&IS_SCARA) {
??do_blocking_move_to_1:
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??do_blocking_move_to_10
// 2028 
// 2029     if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
        MOV      R1,R8
        MOV      R0,R7
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??do_blocking_move_to_2
// 2030 
// 2031     set_destination_from_current();
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
// 2032 
// 2033     // If Z needs to raise, do it before moving XY
// 2034     if (destination[Z_AXIS] < rz) {
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+32]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_11
// 2035       destination[Z_AXIS] = rz;
        STR      R1,[R5, #+32]
// 2036       prepare_uninterpolated_move_to_destination(z_feedrate);
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2037     }
// 2038 
// 2039     destination[X_AXIS] = rx;
??do_blocking_move_to_11:
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+24]
// 2040     destination[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+28]
// 2041     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??do_blocking_move_to_12
        LDR      R2,[R5, #+116]
??do_blocking_move_to_12:
        MOV      R0,R2
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2042 
// 2043     // If Z needs to lower, do it after moving XY
// 2044     if (destination[Z_AXIS] > rz) {
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
// 2045       destination[Z_AXIS] = rz;
??do_blocking_move_to_9:
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+32]
// 2046       prepare_uninterpolated_move_to_destination(z_feedrate);
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
        B.N      ??do_blocking_move_to_8
// 2047     }
// 2048   }
// 2049   //#else
// 2050   else
// 2051   {
// 2052     // If Z needs to raise, do it before moving XY
// 2053     if (current_position[Z_AXIS] < rz) {
??do_blocking_move_to_10:
        LDR      R0,[R5, #+16]
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_13
// 2054       feedrate_mm_s = z_feedrate;
        STR      R10,[R5, #+92]
// 2055       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+16]
// 2056       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2057     }
// 2058 
// 2059     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_13:
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_14
        STR      R2,[R5, #+92]
        B.N      ??do_blocking_move_to_15
??do_blocking_move_to_14:
        LDR      R0,[R5, #+116]
        STR      R0,[R5, #+92]
// 2060     current_position[X_AXIS] = rx;
??do_blocking_move_to_15:
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+8]
// 2061     current_position[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+12]
// 2062     buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2063 
// 2064     // If Z needs to lower, do it after moving XY
// 2065     if (current_position[Z_AXIS] > rz) {
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
// 2066       feedrate_mm_s = z_feedrate;
        STR      R10,[R5, #+92]
// 2067       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+16]
// 2068       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2069     }
// 2070   }
// 2071   //#endif
// 2072 
// 2073   stepper.synchronize();
??do_blocking_move_to_8:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 2074 
// 2075   feedrate_mm_s = old_feedrate_mm_s;
        STR      R6,[R5, #+92]
// 2076 
// 2077   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2078     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 2079   #endif
// 2080 }
??do_blocking_move_to_2:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock29

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_xRKfS0_
        THUMB
// 2081 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_xRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2082   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
        LDR.N    R4,??DataTable136_4
        MOV      R3,R1
        ADD      R2,R4,#+16
        ADD      R1,R4,#+12
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock30
// 2083 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_zRKfS0_
        THUMB
// 2084 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_zRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2085   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
        LDR.N    R4,??DataTable136_4
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,R4,#+12
        ADD      R0,R4,#+8
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock31
// 2086 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function _Z22do_blocking_move_to_xyRKfS0_S0_
        THUMB
// 2087 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
// 2088   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
_Z22do_blocking_move_to_xyRKfS0_S0_:
        MOV      R3,R2
        LDR.W    R2,??DataTable147
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock32
// 2089 }
// 2090 
// 2091 //
// 2092 // Prepare to do endstop or probe moves
// 2093 // with custom feedrates.
// 2094 //
// 2095 //  - Save current feedrates
// 2096 //  - Reset the rate multiplier
// 2097 //  - Reset the command timeout
// 2098 //  - Enable the endstops (for endstop moves)
// 2099 //

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function _Z31setup_for_endstop_or_probe_movev
        THUMB
// 2100 static void setup_for_endstop_or_probe_move() {
// 2101   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2102     if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
// 2103   #endif
// 2104   saved_feedrate_mm_s = feedrate_mm_s;
_Z31setup_for_endstop_or_probe_movev:
        LDR.W    R0,??DataTable147_1
        LDR.N    R1,??DataTable136_4
        LDR      R2,[R1, #+92]
        STR      R2,[R0, #+4]
// 2105   saved_feedrate_percentage = feedrate_percentage;
        LDRH     R2,[R1, #+6]
        STRH     R2,[R0, #+0]
// 2106   feedrate_percentage = 100;
        MOVS     R0,#+100
        STRH     R0,[R1, #+6]
// 2107   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock33
// 2108 }
// 2109 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function _Z36clean_up_after_endstop_or_probe_movev
        THUMB
// 2110 static void clean_up_after_endstop_or_probe_move() {
// 2111   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2112     if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
// 2113   #endif
// 2114   feedrate_mm_s = saved_feedrate_mm_s;
_Z36clean_up_after_endstop_or_probe_movev:
        LDR.N    R0,??DataTable136_4
        LDR.W    R1,??DataTable147_1
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+92]
// 2115   feedrate_percentage = saved_feedrate_percentage;
        LDRH     R1,[R1, #+0]
        STRH     R1,[R0, #+6]
// 2116   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock34
// 2117 }
// 2118 
// 2119 #if HAS_BED_PROBE
// 2120   /**
// 2121    * Raise Z to a minimum height to make room for a probe to move
// 2122    */
// 2123   inline void do_probe_raise(const float z_raise) {
// 2124     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2125       if (DEBUGGING(LEVELING)) {
// 2126         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
// 2127         SERIAL_CHAR(')');
// 2128         SERIAL_EOL();
// 2129       }
// 2130     #endif
// 2131 
// 2132     float z_dest = z_raise;
// 2133     if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
// 2134 
// 2135     if (z_dest > current_position[Z_AXIS])
// 2136       do_blocking_move_to_z(z_dest);
// 2137   }
// 2138 
// 2139 #endif // HAS_BED_PROBE
// 2140 
// 2141 #if HAS_AXIS_UNHOMED_ERR
// 2142 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function _Z18axis_unhomed_errorbbb
        THUMB
// 2143   bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
_Z18axis_unhomed_errorbbb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 2144     #if ENABLED(HOME_AFTER_DEACTIVATE)
// 2145       const bool xx = x && !axis_known_position[X_AXIS],
// 2146                  yy = y && !axis_known_position[Y_AXIS],
// 2147                  zz = z && !axis_known_position[Z_AXIS];
// 2148     #else
// 2149       const bool xx = x && !axis_homed[X_AXIS],
        CMP      R0,#+0
        BEQ.N    ??axis_unhomed_error_0
        LDR.N    R0,??DataTable136_9
        LDRB     R0,[R0, #+0]
        EOR      R4,R0,#0x1
        B.N      ??axis_unhomed_error_1
??axis_unhomed_error_0:
        MOVS     R4,#+0
// 2150                  yy = y && !axis_homed[Y_AXIS],
??axis_unhomed_error_1:
        CMP      R1,#+0
        BEQ.N    ??axis_unhomed_error_2
        LDR.N    R0,??DataTable136_9
        LDRB     R0,[R0, #+1]
        EOR      R5,R0,#0x1
        B.N      ??axis_unhomed_error_3
??axis_unhomed_error_2:
        MOVS     R5,#+0
// 2151                  zz = z && !axis_homed[Z_AXIS];
??axis_unhomed_error_3:
        CMP      R2,#+0
        BEQ.N    ??axis_unhomed_error_4
        LDR.N    R0,??DataTable136_9
        LDRB     R0,[R0, #+2]
        EOR      R6,R0,#0x1
        B.N      ??axis_unhomed_error_5
??axis_unhomed_error_4:
        MOVS     R6,#+0
// 2152     #endif
// 2153     if (xx || yy || zz) {
??axis_unhomed_error_5:
        ORR      R0,R5,R4
        ORRS     R0,R6,R0
        BEQ.N    ??axis_unhomed_error_6
// 2154       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable139_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2155       SERIAL_ECHOPGM(MSG_HOME " ");
        ADR.W    R0,`?<Constant "Home ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2156       if (xx) SERIAL_ECHOPGM(MSG_X);
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_7
        ADR.N    R0,??DataTable136  ;; "X"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2157       if (yy) SERIAL_ECHOPGM(MSG_Y);
??axis_unhomed_error_7:
        CMP      R5,#+0
        BEQ.N    ??axis_unhomed_error_8
        ADR.N    R0,??DataTable136_1  ;; "Y"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2158       if (zz) SERIAL_ECHOPGM(MSG_Z);
??axis_unhomed_error_8:
        CMP      R6,#+0
        BEQ.N    ??axis_unhomed_error_9
        ADR.N    R0,??DataTable136_2  ;; "Z"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2159       SERIAL_ECHOLNPGM(" " MSG_FIRST);
??axis_unhomed_error_9:
        ADR.W    R0,`?<Constant " first\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2160 
// 2161       #if ENABLED(ULTRA_LCD)
// 2162         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
// 2163       #endif
// 2164       return true;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
// 2165     }
// 2166     return false;
??axis_unhomed_error_6:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock35
// 2167   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Home ">`:
        DC8 "Home "
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " first\\n">`:
        DC8 " first\012"
// 2168 
// 2169 #endif // HAS_AXIS_UNHOMED_ERR
// 2170 
// 2171 #if ENABLED(Z_PROBE_SLED)
// 2172 
// 2173   #ifndef SLED_DOCKING_OFFSET
// 2174     #define SLED_DOCKING_OFFSET 0
// 2175   #endif
// 2176 
// 2177   /**
// 2178    * Method to dock/undock a sled designed by Charles Bell.
// 2179    *
// 2180    * stow[in]     If false, move to MAX_X and engage the solenoid
// 2181    *              If true, move to MAX_X and release the solenoid
// 2182    */
// 2183   static void dock_sled(bool stow) {
// 2184     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2185       if (DEBUGGING(LEVELING)) {
// 2186         SERIAL_ECHOPAIR("dock_sled(", stow);
// 2187         SERIAL_CHAR(')');
// 2188         SERIAL_EOL();
// 2189       }
// 2190     #endif
// 2191 
// 2192     // Dock sled a bit closer to ensure proper capturing
// 2193     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
// 2194 
// 2195     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
// 2196       WRITE(SOL1_PIN, !stow); // switch solenoid
// 2197     #endif
// 2198   }
// 2199 
// 2200 #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2201 
// 2202   FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
// 2203     do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
// 2204   }
// 2205 
// 2206   void run_deploy_moves_script() {
// 2207     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
// 2208       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
// 2209         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
// 2210       #endif
// 2211       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
// 2212         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
// 2213       #endif
// 2214       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
// 2215         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
// 2216       #endif
// 2217       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
// 2218         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
// 2219       #endif
// 2220       const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
// 2221       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
// 2222     #endif
// 2223     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
// 2224       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
// 2225         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
// 2226       #endif
// 2227       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
// 2228         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
// 2229       #endif
// 2230       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
// 2231         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
// 2232       #endif
// 2233       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
// 2234         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
// 2235       #endif
// 2236       const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
// 2237       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
// 2238     #endif
// 2239     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
// 2240       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
// 2241         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
// 2242       #endif
// 2243       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
// 2244         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
// 2245       #endif
// 2246       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
// 2247         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
// 2248       #endif
// 2249       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
// 2250         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
// 2251       #endif
// 2252       const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
// 2253       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
// 2254     #endif
// 2255     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
// 2256       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
// 2257         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
// 2258       #endif
// 2259       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
// 2260         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
// 2261       #endif
// 2262       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
// 2263         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
// 2264       #endif
// 2265       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
// 2266         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
// 2267       #endif
// 2268       const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
// 2269       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
// 2270     #endif
// 2271     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
// 2272       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
// 2273         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
// 2274       #endif
// 2275       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
// 2276         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
// 2277       #endif
// 2278       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
// 2279         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
// 2280       #endif
// 2281       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
// 2282         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
// 2283       #endif
// 2284       const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
// 2285       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
// 2286     #endif
// 2287   }
// 2288 
// 2289   void run_stow_moves_script() {
// 2290     #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
// 2291       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
// 2292         #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
// 2293       #endif
// 2294       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
// 2295         #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
// 2296       #endif
// 2297       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
// 2298         #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
// 2299       #endif
// 2300       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
// 2301         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
// 2302       #endif
// 2303       const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
// 2304       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
// 2305     #endif
// 2306     #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
// 2307       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
// 2308         #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
// 2309       #endif
// 2310       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
// 2311         #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
// 2312       #endif
// 2313       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
// 2314         #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
// 2315       #endif
// 2316       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
// 2317         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
// 2318       #endif
// 2319       const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
// 2320       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
// 2321     #endif
// 2322     #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
// 2323       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
// 2324         #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
// 2325       #endif
// 2326       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
// 2327         #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
// 2328       #endif
// 2329       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
// 2330         #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
// 2331       #endif
// 2332       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
// 2333         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
// 2334       #endif
// 2335       const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
// 2336       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
// 2337     #endif
// 2338     #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
// 2339       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
// 2340         #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
// 2341       #endif
// 2342       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
// 2343         #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
// 2344       #endif
// 2345       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
// 2346         #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
// 2347       #endif
// 2348       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
// 2349         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
// 2350       #endif
// 2351       const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
// 2352       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
// 2353     #endif
// 2354     #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
// 2355       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
// 2356         #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
// 2357       #endif
// 2358       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
// 2359         #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
// 2360       #endif
// 2361       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
// 2362         #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
// 2363       #endif
// 2364       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
// 2365         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
// 2366       #endif
// 2367       const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
// 2368       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
// 2369     #endif
// 2370   }
// 2371 
// 2372 #endif // Z_PROBE_ALLEN_KEY
// 2373 
// 2374 #if ENABLED(PROBING_FANS_OFF)
// 2375 
// 2376   void fans_pause(const bool p) {
// 2377     if (p != fans_paused) {
// 2378       fans_paused = p;
// 2379       if (p)
// 2380         for (uint8_t x = 0; x < FAN_COUNT; x++) {
// 2381           paused_fanSpeeds[x] = fanSpeeds[x];
// 2382           fanSpeeds[x] = 0;
// 2383         }
// 2384       else
// 2385         for (uint8_t x = 0; x < FAN_COUNT; x++)
// 2386           fanSpeeds[x] = paused_fanSpeeds[x];
// 2387     }
// 2388   }
// 2389 
// 2390 #endif // PROBING_FANS_OFF
// 2391 
// 2392 #if HAS_BED_PROBE
// 2393 
// 2394   // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
// 2395   #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
// 2396     #if 1 //ENABLED(Z_MIN_PROBE_ENDSTOP)
// 2397       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
// 2398     #else
// 2399       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
// 2400     #endif
// 2401   #endif
// 2402 
// 2403   #if QUIET_PROBING
// 2404     void probing_pause(const bool p) {
// 2405       #if ENABLED(PROBING_HEATERS_OFF)
// 2406         thermalManager.pause(p);
// 2407       #endif
// 2408       #if ENABLED(PROBING_FANS_OFF)
// 2409         fans_pause(p);
// 2410       #endif
// 2411       if (p) safe_delay(
// 2412         #if DELAY_BEFORE_PROBING > 25
// 2413           DELAY_BEFORE_PROBING
// 2414         #else
// 2415           25
// 2416         #endif
// 2417       );
// 2418     }
// 2419   #endif // QUIET_PROBING
// 2420 
// 2421   //#if ENABLED(BLTOUCH)
// 2422 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function _Z15bltouch_commandi
        THUMB
// 2423     void bltouch_command(int angle) {
// 2424     #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
// 2425       //MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
// 2426       int mksAngle;
// 2427  	  switch(angle)
_Z15bltouch_commandi:
        CMP      R0,#+10
        BEQ.N    ??bltouch_command_0
        CMP      R0,#+60
        BEQ.N    ??bltouch_command_1
        CMP      R0,#+90
        BEQ.N    ??bltouch_command_2
        CMP      R0,#+120
        BEQ.N    ??bltouch_command_3
        B.N      ??bltouch_command_4
// 2428 	  {
// 2429 		 case 10:
// 2430 			 mksAngle = 700/2;
??bltouch_command_0:
        MOV      R0,#+350
// 2431 			 break;
        B.N      ??bltouch_command_5
// 2432 		 case 90:
// 2433 			 mksAngle = 1500/2;
??bltouch_command_2:
        MOVW     R0,#+750
// 2434 			 break;
        B.N      ??bltouch_command_5
// 2435 		 case 120:
// 2436 			 mksAngle = 1800/2;
??bltouch_command_3:
        MOV      R0,#+900
// 2437 			 break;
        B.N      ??bltouch_command_5
// 2438 		 case 160:
// 2439 			 mksAngle = 2200/2;
// 2440 			 break;
// 2441 		 case 60:
// 2442 			 mksAngle = 1200/2;
??bltouch_command_1:
        MOV      R0,#+600
// 2443 			 break;
        B.N      ??bltouch_command_5
// 2444 		 default:
// 2445 			 mksAngle = 2200/2;
??bltouch_command_4:
        MOVW     R0,#+1100
// 2446 			 break;
// 2447 	  }
// 2448       MKS_TOUCH_TIM = mksAngle;	  
??bltouch_command_5:
        LDR.W    R1,??DataTable147_2  ;; 0x40012c34
        STR      R0,[R1, #+0]
// 2449       safe_delay(BLTOUCH_DELAY);
        MOVW     R0,#+375
          CFI FunCall _Z10safe_delaym
        B.W      _Z10safe_delaym
          CFI EndBlock cfiBlock36
// 2450       #endif
// 2451     }
// 2452 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function _Z20set_bltouch_deployedb
        THUMB
// 2453     bool set_bltouch_deployed(const bool deploy) {
_Z20set_bltouch_deployedb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
// 2454       if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
        LDR.N    R5,??DataTable136_5
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??set_bltouch_deployed_0
// 2455 		{
// 2456 		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
        CMP      R4,#+0
        BEQ.N    ??set_bltouch_deployed_1
        LDR.W    R6,??DataTable147_3
        LDR.W    R7,??DataTable147_4
        LDRH     R1,[R7, #+26]
        LDR      R0,[R6, #+52]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+57]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
// 2457 		  { 	 // If BL-Touch says it's triggered
// 2458 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2459 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
        MOVS     R0,#+10
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2460 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
        MOVS     R0,#+90
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2461 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
        MOVW     R0,#+1500
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 2462 											 //  (Measured completion time was 0.65 seconds
// 2463 											 //   after reset, deploy, and stow sequence)
// 2464 		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
        LDRH     R1,[R7, #+26]
        LDR      R0,[R6, #+52]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+57]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
        B.N      ??set_bltouch_deployed_2
// 2465 			SERIAL_ERROR_START();
// 2466 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2467 			stop(); 						 // punt!
// 2468 		  	}
// 2469 			}
// 2470 		
// 2471 		}
// 2472 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
??set_bltouch_deployed_0:
        CMP      R0,#+2
        BNE.N    ??set_bltouch_deployed_1
// 2473 		{
// 2474 		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
        CMP      R4,#+0
        BEQ.N    ??set_bltouch_deployed_1
        LDR.W    R6,??DataTable147_3
        LDR.W    R7,??DataTable147_4
        LDRH     R1,[R7, #+28]
        LDR      R0,[R6, #+56]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        ADDW     R5,R5,#+57
        LDRB     R1,[R5, #+4]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
// 2475 		  { 	 // If BL-Touch says it's triggered
// 2476 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2477 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
        MOVS     R0,#+10
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2478 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
        MOVS     R0,#+90
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2479 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
        MOVW     R0,#+1500
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 2480 											 //  (Measured completion time was 0.65 seconds
// 2481 											 //   after reset, deploy, and stow sequence)
// 2482 		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
        LDRH     R1,[R7, #+28]
        LDR      R0,[R6, #+56]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+4]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
// 2483 			SERIAL_ERROR_START();
??set_bltouch_deployed_2:
        LDR.W    R0,??DataTable139_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2484 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
        ADR.W    R0,`?<Constant "STOP called because o...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2485 			stop(); 						 // punt!
          CFI FunCall _Z4stopv
        BL       _Z4stopv
// 2486 		  }
// 2487 		}
// 2488 		}
// 2489       //}
// 2490 
// 2491       bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
??set_bltouch_deployed_1:
        CMP      R4,#+0
        BEQ.N    ??set_bltouch_deployed_3
        MOVS     R0,#+10
        B.N      ??set_bltouch_deployed_4
??set_bltouch_deployed_3:
        MOVS     R0,#+90
??set_bltouch_deployed_4:
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2492 
// 2493       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2494         if (DEBUGGING(LEVELING)) {
// 2495           SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
// 2496           SERIAL_CHAR(')');
// 2497           SERIAL_EOL();
// 2498         }
// 2499       #endif
// 2500 
// 2501       return false;
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock37
// 2502     }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "STOP called because o...">`:
        DC8 53H, 54H, 4FH, 50H, 20H, 63H, 61H, 6CH
        DC8 6CH, 65H, 64H, 20H, 62H, 65H, 63H, 61H
        DC8 75H, 73H, 65H, 20H, 6FH, 66H, 20H, 42H
        DC8 4CH, 54H, 6FH, 75H, 63H, 68H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 2DH, 20H, 72H
        DC8 65H, 73H, 74H, 61H, 72H, 74H, 20H, 77H
        DC8 69H, 74H, 68H, 20H, 4DH, 39H, 39H, 39H
        DC8 0AH, 0
        DC8 0, 0
// 2503 
// 2504   //#endif // BLTOUCH
// 2505 
// 2506   // returns false for ok and true for failure

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function _Z18set_probe_deployedb
        THUMB
// 2507   bool set_probe_deployed(bool deploy) {
_Z18set_probe_deployedb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+16
          CFI CFA R13+24
        MOV      R4,R0
// 2508 
// 2509     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2510       if (DEBUGGING(LEVELING)) {
// 2511         DEBUG_POS("set_probe_deployed", current_position);
// 2512         SERIAL_ECHOLNPAIR("deploy: ", deploy);
// 2513       }
// 2514     #endif
// 2515 
// 2516     if (endstops.z_probe_enabled == deploy) return false;
        LDR.W    R0,??DataTable148
        LDRB     R0,[R0, #+0]
        CMP      R0,R4
        BNE.N    ??set_probe_deployed_0
        MOVS     R0,#+0
        B.N      ??set_probe_deployed_1
// 2517 
// 2518     // Make room for probe
// 2519     //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
// 2520     do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
??set_probe_deployed_0:
        LDR.N    R0,??DataTable136_5
        LDR      R1,[R0, #+100]
        LDR      R0,[R0, #+104]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??set_probe_deployed_2
        MOV      R1,R0
??set_probe_deployed_2:
        MOV      R0,R1
          CFI FunCall _Z14do_probe_raisef
        BL       _Z14do_probe_raisef
// 2521 
// 2522     #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
// 2523       #if ENABLED(Z_PROBE_SLED)
// 2524         #define _AUE_ARGS true, false, false
// 2525       #else
// 2526         #define _AUE_ARGS
// 2527       #endif
// 2528       if (axis_unhomed_error(_AUE_ARGS)) {
// 2529         SERIAL_ERROR_START();
// 2530         SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
// 2531         stop();
// 2532         return true;
// 2533       }
// 2534     #endif
// 2535 
// 2536     const float oldXpos = current_position[X_AXIS],
        LDR.N    R0,??DataTable136_4
        LDR      R1,[R0, #+8]
        STR      R1,[SP, #+8]
// 2537                 oldYpos = current_position[Y_AXIS];
        LDR      R1,[R0, #+12]
        STR      R1,[SP, #+4]
// 2538 
// 2539     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2540       bool _triggered_bool =false;
// 2541 	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2542 		_triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2543 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2544 		_triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2545 
// 2546       // If endstop is already false, the Z probe is deployed
// 2547       if (_triggered_bool == deploy) {
// 2548       //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
// 2549                                                        // Would a goto be less ugly?
// 2550         //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
// 2551                                                        // for a triggered when stowed manual probe.
// 2552 
// 2553         if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
// 2554                                                      // otherwise an Allen-Key probe can't be stowed.
// 2555     #endif
// 2556 
// 2557         #if ENABLED(SOLENOID_PROBE)
// 2558 
// 2559           #if HAS_SOLENOID_1
// 2560             WRITE(SOL1_PIN, deploy);
// 2561           #endif
// 2562 
// 2563         #elif ENABLED(Z_PROBE_SLED)
// 2564 
// 2565           dock_sled(!deploy);
// 2566 
// 2567         #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
// 2568 
// 2569           MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
// 2570 
// 2571         #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2572 
// 2573           deploy ? run_deploy_moves_script() : run_stow_moves_script();
// 2574 
// 2575         #endif
// 2576 
// 2577     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2578       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2579       
// 2580 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2581 		  _triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2582 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2583 		  _triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2584 
// 2585       //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
// 2586       if (_triggered_bool == deploy) { 
// 2587 
// 2588         if (IsRunning()) {
// 2589           SERIAL_ERROR_START();
// 2590           SERIAL_ERRORLNPGM("Z-Probe failed");
// 2591           LCD_ALERTMESSAGEPGM("Err: ZPROBE");
// 2592         }
// 2593         stop();
// 2594         return true;
// 2595 
// 2596       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2597 
// 2598     #endif
// 2599 
// 2600     do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
        MOVS     R1,#+0
        STR      R1,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,R0,#+16
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2601     endstops.enable_z_probe(deploy);
        MOV      R0,R4
          CFI FunCall _ZN8Endstops14enable_z_probeEb
        BL       _ZN8Endstops14enable_z_probeEb
// 2602     return false;
        MOVS     R0,#+0
??set_probe_deployed_1:
        ADD      SP,SP,#+16
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock38
// 2603   }
// 2604 
// 2605   /**
// 2606    * @brief Used by run_z_probe to do a single Z probe move.
// 2607    *
// 2608    * @param  z        Z destination
// 2609    * @param  fr_mm_s  Feedrate in mm/s
// 2610    * @return true to indicate an error
// 2611    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function _Z13do_probe_moveff
        THUMB
// 2612   static bool do_probe_move(const float z, const float fr_mm_m) {
_Z13do_probe_moveff:
        PUSH     {R0,R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOV      R5,R1
// 2613     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2614       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
// 2615     #endif
// 2616 
// 2617     // Deploy BLTouch at the start of any probe
// 2618     //#if ENABLED(BLTOUCH)
// 2619     if(MKSTOUCH == 1)
        LDR.N    R4,??DataTable136_5
        LDRB     R0,[R4, #+256]
        CMP      R0,#+1
        BNE.N    ??do_probe_move_0
// 2620       {if (set_bltouch_deployed(true)) return true;}
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
        CMP      R0,#+0
        BNE.N    ??do_probe_move_1
// 2621     //#endif
// 2622 
// 2623     #if QUIET_PROBING
// 2624       probing_pause(true);
// 2625     #endif
// 2626 
// 2627     // Move down until probe triggered
// 2628     do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
??do_probe_move_0:
        MOV      R0,R5
        LDR.N    R1,??DataTable136_6  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
// 2629    /*
// 2630     // Check to see if the probe was triggered
// 2631     const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
// 2632       #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2633         Z_MIN
// 2634       #else
// 2635         Z_MIN_PROBE
// 2636       #endif
// 2637     );
// 2638     */
// 2639       bool probe_triggered;
// 2640       if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
        LDR.W    R0,??DataTable150
        LDRB     R1,[R4, #+153]
        CMP      R1,#+2
        LDRSB    R0,[R0, #+0]
        UXTB     R0,R0
        BEQ.N    ??do_probe_move_2
// 2641       {
// 2642         probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN);
        LSRS     R0,R0,#+2
        AND      R5,R0,#0x1
        B.N      ??do_probe_move_3
// 2643       }
// 2644       else
// 2645       {
// 2646         probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN_PROBE);
??do_probe_move_2:
        LSRS     R0,R0,#+3
        AND      R5,R0,#0x1
// 2647       }
// 2648 
// 2649     #if QUIET_PROBING
// 2650       probing_pause(false);
// 2651     #endif
// 2652 
// 2653     // Retract BLTouch immediately after a probe if it was triggered
// 2654     //#if ENABLED(BLTOUCH)
// 2655     if(MKSTOUCH == 1)
??do_probe_move_3:
        LDRB     R0,[R4, #+256]
        CMP      R0,#+1
        BNE.N    ??do_probe_move_4
// 2656       {if (probe_triggered && set_bltouch_deployed(false)) return true;}
        CMP      R5,#+0
        BEQ.N    ??do_probe_move_4
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
        CMP      R0,#+0
        BEQ.N    ??do_probe_move_4
??do_probe_move_1:
        MOVS     R0,#+1
        POP      {R1-R5,PC}
// 2657     //#endif
// 2658 
// 2659     // Clear endstop flags
// 2660     endstops.hit_on_purpose();
??do_probe_move_4:
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 2661 
// 2662     // Get Z where the steppers were interrupted
// 2663     set_current_from_steppers_for_axis(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 2664 
// 2665     // Tell the planner where we actually are
// 2666     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 2667 
// 2668     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2669       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
// 2670     #endif
// 2671 
// 2672     return !probe_triggered;
        EOR      R0,R5,#0x1
        POP      {R1-R5,PC}       ;; return
          CFI EndBlock cfiBlock39
// 2673   }
// 2674 
// 2675   /**
// 2676    * @details Used by probe_pt to do a single Z probe at the current position.
// 2677    *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
// 2678    *
// 2679    * @return The raw Z position where the probe was triggered
// 2680    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function _Z11run_z_probev
        THUMB
// 2681   static float run_z_probe() {
_Z11run_z_probev:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
// 2682 
// 2683     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2684       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
// 2685     #endif
// 2686 
// 2687     // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
// 2688     refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 2689 
// 2690     // Double-probing does a fast probe followed by a slow probe
// 2691     #if MULTIPLE_PROBING == 2
// 2692 
// 2693       // Do a first probe at the fast speed
// 2694       if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
// 2695 
// 2696       float first_probe_z = current_position[Z_AXIS];
// 2697 
// 2698       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2699         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
// 2700       #endif
// 2701 
// 2702       // move up to make clearance for the probe
// 2703       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2704 
// 2705     #else
// 2706 
// 2707       // If the nozzle is above the travel height then
// 2708       // move down quickly before doing the slow probe
// 2709       float z = Z_CLEARANCE_DEPLOY_PROBE;
        LDR.N    R4,??DataTable136_5
        LDR      R2,[R4, #+100]
// 2710       if (zprobe_zoffset < 0) z -= zprobe_zoffset;
        LDR.N    R5,??DataTable136_4
        LDR      R3,[R5, #+112]
        MOV      R0,R3
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??run_z_probe_0
        MOV      R0,R2
        MOV      R1,R3
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R2,R0
// 2711 
// 2712       if (z < current_position[Z_AXIS]) {
??run_z_probe_0:
        MOV      R0,R2
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??run_z_probe_1
// 2713 
// 2714         // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
// 2715         if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
        LDR      R1,[R4, #+120]
          CFI FunCall _Z13do_probe_moveff
        BL       _Z13do_probe_moveff
        CMP      R0,#+0
        BNE.N    ??run_z_probe_1
// 2716           do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
        LDR      R1,[R5, #+16]
        LDR      R0,[R4, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+120]
        LDR.N    R1,??DataTable136_6  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
// 2717       }
// 2718     #endif
// 2719 
// 2720     #if MULTIPLE_PROBING > 2
// 2721       float probes_total = 0;
// 2722       for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
// 2723     #endif
// 2724 
// 2725         // move down slowly to find bed
// 2726         if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
??run_z_probe_1:
        LDR      R1,[R4, #+124]
        LDR.W    R0,??DataTable151  ;; 0xc1200000
          CFI FunCall _Z13do_probe_moveff
        BL       _Z13do_probe_moveff
        CMP      R0,#+0
        BEQ.N    ??run_z_probe_2
        MVN      R0,#-2147483648
        POP      {R1-R5,PC}
// 2727 
// 2728     #if MULTIPLE_PROBING > 2
// 2729         probes_total += current_position[Z_AXIS];
// 2730         if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2731       }
// 2732     #endif
// 2733 
// 2734     #if MULTIPLE_PROBING > 2
// 2735 
// 2736       // Return the average value of all probes
// 2737       return probes_total * (1.0 / (MULTIPLE_PROBING));
// 2738 
// 2739     #elif MULTIPLE_PROBING == 2
// 2740 
// 2741       const float z2 = current_position[Z_AXIS];
// 2742 
// 2743       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2744         if (DEBUGGING(LEVELING)) {
// 2745           SERIAL_ECHOPAIR("2nd Probe Z:", z2);
// 2746           SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
// 2747         }
// 2748       #endif
// 2749 
// 2750       // Return a weighted average of the fast and slow probes
// 2751       return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
// 2752 
// 2753     #else
// 2754 
// 2755       // Return the single probe result
// 2756       return current_position[Z_AXIS];
??run_z_probe_2:
        LDR      R0,[R5, #+16]
        POP      {R1-R5,PC}       ;; return
          CFI EndBlock cfiBlock40
// 2757 
// 2758     #endif
// 2759 
// 2760     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2761       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
// 2762     #endif
// 2763   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136:
        DC8      "X",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_1:
        DC8      "Y",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_2:
        DC8      "Z",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_3:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_4:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_5:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_6:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_7:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_8:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_9:
        DC32     axis_homed
// 2764 
// 2765   /**
// 2766    * - Move to the given XY
// 2767    * - Deploy the probe, if not already deployed
// 2768    * - Probe the bed, get the Z position
// 2769    * - Depending on the 'stow' flag
// 2770    *   - Stow the probe, or
// 2771    *   - Raise to the BETWEEN height
// 2772    * - Return the probed Z position
// 2773    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function _Z8probe_ptRKfS0_bhb
        THUMB
// 2774   float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
_Z8probe_ptRKfS0_bhb:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+28
          CFI CFA R13+64
        MOV      R8,R0
        MOV      R4,R1
        MOV      R7,R2
        MOV      R9,R3
// 2775     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2776       if (DEBUGGING(LEVELING)) {
// 2777         SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
// 2778         SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
// 2779         SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
// 2780         SERIAL_ECHOLNPGM("stow)");
// 2781         DEBUG_POS("", current_position);
// 2782       }
// 2783     #endif
// 2784 
// 2785     // TODO: Adapt for SCARA, where the offset rotates
// 2786     float nx = rx, ny = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+0]
        STR      R0,[SP, #+4]
// 2787     if (probe_relative) {
        LDR.W    R10,??DataTable151_1
        LDRSH    R1,[R10, #+88]
        MOVW     R2,#+770
        LDR      R0,[SP, #+64]
        CMP      R0,#+0
        BEQ.N    ??probe_pt_0
// 2788       if(MACHINETPYE & IS_KINEMATIC)
        TST      R1,R2
        MOV      R1,R4
        MOV      R0,R8
        BEQ.N    ??probe_pt_1
// 2789       {
// 2790         if (!position_is_reachable_by_probe_IS_KINEMATIC(rx, ry)) return NAN;  // The given position is in terms of the probe
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_2
        B.N      ??probe_pt_3
// 2791       }
// 2792       else
// 2793       {
// 2794         if (!position_is_reachable_by_probe_IS_CARTESIAN(rx, ry)) return NAN;  // The given position is in terms of the probe
??probe_pt_1:
          CFI FunCall _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.N    ??probe_pt_3
// 2795       }
// 2796       nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
??probe_pt_2:
        LDR      R0,[SP, #+8]
        LDR      R1,[R10, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
// 2797       ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
        LDR      R0,[SP, #+4]
        LDR      R1,[R10, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
// 2798     }
// 2799     else
// 2800     {
// 2801         if(MACHINETPYE & IS_KINEMATIC)
// 2802         {
// 2803             if (!position_is_reachable_IS_KINEMATIC(nx, ny)) return NAN;        // The given position is in terms of the nozzle
// 2804         }
// 2805         else
// 2806         {
// 2807             if (!position_is_reachable_IS_CARTESIAN(nx, ny)) return NAN;        // The given position is in terms of the nozzle            
// 2808         }
// 2809      }
// 2810     //const 
// 2811         float nz;/* =
// 2812       #if ENABLED(DELTA)
// 2813         // Move below clip height or xy move will be aborted by do_blocking_move_to
// 2814         min(current_position[Z_AXIS], delta_clip_start_height)
// 2815       #else
// 2816         current_position[Z_AXIS]
// 2817       #endif
// 2818     ;
// 2819     */
// 2820     if(MACHINETPYE ==  DELTA)
??probe_pt_4:
        LDR.W    R5,??DataTable151_2
        LDR      R0,[R5, #+16]
        LDRSH    R1,[R10, #+88]
        CMP      R1,#+2
        BNE.N    ??probe_pt_5
// 2821     {
// 2822         nz = min(current_position[Z_AXIS], delta_clip_start_height);
        LDR      R1,[R5, #+124]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_pt_6
        STR      R0,[SP, #+12]
        B.N      ??probe_pt_7
// 2823     }
??probe_pt_0:
        TST      R1,R2
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
        BEQ.N    ??probe_pt_8
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_4
        B.N      ??probe_pt_3
??probe_pt_8:
          CFI FunCall _Z34position_is_reachable_IS_CARTESIANRKfS0_
        BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_4
??probe_pt_3:
        MVN      R0,#-2147483648
        B.N      ??probe_pt_9
??probe_pt_6:
        STR      R1,[SP, #+12]
        B.N      ??probe_pt_7
// 2824     else
// 2825     {
// 2826         nz = current_position[Z_AXIS];
??probe_pt_5:
        STR      R0,[SP, #+12]
// 2827     }
// 2828     const float old_feedrate_mm_s = feedrate_mm_s;
??probe_pt_7:
        LDR      R0,[R5, #+92]
        STR      R0,[SP, #+20]
// 2829     feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
        LDR      R0,[R5, #+116]
        STR      R0,[R5, #+92]
// 2830 
// 2831     // Move the probe to the starting XYZ
// 2832     do_blocking_move_to(nx, ny, nz);
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,SP,#+12
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2833 
// 2834     float measured_z = NAN;
        MVN      R11,#-2147483648
        MOV      R6,R11
// 2835     if (!DEPLOY_PROBE()) {
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.N    ??probe_pt_10
// 2836       measured_z = run_z_probe() + zprobe_zoffset;
          CFI FunCall _Z11run_z_probev
        BL       _Z11run_z_probev
        MOV      R1,R0
        LDR      R0,[R5, #+112]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
// 2837 
// 2838       if (!stow)
        CMP      R7,#+0
        BNE.N    ??probe_pt_11
// 2839         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
        LDR      R1,[R5, #+16]
        LDR      R0,[R10, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+16]
        LDR      R0,[R10, #+120]
        LDR.W    R1,??DataTable152  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+16
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
        B.N      ??probe_pt_10
// 2840       else
// 2841         if (STOW_PROBE()) measured_z = NAN;
??probe_pt_11:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??probe_pt_10
        MOV      R6,R11
// 2842     }
// 2843 
// 2844     if (verbose_level > 2) {
??probe_pt_10:
        CMP      R9,#+3
        BLT.N    ??probe_pt_12
// 2845       SERIAL_PROTOCOLPGM("Bed X: ");
        ADR.W    R0,`?<Constant "Bed X: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2846       SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
        LDR.N    R7,??DataTable139_4
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR      R1,[R8, #+0]
        LDR      R0,[R5, #+56]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2847       SERIAL_PROTOCOLPGM(" Y: ");
        ADR.W    R0,`?<Constant " Y: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2848       SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2849       SERIAL_PROTOCOLPGM(" Z: ");
        ADR.W    R0,`?<Constant " Z: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2850       SERIAL_PROTOCOL_F(measured_z, 3);
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2851       SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R7
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 2852     }
// 2853 
// 2854     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2855       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
// 2856     #endif
// 2857 
// 2858     feedrate_mm_s = old_feedrate_mm_s;
??probe_pt_12:
        LDR      R0,[SP, #+20]
        STR      R0,[R5, #+92]
// 2859 
// 2860     if (isnan(measured_z)) {
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??probe_pt_13
// 2861       LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "Probing failed">`
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
// 2862       SERIAL_ERROR_START();
        LDR.N    R0,??DataTable139_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2863       SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
        ADR.W    R0,`?<Constant "Probing failed\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2864     }
// 2865 
// 2866     return measured_z;
??probe_pt_13:
        MOV      R0,R6
??probe_pt_9:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock41
// 2867   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Bed X: ">`:
        DC8 "Bed X: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Y: ">`:
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Z: ">`:
        DC8 " Z: "
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Probing failed">`:
        DC8 "Probing failed"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Probing failed\\n">`:
        DC8 "Probing failed\012"
// 2868 
// 2869 #endif // HAS_BED_PROBE
// 2870 
// 2871 #if 1//HAS_LEVELING
// 2872 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function _Z17leveling_is_validv
          CFI NoCalls
        THUMB
// 2873   bool leveling_is_valid() {
_Z17leveling_is_validv:
        LDR.W    R0,??DataTable151_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??leveling_is_valid_0
// 2874   /*
// 2875     return
// 2876       #if ENABLED(MESH_BED_LEVELING)
// 2877         mbl.has_mesh
// 2878       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2879         !!bilinear_grid_spacing[X_AXIS]
// 2880       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2881         true
// 2882       #else // 3POINT, LINEAR
// 2883         true
// 2884       #endif
// 2885     ;
// 2886     */
// 2887       if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 2888         return mbl.has_mesh;
        LDR.W    R0,??DataTable153
        LDRB     R0,[R0, #+0]
        BX       LR
// 2889       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??leveling_is_valid_0:
        CMP      R0,#+8
        BNE.N    ??leveling_is_valid_1
// 2890         return !!bilinear_grid_spacing[X_AXIS];
        LDR.N    R0,??DataTable141
        LDR      R0,[R0, #+16]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR
// 2891       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
??leveling_is_valid_1:
        CMP      R0,#+16
        BNE.N    ??leveling_is_valid_2
// 2892         return true;
        MOVS     R0,#+1
        BX       LR
// 2893       else
// 2894         return true;
??leveling_is_valid_2:
        MOVS     R0,#+1
        BX       LR               ;; return
          CFI EndBlock cfiBlock42
// 2895   }
// 2896 
// 2897   /**
// 2898    * Turn bed leveling on or off, fixing the current
// 2899    * position as-needed.
// 2900    *
// 2901    * Disable: Current position = physical position
// 2902    *  Enable: Current position = "unleveled" physical position
// 2903    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function _Z24set_bed_leveling_enabledb
        THUMB
// 2904   void set_bed_leveling_enabled(const bool enable/*=true*/) {
_Z24set_bed_leveling_enabledb:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+16
          CFI CFA R13+40
        MOV      R5,R0
// 2905     bool can_change;
// 2906 /*
// 2907     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2908       const bool can_change = (!enable || leveling_is_valid());
// 2909     #else
// 2910       constexpr bool can_change = true;
// 2911     #endif
// 2912 */
// 2913     if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
        LDR.W    R6,??DataTable151_1
        LDRB     R7,[R6, #+64]
        MOV      R8,R7
        CMP      R8,#+8
        BNE.N    ??set_bed_leveling_enabled_0
// 2914         can_change = (!enable || leveling_is_valid());
        CMP      R5,#+0
        BEQ.N    ??set_bed_leveling_enabled_1
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        B.N      ??set_bed_leveling_enabled_2
??set_bed_leveling_enabled_1:
        MOVS     R0,#+1
        B.N      ??set_bed_leveling_enabled_2
// 2915     else
// 2916         can_change = true;
??set_bed_leveling_enabled_0:
        MOVS     R0,#+1
// 2917         
// 2918     if (can_change && enable != planner.leveling_active) {
??set_bed_leveling_enabled_2:
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_3
        LDR.W    R4,??DataTable153_1
        LDRB     R0,[R4, #+0]
        CMP      R5,R0
        BEQ.N    ??set_bed_leveling_enabled_3
// 2919 
// 2920       //#if ENABLED(MESH_BED_LEVELING)
// 2921       if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
        CMP      R8,#+32
        BNE.N    ??set_bed_leveling_enabled_4
// 2922       {
// 2923         if (!enable)
        CMP      R5,#+0
        BNE.N    ??set_bed_leveling_enabled_5
// 2924           planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
        LDR.W    R3,??DataTable151_2
        ADD      R2,R3,#+16
        ADD      R1,R3,#+12
        ADD      R0,R3,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 2925 
// 2926         const bool enabling = enable && leveling_is_valid();
??set_bed_leveling_enabled_5:
        CMP      R5,#+0
        BEQ.N    ??set_bed_leveling_enabled_6
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        B.N      ??set_bed_leveling_enabled_7
??set_bed_leveling_enabled_6:
        MOVS     R0,#+0
// 2927         planner.leveling_active = enabling;
??set_bed_leveling_enabled_7:
        STRB     R0,[R4, #+0]
// 2928         if (enabling) planner.unapply_leveling(current_position);
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_3
        LDR.W    R0,??DataTable154
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        B.N      ??set_bed_leveling_enabled_3
// 2929       }
// 2930       //#elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2931       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
??set_bed_leveling_enabled_4:
        CMP      R8,#+16
        BNE.N    ??set_bed_leveling_enabled_8
// 2932       {
// 2933         //#if PLANNER_LEVELING
// 2934         if(BED_LEVELING_METHOD&ABL_PLANAR)
        MOVS     R1,#+6
        TST      R7,R1
        BEQ.N    ??set_bed_leveling_enabled_9
// 2935         {
// 2936           if (planner.leveling_active) {                       // leveling from on to off
        LDR.W    R3,??DataTable151_2
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_10
// 2937             // change unleveled current_position to physical current_position without moving steppers.
// 2938             planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
        ADD      R2,R3,#+16
        ADD      R1,R3,#+12
        ADD      R0,R3,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 2939             planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        B.N      ??set_bed_leveling_enabled_3
// 2940           }
// 2941           else {                                        // leveling from off to on
// 2942             planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
??set_bed_leveling_enabled_10:
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
// 2943             // change physical current_position to unleveled current_position without moving steppers.
// 2944             planner.unapply_leveling(current_position);
        ADD      R0,R3,#+8
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        B.N      ??set_bed_leveling_enabled_3
// 2945           }
// 2946         }
// 2947         //#else
// 2948         else
// 2949           planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
??set_bed_leveling_enabled_9:
        STRB     R5,[R4, #+0]
        B.N      ??set_bed_leveling_enabled_3
// 2950         //#endif
// 2951       }
// 2952       //#else // ABL
// 2953       else
// 2954       {
// 2955         //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2956         if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
??set_bed_leveling_enabled_8:
        CMP      R8,#+8
        BNE.N    ??set_bed_leveling_enabled_11
// 2957         {
// 2958           // Force bilinear_z_offset to re-calculate next time
// 2959           const float reset[XYZ] = { -9999.999, -9999.999, 0 };
        ADD      R0,SP,#+0
        ADR.W    R1,`?<Constant {(-9.9999990233E+3F), (-9.999999023`
        LDM      R1!,{R2,R3,R7}
        STM      R0!,{R2,R3,R7}
// 2960           (void)bilinear_z_offset(reset);
        ADD      R0,SP,#+0
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
// 2961         }
// 2962         //#endif
// 2963 
// 2964         // Enable or disable leveling compensation in the planner
// 2965         planner.leveling_active = enable;
??set_bed_leveling_enabled_11:
        STRB     R5,[R4, #+0]
// 2966 
// 2967         if (!enable)
        CMP      R5,#+0
        BNE.N    ??set_bed_leveling_enabled_12
// 2968             /*
// 2969           // When disabling just get the current position from the steppers.
// 2970           // This will yield the smallest error when first converted back to steps.
// 2971           set_current_from_steppers_for_axis(
// 2972             #if ABL_PLANAR
// 2973               ALL_AXES
// 2974             #else
// 2975               Z_AXIS
// 2976             #endif
// 2977           );
// 2978           */
// 2979         {
// 2980             if(BED_LEVELING_METHOD&ABL_PLANAR)
        LDRB     R0,[R6, #+64]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??set_bed_leveling_enabled_13
// 2981                 set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
        B.N      ??set_bed_leveling_enabled_14
// 2982             else
// 2983                 set_current_from_steppers_for_axis(Z_AXIS);
??set_bed_leveling_enabled_13:
        MOVS     R0,#+2
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
        B.N      ??set_bed_leveling_enabled_14
// 2984         }
// 2985         else
// 2986           // When enabling, remove compensation from the current position,
// 2987           // so compensation will give the right stepper counts.
// 2988           planner.unapply_leveling(current_position);
??set_bed_leveling_enabled_12:
        LDR.W    R0,??DataTable154
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
// 2989 
// 2990         SYNC_PLAN_POSITION_KINEMATIC();
??set_bed_leveling_enabled_14:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 2991       }
// 2992       //#endif // ABL
// 2993     }
// 2994   }
??set_bed_leveling_enabled_3:
        POP      {R0-R8,PC}       ;; return
          CFI EndBlock cfiBlock43

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139:
        DC32     home_bump_mm_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_1:
        DC32     injected_commands_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_2:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_3:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_4:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_5:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant {(-9.9999990233E+3F), (-9.999999023`:
        DC32 0C61C3FFFH, 0C61C3FFFH, 0H
// 2995 
// 2996   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 2997 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function _Z17set_z_fade_heightfb
        THUMB
// 2998     void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
_Z17set_z_fade_heightfb:
        PUSH     {R0,R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+20
        SUB      SP,SP,#+12
          CFI CFA R13+32
        MOV      R4,R1
// 2999 
// 3000       if (planner.z_fade_height == zfh) return; // do nothing if no change
        LDR.W    R0,??DataTable154_1
        LDR      R0,[R0, #+0]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??set_z_fade_height_0
// 3001 
// 3002       const bool level_active = planner.leveling_active;
        LDR.W    R0,??DataTable153_1
        LDRB     R6,[R0, #+0]
// 3003 
// 3004       //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 3005       if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
        LDR.W    R5,??DataTable151_1
        LDRB     R0,[R5, #+64]
        CMP      R0,#+16
        BNE.N    ??set_z_fade_height_1
// 3006         if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
        CMP      R6,#+0
        BEQ.N    ??set_z_fade_height_1
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 3007       //#endif
// 3008 
// 3009       planner.set_z_fade_height(zfh);
??set_z_fade_height_1:
        ADD      R0,SP,#+12
          CFI FunCall _ZN7Planner17set_z_fade_heightERKf
        BL       _ZN7Planner17set_z_fade_heightERKf
// 3010 
// 3011       if (level_active) {
        CMP      R6,#+0
        BEQ.N    ??set_z_fade_height_0
// 3012         const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
        LDR.W    R6,??DataTable151_2
        LDR      R0,[R6, #+8]
        STR      R0,[SP, #+0]
        LDR      R0,[R6, #+12]
        STR      R0,[SP, #+4]
        LDR      R0,[R6, #+16]
        STR      R0,[SP, #+8]
// 3013         //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 3014         if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
        LDRB     R0,[R5, #+64]
        CMP      R0,#+16
        BNE.N    ??set_z_fade_height_2
// 3015           set_bed_leveling_enabled(true);  // turn back on after changing fade height
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        B.N      ??set_z_fade_height_3
// 3016         //#else
// 3017         else
// 3018         {
// 3019         /*
// 3020           set_current_from_steppers_for_axis(
// 3021             #if ABL_PLANAR
// 3022               ALL_AXES
// 3023             #else
// 3024               Z_AXIS
// 3025             #endif
// 3026           );
// 3027             */
// 3028           if(BED_LEVELING_METHOD&ABL_PLANAR)
??set_z_fade_height_2:
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??set_z_fade_height_4
// 3029           {
// 3030             set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
        B.N      ??set_z_fade_height_5
// 3031           }
// 3032           else
// 3033           {
// 3034             set_current_from_steppers_for_axis(Z_AXIS);
??set_z_fade_height_4:
        MOVS     R0,#+2
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 3035           }
// 3036             
// 3037           SYNC_PLAN_POSITION_KINEMATIC();
??set_z_fade_height_5:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 3038         }
// 3039         //#endif
// 3040         if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
??set_z_fade_height_3:
        CMP      R4,#+0
        BEQ.N    ??set_z_fade_height_0
        MOVS     R2,#+12
        ADD      R1,R6,#+8
        ADD      R0,SP,#+0
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??set_z_fade_height_0
// 3041           report_current_position();
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
// 3042       }
// 3043     }
??set_z_fade_height_0:
        POP      {R0-R6,PC}       ;; return
          CFI EndBlock cfiBlock44
// 3044 
// 3045   #endif // LEVELING_FADE_HEIGHT
// 3046 
// 3047   /**
// 3048    * Reset calibration results to zero.
// 3049    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function _Z15reset_bed_levelv
        THUMB
// 3050   void reset_bed_level() {
_Z15reset_bed_levelv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3051     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3052       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
// 3053     #endif
// 3054     set_bed_leveling_enabled(false);
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 3055     //#if ENABLED(MESH_BED_LEVELING)
// 3056     if(BED_LEVELING_METHOD==MESH_BED_LEVELING)
        LDR.W    R0,??DataTable151_1
        LDRB     R1,[R0, #+64]
        MOV      R2,R1
        CMP      R2,#+32
        BNE.N    ??reset_bed_level_0
// 3057     {
// 3058       if (leveling_is_valid()) {
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BEQ.N    ??reset_bed_level_1
// 3059         mbl.reset();
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
// 3060         mbl.has_mesh = false;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable153
        STRB     R0,[R1, #+0]
        POP      {R4,PC}
// 3061       }
// 3062     }
// 3063     //#elif ENABLED(AUTO_BED_LEVELING_UBL)
// 3064     else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
??reset_bed_level_0:
        CMP      R2,#+16
        BNE.N    ??reset_bed_level_2
// 3065       ubl.reset();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN20unified_bed_leveling5resetEv
        B.W      _ZN20unified_bed_leveling5resetEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3066     //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 3067     else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
??reset_bed_level_2:
        CMP      R2,#+8
        BNE.N    ??reset_bed_level_3
// 3068     {
// 3069       bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
// 3070       bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
        LDR.N    R1,??DataTable141
        MOVS     R2,#+0
        STR      R2,[R1, #+20]
        STR      R2,[R1, #+16]
        STR      R2,[R1, #+28]
        STR      R2,[R1, #+24]
// 3071       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
        MOV      R1,R2
        B.N      ??reset_bed_level_4
// 3072         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3073           z_values[x][y] = NAN;
??reset_bed_level_5:
        ADD      R3,R1,R1, LSL #+1
        LDR.W    R4,??DataTable156
        ADD      R3,R4,R3, LSL #+4
        MVN      R4,#-2147483648
        STR      R4,[R3, R2, LSL #+2]
        ADDS     R2,R2,#+1
??reset_bed_level_6:
        LDRB     R3,[R0, #+97]
        UXTB     R2,R2
        CMP      R2,R3
        BCC.N    ??reset_bed_level_5
        ADDS     R1,R1,#+1
        UXTB     R1,R1
??reset_bed_level_4:
        LDRB     R2,[R0, #+96]
        CMP      R1,R2
        BGE.N    ??reset_bed_level_1
        MOVS     R2,#+0
        B.N      ??reset_bed_level_6
// 3074     }
// 3075     //#elif ABL_PLANAR
// 3076     else if(BED_LEVELING_METHOD&ABL_PLANAR)
??reset_bed_level_3:
        MOVS     R0,#+6
        TST      R1,R0
        BEQ.N    ??reset_bed_level_1
// 3077       planner.bed_level_matrix.set_to_identity();
        LDR.W    R0,??DataTable156_1
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10matrix_3x315set_to_identityEv
        B.W      _ZN10matrix_3x315set_to_identityEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3078     //#endif
// 3079   }
??reset_bed_level_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock45

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141_1:
        DC32     gCfgItems
// 3080 
// 3081 #endif // HAS_LEVELING
// 3082 
// 3083 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
// 3084 
// 3085   /**
// 3086    * Enable to produce output in JSON format suitable
// 3087    * for SCAD or JavaScript mesh visualizers.
// 3088    *
// 3089    * Visualize meshes in OpenSCAD using the included script.
// 3090    *
// 3091    *   buildroot/shared/scripts/MarlinMesh.scad
// 3092    */
// 3093   //#define SCAD_MESH_OUTPUT
// 3094 
// 3095   /**
// 3096    * Print calibration results for plotting or manual frame adjustment.
// 3097    */
// 3098   //static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function _Z14print_2d_arrayhhhh
        THUMB
// 3099     static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, const uint8_t fn) {
_Z14print_2d_arrayhhhh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R9,R0
        MOV      R10,R1
        MOV      R4,R2
        MOV      R8,R3
// 3100     #ifndef SCAD_MESH_OUTPUT
// 3101       for (uint8_t x = 0; x < sx; x++) {
        MOVS     R6,#+0
        LDR.W    R5,??DataTable156_2
        B.N      ??print_2d_array_0
// 3102         for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
??print_2d_array_1:
        MOVS     R0,#+0
??print_2d_array_2:
        UXTB     R7,R7
        ADDS     R0,R0,R4
        ADDS     R0,R0,#+2
        CMP      R7,R0
        BLT.N    ??print_2d_array_3
// 3103           SERIAL_PROTOCOLCHAR(' ');
// 3104         SERIAL_PROTOCOL((int)x);
        MOVS     R2,#+10
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        ADDS     R6,R6,#+1
        UXTB     R6,R6
??print_2d_array_0:
        CMP      R6,R9
        BGE.N    ??print_2d_array_4
        MOVS     R7,#+0
        B.N      ??print_2d_array_5
??print_2d_array_3:
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADDS     R7,R7,#+1
??print_2d_array_5:
        CMP      R6,#+10
        BGE.N    ??print_2d_array_1
        MOVS     R0,#+1
        B.N      ??print_2d_array_2
// 3105       }
// 3106       SERIAL_EOL();
??print_2d_array_4:
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3107     #endif
// 3108     #ifdef SCAD_MESH_OUTPUT
// 3109       SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
// 3110     #endif
// 3111     for (uint8_t y = 0; y < sy; y++) {
        MOVS     R6,#+0
        B.N      ??print_2d_array_6
// 3112       #ifdef SCAD_MESH_OUTPUT
// 3113         SERIAL_PROTOCOLPGM(" [");           // open sub-array
// 3114       #else
// 3115         if (y < 10) SERIAL_PROTOCOLCHAR(' ');
// 3116         SERIAL_PROTOCOL((int)y);
// 3117       #endif
// 3118       for (uint8_t x = 0; x < sx; x++) {
// 3119         SERIAL_PROTOCOLCHAR(' ');
// 3120         //const float offset = fn(x, y);
// 3121         float offset;
// 3122 		switch(fn)
// 3123 		{
// 3124 			case 0:	
// 3125 			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 3126 				offset =z_values[x][y];
// 3127 			break;
// 3128 			case 1:	
// 3129 			#if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3130 				offset =z_values_virt[x][y];	
// 3131 			#endif
// 3132 			break;
// 3133 			case 2:	
// 3134 				if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 3135                    offset =mbl.z_values[x][y];		
// 3136                           break;
// 3137 			default:		break;
// 3138 		}        
// 3139         if (!isnan(offset)) {
// 3140           if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
// 3141           SERIAL_PROTOCOL_F(offset, precision);
// 3142         }
// 3143         else {
// 3144           #ifdef SCAD_MESH_OUTPUT
// 3145             for (uint8_t i = 3; i < precision + 3; i++)
// 3146               SERIAL_PROTOCOLCHAR(' ');
// 3147             SERIAL_PROTOCOLPGM("NAN");
// 3148           #else
// 3149             for (uint8_t i = 0; i < precision + 3; i++)
// 3150               SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
// 3151           #endif
// 3152         }
// 3153         #ifdef SCAD_MESH_OUTPUT
// 3154           if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
// 3155         #endif
// 3156       }
// 3157       #ifdef SCAD_MESH_OUTPUT
// 3158         SERIAL_PROTOCOLCHAR(' ');
// 3159         SERIAL_PROTOCOLCHAR(']');                     // close sub-array
// 3160         if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
// 3161       #endif
// 3162       SERIAL_EOL();
??print_2d_array_7:
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADDS     R6,R6,#+1
        UXTB     R6,R6
??print_2d_array_6:
        CMP      R6,R10
        BGE.N    ??print_2d_array_8
        CMP      R6,#+10
        BGE.N    ??print_2d_array_9
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??print_2d_array_9:
        MOVS     R2,#+10
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        MOVS     R7,#+0
        B.N      ??print_2d_array_10
??print_2d_array_11:
        LDR.W    R0,??DataTable151_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??print_2d_array_12
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable156_5
        ADD      R0,R1,R0, LSL #+4
        LDR      R11,[R0, R6, LSL #+2]
??print_2d_array_12:
        MOV      R0,R11
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??print_2d_array_13
        MOV      R0,R11
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??print_2d_array_14
        MOVS     R1,#+43
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??print_2d_array_14:
        STR      R4,[SP, #+0]
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
??print_2d_array_15:
        ADDS     R7,R7,#+1
        UXTB     R7,R7
??print_2d_array_10:
        CMP      R7,R9
        BGE.N    ??print_2d_array_7
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOV      R0,R8
        CMP      R0,#+0
        BEQ.N    ??print_2d_array_16
        CMP      R0,#+2
        BEQ.N    ??print_2d_array_11
        B.N      ??print_2d_array_12
??print_2d_array_16:
        LDR.W    R0,??DataTable151_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??print_2d_array_12
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable156
        ADD      R0,R1,R0, LSL #+4
        LDR      R11,[R0, R6, LSL #+2]
        B.N      ??print_2d_array_12
??print_2d_array_13:
        MOV      R11,#+0
        B.N      ??print_2d_array_17
??print_2d_array_18:
        MOVS     R1,#+32
??print_2d_array_19:
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADD      R11,R11,#+1
??print_2d_array_17:
        UXTB     R11,R11
        ADDS     R0,R4,#+3
        CMP      R11,R0
        BGE.N    ??print_2d_array_15
        CMP      R11,#+0
        BEQ.N    ??print_2d_array_18
        MOVS     R1,#+61
        B.N      ??print_2d_array_19
// 3163     }
// 3164     #ifdef SCAD_MESH_OUTPUT
// 3165       SERIAL_PROTOCOLPGM("];");                       // close 2D array
// 3166     #endif
// 3167     SERIAL_EOL();
??print_2d_array_8:
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock46
// 3168   }
// 3169 
// 3170 #endif
// 3171 
// 3172 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 3173 
// 3174   /**
// 3175    * Extrapolate a single point from its neighbors
// 3176    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function _Z21extrapolate_one_pointhhaa
        THUMB
// 3177   static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
_Z21extrapolate_one_pointhhaa:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R10,R0
        MOV      R9,R1
        MOV      R7,R2
        MOV      R8,R3
// 3178     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3179       if (DEBUGGING(LEVELING)) {
// 3180         SERIAL_ECHOPGM("Extrapolate [");
// 3181         if (x < 10) SERIAL_CHAR(' ');
// 3182         SERIAL_ECHO((int)x);
// 3183         SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
// 3184         SERIAL_CHAR(' ');
// 3185         if (y < 10) SERIAL_CHAR(' ');
// 3186         SERIAL_ECHO((int)y);
// 3187         SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
// 3188         SERIAL_CHAR(']');
// 3189       }
// 3190     #endif
// 3191     if (!isnan(z_values[x][y])) {
        MOVS     R5,#+48
        LDR.W    R6,??DataTable156
        MLA      R0,R5,R10,R6
        STR      R0,[SP, #+0]
        MOV      R4,R9
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_0
// 3192       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3193         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
// 3194       #endif
// 3195       return;  // Don't overwrite good values.
// 3196     }
// 3197     SERIAL_EOL();
        MOVS     R1,#+10
        LDR.W    R0,??DataTable156_2
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3198 
// 3199     // Get X neighbors, Y neighbors, and XY neighbors
// 3200     const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
        ADD      R2,R7,R10
        UXTB     R2,R2
        ADD      R0,R8,R9
        UXTB     R0,R0
        ADDS     R3,R7,R2
        UXTB     R3,R3
        ADD      R1,R8,R0
        UXTB     R1,R1
// 3201     float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
        MLA      R2,R5,R2,R6
        LDR      R7,[R2, R4, LSL #+2]
        MLA      R3,R5,R3,R6
        LDR      R5,[R3, R4, LSL #+2]
// 3202           b1 = z_values[x ][y1], b2 = z_values[x ][y2],
        LDR      R6,[SP, #+0]
        LDR      R6,[R6, R0, LSL #+2]
        LDR      R12,[SP, #+0]
        LDR      R8,[R12, R1, LSL #+2]
// 3203           c1 = z_values[x1][y1], c2 = z_values[x2][y2];
        LDR      R9,[R2, R0, LSL #+2]
        LDR      R10,[R3, R1, LSL #+2]
// 3204 
// 3205     // Treat far unprobed points as zero, near as equal to far
// 3206     if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
        MOV      R0,R5
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_1
        MOVS     R5,#+0
??extrapolate_one_point_1:
        MOV      R0,R7
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_2
        MOV      R7,R5
// 3207     if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
??extrapolate_one_point_2:
        MOV      R0,R8
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_3
        MOV      R8,#+0
??extrapolate_one_point_3:
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_4
        MOV      R6,R8
// 3208     if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
??extrapolate_one_point_4:
        MOV      R0,R10
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_5
        MOV      R10,#+0
??extrapolate_one_point_5:
        MOV      R0,R9
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_6
        MOV      R9,R10
// 3209 
// 3210     const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
// 3211 
// 3212     // Take the average instead of the median
// 3213     z_values[x][y] = (a + b + c) / 3.0;
??extrapolate_one_point_6:
        MOV      R11,#+1073741824
        MOV      R0,R7
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable157_2  ;; 0x40400000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[SP, #+0]
        STR      R0,[R1, R4, LSL #+2]
// 3214 
// 3215     // Median is robust (ignores outliers).
// 3216     // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
// 3217     //                                : ((c < b) ? b : (a < c) ? a : c);
// 3218   }
??extrapolate_one_point_0:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock47
// 3219 
// 3220   //Enable this if your SCARA uses 180¬∞ of total area
// 3221   //#define EXTRAPOLATE_FROM_EDGE
// 3222 
// 3223   #if ENABLED(EXTRAPOLATE_FROM_EDGE)
// 3224     #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
// 3225       #define HALF_IN_X
// 3226     #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
// 3227       #define HALF_IN_Y
// 3228     #endif
// 3229   #endif
// 3230 
// 3231   /**
// 3232    * Fill in the unprobed points (corners of circular print surface)
// 3233    * using linear extrapolation, away from the center.
// 3234    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function _Z30extrapolate_unprobed_bed_levelv
        THUMB
// 3235   static void extrapolate_unprobed_bed_level() {
_Z30extrapolate_unprobed_bed_levelv:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
// 3236     #ifdef HALF_IN_X
// 3237       constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
// 3238     #else
// 3239       constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
        LDR.W    R0,??DataTable151_1
        LDRB     R1,[R0, #+96]
        SUBS     R2,R1,#+1
        ADD      R2,R2,R2, LSR #+31
        ASRS     R4,R2,#+1
        UXTB     R4,R4
// 3240                         ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
        LSRS     R1,R1,#+1
        STR      R1,[SP, #+12]
// 3241                         xlen = ctrx1;
        MOV      R1,R4
        STR      R1,[SP, #+8]
        ADDS     R0,R0,#+96
        LDRB     R0,[R0, #+1]
        SUBS     R1,R0,#+1
        ADD      R1,R1,R1, LSR #+31
        ASRS     R5,R1,#+1
        UXTB     R5,R5
// 3242     #endif
// 3243 
// 3244     #ifdef HALF_IN_Y
// 3245       constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
// 3246     #else
// 3247       constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
// 3248                         ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
        LSRS     R0,R0,#+1
        STR      R0,[SP, #+4]
// 3249                         ylen = ctry1;
        MOV      R0,R5
        STR      R0,[SP, #+0]
// 3250     #endif
// 3251 
// 3252     for (uint8_t xo = 0; xo <= xlen; xo++)
        MOVS     R6,#+0
        B.N      ??extrapolate_unprobed_bed_level_0
// 3253       for (uint8_t yo = 0; yo <= ylen; yo++) {
// 3254         uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
??extrapolate_unprobed_bed_level_1:
        LDR      R0,[SP, #+12]
        ADD      R8,R6,R0
        LDR      R0,[SP, #+4]
        ADD      R9,R7,R0
// 3255         #ifndef HALF_IN_X
// 3256           const uint8_t x1 = ctrx1 - xo;
// 3257         #endif
// 3258         #ifndef HALF_IN_Y
// 3259           const uint8_t y1 = ctry1 - yo;
        SUB      R11,R5,R7
// 3260           #ifndef HALF_IN_X
// 3261             extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R11
        UXTB     R1,R1
        MOV      R0,R10
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3262           #endif
// 3263           extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
        MOVS     R3,#+1
        MOV      R2,#-1
        MOV      R1,R11
        UXTB     R1,R1
        MOV      R0,R8
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3264         #endif
// 3265         #ifndef HALF_IN_X
// 3266           extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
        MOV      R3,#-1
        MOVS     R2,#+1
        MOV      R1,R9
        UXTB     R1,R1
        MOV      R0,R10
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3267         #endif
// 3268         extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
        MOV      R3,#-1
        MOV      R2,R3
        MOV      R1,R9
        UXTB     R1,R1
        MOV      R0,R8
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3269       }
        ADDS     R7,R7,#+1
        UXTB     R7,R7
??extrapolate_unprobed_bed_level_2:
        LDR      R0,[SP, #+0]
        CMP      R0,R7
        BGE.N    ??extrapolate_unprobed_bed_level_1
        ADDS     R6,R6,#+1
        UXTB     R6,R6
??extrapolate_unprobed_bed_level_0:
        LDR      R0,[SP, #+8]
        CMP      R0,R6
        BLT.N    ??extrapolate_unprobed_bed_level_3
        MOVS     R7,#+0
        SUB      R10,R4,R6
        B.N      ??extrapolate_unprobed_bed_level_2
// 3270 
// 3271   }
??extrapolate_unprobed_bed_level_3:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock48
// 3272 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function _Z28print_bilinear_leveling_gridv
        THUMB
// 3273   static void print_bilinear_leveling_grid() {
_Z28print_bilinear_leveling_gridv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3274     SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
        ADR.W    R0,`?<Constant "Bilinear Leveling Grid:\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3275     /*
// 3276     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
// 3277       [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
// 3278     );
// 3279     */
// 3280     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,0);
        LDR.W    R0,??DataTable151_1
        MOVS     R3,#+0
        MOVS     R2,#+3
        LDRB     R1,[R0, #+97]
        LDRB     R0,[R0, #+96]
        POP      {R12,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14print_2d_arrayhhhh
        B.N      _Z14print_2d_arrayhhhh
          CFI EndBlock cfiBlock49
// 3281   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Bilinear Leveling Grid:\\n">`:
        DC8 "Bilinear Leveling Grid:\012"
        DC8 0, 0, 0
// 3282 
// 3283   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3284 
// 3285     #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3286     #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3287     #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
// 3288     #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
// 3289     float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
// 3290     int bilinear_grid_spacing_virt[2] = { 0 };
// 3291     float bilinear_grid_factor_virt[2] = { 0 };
// 3292 
// 3293     static void print_bilinear_leveling_grid_virt() {
// 3294       SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
// 3295       /*
// 3296       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
// 3297         [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
// 3298       );
// 3299       */
// 3300       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,1);
// 3301     }
// 3302 
// 3303     #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
// 3304     float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
// 3305       uint8_t ep = 0, ip = 1;
// 3306       if (!x || x == ABL_TEMP_POINTS_X - 1) {
// 3307         if (x) {
// 3308           ep = GRID_MAX_POINTS_X - 1;
// 3309           ip = GRID_MAX_POINTS_X - 2;
// 3310         }
// 3311         if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
// 3312           return LINEAR_EXTRAPOLATION(
// 3313             z_values[ep][y - 1],
// 3314             z_values[ip][y - 1]
// 3315           );
// 3316         else
// 3317           return LINEAR_EXTRAPOLATION(
// 3318             bed_level_virt_coord(ep + 1, y),
// 3319             bed_level_virt_coord(ip + 1, y)
// 3320           );
// 3321       }
// 3322       if (!y || y == ABL_TEMP_POINTS_Y - 1) {
// 3323         if (y) {
// 3324           ep = GRID_MAX_POINTS_Y - 1;
// 3325           ip = GRID_MAX_POINTS_Y - 2;
// 3326         }
// 3327         if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
// 3328           return LINEAR_EXTRAPOLATION(
// 3329             z_values[x - 1][ep],
// 3330             z_values[x - 1][ip]
// 3331           );
// 3332         else
// 3333           return LINEAR_EXTRAPOLATION(
// 3334             bed_level_virt_coord(x, ep + 1),
// 3335             bed_level_virt_coord(x, ip + 1)
// 3336           );
// 3337       }
// 3338       return z_values[x - 1][y - 1];
// 3339     }
// 3340 
// 3341     static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
// 3342       return (
// 3343           p[i-1] * -t * sq(1 - t)
// 3344         + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
// 3345         + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
// 3346         - p[i+2] * sq(t) * (1 - t)
// 3347       ) * 0.5;
// 3348     }
// 3349 
// 3350     static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
// 3351       float row[4], column[4];
// 3352       for (uint8_t i = 0; i < 4; i++) {
// 3353         for (uint8_t j = 0; j < 4; j++) {
// 3354           column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
// 3355         }
// 3356         row[i] = bed_level_virt_cmr(column, 1, ty);
// 3357       }
// 3358       return bed_level_virt_cmr(row, 1, tx);
// 3359     }
// 3360 
// 3361     void bed_level_virt_interpolate() {
// 3362       bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3363       bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3364       bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
// 3365       bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
// 3366       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3367         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 3368           for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
// 3369             for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
// 3370               if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
// 3371                 continue;
// 3372               z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
// 3373                 bed_level_virt_2cmr(
// 3374                   x + 1,
// 3375                   y + 1,
// 3376                   (float)tx / (BILINEAR_SUBDIVISIONS),
// 3377                   (float)ty / (BILINEAR_SUBDIVISIONS)
// 3378                 );
// 3379             }
// 3380     }
// 3381   #endif // ABL_BILINEAR_SUBDIVISION
// 3382 
// 3383   // Refresh after other values have been updated

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function _Z17refresh_bed_levelv
        THUMB
// 3384   void refresh_bed_level() {
_Z17refresh_bed_levelv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3385     bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
        LDR.W    R4,??DataTable156_7
        LDR      R0,[R4, #+16]
        CMP      R0,#+0
        BNE.N    ??refresh_bed_level_0
        MOVS     R0,#+0
        STR      R0,[R4, #+32]
        B.N      ??refresh_bed_level_1
??refresh_bed_level_0:
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable157_3  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+32]
// 3386     bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
??refresh_bed_level_1:
        LDR      R0,[R4, #+20]
        CMP      R0,#+0
        BNE.N    ??refresh_bed_level_2
        MOVS     R0,#+0
        STR      R0,[R4, #+36]
        POP      {R4,PC}
??refresh_bed_level_2:
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable157_3  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+36]
// 3387     #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3388       bed_level_virt_interpolate();
// 3389     #endif
// 3390   }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146:
        DC32     0x3f847ae1
// 3391 
// 3392 #endif // AUTO_BED_LEVELING_BILINEAR
// 3393 
// 3394 /**
// 3395  * Home an individual linear axis
// 3396  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function _Z14do_homing_move8AxisEnumff
        THUMB
// 3397 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
_Z14do_homing_move8AxisEnumff:
        PUSH     {R1-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+40
        MOV      R9,R0
        MOV      R8,R1
        MOV      R7,R2
// 3398 
// 3399   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3400     if (DEBUGGING(LEVELING)) {
// 3401       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
// 3402       SERIAL_ECHOPAIR(", ", distance);
// 3403       SERIAL_ECHOPAIR(", ", fr_mm_s);
// 3404       SERIAL_CHAR(')');
// 3405       SERIAL_EOL();
// 3406     }
// 3407   #endif
// 3408 
// 3409   //#if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3410   #if HOMING_Z_WITH_PROBE
// 3411     //const 
// 3412     bool deploy_bltouch;
// 3413   if(MKSTOUCH == 1)
        LDR.W    R5,??DataTable151_1
        LDRB     R0,[R5, #+256]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_0
// 3414   {
// 3415   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)){	/*--mks cfg--*/
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+0
        BPL.N    ??do_homing_move_0
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_0
// 3416     deploy_bltouch = (axis == Z_AXIS && distance < 0);
        CMP      R9,#+2
        BNE.N    ??do_homing_move_1
        MOV      R0,R8
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_homing_move_1
        MOVS     R4,#+1
        B.N      ??do_homing_move_2
??do_homing_move_1:
        MOVS     R4,#+0
// 3417     if (deploy_bltouch) set_bltouch_deployed(true);
??do_homing_move_2:
        CMP      R4,#+0
        BEQ.N    ??do_homing_move_0
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 3418     }
// 3419   }
// 3420   #endif
// 3421 
// 3422   #if QUIET_PROBING
// 3423     if (axis == Z_AXIS) probing_pause(true);
// 3424   #endif
// 3425 
// 3426   // Tell the planner the axis is at 0
// 3427   current_position[axis] = 0;
??do_homing_move_0:
        LDR.W    R6,??DataTable151_2
        ADD      R9,R6,R9, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R9, #+8]
// 3428 
// 3429   //#if IS_SCARA
// 3430   if(MACHINETPYE&IS_SCARA)
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??do_homing_move_3
// 3431   {
// 3432     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 3433     current_position[axis] = distance;
        STR      R8,[R9, #+8]
// 3434     if(MACHINETPYE&IS_SCARA)
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        ADD      R0,R6,#+8
        BEQ.N    ??do_homing_move_4
// 3435 		inverse_kinematics_MORGAN_SCARA(current_position);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??do_homing_move_5
// 3436 	else
// 3437         inverse_kinematics(current_position);
??do_homing_move_4:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 3438     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
??do_homing_move_5:
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_homing_move_6
        STR      R7,[SP, #+8]
        B.N      ??do_homing_move_7
??do_homing_move_6:
        LDR      R0,[R9, #+40]
        STR      R0,[SP, #+8]
??do_homing_move_7:
        LDRB     R0,[R6, #+3]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        ADD      R3,R6,#+20
        LDR      R2,[R6, #+88]
        LDR      R1,[R6, #+84]
        LDR      R0,[R6, #+80]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        B.N      ??do_homing_move_8
// 3439   }
// 3440   //#else
// 3441   else
// 3442   {
// 3443     sync_plan_position();
??do_homing_move_3:
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3444     current_position[axis] = distance;
        STR      R8,[R9, #+8]
// 3445     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_homing_move_9
        STR      R7,[SP, #+8]
        B.N      ??do_homing_move_10
??do_homing_move_9:
        LDR      R0,[R9, #+40]
        STR      R0,[SP, #+8]
??do_homing_move_10:
        LDRB     R0,[R6, #+3]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        ADD      R3,R6,#+20
        LDR      R2,[R6, #+16]
        LDR      R1,[R6, #+12]
        LDR      R0,[R6, #+8]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
// 3446   }
// 3447   //#endif
// 3448 
// 3449   stepper.synchronize();
??do_homing_move_8:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 3450 
// 3451   #if QUIET_PROBING
// 3452     if (axis == Z_AXIS) probing_pause(false);
// 3453   #endif
// 3454 
// 3455   #if HOMING_Z_WITH_PROBE //&& ENABLED(BLTOUCH)
// 3456   if(MKSTOUCH == 1)
        LDRB     R0,[R5, #+256]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_11
// 3457   {
// 3458     if((Z_HOME_DIR < 0) &&  (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+0
        BPL.N    ??do_homing_move_11
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_11
// 3459     {
// 3460         if (deploy_bltouch) set_bltouch_deployed(false);
        UXTB     R4,R4
        CMP      R4,#+0
        BEQ.N    ??do_homing_move_11
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 3461     }
// 3462   }
// 3463   #endif
// 3464 
// 3465   endstops.hit_on_purpose();
??do_homing_move_11:
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 3466 
// 3467   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3468     if (DEBUGGING(LEVELING)) {
// 3469       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
// 3470       SERIAL_CHAR(')');
// 3471       SERIAL_EOL();
// 3472     }
// 3473   #endif
// 3474 }
        POP      {R0-R2,R4-R9,PC}  ;; return
          CFI EndBlock cfiBlock51

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147:
        DC32     mks_heating_busy+0x10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_1:
        DC32     saved_feedrate_percentage

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_2:
        DC32     0x40012c34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_3:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_4:
        DC32     gArrayGpioPin
// 3475 
// 3476 /**
// 3477  * TMC2130 specific sensorless homing using stallGuard2.
// 3478  * stallGuard2 only works when in spreadCycle mode.
// 3479  * spreadCycle and stealthChop are mutually exclusive.
// 3480  */
// 3481 #if ENABLED(SENSORLESS_HOMING)
// 3482   template<typename TMC>
// 3483   void tmc_sensorless_homing(TMC &st, bool enable=true) {
// 3484     #if ENABLED(STEALTHCHOP)
// 3485       if (enable) {
// 3486         st.coolstep_min_speed(1024UL * 1024UL - 1UL);
// 3487         st.stealthChop(0);
// 3488       }
// 3489       else {
// 3490         st.coolstep_min_speed(0);
// 3491         st.stealthChop(1);
// 3492       }
// 3493     #endif
// 3494 
// 3495     st.diag1_stall(enable ? 1 : 0);
// 3496   }
// 3497 #endif
// 3498 
// 3499 /**
// 3500  * Home an individual "raw axis" to its endstop.
// 3501  * This applies to XYZ on Cartesian and Core robots, and
// 3502  * to the individual ABC steppers on DELTA and SCARA.
// 3503  *
// 3504  * At the end of the procedure the axis is marked as
// 3505  * homed and the current position of that axis is updated.
// 3506  * Kinematic robots should wait till all axes are homed
// 3507  * before updating the current position.
// 3508  */
// 3509 
// 3510 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
// 3511 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function _Z8homeaxis8AxisEnum
        THUMB
// 3512 static void homeaxis(const AxisEnum axis) {
_Z8homeaxis8AxisEnum:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
// 3513 
// 3514 #define CAN_HOME(A) \ 
// 3515     (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
// 3516 
// 3517   //#if IS_SCARA
// 3518   if(MACHINETPYE&IS_SCARA)
        LDR.W    R5,??DataTable151_1
        ADDW     R8,R5,#+5
        MOV      R6,R4
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??homeaxis_0
// 3519   {
// 3520     // Only Z homing (with probe) is permitted
// 3521     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
        CMP      R6,#+2
        BEQ.N    ??homeaxis_1
        B.N      ??homeaxis_2
// 3522   }
// 3523   //#else
// 3524   else
// 3525    {
// 3526     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
??homeaxis_0:
        CMP      R4,#+0
        BNE.N    ??homeaxis_3
        LDRSB    R0,[R5, #+5]
        CMP      R0,#+0
        BNE.N    ??homeaxis_1
??homeaxis_3:
        CMP      R6,#+1
        BNE.N    ??homeaxis_4
        LDRSB    R0,[R8, #+1]
        CMP      R0,#+0
        BNE.N    ??homeaxis_1
??homeaxis_4:
        CMP      R6,#+2
        BNE.W    ??homeaxis_2
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BEQ.W    ??homeaxis_2
// 3527    }
// 3528   //#endif
// 3529 
// 3530   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3531     if (DEBUGGING(LEVELING)) {
// 3532       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
// 3533       SERIAL_CHAR(')');
// 3534       SERIAL_EOL();
// 3535     }
// 3536   #endif
// 3537 
// 3538   const int axis_home_dir =
// 3539     #if ENABLED(DUAL_X_CARRIAGE)
// 3540       (axis == X_AXIS) ? x_home_dir(active_extruder) :
// 3541     #endif
// 3542     home_dir(axis);
??homeaxis_1:
        MOV      R0,R4
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        MOV      R7,R0
// 3543 
// 3544   // Homing Z towards the bed? Deploy the Z probe or endstop.
// 3545   #if HOMING_Z_WITH_PROBE
// 3546   
// 3547   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_5
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_5
// 3548   {
// 3549     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
        CMP      R6,#+2
        BNE.N    ??homeaxis_5
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.W    ??homeaxis_2
// 3550   }
// 3551   #endif
// 3552 
// 3553   // Set flags for X, Y, Z motor locking
// 3554   #if ENABLED(X_DUAL_ENDSTOPS)
// 3555     if (axis == X_AXIS) stepper.set_homing_flag_x(true);
// 3556   #endif
// 3557   #if ENABLED(Y_DUAL_ENDSTOPS)
// 3558     if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
// 3559   #endif
// 3560   #if 1//ENABLED(Z_DUAL_ENDSTOPS)
// 3561     if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
??homeaxis_5:
        CMP      R6,#+2
        BNE.N    ??homeaxis_6
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper17set_homing_flag_zEb
        BL       _ZN7Stepper17set_homing_flag_zEb
// 3562   #endif
// 3563 
// 3564   // Disable stealthChop if used. Enable diag1 pin on driver.
// 3565   #if ENABLED(SENSORLESS_HOMING)
// 3566     #if ENABLED(X_IS_TMC2130)
// 3567       if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
// 3568     #endif
// 3569     #if ENABLED(Y_IS_TMC2130)
// 3570       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
// 3571     #endif
// 3572   #endif
// 3573 
// 3574   // Fast move towards endstop until triggered
// 3575   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3576     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
// 3577   #endif
// 3578   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
??homeaxis_6:
        MOV      R0,R4
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        MOVS     R2,#+0
        MOV      R9,R2
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R9
        LDR.W    R3,??DataTable157_4  ;; 0x3ff80000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOV      R2,R9
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3579 
// 3580   // When homing Z with probe respect probe clearance
// 3581   /*
// 3582   const float bump = axis_home_dir * (
// 3583     #if HOMING_Z_WITH_PROBE
// 3584       (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
// 3585     #endif
// 3586     home_bump_mm(axis)
// 3587   );
// 3588   */
// 3589     float bump = 0;
// 3590     #if HOMING_Z_WITH_PROBE
// 3591         if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))    /*--mks cfg--*/
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_7
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_7
// 3592             bump = axis_home_dir*((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
        CMP      R6,#+2
        BNE.N    ??homeaxis_8
        ADD      R0,R5,#+88
        LDR      R9,[R0, #+16]
        MOVS     R0,#+2
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R1,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??homeaxis_9
        MOVS     R0,#+2
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R9,R0
        B.N      ??homeaxis_9
??homeaxis_8:
        MOV      R0,R4
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R9,R0
??homeaxis_9:
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        B.N      ??homeaxis_10
// 3593         else
// 3594             bump = axis_home_dir *home_bump_mm(axis);
??homeaxis_7:
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R9,R0
        MOV      R0,R4
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
// 3595     #else
// 3596         bump = axis_home_dir *home_bump_mm(axis);
// 3597     #endif
// 3598 
// 3599   // If a second homing move is configured...
// 3600   if (bump) {
??homeaxis_10:
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??homeaxis_11
// 3601     // Move away from the endstop by the axis HOME_BUMP_MM
// 3602     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3603       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
// 3604     #endif
// 3605     do_homing_move(axis, -bump);
        MOV      R2,R1
        MOV      R1,R9
        EOR      R1,R1,#0x80000000
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3606 
// 3607     // Slow move towards endstop until triggered
// 3608     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3609       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
// 3610     #endif
// 3611     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
        MOV      R0,R4
          CFI FunCall _Z24get_homing_bump_feedrate8AxisEnum
        BL       _Z24get_homing_bump_feedrate8AxisEnum
        MOV      R2,R0
        MOV      R10,R2
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R2,R10
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3612   }
// 3613 
// 3614   /**
// 3615    * Home axes that have dual endstops... differently
// 3616    */
// 3617   #if 1//ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 3618     const bool pos_dir = axis_home_dir > 0;
??homeaxis_11:
        CMP      R7,#+1
        BLT.N    ??homeaxis_12
        MOVS     R7,#+1
        B.N      ??homeaxis_13
??homeaxis_12:
        MOVS     R7,#+0
// 3619     #if ENABLED(X_DUAL_ENDSTOPS)
// 3620       if (axis == X_AXIS) {
// 3621         const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
// 3622         const float adj = FABS(x_endstop_adj);
// 3623         if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
// 3624         do_homing_move(axis, pos_dir ? -adj : adj);
// 3625         if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
// 3626         stepper.set_homing_flag_x(false);
// 3627       }
// 3628     #endif
// 3629     #if ENABLED(Y_DUAL_ENDSTOPS)
// 3630       if (axis == Y_AXIS) {
// 3631         const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
// 3632         const float adj = FABS(y_endstop_adj);
// 3633         if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
// 3634         do_homing_move(axis, pos_dir ? -adj : adj);
// 3635         if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
// 3636         stepper.set_homing_flag_y(false);
// 3637       }
// 3638     #endif
// 3639     //#if ENABLED(Z_DUAL_ENDSTOPS)
// 3640     if(Z_DUAL_ENDSTOPS==1)
??homeaxis_13:
        LDRB     R0,[R5, #+258]
        CMP      R0,#+1
        BNE.N    ??homeaxis_14
// 3641     {
// 3642       if (axis == Z_AXIS) {
        CMP      R6,#+2
        BNE.N    ??homeaxis_14
// 3643         const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
        LDR.W    R0,??DataTable157_5
        LDR      R0,[R0, #+0]
        CMP      R7,#+0
        BEQ.N    ??homeaxis_15
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??homeaxis_16
        MOV      R9,#+1
        B.N      ??homeaxis_17
??homeaxis_16:
        MOV      R9,R1
        B.N      ??homeaxis_17
??homeaxis_15:
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??homeaxis_18
        MOV      R9,#+1
        B.N      ??homeaxis_17
??homeaxis_18:
        MOV      R9,R1
// 3644         const float adj = FABS(z_endstop_adj);
??homeaxis_17:
        BIC      R10,R0,#0x80000000
// 3645         if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
        CMP      R9,#+0
        BEQ.N    ??homeaxis_19
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper10set_z_lockEb
        BL       _ZN7Stepper10set_z_lockEb
        B.N      ??homeaxis_20
??homeaxis_19:
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper11set_z2_lockEb
        BL       _ZN7Stepper11set_z2_lockEb
// 3646         do_homing_move(axis, pos_dir ? -adj : adj);
??homeaxis_20:
        CMP      R7,#+0
        BEQ.N    ??homeaxis_21
        EOR      R10,R10,#0x80000000
??homeaxis_21:
        MOVS     R2,#+0
        MOV      R1,R10
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3647         if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
        CMP      R9,#+0
        BEQ.N    ??homeaxis_22
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper10set_z_lockEb
        BL       _ZN7Stepper10set_z_lockEb
        B.N      ??homeaxis_23
??homeaxis_22:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper11set_z2_lockEb
        BL       _ZN7Stepper11set_z2_lockEb
// 3648         stepper.set_homing_flag_z(false);
??homeaxis_23:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper17set_homing_flag_zEb
        BL       _ZN7Stepper17set_homing_flag_zEb
// 3649       }
// 3650     }
// 3651     //#endif
// 3652   #endif
// 3653 
// 3654   //#if IS_SCARA
// 3655   if(MACHINETPYE&IS_SCARA)
??homeaxis_14:
        LDRSH    R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??homeaxis_24
// 3656   {
// 3657     set_axis_is_at_home(axis);
        MOV      R0,R4
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
// 3658     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??homeaxis_25
// 3659   }
// 3660   //#elif ENABLED(DELTA)
// 3661   else if(MACHINETPYE == DELTA) {
??homeaxis_24:
        CMP      R0,#+2
        BNE.N    ??homeaxis_26
// 3662 
// 3663     // Delta has already moved all three towers up in G28
// 3664     // so here it re-homes each tower in turn.
// 3665     // Delta homing treats the axes as normal linear axes.
// 3666 
// 3667     // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
// 3668     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
        LDR.W    R0,??DataTable157_5
        ADD      R0,R0,R6, LSL #+2
        LDR      R10,[R0, #+4]
        LDRSB    R7,[R8, #+2]
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BHI.N    ??homeaxis_25
// 3669       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3670         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
// 3671       #endif
// 3672       do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
        MOV      R2,R1
        MOV      R9,R2
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.W    R2,??DataTable157_6  ;; 0x9999999a
        LDR.W    R3,??DataTable157_7  ;; 0x3fb99999
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOV      R2,R9
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
        B.N      ??homeaxis_25
// 3673     }
// 3674   }
// 3675   //#else
// 3676   else
// 3677   {
// 3678     // For cartesian/core machines,
// 3679     // set the axis to its home position
// 3680     set_axis_is_at_home(axis);
??homeaxis_26:
        MOV      R0,R4
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
// 3681     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3682 
// 3683     destination[axis] = current_position[axis];
        LDR.N    R0,??DataTable151_2
        ADD      R0,R0,R6, LSL #+2
        LDR      R1,[R0, #+8]
        STR      R1,[R0, #+24]
// 3684 
// 3685     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3686       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
// 3687     #endif
// 3688   }
// 3689   //#endif
// 3690 
// 3691   // Re-enable stealthChop if used. Disable diag1 pin on driver.
// 3692   #if ENABLED(SENSORLESS_HOMING)
// 3693     #if ENABLED(X_IS_TMC2130)
// 3694       if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
// 3695     #endif
// 3696     #if ENABLED(Y_IS_TMC2130)
// 3697       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
// 3698     #endif
// 3699   #endif
// 3700 
// 3701   // Put away the Z probe
// 3702   #if HOMING_Z_WITH_PROBE
// 3703   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
??homeaxis_25:
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_2
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_2
// 3704   {    
// 3705     if (axis == Z_AXIS && STOW_PROBE()) return;
        CMP      R6,#+2
        BNE.N    ??homeaxis_2
        MOVS     R0,#+0
        POP      {R1,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
// 3706    }
// 3707   #endif
// 3708 
// 3709   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3710     if (DEBUGGING(LEVELING)) {
// 3711       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
// 3712       SERIAL_CHAR(')');
// 3713       SERIAL_EOL();
// 3714     }
// 3715   #endif
// 3716 } // homeaxis()
??homeaxis_2:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock52

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148:
        DC32     _ZN8Endstops15z_probe_enabledE
// 3717 
// 3718 #if ENABLED(FWRETRACT)
// 3719 
// 3720   /**
// 3721    * Retract or recover according to firmware settings
// 3722    *
// 3723    * This function handles retract/recover moves for G10 and G11,
// 3724    * plus auto-retract moves sent from G0/G1 when E-only moves are done.
// 3725    *
// 3726    * To simplify the logic, doubled retract/recover moves are ignored.
// 3727    *
// 3728    * Note: Z lift is done transparently to the planner. Aborting
// 3729    *       a print between G10 and G11 may corrupt the Z position.
// 3730    *
// 3731    * Note: Auto-retract will apply the set Z hop in addition to any Z hop
// 3732    *       included in the G-code. Use M207 Z0 to to prevent double hop.
// 3733    */
// 3734   void retract(const bool retracting
// 3735     #if EXTRUDERS > 1
// 3736       , bool swapping = false
// 3737     #endif
// 3738   ) {
// 3739 
// 3740     static float hop_amount = 0.0;  // Total amount lifted, for use in recover
// 3741 
// 3742     // Prevent two retracts or recovers in a row
// 3743     if (retracted[active_extruder] == retracting) return;
// 3744 
// 3745     // Prevent two swap-retract or recovers in a row
// 3746     #if EXTRUDERS > 1
// 3747       // Allow G10 S1 only after G10
// 3748       if (swapping && retracted_swap[active_extruder] == retracting) return;
// 3749       // G11 priority to recover the long retract if activated
// 3750       if (!retracting) swapping = retracted_swap[active_extruder];
// 3751     #else
// 3752       const bool swapping = false;
// 3753     #endif
// 3754 
// 3755     /* // debugging
// 3756       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3757       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3758       SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
// 3759       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3760         SERIAL_ECHOPAIR("retracted[", i);
// 3761         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3762         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3763         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3764       }
// 3765       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3766       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3767     //*/
// 3768 
// 3769     const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
// 3770     const float old_feedrate_mm_s = feedrate_mm_s;
// 3771 
// 3772     // The current position will be the destination for E and Z moves
// 3773     set_destination_from_current();
// 3774     stepper.synchronize();  // Wait for buffered moves to complete
// 3775 
// 3776     const float renormalize = 1.0 / planner.e_factor[active_extruder];
// 3777 
// 3778     if (retracting) {
// 3779       // Retract by moving from a faux E position back to the current E position
// 3780       feedrate_mm_s = retract_feedrate_mm_s;
// 3781       current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
// 3782       sync_plan_position_e();
// 3783       prepare_move_to_destination();
// 3784 
// 3785       // Is a Z hop set, and has the hop not yet been done?
// 3786       if (has_zhop && !hop_amount) {
// 3787         hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
// 3788         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3789         current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3790         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3791         prepare_move_to_destination();                      // Raise up to the old current pos
// 3792         feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
// 3793       }
// 3794     }
// 3795     else {
// 3796       // If a hop was done and Z hasn't changed, undo the Z hop
// 3797       if (hop_amount) {
// 3798         current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3799         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3800         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3801         prepare_move_to_destination();                      // Raise up to the old current pos
// 3802         hop_amount = 0.0;                                   // Clear hop
// 3803       }
// 3804 
// 3805       // A retract multiplier has been added here to get faster swap recovery
// 3806       feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
// 3807 
// 3808       const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
// 3809       current_position[E_AXIS] -= move_e * renormalize;
// 3810       sync_plan_position_e();
// 3811       prepare_move_to_destination();                        // Recover E
// 3812     }
// 3813 
// 3814     feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
// 3815 
// 3816     retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
// 3817 
// 3818     // If swap retract/recover update the retracted_swap flag too
// 3819     #if EXTRUDERS > 1
// 3820       if (swapping) retracted_swap[active_extruder] = retracting;
// 3821     #endif
// 3822 
// 3823     /* // debugging
// 3824       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3825       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3826       SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
// 3827       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3828         SERIAL_ECHOPAIR("retracted[", i);
// 3829         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3830         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3831         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3832       }
// 3833       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3834       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3835     //*/
// 3836 
// 3837   }
// 3838 
// 3839 #endif // FWRETRACT
// 3840 
// 3841 #if ENABLED(MIXING_EXTRUDER)
// 3842 
// 3843   void normalize_mix() {
// 3844     float mix_total = 0.0;
// 3845     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
// 3846     // Scale all values if they don't add up to ~1.0
// 3847     if (!NEAR(mix_total, 1.0)) {
// 3848       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
// 3849       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
// 3850     }
// 3851   }
// 3852 
// 3853   #if ENABLED(DIRECT_MIXING_IN_G1)
// 3854     // Get mixing parameters from the GCode
// 3855     // The total "must" be 1.0 (but it will be normalized)
// 3856     // If no mix factors are given, the old mix is preserved
// 3857     void gcode_get_mix() {
// 3858       const char* mixing_codes = "ABCDHI";
// 3859       byte mix_bits = 0;
// 3860       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
// 3861         if (parser.seenval(mixing_codes[i])) {
// 3862           SBI(mix_bits, i);
// 3863           float v = parser.value_float();
// 3864           NOLESS(v, 0.0);
// 3865           mixing_factor[i] = RECIPROCAL(v);
// 3866         }
// 3867       }
// 3868       // If any mixing factors were included, clear the rest
// 3869       // If none were included, preserve the last mix
// 3870       if (mix_bits) {
// 3871         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 3872           if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
// 3873         normalize_mix();
// 3874       }
// 3875     }
// 3876   #endif
// 3877 
// 3878 #endif
// 3879 
// 3880 /**
// 3881  * ***************************************************************************
// 3882  * ***************************** G-CODE HANDLING *****************************
// 3883  * ***************************************************************************
// 3884  */
// 3885 
// 3886 /**
// 3887  * Set XYZE destination and feedrate from the current GCode command
// 3888  *
// 3889  *  - Set destination from included axis codes
// 3890  *  - Set to current for missing axis codes
// 3891  *  - Set the feedrate, if included
// 3892  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function _Z21gcode_get_destinationv
        THUMB
// 3893 void gcode_get_destination() {
_Z21gcode_get_destinationv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3894   LOOP_XYZE(i) {
        MOVS     R4,#+0
        B.N      ??gcode_get_destination_0
// 3895     if (parser.seen(axis_codes[i])) {
// 3896       const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
// 3897       //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
// 3898       destination[i] = v;
// 3899     }
// 3900     else
// 3901       destination[i] = current_position[i];
??gcode_get_destination_1:
        LDR      R0,[R5, #+8]
        STR      R0,[R5, #+24]
??gcode_get_destination_2:
        ADDS     R4,R4,#+1
??gcode_get_destination_0:
        CMP      R4,#+4
        BGE.N    ??gcode_get_destination_3
        LDR.N    R0,??DataTable151_2
        ADD      R5,R0,R4, LSL #+2
        ADR.W    R0,axis_codes
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_get_destination_1
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDR.W    R1,??DataTable156_7
        LDRB     R2,[R4, R1]
        LDRB     R1,[R1, #+5]
        ORRS     R1,R1,R2
        BEQ.N    ??gcode_get_destination_4
        LDR      R1,[R5, #+8]
        B.N      ??gcode_get_destination_5
??gcode_get_destination_4:
        MOVS     R1,#+0
??gcode_get_destination_5:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+24]
        B.N      ??gcode_get_destination_2
// 3902   }
// 3903 
// 3904   if (parser.linearval('F') > 0.0)
??gcode_get_destination_3:
        MOVS     R1,#+0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_get_destination_6
// 3905     feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
          CFI FunCall _ZN11GCodeParser14value_feedrateEv
        BL       _ZN11GCodeParser14value_feedrateEv
        LDR.N    R1,??DataTable152  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.N    R1,??DataTable151_2
        STR      R0,[R1, #+92]
// 3906 
// 3907   #if ENABLED(PRINTCOUNTER)
// 3908     if (!DEBUGGING(DRYRUN))
// 3909       print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
// 3910   #endif
// 3911 
// 3912   // Get ABCDHI mixing factors
// 3913   #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
// 3914     gcode_get_mix();
// 3915   #endif
// 3916 }
??gcode_get_destination_6:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock53

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
axis_codes:
        DC8 88, 89, 90, 69
// 3917 
// 3918 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 3919 
// 3920   /**
// 3921    * Output a "busy" message at regular intervals
// 3922    * while the machine is not accepting commands.
// 3923    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function _Z14host_keepalivev
        THUMB
// 3924   void host_keepalive() {
_Z14host_keepalivev:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3925     const millis_t ms = millis();
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R5,R0
// 3926     if (host_keepalive_interval && busy_state != NOT_BUSY) {
        LDR.W    R4,??DataTable156_7
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BEQ.N    ??host_keepalive_0
        LDRSB    R0,[R4, #+6]
        CMP      R0,#+0
        BEQ.N    ??host_keepalive_0
// 3927       if (PENDING(ms, next_busy_signal_ms)) return;
        LDR      R1,[R4, #+60]
        SUBS     R1,R5,R1
        BMI.N    ??host_keepalive_1
// 3928       switch (busy_state) {
        CMP      R0,#+1
        BEQ.N    ??host_keepalive_2
        BCC.N    ??host_keepalive_0
        CMP      R0,#+3
        BEQ.N    ??host_keepalive_3
        BCC.N    ??host_keepalive_2
        CMP      R0,#+4
        BEQ.N    ??host_keepalive_4
        B.N      ??host_keepalive_0
// 3929         case IN_HANDLER:
// 3930         case IN_PROCESS:
// 3931           SERIAL_ECHO_START();
??host_keepalive_2:
        LDR.W    R0,??DataTable157_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3932           SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
        ADR.W    R0,`?<Constant "busy: processing\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3933           break;
        B.N      ??host_keepalive_0
// 3934         case PAUSED_FOR_USER:
// 3935           SERIAL_ECHO_START();
??host_keepalive_3:
        LDR.W    R0,??DataTable157_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3936           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
        ADR.W    R0,`?<Constant "busy: paused for user\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3937           break;
        B.N      ??host_keepalive_0
// 3938         case PAUSED_FOR_INPUT:
// 3939           SERIAL_ECHO_START();
??host_keepalive_4:
        LDR.W    R0,??DataTable157_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3940           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
        ADR.W    R0,`?<Constant "busy: paused for input\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3941           break;
// 3942         default:
// 3943           break;
// 3944       }
// 3945     }
// 3946     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
??host_keepalive_0:
        LDRB     R0,[R4, #+7]
        MOV      R1,#+1000
        MLA      R0,R1,R0,R5
        STR      R0,[R4, #+60]
// 3947   }
??host_keepalive_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock54

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable150:
        DC32     _ZN8Endstops16endstop_hit_bitsE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "busy: processing\\n">`:
        DC8 "busy: processing\012"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "busy: paused for user\\n">`:
        DC8 "busy: paused for user\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "busy: paused for input\\n">`:
        DC8 "busy: paused for input\012"
// 3948 
// 3949 #endif // HOST_KEEPALIVE_FEATURE
// 3950 
// 3951 
// 3952 /**************************************************
// 3953  ***************** GCode Handlers *****************
// 3954  **************************************************/
// 3955 
// 3956 #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3957   #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
// 3958 #else
// 3959   #define G0_G1_CONDITION true
// 3960 #endif
// 3961 
// 3962 /**
// 3963  * G0, G1: Coordinated movement of X Y Z E axes
// 3964  */
// 3965 inline void gcode_G0_G1(
// 3966   #if 0//IS_SCARA
// 3967     bool fast_move=false
// 3968   #endif
// 3969 ) {
// 3970   if (IsRunning() && G0_G1_CONDITION) {
// 3971     gcode_get_destination(); // For X Y Z E F
// 3972     
// 3973    /*    
// 3974     if (gCfgItems.breakpoint_reprint_flg == 1) 
// 3975     {
// 3976         if ((destination[2] <= gCfgItems.breakpoint_z_pos)&&(card.sdpos >= 5000)) //∂œµ„–¯¥Ú–Ë“™¥Û”⁄5k÷Æ∫Ûµƒƒ⁄»›≤≈ƒ‹Ω¯–––¯¥Ú°£
// 3977         {
// 3978             return;
// 3979         }
// 3980     }
// 3981     */
// 3982     #if ENABLED(FWRETRACT)
// 3983       if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 3984         // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 3985         if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 3986           const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 3987           // Is this a retract or recover move?
// 3988           if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 3989             current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 3990             sync_plan_position_e();                         // AND from the planner
// 3991             return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 3992           }
// 3993         }
// 3994       }
// 3995     #endif // FWRETRACT
// 3996 
// 3997     #if 0//IS_SCARA
// 3998       fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 3999     #else
// 4000       prepare_move_to_destination();
// 4001     #endif
// 4002 
// 4003     #if ENABLED(NANODLP_Z_SYNC)
// 4004       #if ENABLED(NANODLP_ALL_AXIS)
// 4005         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 4006       #else
// 4007         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 4008       #endif
// 4009       if (_MOVE_SYNC) {
// 4010         stepper.synchronize();
// 4011         SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4012       }
// 4013     #endif
// 4014   }
// 4015 }
// 4016 inline void gcode_G0_G1_SCARA(
// 4017 	  bool fast_move=false
// 4018   )
// 4019   {
// 4020     if (IsRunning() && G0_G1_CONDITION) {
// 4021       gcode_get_destination(); // For X Y Z E F
// 4022 
// 4023     #if ENABLED(FWRETRACT)
// 4024         if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 4025           // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 4026           if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 4027             const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 4028             // Is this a retract or recover move?
// 4029             if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 4030               current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 4031               sync_plan_position_e();                         // AND from the planner
// 4032               return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 4033             }
// 4034           }
// 4035         }
// 4036     #endif // FWRETRACT
// 4037 
// 4038     #if 1//IS_SCARA
// 4039         fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 4040     #else
// 4041         prepare_move_to_destination();
// 4042     #endif
// 4043 
// 4044     #if ENABLED(NANODLP_Z_SYNC)
// 4045     #if ENABLED(NANODLP_ALL_AXIS)
// 4046         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 4047     #else
// 4048         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 4049     #endif
// 4050         if (_MOVE_SYNC) {
// 4051           stepper.synchronize();
// 4052           SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4053         }
// 4054     #endif
// 4055     }
// 4056 }
// 4057 
// 4058 /**
// 4059  * G2: Clockwise Arc
// 4060  * G3: Counterclockwise Arc
// 4061  *
// 4062  * This command has two forms: IJ-form and R-form.
// 4063  *
// 4064  *  - I specifies an X offset. J specifies a Y offset.
// 4065  *    At least one of the IJ parameters is required.
// 4066  *    X and Y can be omitted to do a complete circle.
// 4067  *    The given XY is not error-checked. The arc ends
// 4068  *     based on the angle of the destination.
// 4069  *    Mixing I or J with R will throw an error.
// 4070  *
// 4071  *  - R specifies the radius. X or Y is required.
// 4072  *    Omitting both X and Y will throw an error.
// 4073  *    X or Y must differ from the current XY.
// 4074  *    Mixing R with I or J will throw an error.
// 4075  *
// 4076  *  - P specifies the number of full circles to do
// 4077  *    before the specified arc move.
// 4078  *
// 4079  *  Examples:
// 4080  *
// 4081  *    G2 I10           ; CW circle centered at X+10
// 4082  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
// 4083  */
// 4084 #if ENABLED(ARC_SUPPORT)
// 4085 
// 4086   inline void gcode_G2_G3(const bool clockwise) {
// 4087     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 4088       if (axis_unhomed_error()) return;
// 4089     #endif
// 4090 
// 4091     if (IsRunning()) {
// 4092 
// 4093       #if ENABLED(SF_ARC_FIX)
// 4094         const bool relative_mode_backup = relative_mode;
// 4095         relative_mode = true;
// 4096       #endif
// 4097 
// 4098       gcode_get_destination();
// 4099 
// 4100       #if ENABLED(SF_ARC_FIX)
// 4101         relative_mode = relative_mode_backup;
// 4102       #endif
// 4103 
// 4104       float arc_offset[2] = { 0.0, 0.0 };
// 4105       if (parser.seenval('R')) {
// 4106         const float r = parser.value_linear_units(),
// 4107                     p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
// 4108                     p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
// 4109         if (r && (p2 != p1 || q2 != q1)) {
// 4110           const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
// 4111                       dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
// 4112                       d = HYPOT(dx, dy),                          // Linear distance between the points
// 4113                       h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
// 4114                       mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
// 4115                       sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
// 4116                       cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
// 4117           arc_offset[0] = cx - p1;
// 4118           arc_offset[1] = cy - q1;
// 4119         }
// 4120       }
// 4121       else {
// 4122         if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
// 4123         if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
// 4124       }
// 4125 
// 4126       if (arc_offset[0] || arc_offset[1]) {
// 4127 
// 4128         #if ENABLED(ARC_P_CIRCLES)
// 4129           // P indicates number of circles to do
// 4130           int8_t circles_to_do = parser.byteval('P');
// 4131           if (!WITHIN(circles_to_do, 0, 100)) {
// 4132             SERIAL_ERROR_START();
// 4133             SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 4134           }
// 4135           while (circles_to_do--)
// 4136             plan_arc(current_position, arc_offset, clockwise);
// 4137         #endif
// 4138 
// 4139         // Send the arc to the planner
// 4140         plan_arc(destination, arc_offset, clockwise);
// 4141         refresh_cmd_timeout();
// 4142       }
// 4143       else {
// 4144         // Bad arguments
// 4145         SERIAL_ERROR_START();
// 4146         SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 4147       }
// 4148     }
// 4149   }
// 4150 
// 4151 #endif // ARC_SUPPORT
// 4152 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function _Z5dwellm
        THUMB
// 4153 void dwell(millis_t time) {
_Z5dwellm:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 4154   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 4155   time += previous_cmd_ms;
        LDR.W    R0,??DataTable158
        LDR      R0,[R0, #+92]
        ADDS     R4,R0,R4
        B.N      ??dwell_0
// 4156   while (PENDING(millis(), time)) idle();
??dwell_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??dwell_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R4
        BMI.N    ??dwell_1
// 4157 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock55

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151:
        DC32     0xc1200000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_1:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_2:
        DC32     mks_heating_busy
// 4158 
// 4159 /**
// 4160  * G4: Dwell S<seconds> or P<milliseconds>
// 4161  */
// 4162 inline void gcode_G4() {
// 4163   millis_t dwell_ms = 0;
// 4164 
// 4165   if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
// 4166   if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
// 4167 
// 4168   stepper.synchronize();
// 4169   #if ENABLED(NANODLP_Z_SYNC)
// 4170     SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4171   #endif
// 4172 
// 4173   if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
// 4174 
// 4175   dwell(dwell_ms);
// 4176 }
// 4177 
// 4178 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 4179 
// 4180   /**
// 4181    * Parameters interpreted according to:
// 4182    * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
// 4183    * However I, J omission is not supported at this point; all
// 4184    * parameters can be omitted and default to zero.
// 4185    */
// 4186 
// 4187   /**
// 4188    * G5: Cubic B-spline
// 4189    */
// 4190   inline void gcode_G5() {
// 4191     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 4192       if (axis_unhomed_error()) return;
// 4193     #endif
// 4194 
// 4195     if (IsRunning()) {
// 4196 
// 4197       #if ENABLED(CNC_WORKSPACE_PLANES)
// 4198         if (workspace_plane != PLANE_XY) {
// 4199           SERIAL_ERROR_START();
// 4200           SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
// 4201           return;
// 4202         }
// 4203       #endif
// 4204 
// 4205       gcode_get_destination();
// 4206 
// 4207       const float offset[] = {
// 4208         parser.linearval('I'),
// 4209         parser.linearval('J'),
// 4210         parser.linearval('P'),
// 4211         parser.linearval('Q')
// 4212       };
// 4213 
// 4214       plan_cubic_move(offset);
// 4215     }
// 4216   }
// 4217 
// 4218 #endif // BEZIER_CURVE_SUPPORT
// 4219 
// 4220 #if ENABLED(FWRETRACT)
// 4221 
// 4222   /**
// 4223    * G10 - Retract filament according to settings of M207
// 4224    */
// 4225   inline void gcode_G10() {
// 4226     #if EXTRUDERS > 1
// 4227       const bool rs = parser.boolval('S');
// 4228       retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
// 4229     #endif
// 4230     retract(true
// 4231       #if EXTRUDERS > 1
// 4232         , rs
// 4233       #endif
// 4234     );
// 4235   }
// 4236 
// 4237   /**
// 4238    * G11 - Recover filament according to settings of M208
// 4239    */
// 4240   inline void gcode_G11() { retract(false); }
// 4241 
// 4242 #endif // FWRETRACT
// 4243 
// 4244 #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 4245   /**
// 4246    * G12: Clean the nozzle
// 4247    */
// 4248   inline void gcode_G12() {
// 4249     // Don't allow nozzle cleaning without homing first
// 4250     if (axis_unhomed_error()) return;
// 4251 
// 4252     const uint8_t pattern = parser.ushortval('P', 0),
// 4253                   strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
// 4254                   objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
// 4255     const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
// 4256 
// 4257     Nozzle::clean(pattern, strokes, radius, objects);
// 4258   }
// 4259 #endif
// 4260 
// 4261 #if ENABLED(CNC_WORKSPACE_PLANES)
// 4262 
// 4263   inline void report_workspace_plane() {
// 4264     SERIAL_ECHO_START();
// 4265     SERIAL_ECHOPGM("Workspace Plane ");
// 4266     serialprintPGM(
// 4267       workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
// 4268       workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
// 4269                                     PSTR("XY\n")
// 4270     );
// 4271   }
// 4272 
// 4273   inline void set_workspace_plane(const WorkspacePlane plane) {
// 4274     workspace_plane = plane;
// 4275     if (DEBUGGING(INFO)) report_workspace_plane();
// 4276   }
// 4277 
// 4278   /**
// 4279    * G17: Select Plane XY
// 4280    * G18: Select Plane ZX
// 4281    * G19: Select Plane YZ
// 4282    */
// 4283   inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
// 4284   inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
// 4285   inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
// 4286 
// 4287 #endif // CNC_WORKSPACE_PLANES
// 4288 
// 4289 #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 4290 
// 4291   /**
// 4292    * Select a coordinate system and update the workspace offset.
// 4293    * System index -1 is used to specify machine-native.
// 4294    */
// 4295   bool select_coordinate_system(const int8_t _new) {
// 4296     if (active_coordinate_system == _new) return false;
// 4297     float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
// 4298     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4299       COPY(old_offset, coordinate_system[active_coordinate_system]);
// 4300     if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4301       COPY(new_offset, coordinate_system[_new]);
// 4302     active_coordinate_system = _new;
// 4303     LOOP_XYZ(i) {
// 4304       const float diff = new_offset[i] - old_offset[i];
// 4305       if (diff) {
// 4306         position_shift[i] += diff;
// 4307         update_software_endstops((AxisEnum)i);
// 4308       }
// 4309     }
// 4310     return true;
// 4311   }
// 4312 
// 4313   /**
// 4314    * In CNC G-code G53 is like a modifier
// 4315    * It precedes a movement command (or other modifiers) on the same line.
// 4316    * This is the first command to use parser.chain() to make this possible.
// 4317    */
// 4318   inline void gcode_G53() {
// 4319     // If this command has more following...
// 4320     if (parser.chain()) {
// 4321       const int8_t _system = active_coordinate_system;
// 4322       active_coordinate_system = -1;
// 4323       process_parsed_command();
// 4324       active_coordinate_system = _system;
// 4325     }
// 4326   }
// 4327 
// 4328   /**
// 4329    * G54-G59.3: Select a new workspace
// 4330    *
// 4331    * A workspace is an XYZ offset to the machine native space.
// 4332    * All workspaces default to 0,0,0 at start, or with EEPROM
// 4333    * support they may be restored from a previous session.
// 4334    *
// 4335    * G92 is used to set the current workspace's offset.
// 4336    */
// 4337   inline void gcode_G54_59(uint8_t subcode=0) {
// 4338     const int8_t _space = parser.codenum - 54 + subcode;
// 4339     if (select_coordinate_system(_space)) {
// 4340       SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
// 4341       report_current_position();
// 4342     }
// 4343   }
// 4344   FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
// 4345   FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
// 4346   FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
// 4347   FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
// 4348   FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
// 4349   FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
// 4350 
// 4351 #endif
// 4352 
// 4353 #if ENABLED(INCH_MODE_SUPPORT)
// 4354   /**
// 4355    * G20: Set input mode to inches
// 4356    */
// 4357   inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
// 4358 
// 4359   /**
// 4360    * G21: Set input mode to millimeters
// 4361    */
// 4362   inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
// 4363 #endif
// 4364 
// 4365 #if ENABLED(NOZZLE_PARK_FEATURE)
// 4366   /**
// 4367    * G27: Park the nozzle
// 4368    */
// 4369   inline void gcode_G27() {
// 4370     // Don't allow nozzle parking without homing first
// 4371     if (axis_unhomed_error()) return;
// 4372     Nozzle::park(parser.ushortval('P'));
// 4373   }
// 4374 #endif // NOZZLE_PARK_FEATURE
// 4375 
// 4376 #if 1//ENABLED(QUICK_HOME)
// 4377 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function _Z13quick_home_xyv
        THUMB
// 4378   static void quick_home_xy() {
_Z13quick_home_xyv:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
// 4379 
// 4380     // Pretend the current position is 0,0
// 4381     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        LDR.W    R6,??DataTable158_1
        MOVS     R0,#+0
        STR      R0,[R6, #+12]
        STR      R0,[R6, #+8]
// 4382     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 4383 
// 4384     const int x_axis_home_dir =
// 4385       #if ENABLED(DUAL_X_CARRIAGE)
// 4386         x_home_dir(active_extruder)
// 4387       #else
// 4388         home_dir(X_AXIS)
// 4389       #endif
// 4390     ;
        MOVS     R0,#+0
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        MOV      R9,R0
// 4391 
// 4392     const float mlx = max_length(X_AXIS),
        MOVS     R0,#+0
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        MOV      R8,R0
// 4393                 mly = max_length(Y_AXIS),
        MOVS     R0,#+1
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        MOV      R7,R0
// 4394                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??quick_home_xy_0
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R10,R0
        B.N      ??quick_home_xy_1
??quick_home_xy_0:
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R10,R0
// 4395                 fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
??quick_home_xy_1:
        LDR      R11,[R6, #+44]
        LDR      R0,[R6, #+40]
        MOV      R1,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??quick_home_xy_2
        MOV      R11,R0
??quick_home_xy_2:
        MOVS     R5,#+2
        MOV      R4,#+1065353216
        B.N      ??quick_home_xy_3
??quick_home_xy_4:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??quick_home_xy_3:
        LSLS     R0,R5,#+31
        BPL.N    ??quick_home_xy_5
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??quick_home_xy_5:
        LSRS     R5,R5,#+1
        BNE.N    ??quick_home_xy_4
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable157_3  ;; 0x3ff00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall sqrt
        BL       sqrt
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
// 4396 
// 4397     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
        MOVS     R4,#+0
        LDR.W    R5,??DataTable157_4  ;; 0x3ff80000
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R9
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R0,#+1
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+4]
        ADD      R2,SP,#+0
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z22do_blocking_move_to_xyRKfS0_S0_
        BL       _Z22do_blocking_move_to_xyRKfS0_S0_
// 4398     endstops.hit_on_purpose(); // clear endstop hit flags
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 4399     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        MOVS     R0,#+0
        STR      R0,[R6, #+12]
        STR      R0,[R6, #+8]
// 4400   }
        POP      {R0-R2,R4-R11,PC}  ;; return
          CFI EndBlock cfiBlock56

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152:
        DC32     0x42700000
// 4401 
// 4402 #endif // QUICK_HOME
// 4403 
// 4404 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4405 
// 4406   void log_machine_info() {
// 4407     SERIAL_ECHOPGM("Machine Type: ");
// 4408     #if ENABLED(DELTA)
// 4409       SERIAL_ECHOLNPGM("Delta");
// 4410     #elif IS_SCARA
// 4411       SERIAL_ECHOLNPGM("SCARA");
// 4412     #elif IS_CORE
// 4413       SERIAL_ECHOLNPGM("Core");
// 4414     #else
// 4415       SERIAL_ECHOLNPGM("Cartesian");
// 4416     #endif
// 4417 
// 4418     SERIAL_ECHOPGM("Probe: ");
// 4419     #if ENABLED(PROBE_MANUALLY)
// 4420       SERIAL_ECHOLNPGM("PROBE_MANUALLY");
// 4421     #elif ENABLED(FIX_MOUNTED_PROBE)
// 4422       SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
// 4423     #elif ENABLED(BLTOUCH)
// 4424       SERIAL_ECHOLNPGM("BLTOUCH");
// 4425     #elif HAS_Z_SERVO_ENDSTOP
// 4426       SERIAL_ECHOLNPGM("SERVO PROBE");
// 4427     #elif ENABLED(Z_PROBE_SLED)
// 4428       SERIAL_ECHOLNPGM("Z_PROBE_SLED");
// 4429     #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 4430       SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
// 4431     #else
// 4432       SERIAL_ECHOLNPGM("NONE");
// 4433     #endif
// 4434 
// 4435     #if HAS_BED_PROBE
// 4436       SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
// 4437       SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
// 4438       SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
// 4439       #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4440         SERIAL_ECHOPGM(" (Right");
// 4441       #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4442         SERIAL_ECHOPGM(" (Left");
// 4443       #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4444         SERIAL_ECHOPGM(" (Middle");
// 4445       #else
// 4446         SERIAL_ECHOPGM(" (Aligned With");
// 4447       #endif
// 4448       #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4449         SERIAL_ECHOPGM("-Back");
// 4450       #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4451         SERIAL_ECHOPGM("-Front");
// 4452       #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4453         SERIAL_ECHOPGM("-Center");
// 4454       #endif
// 4455       if (zprobe_zoffset < 0)
// 4456         SERIAL_ECHOPGM(" & Below");
// 4457       else if (zprobe_zoffset > 0)
// 4458         SERIAL_ECHOPGM(" & Above");
// 4459       else
// 4460         SERIAL_ECHOPGM(" & Same Z as");
// 4461       SERIAL_ECHOLNPGM(" Nozzle)");
// 4462     #endif
// 4463 
// 4464     #if HAS_ABL
// 4465       SERIAL_ECHOPGM("Auto Bed Leveling: ");
// 4466       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4467         SERIAL_ECHOPGM("LINEAR");
// 4468       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4469         SERIAL_ECHOPGM("BILINEAR");
// 4470       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4471         SERIAL_ECHOPGM("3POINT");
// 4472       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4473         SERIAL_ECHOPGM("UBL");
// 4474       #endif
// 4475       if (planner.leveling_active) {
// 4476         SERIAL_ECHOLNPGM(" (enabled)");
// 4477         #if ABL_PLANAR
// 4478           const float diff[XYZ] = {
// 4479             stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
// 4480             stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
// 4481             stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
// 4482           };
// 4483           SERIAL_ECHOPGM("ABL Adjustment X");
// 4484           if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
// 4485           SERIAL_ECHO(diff[X_AXIS]);
// 4486           SERIAL_ECHOPGM(" Y");
// 4487           if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
// 4488           SERIAL_ECHO(diff[Y_AXIS]);
// 4489           SERIAL_ECHOPGM(" Z");
// 4490           if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
// 4491           SERIAL_ECHO(diff[Z_AXIS]);
// 4492         #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4493           SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
// 4494         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4495           SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
// 4496         #endif
// 4497       }
// 4498       else
// 4499         SERIAL_ECHOLNPGM(" (disabled)");
// 4500 
// 4501       SERIAL_EOL();
// 4502 
// 4503     #elif ENABLED(MESH_BED_LEVELING)
// 4504 
// 4505       SERIAL_ECHOPGM("Mesh Bed Leveling");
// 4506       if (planner.leveling_active) {
// 4507         float rz = current_position[Z_AXIS];
// 4508         planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
// 4509         SERIAL_ECHOLNPGM(" (enabled)");
// 4510         SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
// 4511       }
// 4512       else
// 4513         SERIAL_ECHOPGM(" (disabled)");
// 4514 
// 4515       SERIAL_EOL();
// 4516 
// 4517     #endif // MESH_BED_LEVELING
// 4518   }
// 4519 
// 4520 #endif // DEBUG_LEVELING_FEATURE
// 4521 
// 4522 #if 1//ENABLED(DELTA)
// 4523 
// 4524   /**
// 4525    * A delta can only safely home all axes at the same time
// 4526    * This is like quick_home_xy() but for 3 towers.
// 4527    */
// 4528   inline bool home_delta() {
// 4529     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4530       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
// 4531     #endif
// 4532     // Init the current position of all carriages to 0,0,0
// 4533     ZERO(current_position);
// 4534     sync_plan_position();
// 4535 
// 4536     // Move all carriages together linearly until an endstop is hit.
// 4537     current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
// 4538     feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
// 4539     buffer_line_to_current_position();
// 4540     stepper.synchronize();
// 4541 
// 4542     // If an endstop was not hit, then damage can occur if homing is continued.
// 4543     // This can occur if the delta height not set correctly.
// 4544     if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
// 4545       LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
// 4546       SERIAL_ERROR_START();
// 4547       SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
// 4548       return false;
// 4549     }
// 4550 
// 4551     endstops.hit_on_purpose(); // clear endstop hit flags
// 4552 
// 4553     // At least one carriage has reached the top.
// 4554     // Now re-home each carriage separately.
// 4555     HOMEAXIS(A);
// 4556     HOMEAXIS(B);
// 4557     HOMEAXIS(C);
// 4558 
// 4559     // Set all carriages to their home positions
// 4560     // Do this here all at once for Delta, because
// 4561     // XYZ isn't ABC. Applying this per-tower would
// 4562     // give the impression that they are the same.
// 4563     LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
// 4564 
// 4565     SYNC_PLAN_POSITION_KINEMATIC();
// 4566 
// 4567     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4568       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
// 4569     #endif
// 4570 
// 4571     return true;
// 4572   }
// 4573 
// 4574 #endif // DELTA
// 4575 
// 4576 #if ENABLED(Z_SAFE_HOMING)
// 4577 
// 4578   inline void home_z_safely() {
// 4579 
// 4580     // Disallow Z homing if X or Y are unknown
// 4581     if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
// 4582       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
// 4583       SERIAL_ECHO_START();
// 4584       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
// 4585       return;
// 4586     }
// 4587 
// 4588     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4589       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
// 4590     #endif
// 4591 
// 4592     SYNC_PLAN_POSITION_KINEMATIC();
// 4593 
// 4594     /**
// 4595      * Move the Z probe (or just the nozzle) to the safe homing point
// 4596      */
// 4597     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
// 4598     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
// 4599     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
// 4600 
// 4601     #if HOMING_Z_WITH_PROBE
// 4602     if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))  /*--mks cfg--*/
// 4603     {      
// 4604         destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 4605         destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 4606     }
// 4607     #endif
// 4608 if(MACHINETPYE & IS_KINEMATIC)
// 4609 {
// 4610     if (position_is_reachable_IS_KINEMATIC(destination[X_AXIS], destination[Y_AXIS])) {
// 4611 
// 4612       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4613         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4614       #endif
// 4615 
// 4616       // This causes the carriage on Dual X to unpark
// 4617       #if ENABLED(DUAL_X_CARRIAGE)
// 4618         active_extruder_parked = false;
// 4619       #endif
// 4620 
// 4621       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4622       HOMEAXIS(Z);
// 4623     }
// 4624     else {
// 4625       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4626       SERIAL_ECHO_START();
// 4627       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4628     }
// 4629 }
// 4630 else
// 4631 {
// 4632     if (position_is_reachable_IS_CARTESIAN(destination[X_AXIS], destination[Y_AXIS])) {
// 4633 
// 4634       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4635         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4636       #endif
// 4637 
// 4638       // This causes the carriage on Dual X to unpark
// 4639       #if ENABLED(DUAL_X_CARRIAGE)
// 4640         active_extruder_parked = false;
// 4641       #endif
// 4642 
// 4643       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4644       HOMEAXIS(Z);
// 4645     }
// 4646     else {
// 4647       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4648       SERIAL_ECHO_START();
// 4649       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4650     }    
// 4651 }
// 4652     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4653       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
// 4654     #endif
// 4655   }
// 4656 
// 4657 #endif // Z_SAFE_HOMING
// 4658 
// 4659 #if ENABLED(PROBE_MANUALLY)
// 4660   bool g29_in_progress = false;
// 4661 #else
// 4662   constexpr bool g29_in_progress = false;
// 4663 #endif
// 4664 
// 4665 /**
// 4666  * G28: Home all axes according to settings
// 4667  *
// 4668  * Parameters
// 4669  *
// 4670  *  None  Home to all axes with no parameters.
// 4671  *        With QUICK_HOME enabled XY will home together, then Z.
// 4672  *
// 4673  * Cartesian parameters
// 4674  *
// 4675  *  X   Home to the X endstop
// 4676  *  Y   Home to the Y endstop
// 4677  *  Z   Home to the Z endstop
// 4678  *
// 4679  */
// 4680 inline void gcode_G28(const bool always_home_all) {
// 4681 
// 4682   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4683     if (DEBUGGING(LEVELING)) {
// 4684       SERIAL_ECHOLNPGM(">>> gcode_G28");
// 4685       log_machine_info();
// 4686     }
// 4687   #endif
// 4688 
// 4689   // Wait for planner moves to finish!
// 4690   stepper.synchronize();
// 4691 
// 4692   // Cancel the active G29 session
// 4693   #if ENABLED(PROBE_MANUALLY)
// 4694     g29_in_progress = false;
// 4695   #endif
// 4696 
// 4697   // Disable the leveling matrix before homing
// 4698   //#if HAS_LEVELING
// 4699   	//const 
// 4700   	bool ubl_state_at_entry;
// 4701     //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4702     if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4703     {
// 4704     	ubl_state_at_entry = planner.leveling_active;
// 4705     }
// 4706     //#endif
// 4707     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 4708     {
// 4709     	set_bed_leveling_enabled(false);
// 4710     }
// 4711   //#endif
// 4712 
// 4713   #if ENABLED(CNC_WORKSPACE_PLANES)
// 4714     workspace_plane = PLANE_XY;
// 4715   #endif
// 4716 
// 4717   // Always home with tool 0 active
// 4718   #if HOTENDS > 1
// 4719     const uint8_t old_tool_index = active_extruder;
// 4720     tool_change(0, 0, true);
// 4721   #endif
// 4722 
// 4723   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 4724     extruder_duplication_enabled = false;
// 4725   #endif
// 4726 
// 4727   setup_for_endstop_or_probe_move();
// 4728   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4729     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
// 4730   #endif
// 4731   endstops.enable(true); // Enable endstops for next homing move
// 4732 
// 4733   //#if ENABLED(DELTA)
// 4734   if(MACHINETPYE == DELTA)
// 4735   {
// 4736     home_delta();
// 4737     UNUSED(always_home_all);
// 4738   }
// 4739   //#else // NOT DELTA
// 4740   else
// 4741   {
// 4742     const bool homeX = always_home_all || parser.seen('X'),
// 4743                homeY = always_home_all || parser.seen('Y'),
// 4744                homeZ = always_home_all || parser.seen('Z'),
// 4745                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
// 4746 
// 4747     set_destination_from_current();
// 4748 
// 4749     //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
// 4750 	if(Z_HOME_DIR > 0)
// 4751 	{
// 4752       if (home_all || homeZ) {
// 4753         HOMEAXIS(Z);
// 4754         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4755           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
// 4756         #endif
// 4757       }
// 4758 	}
// 4759     //#endif
// 4760 
// 4761     if ((home_all || homeX || homeY) 
// 4762         #if 1
// 4763 		&& ((mksReprint.mks_printer_state != MKS_REPRINTING)
// 4764 	  	||(mksReprint.mks_printer_state != MKS_REPRINTED))
// 4765 	  	#endif
// 4766         )
// 4767       {
// 4768       // Raise Z before homing any other axes and z is not already high enough (never lower z)
// 4769       destination[Z_AXIS] = Z_HOMING_HEIGHT;
// 4770       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
// 4771 
// 4772         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4773           if (DEBUGGING(LEVELING))
// 4774             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
// 4775         #endif
// 4776 
// 4777         do_blocking_move_to_z(destination[Z_AXIS]);
// 4778       }
// 4779     }
// 4780 
// 4781     //#if ENABLED(QUICK_HOME)
// 4782 	if(MACHINETPYE&IS_SCARA)
// 4783 	{
// 4784       if (home_all || (homeX && homeY)) quick_home_xy();
// 4785 	}
// 4786     //#endif
// 4787 
// 4788     //#if ENABLED(HOME_Y_BEFORE_X)
// 4789 	if(MACHINETPYE&IS_SCARA)
// 4790 	{
// 4791       // Home Y
// 4792       if (home_all || homeY) {
// 4793         HOMEAXIS(Y);
// 4794         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4795           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4796         #endif
// 4797       }
// 4798 	}
// 4799     //#endif
// 4800 
// 4801     // Home X
// 4802     if (home_all || homeX) {
// 4803 
// 4804       #if ENABLED(DUAL_X_CARRIAGE)
// 4805 
// 4806         // Always home the 2nd (right) extruder first
// 4807         active_extruder = 1;
// 4808         HOMEAXIS(X);
// 4809 
// 4810         // Remember this extruder's position for later tool change
// 4811         inactive_extruder_x_pos = current_position[X_AXIS];
// 4812 
// 4813         // Home the 1st (left) extruder
// 4814         active_extruder = 0;
// 4815         HOMEAXIS(X);
// 4816 
// 4817         // Consider the active extruder to be parked
// 4818         COPY(raised_parked_position, current_position);
// 4819         delayed_move_time = 0;
// 4820         active_extruder_parked = true;
// 4821 
// 4822       #else
// 4823 
// 4824         HOMEAXIS(X);
// 4825 
// 4826       #endif
// 4827 
// 4828       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4829         if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
// 4830       #endif
// 4831     }
// 4832 
// 4833     //#if DISABLED(HOME_Y_BEFORE_X)
// 4834 	if(!HOME_Y_BEFORE_X)
// 4835 	{
// 4836       // Home Y
// 4837       if (home_all || homeY) {
// 4838         HOMEAXIS(Y);
// 4839         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4840           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4841         #endif
// 4842       }
// 4843 	}
// 4844     //#endif
// 4845 
// 4846     // Home Z last if homing towards the bed
// 4847     //#if Z_HOME_DIR < 0
// 4848     if(Z_HOME_DIR < 0)
// 4849     {
// 4850       if (home_all || homeZ) {
// 4851         #if ENABLED(Z_SAFE_HOMING)
// 4852           home_z_safely();
// 4853         #else
// 4854           HOMEAXIS(Z);
// 4855         #endif
// 4856         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4857           if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
// 4858         #endif
// 4859       } // home_all || homeZ
// 4860     }
// 4861     //#endif // Z_HOME_DIR < 0
// 4862 
// 4863     SYNC_PLAN_POSITION_KINEMATIC();
// 4864 
// 4865 	//if(home_all)
// 4866 	  //{
// 4867 	  	//Z÷·…œ…˝
// 4868 		//mks_home_moveZ(5);
// 4869 	      //“∆∂ØX,Y
// 4870 		//mks_home_moveXY(mksReprint.mks_zero_x,mksReprint.mks_zero_y,mksCfg.homing_feedrate_xy);
// 4871 		  //mks_home_moveZ(0);
// 4872 		  //SYNC_PLAN_POSITION_KINEMATIC();
// 4873 	  //}
// 4874 }
// 4875   //#endif // !DELTA (gcode_G28)
// 4876 
// 4877   endstops.not_homing();
// 4878 
// 4879   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 4880     // move to a height where we can use the full xy-area
// 4881     do_blocking_move_to_z(delta_clip_start_height);
// 4882   #endif
// 4883 
// 4884   //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4885   if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4886     set_bed_leveling_enabled(ubl_state_at_entry);
// 4887   //#endif
// 4888 
// 4889   clean_up_after_endstop_or_probe_move();
// 4890 
// 4891   // Restore the active tool after homing
// 4892   #if HOTENDS > 1
// 4893     #if ENABLED(PARKING_EXTRUDER)
// 4894       #define NO_FETCH false // fetch the previous toolhead
// 4895     #else
// 4896       #define NO_FETCH true
// 4897     #endif
// 4898     tool_change(old_tool_index, 0, NO_FETCH);
// 4899   #endif
// 4900 
// 4901   lcd_refresh();
// 4902 
// 4903   report_current_position();
// 4904 
// 4905   #if ENABLED(NANODLP_Z_SYNC)
// 4906     #if ENABLED(NANODLP_ALL_AXIS)
// 4907       #define _HOME_SYNC true                 // For any axis, output sync text.
// 4908     #else
// 4909       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
// 4910     #endif
// 4911     if (_HOME_SYNC)
// 4912       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4913   #endif
// 4914 
// 4915   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4916     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
// 4917   #endif
// 4918 
// 4919   
// 4920 } // G28
// 4921 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function _Z13home_all_axesv
        THUMB
// 4922 void home_all_axes() { gcode_G28(true); }
_Z13home_all_axesv:
        MOVS     R0,#+1
          CFI FunCall _Z9gcode_G28b
        B.W      _Z9gcode_G28b
          CFI EndBlock cfiBlock57
// 4923 
// 4924 #if HAS_PROBING_PROCEDURE
// 4925 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function _Z18out_of_range_errorPKc
        THUMB
// 4926   void out_of_range_error(const char* p_edge) {
_Z18out_of_range_errorPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 4927     SERIAL_PROTOCOLPGM("?Probe ");
        ADR.W    R0,`?<Constant "?Probe ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4928     serialprintPGM(p_edge);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4929     SERIAL_PROTOCOLLNPGM(" position out of range.");
        ADR.W    R0,`?<Constant " position out of range.\\n">`
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI EndBlock cfiBlock58
// 4930   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "?Probe ">`:
        DC8 "?Probe "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " position out of range.\\n">`:
        DC8 " position out of range.\012"
        DC8 0, 0, 0
// 4931 
// 4932 #endif
// 4933 
// 4934 #if 1//ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
// 4935 
// 4936   #if ENABLED(LCD_BED_LEVELING)
// 4937     //extern 
// 4938     bool lcd_wait_for_move;
// 4939   #else
// 4940     constexpr bool lcd_wait_for_move = false;
// 4941   #endif
// 4942 
// 4943   inline void _manual_goto_xy(const float &rx, const float &ry) {
// 4944 
// 4945     //#if MANUAL_PROBE_HEIGHT > 0
// 4946     if(MANUAL_PROBE_HEIGHT > 0)
// 4947     {
// 4948       const float prev_z = current_position[Z_AXIS];
// 4949       do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
// 4950       do_blocking_move_to_z(prev_z);
// 4951     }
// 4952     //#else
// 4953     else
// 4954     {
// 4955       do_blocking_move_to_xy(rx, ry);
// 4956     }
// 4957     //#endif
// 4958 
// 4959     current_position[X_AXIS] = rx;
// 4960     current_position[Y_AXIS] = ry;
// 4961 
// 4962     #if ENABLED(LCD_BED_LEVELING)
// 4963       lcd_wait_for_move = false;
// 4964     #endif
// 4965   }
// 4966 
// 4967 #endif
// 4968 
// 4969 #if 1//ENABLED(MESH_BED_LEVELING)
// 4970 
// 4971   // Save 130 bytes with non-duplication of PSTR

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function _Z16echo_not_enteredv
        THUMB
// 4972   void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
_Z16echo_not_enteredv:
        ADR.W    R0,`?<Constant " not entered.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI EndBlock cfiBlock59

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " not entered.\\n">`:
        DC8 " not entered.\012"
        DC8 0
// 4973 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function _Z15mbl_mesh_reportv
        THUMB
// 4974   void mbl_mesh_report() {
_Z15mbl_mesh_reportv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
// 4975     //SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
// 4976     SERIAL_PROTOCOLPGM("Num X,Y: ");
        ADR.W    R0,`?<Constant "Num X,Y: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4977     SERIAL_PROTOCOL((int)GRID_MAX_POINTS_X);
        LDR.N    R4,??DataTable156_2
        LDR.W    R5,??DataTable160
        MOVS     R2,#+10
        LDRB     R1,[R5, #+96]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 4978     SERIAL_PROTOCOLCHAR(',');
        MOVS     R1,#+44
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 4979     SERIAL_PROTOCOL((int)GRID_MAX_POINTS_Y);
        ADD      R6,R5,#+96
        MOVS     R2,#+10
        LDRB     R1,[R6, #+1]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 4980     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 4981     SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
        ADR.W    R0,`?<Constant "Z offset: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        LDR.W    R0,??DataTable161
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 4982     SERIAL_PROTOCOLLNPGM("\nMeasured points:");
        ADR.W    R0,`?<Constant "\\nMeasured points:\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4983 	/*
// 4984     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
// 4985       [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
// 4986     );
// 4987     */
// 4988     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,2);
        MOVS     R3,#+2
        MOVS     R2,#+5
        LDRB     R1,[R6, #+1]
        LDRB     R0,[R5, #+96]
        ADD      SP,SP,#+8
          CFI CFA R13+16
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14print_2d_arrayhhhh
        B.W      _Z14print_2d_arrayhhhh
          CFI EndBlock cfiBlock60
// 4989   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153:
        DC32     _ZN17mesh_bed_leveling8has_meshE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153_1:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Num X,Y: ">`:
        DC8 "Num X,Y: "
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Z offset: ">`:
        DC8 "Z offset: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "\\nMeasured points:\\n">`:
        DC8 "\012Measured points:\012"
        DC8 0
// 4990 
// 4991   /**
// 4992    * G29: Mesh-based Z probe, probes a grid and produces a
// 4993    *      mesh to compensate for variable bed height
// 4994    *
// 4995    * Parameters With MESH_BED_LEVELING:
// 4996    *
// 4997    *  S0              Produce a mesh report
// 4998    *  S1              Start probing mesh points
// 4999    *  S2              Probe the next mesh point
// 5000    *  S3 Xn Yn Zn.nn  Manually modify a single point
// 5001    *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
// 5002    *  S5              Reset and disable mesh
// 5003    *
// 5004    * The S0 report the points as below
// 5005    *
// 5006    *  +----> X-axis  1-n
// 5007    *  |
// 5008    *  |
// 5009    *  v Y-axis  1-n
// 5010    *
// 5011    */
// 5012 //  inline void gcode_G29() {
// 5013 inline void gcode_G29_MESH_BED_LEVELING() {
// 5014 
// 5015     static int mbl_probe_index = -1;
// 5016     #if HAS_SOFTWARE_ENDSTOPS
// 5017       static bool enable_soft_endstops;
// 5018     #endif
// 5019 
// 5020     const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
// 5021     if (!WITHIN(state, 0, 5)) {
// 5022       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
// 5023       return;
// 5024     }
// 5025 
// 5026     int8_t px, py;
// 5027 
// 5028     switch (state) {
// 5029       case MeshReport:
// 5030         if (leveling_is_valid()) {
// 5031           SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
// 5032           mbl_mesh_report();
// 5033         }
// 5034         else
// 5035           SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
// 5036         break;
// 5037 
// 5038       case MeshStart:
// 5039         mbl.reset();
// 5040         mbl_probe_index = 0;
// 5041         enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
// 5042         break;
// 5043 
// 5044       case MeshNext:
// 5045         if (mbl_probe_index < 0) {
// 5046           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
// 5047           return;
// 5048         }
// 5049         // For each G29 S2...
// 5050         if (mbl_probe_index == 0) {
// 5051           #if HAS_SOFTWARE_ENDSTOPS
// 5052             // For the initial G29 S2 save software endstop state
// 5053             enable_soft_endstops = soft_endstops_enabled;
// 5054           #endif
// 5055         }
// 5056         else {
// 5057           // For G29 S2 after adjusting Z.
// 5058           mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
// 5059           #if HAS_SOFTWARE_ENDSTOPS
// 5060             soft_endstops_enabled = enable_soft_endstops;
// 5061           #endif
// 5062         }
// 5063         // If there's another point to sample, move there with optional lift.
// 5064         if (mbl_probe_index < GRID_MAX_POINTS) {
// 5065           mbl.zigzag(mbl_probe_index, px, py);
// 5066           _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
// 5067 
// 5068           #if HAS_SOFTWARE_ENDSTOPS
// 5069             // Disable software endstops to allow manual adjustment
// 5070             // If G29 is not completed, they will not be re-enabled
// 5071             soft_endstops_enabled = false;
// 5072           #endif
// 5073 
// 5074           mbl_probe_index++;
// 5075         }
// 5076         else {
// 5077           // One last "return to the bed" (as originally coded) at completion
// 5078           current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
// 5079           buffer_line_to_current_position();
// 5080           stepper.synchronize();
// 5081 
// 5082           // After recording the last point, activate home and activate
// 5083           mbl_probe_index = -1;
// 5084           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
// 5085           BUZZ(100, 659);
// 5086           BUZZ(100, 698);
// 5087           mbl.has_mesh = true;
// 5088 
// 5089           home_all_axes();
// 5090           set_bed_leveling_enabled(true);
// 5091 
// 5092           #if ENABLED(MESH_G28_REST_ORIGIN)
// 5093             current_position[Z_AXIS] = Z_MIN_POS;
// 5094             set_destination_from_current();
// 5095             buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
// 5096             stepper.synchronize();
// 5097           #endif
// 5098 
// 5099           #if ENABLED(LCD_BED_LEVELING)
// 5100             lcd_wait_for_move = false;
// 5101           #endif
// 5102         }
// 5103         break;
// 5104 
// 5105       case MeshSet:
// 5106         if (parser.seenval('X')) {
// 5107           px = parser.value_int() - 1;
// 5108           if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
// 5109             SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
// 5110             return;
// 5111           }
// 5112         }
// 5113         else {
// 5114           SERIAL_CHAR('X'); echo_not_entered();
// 5115           return;
// 5116         }
// 5117 
// 5118         if (parser.seenval('Y')) {
// 5119           py = parser.value_int() - 1;
// 5120           if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
// 5121             SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
// 5122             return;
// 5123           }
// 5124         }
// 5125         else {
// 5126           SERIAL_CHAR('Y'); echo_not_entered();
// 5127           return;
// 5128         }
// 5129 
// 5130         if (parser.seenval('Z'))
// 5131           mbl.z_values[px][py] = parser.value_linear_units();
// 5132         else {
// 5133           SERIAL_CHAR('Z'); echo_not_entered();
// 5134           return;
// 5135         }
// 5136         break;
// 5137 
// 5138       case MeshSetZOffset:
// 5139         if (parser.seenval('Z'))
// 5140           mbl.z_offset = parser.value_linear_units();
// 5141         else {
// 5142           SERIAL_CHAR('Z'); echo_not_entered();
// 5143           return;
// 5144         }
// 5145         break;
// 5146 
// 5147       case MeshReset:
// 5148         reset_bed_level();
// 5149         break;
// 5150 
// 5151     } // switch(state)
// 5152 
// 5153     if (state == MeshStart || state == MeshNext) {
// 5154       SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
// 5155       SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
// 5156     }
// 5157 
// 5158     report_current_position();
// 5159   }
// 5160 #endif
// 5161 //#if 1
// 5162 //#elif OLDSCHOOL_ABL
// 5163 
// 5164   #if 1//ABL_GRID
// 5165     #if ENABLED(PROBE_Y_FIRST)
// 5166       #define PR_OUTER_VAR xCount
// 5167       #define PR_OUTER_END abl_grid_points_x
// 5168       #define PR_INNER_VAR yCount
// 5169       #define PR_INNER_END abl_grid_points_y
// 5170     #else
// 5171       #define PR_OUTER_VAR yCount
// 5172       #define PR_OUTER_END abl_grid_points_y
// 5173       #define PR_INNER_VAR xCount
// 5174       #define PR_INNER_END abl_grid_points_x
// 5175     #endif
// 5176   #endif
// 5177 
// 5178   /**
// 5179    * G29: Detailed Z probe, probes the bed at 3 or more points.
// 5180    *      Will fail if the printer has not been homed with G28.
// 5181    *
// 5182    * Enhanced G29 Auto Bed Leveling Probe Routine
// 5183    *
// 5184    *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
// 5185    *     or alter the bed level data. Useful to check the topology
// 5186    *     after a first run of G29.
// 5187    *
// 5188    *  J  Jettison current bed leveling data
// 5189    *
// 5190    *  V  Set the verbose level (0-4). Example: "G29 V3"
// 5191    *
// 5192    * Parameters With LINEAR leveling only:
// 5193    *
// 5194    *  P  Set the size of the grid that will be probed (P x P points).
// 5195    *     Example: "G29 P4"
// 5196    *
// 5197    *  X  Set the X size of the grid that will be probed (X x Y points).
// 5198    *     Example: "G29 X7 Y5"
// 5199    *
// 5200    *  Y  Set the Y size of the grid that will be probed (X x Y points).
// 5201    *
// 5202    *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
// 5203    *     This is useful for manual bed leveling and finding flaws in the bed (to
// 5204    *     assist with part placement).
// 5205    *     Not supported by non-linear delta printer bed leveling.
// 5206    *
// 5207    * Parameters With LINEAR and BILINEAR leveling only:
// 5208    *
// 5209    *  S  Set the XY travel speed between probe points (in units/min)
// 5210    *
// 5211    *  F  Set the Front limit of the probing grid
// 5212    *  B  Set the Back limit of the probing grid
// 5213    *  L  Set the Left limit of the probing grid
// 5214    *  R  Set the Right limit of the probing grid
// 5215    *
// 5216    * Parameters with DEBUG_LEVELING_FEATURE only:
// 5217    *
// 5218    *  C  Make a totally fake grid with no actual probing.
// 5219    *     For use in testing when no probing is possible.
// 5220    *
// 5221    * Parameters with BILINEAR leveling only:
// 5222    *
// 5223    *  Z  Supply an additional Z probe offset
// 5224    *
// 5225    * Extra parameters with PROBE_MANUALLY:
// 5226    *
// 5227    *  To do manual probing simply repeat G29 until the procedure is complete.
// 5228    *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
// 5229    *
// 5230    *  Q  Query leveling and G29 state
// 5231    *
// 5232    *  A  Abort current leveling procedure
// 5233    *
// 5234    * Extra parameters with BILINEAR only:
// 5235    *
// 5236    *  W  Write a mesh point. (If G29 is idle.)
// 5237    *  I  X index for mesh point
// 5238    *  J  Y index for mesh point
// 5239    *  X  X for mesh point, overrides I
// 5240    *  Y  Y for mesh point, overrides J
// 5241    *  Z  Z for mesh point. Otherwise, raw current Z.
// 5242    *
// 5243    * Without PROBE_MANUALLY:
// 5244    *
// 5245    *  E  By default G29 will engage the Z probe, test the bed, then disengage.
// 5246    *     Include "E" to engage/disengage the Z probe for each sample.
// 5247    *     There's no extra effect if you have a fixed Z probe.
// 5248    *
// 5249    */
// 5250   inline void gcode_G29() {
// 5251 
// 5252     // G29 Q is also available if debugging
// 5253     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5254       const bool query = parser.seen('Q');
// 5255       const uint8_t old_debug_flags = marlin_debug_flags;
// 5256       if (query) marlin_debug_flags |= DEBUG_LEVELING;
// 5257       if (DEBUGGING(LEVELING)) {
// 5258         DEBUG_POS(">>> G29", current_position);
// 5259         log_machine_info();
// 5260       }
// 5261       marlin_debug_flags = old_debug_flags;
// 5262       #if DISABLED(PROBE_MANUALLY)
// 5263         if (query) return;
// 5264       #endif
// 5265     #endif
// 5266 
// 5267     #if ENABLED(PROBE_MANUALLY)
// 5268       const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
// 5269     #endif
// 5270 
// 5271     #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
// 5272       const bool faux = parser.boolval('C');
// 5273     #elif ENABLED(PROBE_MANUALLY)
// 5274       const bool faux = no_action;
// 5275     #else
// 5276       bool constexpr faux = false;
// 5277     #endif
// 5278 
// 5279     // Don't allow auto-leveling without homing first
// 5280     if (axis_unhomed_error()) return;
// 5281 
// 5282     // Define local vars 'static' for manual probing, 'auto' otherwise
// 5283     #if ENABLED(PROBE_MANUALLY)
// 5284       #define ABL_VAR static
// 5285     #else
// 5286       #define ABL_VAR
// 5287     #endif
// 5288 
// 5289     ABL_VAR int verbose_level=0;
// 5290     ABL_VAR float xProbe=0, yProbe=0, measured_z=0;
// 5291     ABL_VAR bool dryrun=false, abl_should_enable=false;
// 5292 
// 5293     //#if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5294       ABL_VAR int abl_probe_index=0;
// 5295     //#endif
// 5296 
// 5297     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
// 5298       ABL_VAR bool enable_soft_endstops = true;
// 5299     #endif
// 5300 
// 5301     #if 1//ABL_GRID
// 5302 
// 5303       #if ENABLED(PROBE_MANUALLY)
// 5304         ABL_VAR uint8_t PR_OUTER_VAR;
// 5305         ABL_VAR  int8_t PR_INNER_VAR;
// 5306       #endif
// 5307 
// 5308       ABL_VAR int left_probe_bed_position=0, right_probe_bed_position=0, front_probe_bed_position=0, back_probe_bed_position=0;
// 5309       ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
// 5310 
// 5311       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5312         ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
// 5313                         abl_grid_points_y = GRID_MAX_POINTS_Y;
// 5314         ABL_VAR bool do_topography_map=0;
// 5315       //#else // Bilinear
// 5316       //  uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
// 5317       //                    abl_grid_points_y = GRID_MAX_POINTS_Y;
// 5318       //#endif
// 5319 
// 5320       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5321         ABL_VAR int abl2;
// 5322       //#elif ENABLED(PROBE_MANUALLY) // Bilinear
// 5323       //  int constexpr abl2 = GRID_MAX_POINTS;
// 5324       //#endif
// 5325       if(! (BED_LEVELING_METHOD&ABL_PLANAR)) abl2 = GRID_MAX_POINTS;
// 5326 
// 5327       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5328 
// 5329         ABL_VAR float zoffset;
// 5330 
// 5331       //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5332 
// 5333         ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
// 5334 
// 5335         ABL_VAR float *eqnAMatrix=NULL,//[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
// 5336                       *eqnBVector=NULL,//[GRID_MAX_POINTS],     // "B" vector of Z points
// 5337                       mean;
// 5338 		eqnAMatrix = (float *)malloc((GRID_MAX_POINTS * 3 + 1) * sizeof(float));
// 5339 		if(eqnAMatrix == NULL)
// 5340 			{
// 5341 			Running = false;
// 5342 			kill("malloc eqnAMatrix err!");
// 5343 			}
// 5344 		for(int i=0;i<GRID_MAX_POINTS * 3 + 1;i++)
// 5345             *(eqnAMatrix+i) = 0.0;
// 5346 
// 5347 		
// 5348 		eqnBVector = (float *)malloc((GRID_MAX_POINTS + 1) * sizeof(float));
// 5349 		if(eqnBVector == NULL)
// 5350 		{
// 5351 			Running = false;
// 5352 			kill("malloc eqnBVector err!");
// 5353 		}
// 5354 		for(int i=0;i<GRID_MAX_POINTS + 1;i++) 	*(eqnBVector+i) = 0.0;        
// 5355       //#endif
// 5356 
// 5357    // #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5358 
// 5359       #if ENABLED(PROBE_MANUALLY)
// 5360         int constexpr abl2 = 3; // used to show total points
// 5361       #endif
// 5362 
// 5363       // Probe at 3 arbitrary points
// 5364       ABL_VAR vector_3 points[3] = {
// 5365         vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
// 5366         vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
// 5367         vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
// 5368       };
// 5369 
// 5370    // #endif // AUTO_BED_LEVELING_3POINT
// 5371 
// 5372     //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5373     struct linear_fit_data lsf_results;
// 5374     if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_LINEAR)
// 5375     {
// 5376       incremental_LSF_reset(&lsf_results);
// 5377     }
// 5378     //#endif
// 5379 
// 5380     /**
// 5381      * On the initial G29 fetch command parameters.
// 5382      */
// 5383     if (!g29_in_progress) {
// 5384 #if 0
// 5385       #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5386         abl_probe_index = -1;
// 5387       #endif
// 5388 #else
// 5389       if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5390          abl_probe_index = -1;
// 5391 #endif
// 5392       abl_should_enable = planner.leveling_active;
// 5393 
// 5394       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5395       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 5396 
// 5397         if (parser.seen('W')) {
// 5398           if (!leveling_is_valid()) {
// 5399             SERIAL_ERROR_START();
// 5400             SERIAL_ERRORLNPGM("No bilinear grid");
// 5401             return;
// 5402           }
// 5403 
// 5404           const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
// 5405           if (!WITHIN(rz, -10, 10)) {
// 5406             SERIAL_ERROR_START();
// 5407             SERIAL_ERRORLNPGM("Bad Z value");
// 5408             return;
// 5409           }
// 5410 
// 5411           const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
// 5412                       ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
// 5413           int8_t i = parser.byteval('I', -1),
// 5414                  j = parser.byteval('J', -1);
// 5415 
// 5416           if (!isnan(rx) && !isnan(ry)) {
// 5417             // Get nearest i / j from rx / ry
// 5418             i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
// 5419             j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
// 5420             i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
// 5421             j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
// 5422           }
// 5423           if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
// 5424             set_bed_leveling_enabled(false);
// 5425             z_values[i][j] = rz;
// 5426             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5427               bed_level_virt_interpolate();
// 5428             #endif
// 5429             set_bed_leveling_enabled(abl_should_enable);
// 5430             if (abl_should_enable) report_current_position();
// 5431           }
// 5432           return;
// 5433         } // parser.seen('W')
// 5434       }
// 5435       //#endif
// 5436 
// 5437       // Jettison bed leveling data
// 5438       if (parser.seen('J')) {
// 5439         reset_bed_level();
// 5440         return;
// 5441       }
// 5442 
// 5443       verbose_level = parser.intval('V');
// 5444       if (!WITHIN(verbose_level, 0, 4)) {
// 5445         SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 5446         return;
// 5447       }
// 5448 
// 5449       dryrun = parser.boolval('D')
// 5450         #if ENABLED(PROBE_MANUALLY)
// 5451           || no_action
// 5452         #endif
// 5453       ;
// 5454 
// 5455       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5456       if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5457         {
// 5458         do_topography_map = verbose_level > 2 || parser.boolval('T');
// 5459 
// 5460         // X and Y specify points in each direction, overriding the default
// 5461         // These values may be saved with the completed mesh
// 5462         abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
// 5463         abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
// 5464         if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
// 5465 
// 5466         if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
// 5467           SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
// 5468           return;
// 5469         }
// 5470 
// 5471         abl2 = abl_grid_points_x * abl_grid_points_y;
// 5472         mean = 0;
// 5473         }
// 5474       //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5475       else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 5476       {
// 5477         zoffset = parser.linearval('Z');
// 5478       }
// 5479 
// 5480       //#endif
// 5481 
// 5482       //#if ABL_GRID
// 5483       if(BED_LEVELING_METHOD&ABL_GRID)  {
// 5484 
// 5485         xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
// 5486 
// 5487         left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
// 5488         right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
// 5489         front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
// 5490         back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
// 5491 
// 5492         const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
// 5493                    left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
// 5494                    right_out_r = right_probe_bed_position > MAX_PROBE_X,
// 5495                    right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
// 5496                    front_out_f = front_probe_bed_position < MIN_PROBE_Y,
// 5497                    front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
// 5498                    back_out_b = back_probe_bed_position > MAX_PROBE_Y,
// 5499                    back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
// 5500 
// 5501         if (left_out || right_out || front_out || back_out) {
// 5502           if (left_out) {
// 5503             out_of_range_error(PSTR("(L)eft"));
// 5504             left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
// 5505           }
// 5506           if (right_out) {
// 5507             out_of_range_error(PSTR("(R)ight"));
// 5508             right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
// 5509           }
// 5510           if (front_out) {
// 5511             out_of_range_error(PSTR("(F)ront"));
// 5512             front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
// 5513           }
// 5514           if (back_out) {
// 5515             out_of_range_error(PSTR("(B)ack"));
// 5516             back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
// 5517           }
// 5518           return;
// 5519         }
// 5520 
// 5521         // probe at the points of a lattice grid
// 5522         xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
// 5523         yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
// 5524       }
// 5525       //#endif // ABL_GRID
// 5526 
// 5527       if (verbose_level > 0) {
// 5528         SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
// 5529         if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
// 5530         SERIAL_EOL();
// 5531       }
// 5532 
// 5533       stepper.synchronize();
// 5534 
// 5535       // Disable auto bed leveling during G29.
// 5536       // Be formal so G29 can be done successively without G28.
// 5537       set_bed_leveling_enabled(false);
// 5538 
// 5539       #if HAS_BED_PROBE
// 5540         // Deploy the probe. Probe will raise if needed.
// 5541         if (DEPLOY_PROBE()) {
// 5542           set_bed_leveling_enabled(abl_should_enable);
// 5543           return;
// 5544         }
// 5545       #endif
// 5546 
// 5547       if (!faux) setup_for_endstop_or_probe_move();
// 5548 
// 5549       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5550       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5551       {
// 5552         #if ENABLED(PROBE_MANUALLY)
// 5553           if (!no_action)
// 5554         #endif
// 5555         if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
// 5556           || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
// 5557           || left_probe_bed_position != bilinear_start[X_AXIS]
// 5558           || front_probe_bed_position != bilinear_start[Y_AXIS]
// 5559         ) {
// 5560           // Reset grid to 0.0 or "not probed". (Also disables ABL)
// 5561           reset_bed_level();
// 5562 
// 5563           // Initialize a grid with the given dimensions
// 5564           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
// 5565           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
// 5566           bilinear_start[X_AXIS] = left_probe_bed_position;
// 5567           bilinear_start[Y_AXIS] = front_probe_bed_position;
// 5568 
// 5569           // Can't re-enable (on error) until the new grid is written
// 5570           abl_should_enable = false;
// 5571         }
// 5572       }
// 5573       //#endif // AUTO_BED_LEVELING_BILINEAR
// 5574 
// 5575       //#if ENABLED(AUTO_BED_LEVELING_3POINT)
// 5576       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)
// 5577       {
// 5578         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5579           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
// 5580         #endif
// 5581 
// 5582         // Probe at 3 arbitrary points
// 5583         points[0].z = points[1].z = points[2].z = 0;
// 5584       }
// 5585       //#endif // AUTO_BED_LEVELING_3POINT
// 5586 
// 5587     } // !g29_in_progress
// 5588 
// 5589     #if ENABLED(PROBE_MANUALLY)
// 5590 
// 5591       // For manual probing, get the next index to probe now.
// 5592       // On the first probe this will be incremented to 0.
// 5593       if (!no_action) {
// 5594         ++abl_probe_index;
// 5595         g29_in_progress = true;
// 5596       }
// 5597 
// 5598       // Abort current G29 procedure, go back to idle state
// 5599       if (seenA && g29_in_progress) {
// 5600         SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
// 5601         #if HAS_SOFTWARE_ENDSTOPS
// 5602           soft_endstops_enabled = enable_soft_endstops;
// 5603         #endif
// 5604         set_bed_leveling_enabled(abl_should_enable);
// 5605         g29_in_progress = false;
// 5606         #if ENABLED(LCD_BED_LEVELING)
// 5607           lcd_wait_for_move = false;
// 5608         #endif
// 5609       }
// 5610 
// 5611       // Query G29 status
// 5612       if (verbose_level || seenQ) {
// 5613         SERIAL_PROTOCOLPGM("Manual G29 ");
// 5614         if (g29_in_progress) {
// 5615           SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
// 5616           SERIAL_PROTOCOLLNPAIR(" of ", abl2);
// 5617         }
// 5618         else
// 5619           SERIAL_PROTOCOLLNPGM("idle");
// 5620       }
// 5621 
// 5622       if (no_action) return;
// 5623 
// 5624       if (abl_probe_index == 0) {
// 5625         // For the initial G29 save software endstop state
// 5626         #if HAS_SOFTWARE_ENDSTOPS
// 5627           enable_soft_endstops = soft_endstops_enabled;
// 5628         #endif
// 5629       }
// 5630       else {
// 5631         // For G29 after adjusting Z.
// 5632         // Save the previous Z before going to the next point
// 5633         measured_z = current_position[Z_AXIS];
// 5634 
// 5635         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5636 
// 5637           mean += measured_z;
// 5638           eqnBVector[abl_probe_index] = measured_z;
// 5639           eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5640           eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5641           eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5642 
// 5643           incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5644 
// 5645         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5646 
// 5647           z_values[xCount][yCount] = measured_z + zoffset;
// 5648 
// 5649           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5650             if (DEBUGGING(LEVELING)) {
// 5651               SERIAL_PROTOCOLPAIR("Save X", xCount);
// 5652               SERIAL_PROTOCOLPAIR(" Y", yCount);
// 5653               SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
// 5654             }
// 5655           #endif
// 5656 
// 5657         #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5658 
// 5659           points[abl_probe_index].z = measured_z;
// 5660 
// 5661         #endif
// 5662       }
// 5663 
// 5664       //
// 5665       // If there's another point to sample, move there with optional lift.
// 5666       //
// 5667 
// 5668       #if ABL_GRID
// 5669 
// 5670         // Skip any unreachable points
// 5671         while (abl_probe_index < abl2) {
// 5672 
// 5673           // Set xCount, yCount based on abl_probe_index, with zig-zag
// 5674           PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
// 5675           PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
// 5676 
// 5677           // Probe in reverse order for every other row/column
// 5678           bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
// 5679 
// 5680           if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
// 5681 
// 5682           const float xBase = xCount * xGridSpacing + left_probe_bed_position,
// 5683                       yBase = yCount * yGridSpacing + front_probe_bed_position;
// 5684 
// 5685           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5686           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5687 
// 5688           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5689             indexIntoAB[xCount][yCount] = abl_probe_index;
// 5690           #endif
// 5691 
// 5692           // Keep looping till a reachable point is found
// 5693           if(MACHINETPYE & IS_KINEMATIC)
// 5694             if (position_is_reachable_IS_KINEMATIC(xProbe, yProbe)) break;
// 5695           else
// 5696             if (position_is_reachable_IS_CARTESIAN(xProbe, yProbe)) break;
// 5697             
// 5698           ++abl_probe_index;
// 5699         }
// 5700 
// 5701         // Is there a next point to move to?
// 5702         if (abl_probe_index < abl2) {
// 5703           _manual_goto_xy(xProbe, yProbe); // Can be used here too!
// 5704           #if HAS_SOFTWARE_ENDSTOPS
// 5705             // Disable software endstops to allow manual adjustment
// 5706             // If G29 is not completed, they will not be re-enabled
// 5707             soft_endstops_enabled = false;
// 5708           #endif
// 5709           return;
// 5710         }
// 5711         else {
// 5712 
// 5713           // Leveling done! Fall through to G29 finishing code below
// 5714 
// 5715           SERIAL_PROTOCOLLNPGM("Grid probing done.");
// 5716 
// 5717           // Re-enable software endstops, if needed
// 5718           #if HAS_SOFTWARE_ENDSTOPS
// 5719             soft_endstops_enabled = enable_soft_endstops;
// 5720           #endif
// 5721         }
// 5722 
// 5723       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5724 
// 5725         // Probe at 3 arbitrary points
// 5726         if (abl_probe_index < abl2) {
// 5727           xProbe = points[abl_probe_index].x;
// 5728           yProbe = points[abl_probe_index].y;
// 5729           _manual_goto_xy(xProbe, yProbe);
// 5730           #if HAS_SOFTWARE_ENDSTOPS
// 5731             // Disable software endstops to allow manual adjustment
// 5732             // If G29 is not completed, they will not be re-enabled
// 5733             soft_endstops_enabled = false;
// 5734           #endif
// 5735           return;
// 5736         }
// 5737         else {
// 5738 
// 5739           SERIAL_PROTOCOLLNPGM("3-point probing done.");
// 5740 
// 5741           // Re-enable software endstops, if needed
// 5742           #if HAS_SOFTWARE_ENDSTOPS
// 5743             soft_endstops_enabled = enable_soft_endstops;
// 5744           #endif
// 5745 
// 5746           if (!dryrun) {
// 5747             vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5748             if (planeNormal.z < 0) {
// 5749               planeNormal.x *= -1;
// 5750               planeNormal.y *= -1;
// 5751               planeNormal.z *= -1;
// 5752             }
// 5753             planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5754 
// 5755             // Can't re-enable (on error) until the new grid is written
// 5756             abl_should_enable = false;
// 5757           }
// 5758 
// 5759         }
// 5760 
// 5761       #endif // AUTO_BED_LEVELING_3POINT
// 5762 
// 5763     #else // !PROBE_MANUALLY
// 5764     {
// 5765       const bool stow_probe_after_each = parser.boolval('E');
// 5766 
// 5767       measured_z = 0;
// 5768 
// 5769       //#if ABL_GRID
// 5770         if(BED_LEVELING_METHOD&ABL_GRID)
// 5771         {
// 5772         bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
// 5773 
// 5774         measured_z = 0;
// 5775 
// 5776         // Outer loop is Y with PROBE_Y_FIRST disabled
// 5777         for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
// 5778 
// 5779           int8_t inStart, inStop, inInc;
// 5780 
// 5781           if (zig) { // away from origin
// 5782             inStart = 0;
// 5783             inStop = PR_INNER_END;
// 5784             inInc = 1;
// 5785           }
// 5786           else {     // towards origin
// 5787             inStart = PR_INNER_END - 1;
// 5788             inStop = -1;
// 5789             inInc = -1;
// 5790           }
// 5791 
// 5792           zig ^= true; // zag
// 5793 
// 5794           // Inner loop is Y with PROBE_Y_FIRST enabled
// 5795           for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
// 5796 
// 5797             float xBase = left_probe_bed_position + xGridSpacing * xCount,
// 5798                   yBase = front_probe_bed_position + yGridSpacing * yCount;
// 5799 
// 5800             xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5801             yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5802 
// 5803             //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5804             if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5805               indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
// 5806             //#endif
// 5807 
// 5808             //#if IS_KINEMATIC
// 5809             if(MACHINETPYE & IS_KINEMATIC)
// 5810               // Avoid probing outside the round or hexagonal area
// 5811               if (!position_is_reachable_by_probe_IS_KINEMATIC(xProbe, yProbe)) continue;
// 5812             //#endif
// 5813             
// 5814             int16_t randData = rand()%200;
// 5815             if(randData > 100)  randData = 100 - randData;
// 5816 
// 5817             measured_z = faux ? 0.001 * randData/*random(-100, 101) */: probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5818 
// 5819             if (isnan(measured_z)) {
// 5820               set_bed_leveling_enabled(abl_should_enable);
// 5821               break;
// 5822             }
// 5823 
// 5824             //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5825             if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5826             {
// 5827               mean += measured_z;
// 5828               /*
// 5829               eqnBVector[abl_probe_index] = measured_z;
// 5830               eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5831               eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5832               eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5833               */
// 5834             *(eqnBVector+abl_probe_index) = measured_z;
// 5835             *(eqnAMatrix+abl_probe_index + 0 * abl2) = xProbe;
// 5836             *(eqnAMatrix+abl_probe_index + 1 * abl2) = yProbe;
// 5837             *(eqnAMatrix+abl_probe_index + 2 * abl2) = 1;
// 5838 
// 5839               incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5840             }
// 5841             //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5842             else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 5843             {
// 5844               z_values[xCount][yCount] = measured_z + zoffset;
// 5845             }
// 5846             //#endif
// 5847 
// 5848             abl_should_enable = false;
// 5849             idle();
// 5850 
// 5851           } // inner
// 5852         } // outer
// 5853       }
// 5854       //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5855       else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_3POINT)
// 5856       {
// 5857         // Probe at 3 arbitrary points
// 5858 
// 5859         for (uint8_t i = 0; i < 3; ++i) {
// 5860           // Retain the last probe position
// 5861           xProbe = points[i].x;
// 5862           yProbe = points[i].y;
// 5863           int16_t randData = rand()%200;
// 5864 	      if(randData > 100)	randData = 100 - randData;
// 5865           measured_z = faux ? 0.001 * randData/*random(-100, 101)*/ : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5866           if (isnan(measured_z)) {
// 5867             set_bed_leveling_enabled(abl_should_enable);
// 5868             break;
// 5869           }
// 5870           points[i].z = measured_z;
// 5871         }
// 5872 
// 5873         if (!dryrun && !isnan(measured_z)) {
// 5874           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5875           if (planeNormal.z < 0) {
// 5876             planeNormal.x *= -1;
// 5877             planeNormal.y *= -1;
// 5878             planeNormal.z *= -1;
// 5879           }
// 5880           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5881 
// 5882           // Can't re-enable (on error) until the new grid is written
// 5883           abl_should_enable = false;
// 5884         }
// 5885       }
// 5886       //#endif // AUTO_BED_LEVELING_3POINT
// 5887 
// 5888       // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
// 5889       if (STOW_PROBE()) {
// 5890         set_bed_leveling_enabled(abl_should_enable);
// 5891         measured_z = NAN;
// 5892       }
// 5893     }
// 5894     #endif // !PROBE_MANUALLY
// 5895 
// 5896     //
// 5897     // G29 Finishing Code
// 5898     //
// 5899     // Unless this is a dry run, auto bed leveling will
// 5900     // definitely be enabled after this point.
// 5901     //
// 5902     // If code above wants to continue leveling, it should
// 5903     // return or loop before this point.
// 5904     //
// 5905 
// 5906     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5907       if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
// 5908     #endif
// 5909 
// 5910     #if ENABLED(PROBE_MANUALLY)
// 5911       g29_in_progress = false;
// 5912       #if ENABLED(LCD_BED_LEVELING)
// 5913         lcd_wait_for_move = false;
// 5914       #endif
// 5915     #endif
// 5916 
// 5917     // Calculate leveling, print reports, correct the position
// 5918     if (!isnan(measured_z)) {
// 5919       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5920         if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5921         {
// 5922             if (!dryrun) extrapolate_unprobed_bed_level();
// 5923             print_bilinear_leveling_grid();
// 5924 
// 5925             refresh_bed_level();
// 5926 
// 5927             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5928               print_bilinear_leveling_grid_virt();
// 5929             #endif
// 5930        }
// 5931       //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5932        else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 5933         {
// 5934         // For LINEAR leveling calculate matrix, print reports, correct the position
// 5935 
// 5936         /**
// 5937          * solve the plane equation ax + by + d = z
// 5938          * A is the matrix with rows [x y 1] for all the probed points
// 5939          * B is the vector of the Z positions
// 5940          * the normal vector to the plane is formed by the coefficients of the
// 5941          * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
// 5942          * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
// 5943          */
// 5944         float plane_equation_coefficients[3];
// 5945 
// 5946         finish_incremental_LSF(&lsf_results);
// 5947         plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
// 5948         plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
// 5949         plane_equation_coefficients[2] = -lsf_results.D;
// 5950 
// 5951         mean /= abl2;
// 5952 
// 5953         if (verbose_level) {
// 5954           SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
// 5955           SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
// 5956           SERIAL_PROTOCOLPGM(" b: ");
// 5957           SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
// 5958           SERIAL_PROTOCOLPGM(" d: ");
// 5959           SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
// 5960           SERIAL_EOL();
// 5961           if (verbose_level > 2) {
// 5962             SERIAL_PROTOCOLPGM("Mean of sampled points: ");
// 5963             SERIAL_PROTOCOL_F(mean, 8);
// 5964             SERIAL_EOL();
// 5965           }
// 5966         }
// 5967 
// 5968         // Create the matrix but don't correct the position yet
// 5969         if (!dryrun)
// 5970           planner.bed_level_matrix = matrix_3x3::create_look_at(
// 5971             vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
// 5972           );
// 5973 
// 5974         // Show the Topography map if enabled
// 5975         if (do_topography_map) {
// 5976 
// 5977           SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
// 5978                                  "   +--- BACK --+\n"
// 5979                                  "   |           |\n"
// 5980                                  " L |    (+)    | R\n"
// 5981                                  " E |           | I\n"
// 5982                                  " F | (-) N (+) | G\n"
// 5983                                  " T |           | H\n"
// 5984                                  "   |    (-)    | T\n"
// 5985                                  "   |           |\n"
// 5986                                  "   O-- FRONT --+\n"
// 5987                                  " (0,0)");
// 5988 
// 5989           float min_diff = 999;
// 5990 
// 5991           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5992             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5993               int ind = indexIntoAB[xx][yy];
// 5994               /*
// 5995               float diff = eqnBVector[ind] - mean,
// 5996                     x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5997                     y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5998                     z_tmp = 0;
// 5999                     */
// 6000                   float diff = *(eqnBVector+ind) - mean,
// 6001                         x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 6002                         y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 6003                         z_tmp = 0;
// 6004 
// 6005               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 6006 
// 6007               //NOMORE(min_diff, eqnBVector[ind] - z_tmp);
// 6008               NOMORE(min_diff, *(eqnBVector+ind) - z_tmp);
// 6009 
// 6010               if (diff >= 0.0)
// 6011                 SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
// 6012               else
// 6013                 SERIAL_PROTOCOLCHAR(' ');
// 6014               SERIAL_PROTOCOL_F(diff, 5);
// 6015             } // xx
// 6016             SERIAL_EOL();
// 6017           } // yy
// 6018           SERIAL_EOL();
// 6019 
// 6020           if (verbose_level > 3) {
// 6021             SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
// 6022 
// 6023             for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 6024               for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 6025                 int ind = indexIntoAB[xx][yy];
// 6026                 /*
// 6027                 float x_tmp = eqnAMatrix[ind + 0 * abl2],
// 6028                       y_tmp = eqnAMatrix[ind + 1 * abl2],
// 6029                       z_tmp = 0;
// 6030                       */
// 6031                 float x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 6032                       y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 6033                       z_tmp = 0;
// 6034 
// 6035                 apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 6036 
// 6037                 //float diff = eqnBVector[ind] - z_tmp - min_diff;
// 6038                 float diff = *(eqnBVector+ind) - z_tmp - min_diff;
// 6039                 if (diff >= 0.0)
// 6040                   SERIAL_PROTOCOLPGM(" +");
// 6041                 // Include + for column alignment
// 6042                 else
// 6043                   SERIAL_PROTOCOLCHAR(' ');
// 6044                 SERIAL_PROTOCOL_F(diff, 5);
// 6045               } // xx
// 6046               SERIAL_EOL();
// 6047             } // yy
// 6048             SERIAL_EOL();
// 6049           }
// 6050         } //do_topography_map
// 6051         }
// 6052       //#endif // AUTO_BED_LEVELING_LINEAR
// 6053 
// 6054       //#if ABL_PLANAR
// 6055       if(BED_LEVELING_METHOD&ABL_PLANAR)  {
// 6056 
// 6057         // For LINEAR and 3POINT leveling correct the current position
// 6058 
// 6059         if (verbose_level > 0)
// 6060           planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
// 6061 
// 6062         if (!dryrun) {
// 6063           //
// 6064           // Correct the current XYZ position based on the tilted plane.
// 6065           //
// 6066 
// 6067           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6068             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
// 6069           #endif
// 6070 
// 6071           float converted[XYZ];
// 6072           COPY(converted, current_position);
// 6073 
// 6074           planner.leveling_active = true;
// 6075           planner.unapply_leveling(converted); // use conversion machinery
// 6076           planner.leveling_active = false;
// 6077 
// 6078           // Use the last measured distance to the bed, if possible
// 6079           if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
// 6080             && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
// 6081           ) {
// 6082             const float simple_z = current_position[Z_AXIS] - measured_z;
// 6083             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6084               if (DEBUGGING(LEVELING)) {
// 6085                 SERIAL_ECHOPAIR("Z from Probe:", simple_z);
// 6086                 SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
// 6087                 SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
// 6088               }
// 6089             #endif
// 6090             converted[Z_AXIS] = simple_z;
// 6091           }
// 6092 
// 6093           // The rotated XY and corrected Z are now current_position
// 6094           COPY(current_position, converted);
// 6095 
// 6096           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6097             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
// 6098           #endif
// 6099         }
// 6100         }
// 6101       //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 6102       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 6103 
// 6104         if (!dryrun) {
// 6105           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6106             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
// 6107           #endif
// 6108 
// 6109           // Unapply the offset because it is going to be immediately applied
// 6110           // and cause compensation movement in Z
// 6111           current_position[Z_AXIS] -= bilinear_z_offset(current_position);
// 6112 
// 6113           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6114             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
// 6115           #endif
// 6116         }
// 6117         }
// 6118       //#endif // ABL_PLANAR
// 6119 
// 6120       #ifdef Z_PROBE_END_SCRIPT
// 6121         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6122           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
// 6123         #endif
// 6124         enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
// 6125         stepper.synchronize();
// 6126       #endif
// 6127 
// 6128       // Auto Bed Leveling is complete! Enable if possible.
// 6129       planner.leveling_active = dryrun ? abl_should_enable : true;
// 6130     } // !isnan(measured_z)
// 6131 
// 6132     // Restore state after probing
// 6133     if (!faux) clean_up_after_endstop_or_probe_move();
// 6134 
// 6135     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6136       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
// 6137     #endif
// 6138 
// 6139     report_current_position();
// 6140 
// 6141     KEEPALIVE_STATE(IN_HANDLER);
// 6142 
// 6143     if (planner.leveling_active)
// 6144       SYNC_PLAN_POSITION_KINEMATIC();
// 6145 
// 6146     free(eqnBVector);
// 6147 	free(eqnAMatrix);
// 6148   }
// 6149 
// 6150 #endif // OLDSCHOOL_ABL
// 6151 
// 6152 #if HAS_BED_PROBE
// 6153 
// 6154   /**
// 6155    * G30: Do a single Z probe at the current XY
// 6156    *
// 6157    * Parameters:
// 6158    *
// 6159    *   X   Probe X position (default current X)
// 6160    *   Y   Probe Y position (default current Y)
// 6161    *   E   Engage the probe for each probe
// 6162    */
// 6163   inline void gcode_G30() {
// 6164     const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
// 6165                 ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 6166     if(MACHINETPYE & IS_KINEMATIC)
// 6167         if (!position_is_reachable_by_probe_IS_KINEMATIC(xpos, ypos)) return;
// 6168     else
// 6169         if (!position_is_reachable_by_probe_IS_CARTESIAN(xpos, ypos)) return;
// 6170 
// 6171     // Disable leveling so the planner won't mess with us
// 6172     //#if HAS_LEVELING
// 6173 	if(BED_LEVELING_METHOD&HAS_LEVELING)
// 6174       set_bed_leveling_enabled(false);
// 6175     //#endif
// 6176 
// 6177     setup_for_endstop_or_probe_move();
// 6178 
// 6179     const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
// 6180 
// 6181     if (!isnan(measured_z)) {
// 6182       SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
// 6183       SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
// 6184       SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
// 6185     }
// 6186 
// 6187     clean_up_after_endstop_or_probe_move();
// 6188 
// 6189     report_current_position();
// 6190   }
// 6191 
// 6192   #if ENABLED(Z_PROBE_SLED)
// 6193 
// 6194     /**
// 6195      * G31: Deploy the Z probe
// 6196      */
// 6197     inline void gcode_G31() { DEPLOY_PROBE(); }
// 6198 
// 6199     /**
// 6200      * G32: Stow the Z probe
// 6201      */
// 6202     inline void gcode_G32() { STOW_PROBE(); }
// 6203 
// 6204   #endif // Z_PROBE_SLED
// 6205 
// 6206 #endif // HAS_BED_PROBE
// 6207 
// 6208 #if ENABLED(DELTA_AUTO_CALIBRATION)
// 6209 
// 6210   constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
// 6211                     _4P_STEP = _7P_STEP * 2,   // 4-point step
// 6212                     NPP      = _7P_STEP * 6;   // number of calibration points on the radius
// 6213   enum CalEnum {                               // the 7 main calibration points - add definitions if needed
// 6214     CEN      = 0,
// 6215     __A      = 1,
// 6216     _AB      = __A + _7P_STEP,
// 6217     __B      = _AB + _7P_STEP,
// 6218     _BC      = __B + _7P_STEP,
// 6219     __C      = _BC + _7P_STEP,
// 6220     _CA      = __C + _7P_STEP,
// 6221   };
// 6222 
// 6223   #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
// 6224   #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
// 6225   #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
// 6226   #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
// 6227   #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
// 6228   #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
// 6229 
// 6230   static void print_signed_float(const char * const prefix, const float &f) {
// 6231     SERIAL_PROTOCOLPGM("  ");
// 6232     serialprintPGM(prefix);
// 6233     SERIAL_PROTOCOLCHAR(':');
// 6234     if (f >= 0) SERIAL_CHAR('+');
// 6235     SERIAL_PROTOCOL_F(f, 2);
// 6236   }
// 6237 
// 6238   static void print_G33_settings(const bool end_stops, const bool tower_angles) {
// 6239     SERIAL_PROTOCOLPAIR(".Height:", delta_height);
// 6240     if (end_stops) {
// 6241       print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
// 6242       print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
// 6243       print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
// 6244     }
// 6245     if (end_stops && tower_angles) {
// 6246       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 6247       SERIAL_EOL();
// 6248       SERIAL_CHAR('.');
// 6249       SERIAL_PROTOCOL_SP(13);
// 6250     }
// 6251     if (tower_angles) {
// 6252       print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
// 6253       print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
// 6254       print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
// 6255     }
// 6256     if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
// 6257       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 6258     }
// 6259     SERIAL_EOL();
// 6260   }
// 6261 
// 6262   static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
// 6263     SERIAL_PROTOCOLPGM(".    ");
// 6264     print_signed_float(PSTR("c"), z_at_pt[CEN]);
// 6265     if (tower_points) {
// 6266       print_signed_float(PSTR(" x"), z_at_pt[__A]);
// 6267       print_signed_float(PSTR(" y"), z_at_pt[__B]);
// 6268       print_signed_float(PSTR(" z"), z_at_pt[__C]);
// 6269     }
// 6270     if (tower_points && opposite_points) {
// 6271       SERIAL_EOL();
// 6272       SERIAL_CHAR('.');
// 6273       SERIAL_PROTOCOL_SP(13);
// 6274     }
// 6275     if (opposite_points) {
// 6276       print_signed_float(PSTR("yz"), z_at_pt[_BC]);
// 6277       print_signed_float(PSTR("zx"), z_at_pt[_CA]);
// 6278       print_signed_float(PSTR("xy"), z_at_pt[_AB]);
// 6279     }
// 6280     SERIAL_EOL();
// 6281   }
// 6282 
// 6283   /**
// 6284    * After G33:
// 6285    *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
// 6286    *  - Stow the probe
// 6287    *  - Restore endstops state
// 6288    *  - Select the old tool, if needed
// 6289    */
// 6290   static void G33_cleanup(
// 6291     #if HOTENDS > 1
// 6292       const uint8_t old_tool_index
// 6293     #endif
// 6294   ) {
// 6295     #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 6296       do_blocking_move_to_z(delta_clip_start_height);
// 6297     #endif
// 6298     STOW_PROBE();
// 6299     clean_up_after_endstop_or_probe_move();
// 6300     #if HOTENDS > 1
// 6301       tool_change(old_tool_index, 0, true);
// 6302     #endif
// 6303   }
// 6304 
// 6305   inline float calibration_probe(const float nx, const float ny, const bool stow) {
// 6306     #if HAS_BED_PROBE
// 6307       return probe_pt(nx, ny, stow, 0, false);
// 6308     #else
// 6309       UNUSED(stow);
// 6310       return lcd_probe_pt(nx, ny);
// 6311     #endif
// 6312   }
// 6313 
// 6314   static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
// 6315     const bool _0p_calibration      = probe_points == 0,
// 6316                _1p_calibration      = probe_points == 1,
// 6317                _4p_calibration      = probe_points == 2,
// 6318                _4p_opposite_points  = _4p_calibration && !towers_set,
// 6319                _7p_calibration      = probe_points >= 3 || probe_points == 0,
// 6320                _7p_no_intermediates = probe_points == 3,
// 6321                _7p_1_intermediates  = probe_points == 4,
// 6322                _7p_2_intermediates  = probe_points == 5,
// 6323                _7p_4_intermediates  = probe_points == 6,
// 6324                _7p_6_intermediates  = probe_points == 7,
// 6325                _7p_8_intermediates  = probe_points == 8,
// 6326                _7p_11_intermediates = probe_points == 9,
// 6327                _7p_14_intermediates = probe_points == 10,
// 6328                _7p_intermed_points  = probe_points >= 4,
// 6329                _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
// 6330                _7p_9_centre         = probe_points >= 8;
// 6331 
// 6332     LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
// 6333 
// 6334     if (!_0p_calibration) {
// 6335 
// 6336       if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
// 6337         z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
// 6338         if (isnan(z_at_pt[CEN])) return NAN;
// 6339       }
// 6340 
// 6341       if (_7p_calibration) { // probe extra center points
// 6342         const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
// 6343                     steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
// 6344         I_LOOP_CAL_PT(axis, start, steps) {
// 6345           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6346                       r = delta_calibration_radius * 0.1;
// 6347           z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 6348           if (isnan(z_at_pt[CEN])) return NAN;
// 6349        }
// 6350         z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
// 6351       }
// 6352 
// 6353       if (!_1p_calibration) {  // probe the radius
// 6354         const CalEnum start  = _4p_opposite_points ? _AB : __A;
// 6355         const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
// 6356                                _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
// 6357                                _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
// 6358                                _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
// 6359                                _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
// 6360                                _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
// 6361                                _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
// 6362                                _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
// 6363                                _4P_STEP;                                // .5r * 6 +  1c = 4
// 6364         bool zig_zag = true;
// 6365         F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
// 6366           const int8_t offset = _7p_9_centre ? 1 : 0;
// 6367           for (int8_t circle = -offset; circle <= offset; circle++) {
// 6368             const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6369                         r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
// 6370                         interpol = fmod(axis, 1);
// 6371             const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 6372             if (isnan(z_temp)) return NAN;
// 6373             // split probe point to neighbouring calibration points
// 6374             z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
// 6375             z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
// 6376           }
// 6377           zig_zag = !zig_zag;
// 6378         }
// 6379         if (_7p_intermed_points)
// 6380           LOOP_CAL_RAD(axis)
// 6381             z_at_pt[axis] /= _7P_STEP / steps;
// 6382       }
// 6383 
// 6384       float S1 = z_at_pt[CEN],
// 6385             S2 = sq(z_at_pt[CEN]);
// 6386       int16_t N = 1;
// 6387       if (!_1p_calibration) { // std dev from zero plane
// 6388         LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
// 6389           S1 += z_at_pt[axis];
// 6390           S2 += sq(z_at_pt[axis]);
// 6391           N++;
// 6392         }
// 6393         return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
// 6394       }
// 6395     }
// 6396 
// 6397     return 0.00001;
// 6398   }
// 6399 
// 6400   #if HAS_BED_PROBE
// 6401 
// 6402     static bool G33_auto_tune() {
// 6403       float z_at_pt[NPP + 1]      = { 0.0 },
// 6404             z_at_pt_base[NPP + 1] = { 0.0 },
// 6405             z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
// 6406 
// 6407       #define ZP(N,I) ((N) * z_at_pt[I])
// 6408       #define Z06(I)  ZP(6, I)
// 6409       #define Z03(I)  ZP(3, I)
// 6410       #define Z02(I)  ZP(2, I)
// 6411       #define Z01(I)  ZP(1, I)
// 6412       #define Z32(I)  ZP(3/2, I)
// 6413 
// 6414       SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
// 6415       SERIAL_EOL();
// 6416       if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
// 6417       print_G33_results(z_at_pt_base, true, true);
// 6418 
// 6419       LOOP_XYZ(axis) {
// 6420         delta_endstop_adj[axis] -= 1.0;
// 6421         recalc_delta_settings();
// 6422 
// 6423         endstops.enable(true);
// 6424         if (!home_delta()) return false;
// 6425         endstops.not_homing();
// 6426 
// 6427         SERIAL_PROTOCOLPGM("Tuning E");
// 6428         SERIAL_CHAR(tolower(axis_codes[axis]));
// 6429         SERIAL_EOL();
// 6430 
// 6431         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6432         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6433         print_G33_results(z_at_pt, true, true);
// 6434         delta_endstop_adj[axis] += 1.0;
// 6435         recalc_delta_settings();
// 6436         switch (axis) {
// 6437           case A_AXIS :
// 6438             h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
// 6439             break;
// 6440           case B_AXIS :
// 6441             h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
// 6442             break;
// 6443           case C_AXIS :
// 6444             h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
// 6445             break;
// 6446         }
// 6447       }
// 6448       h_fac /= 3.0;
// 6449       h_fac *= norm; // Normalize to 1.02 for Kossel mini
// 6450 
// 6451       for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
// 6452         delta_radius += 1.0 * zig_zag;
// 6453         recalc_delta_settings();
// 6454 
// 6455         endstops.enable(true);
// 6456         if (!home_delta()) return false;
// 6457         endstops.not_homing();
// 6458 
// 6459         SERIAL_PROTOCOLPGM("Tuning R");
// 6460         SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
// 6461         SERIAL_EOL();
// 6462         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6463         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6464         print_G33_results(z_at_pt, true, true);
// 6465         delta_radius -= 1.0 * zig_zag;
// 6466         recalc_delta_settings();
// 6467         r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
// 6468       }
// 6469       r_fac /= 2.0;
// 6470       r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
// 6471 
// 6472       LOOP_XYZ(axis) {
// 6473         delta_tower_angle_trim[axis] += 1.0;
// 6474         delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
// 6475         delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
// 6476         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6477         delta_height -= z_temp;
// 6478         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6479         recalc_delta_settings();
// 6480 
// 6481         endstops.enable(true);
// 6482         if (!home_delta()) return false;
// 6483         endstops.not_homing();
// 6484 
// 6485         SERIAL_PROTOCOLPGM("Tuning T");
// 6486         SERIAL_CHAR(tolower(axis_codes[axis]));
// 6487         SERIAL_EOL();
// 6488 
// 6489         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6490         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6491         print_G33_results(z_at_pt, true, true);
// 6492 
// 6493         delta_tower_angle_trim[axis] -= 1.0;
// 6494         delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
// 6495         delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
// 6496         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6497         delta_height -= z_temp;
// 6498         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6499         recalc_delta_settings();
// 6500         switch (axis) {
// 6501           case A_AXIS :
// 6502             a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
// 6503             break;
// 6504           case B_AXIS :
// 6505             a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
// 6506             break;
// 6507           case C_AXIS :
// 6508             a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
// 6509             break;
// 6510         }
// 6511       }
// 6512       a_fac /= 3.0;
// 6513       a_fac *= norm; // Normalize to 0.83 for Kossel mini
// 6514 
// 6515       endstops.enable(true);
// 6516       if (!home_delta()) return false;
// 6517       endstops.not_homing();
// 6518       print_signed_float(PSTR( "H_FACTOR: "), h_fac);
// 6519       print_signed_float(PSTR(" R_FACTOR: "), r_fac);
// 6520       print_signed_float(PSTR(" A_FACTOR: "), a_fac);
// 6521       SERIAL_EOL();
// 6522       SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
// 6523       SERIAL_EOL();
// 6524       return true;
// 6525     }
// 6526 
// 6527   #endif // HAS_BED_PROBE
// 6528 
// 6529   /**
// 6530    * G33 - Delta '1-4-7-point' Auto-Calibration
// 6531    *       Calibrate height, endstops, delta radius, and tower angles.
// 6532    *
// 6533    * Parameters:
// 6534    *
// 6535    *   Pn  Number of probe points:
// 6536    *      P0     No probe. Normalize only.
// 6537    *      P1     Probe center and set height only.
// 6538    *      P2     Probe center and towers. Set height, endstops and delta radius.
// 6539    *      P3     Probe all positions: center, towers and opposite towers. Set all.
// 6540    *      P4-P10 Probe all positions + at different itermediate locations and average them.
// 6541    *
// 6542    *   T   Don't calibrate tower angle corrections
// 6543    *
// 6544    *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
// 6545    *
// 6546    *   Fn  Force to run at least n iterations and takes the best result
// 6547    *
// 6548    *   A   Auto tune calibartion factors (set in Configuration.h)
// 6549    *
// 6550    *   Vn  Verbose level:
// 6551    *      V0  Dry-run mode. Report settings and probe results. No calibration.
// 6552    *      V1  Report start and end settings only
// 6553    *      V2  Report settings at each iteration
// 6554    *      V3  Report settings and probe results
// 6555    *
// 6556    *   E   Engage the probe for each point
// 6557    */
// 6558   inline void gcode_G33() {
// 6559 
// 6560     const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
// 6561     if (!WITHIN(probe_points, 0, 10)) {
// 6562       SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
// 6563       return;
// 6564     }
// 6565 
// 6566     const int8_t verbose_level = parser.byteval('V', 1);
// 6567     if (!WITHIN(verbose_level, 0, 3)) {
// 6568       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
// 6569       return;
// 6570     }
// 6571 
// 6572     const float calibration_precision = parser.floatval('C', 0.0);
// 6573     if (calibration_precision < 0) {
// 6574       SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
// 6575       return;
// 6576     }
// 6577 
// 6578     const int8_t force_iterations = parser.intval('F', 0);
// 6579     if (!WITHIN(force_iterations, 0, 30)) {
// 6580       SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
// 6581       return;
// 6582     }
// 6583 
// 6584     const bool towers_set           = !parser.boolval('T'),
// 6585                auto_tune            = parser.boolval('A'),
// 6586                stow_after_each      = parser.boolval('E'),
// 6587                _0p_calibration      = probe_points == 0,
// 6588                _1p_calibration      = probe_points == 1,
// 6589                _4p_calibration      = probe_points == 2,
// 6590                _7p_9_centre         = probe_points >= 8,
// 6591                _tower_results       = (_4p_calibration && towers_set)
// 6592                                       || probe_points >= 3 || probe_points == 0,
// 6593                _opposite_results    = (_4p_calibration && !towers_set)
// 6594                                       || probe_points >= 3 || probe_points == 0,
// 6595                _endstop_results     = probe_points != 1,
// 6596                _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
// 6597     const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
// 6598     int8_t iterations = 0;
// 6599     float test_precision,
// 6600           zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
// 6601           zero_std_dev_min = zero_std_dev,
// 6602           e_old[ABC] = {
// 6603             delta_endstop_adj[A_AXIS],
// 6604             delta_endstop_adj[B_AXIS],
// 6605             delta_endstop_adj[C_AXIS]
// 6606           },
// 6607           dr_old = delta_radius,
// 6608           zh_old = delta_height,
// 6609           ta_old[ABC] = {
// 6610             delta_tower_angle_trim[A_AXIS],
// 6611             delta_tower_angle_trim[B_AXIS],
// 6612             delta_tower_angle_trim[C_AXIS]
// 6613           };
// 6614 
// 6615     SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
// 6616 
// 6617     if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
// 6618       LOOP_CAL_RAD(axis) {
// 6619         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6620                     r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
// 6621         if(MACHINETPYE & IS_KINEMATIC)
// 6622         {
// 6623         if (!position_is_reachable_IS_KINEMATIC(cos(a) * r, sin(a) * r)) {
// 6624           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6625           return;
// 6626         }
// 6627         else
// 6628         {
// 6629         if (!position_is_reachable_IS_CARTESIAN(cos(a) * r, sin(a) * r)) {
// 6630           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6631           return;        
// 6632         }
// 6633         }
// 6634       }
// 6635     }
// 6636 
// 6637     stepper.synchronize();
// 6638     //#if HAS_LEVELING
// 6639     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 6640       reset_bed_level(); // After calibration bed-level data is no longer valid
// 6641     //#endif
// 6642 
// 6643     #if HOTENDS > 1
// 6644       const uint8_t old_tool_index = active_extruder;
// 6645       tool_change(0, 0, true);
// 6646       #define G33_CLEANUP() G33_cleanup(old_tool_index)
// 6647     #else
// 6648       #define G33_CLEANUP() G33_cleanup()
// 6649     #endif
// 6650 
// 6651     setup_for_endstop_or_probe_move();
// 6652     endstops.enable(true);
// 6653     if (!_0p_calibration) {
// 6654       if (!home_delta())
// 6655         return;
// 6656       endstops.not_homing();
// 6657     }
// 6658 
// 6659     if (auto_tune) {
// 6660       #if HAS_BED_PROBE
// 6661         G33_auto_tune();
// 6662       #else
// 6663         SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
// 6664       #endif
// 6665       G33_CLEANUP();
// 6666       return;
// 6667     }
// 6668 
// 6669     // Report settings
// 6670 
// 6671     const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
// 6672     serialprintPGM(checkingac);
// 6673     if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
// 6674     SERIAL_EOL();
// 6675     lcd_setstatusPGM(checkingac);
// 6676 
// 6677     print_G33_settings(_endstop_results, _angle_results);
// 6678 
// 6679     do {
// 6680 
// 6681       float z_at_pt[NPP + 1] = { 0.0 };
// 6682 
// 6683       test_precision = zero_std_dev;
// 6684 
// 6685       iterations++;
// 6686 
// 6687       // Probe the points
// 6688 
// 6689       zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
// 6690       if (isnan(zero_std_dev)) {
// 6691         SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
// 6692         SERIAL_EOL();
// 6693         return G33_CLEANUP();
// 6694       }
// 6695 
// 6696       // Solve matrices
// 6697 
// 6698       if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
// 6699         if (zero_std_dev < zero_std_dev_min) {
// 6700           COPY(e_old, delta_endstop_adj);
// 6701           dr_old = delta_radius;
// 6702           zh_old = delta_height;
// 6703           COPY(ta_old, delta_tower_angle_trim);
// 6704         }
// 6705 
// 6706         float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
// 6707         const float r_diff = delta_radius - delta_calibration_radius,
// 6708                     h_factor = 1 / 6.0 *
// 6709                       #ifdef H_FACTOR
// 6710                         (H_FACTOR),                                       // Set in Configuration.h
// 6711                       #else
// 6712                         (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
// 6713                       #endif
// 6714                     r_factor = 1 / 6.0 *
// 6715                       #ifdef R_FACTOR
// 6716                         -(R_FACTOR),                                      // Set in Configuration.h
// 6717                       #else
// 6718                         -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
// 6719                       #endif
// 6720                     a_factor = 1 / 6.0 *
// 6721                       #ifdef A_FACTOR
// 6722                         (A_FACTOR);                                       // Set in Configuration.h
// 6723                       #else
// 6724                         (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
// 6725                       #endif
// 6726 
// 6727         #define ZP(N,I) ((N) * z_at_pt[I])
// 6728         #define Z6(I) ZP(6, I)
// 6729         #define Z4(I) ZP(4, I)
// 6730         #define Z2(I) ZP(2, I)
// 6731         #define Z1(I) ZP(1, I)
// 6732 
// 6733         #if !HAS_BED_PROBE
// 6734           test_precision = 0.00; // forced end
// 6735         #endif
// 6736 
// 6737         switch (probe_points) {
// 6738           case 0:
// 6739             test_precision = 0.00; // forced end
// 6740             break;
// 6741 
// 6742           case 1:
// 6743             test_precision = 0.00; // forced end
// 6744             LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
// 6745             break;
// 6746 
// 6747           case 2:
// 6748             if (towers_set) {
// 6749               e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
// 6750               e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
// 6751               e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
// 6752               r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
// 6753             }
// 6754             else {
// 6755               e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
// 6756               e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
// 6757               e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
// 6758               r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
// 6759             }
// 6760             break;
// 6761 
// 6762           default:
// 6763             e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
// 6764             e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
// 6765             e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
// 6766             r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
// 6767 
// 6768             if (towers_set) {
// 6769               t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
// 6770               t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
// 6771               t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
// 6772               e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
// 6773               e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
// 6774               e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
// 6775             }
// 6776             break;
// 6777         }
// 6778 
// 6779         LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
// 6780         delta_radius += r_delta;
// 6781         LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
// 6782       }
// 6783       else if (zero_std_dev >= test_precision) {   // step one back
// 6784         COPY(delta_endstop_adj, e_old);
// 6785         delta_radius = dr_old;
// 6786         delta_height = zh_old;
// 6787         COPY(delta_tower_angle_trim, ta_old);
// 6788       }
// 6789 
// 6790       if (verbose_level != 0) {                                    // !dry run
// 6791         // normalise angles to least squares
// 6792         if (_angle_results) {
// 6793           float a_sum = 0.0;
// 6794           LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
// 6795           LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
// 6796         }
// 6797 
// 6798         // adjust delta_height and endstops by the max amount
// 6799         const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6800         delta_height -= z_temp;
// 6801         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6802       }
// 6803       recalc_delta_settings();
// 6804       NOMORE(zero_std_dev_min, zero_std_dev);
// 6805 
// 6806       // print report
// 6807 
// 6808       if (verbose_level > 2)
// 6809         print_G33_results(z_at_pt, _tower_results, _opposite_results);
// 6810 
// 6811       if (verbose_level != 0) {                                    // !dry run
// 6812         if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
// 6813           SERIAL_PROTOCOLPGM("Calibration OK");
// 6814           SERIAL_PROTOCOL_SP(32);
// 6815           #if HAS_BED_PROBE
// 6816             if (zero_std_dev >= test_precision && !_1p_calibration)
// 6817               SERIAL_PROTOCOLPGM("rolling back.");
// 6818             else
// 6819           #endif
// 6820             {
// 6821               SERIAL_PROTOCOLPGM("std dev:");
// 6822               SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
// 6823             }
// 6824           SERIAL_EOL();
// 6825           char mess[21];
// 6826           strcpy_P(mess, PSTR("Calibration sd:"));
// 6827           if (zero_std_dev_min < 1)
// 6828             sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
// 6829           else
// 6830             sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
// 6831           lcd_setstatus(mess);
// 6832           print_G33_settings(_endstop_results, _angle_results);
// 6833           serialprintPGM(save_message);
// 6834           SERIAL_EOL();
// 6835         }
// 6836         else {                                                     // !end iterations
// 6837           char mess[15];
// 6838           if (iterations < 31)
// 6839             sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
// 6840           else
// 6841             strcpy_P(mess, PSTR("No convergence"));
// 6842           SERIAL_PROTOCOL(mess);
// 6843           SERIAL_PROTOCOL_SP(32);
// 6844           SERIAL_PROTOCOLPGM("std dev:");
// 6845           SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6846           SERIAL_EOL();
// 6847           lcd_setstatus(mess);
// 6848           if (verbose_level > 1)
// 6849             print_G33_settings(_endstop_results, _angle_results);
// 6850         }
// 6851       }
// 6852       else {                                                       // dry run
// 6853         const char *enddryrun = PSTR("End DRY-RUN");
// 6854         serialprintPGM(enddryrun);
// 6855         SERIAL_PROTOCOL_SP(35);
// 6856         SERIAL_PROTOCOLPGM("std dev:");
// 6857         SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6858         SERIAL_EOL();
// 6859 
// 6860         char mess[21];
// 6861         strcpy_P(mess, enddryrun);
// 6862         strcpy_P(&mess[11], PSTR(" sd:"));
// 6863         if (zero_std_dev < 1)
// 6864           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
// 6865         else
// 6866           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
// 6867         lcd_setstatus(mess);
// 6868       }
// 6869 
// 6870       endstops.enable(true);
// 6871       if (!home_delta())
// 6872         return;
// 6873       endstops.not_homing();
// 6874 
// 6875     }
// 6876     while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
// 6877 
// 6878     G33_CLEANUP();
// 6879   }
// 6880 
// 6881 #endif // DELTA_AUTO_CALIBRATION
// 6882 
// 6883 #if ENABLED(G38_PROBE_TARGET)
// 6884 
// 6885   static bool G38_run_probe() {
// 6886 
// 6887     bool G38_pass_fail = false;
// 6888 
// 6889     #if MULTIPLE_PROBING > 1
// 6890       // Get direction of move and retract
// 6891       float retract_mm[XYZ];
// 6892       LOOP_XYZ(i) {
// 6893         float dist = destination[i] - current_position[i];
// 6894         retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
// 6895       }
// 6896     #endif
// 6897 
// 6898     stepper.synchronize();  // wait until the machine is idle
// 6899 
// 6900     // Move until destination reached or target hit
// 6901     endstops.enable(true);
// 6902     G38_move = true;
// 6903     G38_endstop_hit = false;
// 6904     prepare_move_to_destination();
// 6905     stepper.synchronize();
// 6906     G38_move = false;
// 6907 
// 6908     endstops.hit_on_purpose();
// 6909     set_current_from_steppers_for_axis(ALL_AXES);
// 6910     SYNC_PLAN_POSITION_KINEMATIC();
// 6911 
// 6912     if (G38_endstop_hit) {
// 6913 
// 6914       G38_pass_fail = true;
// 6915 
// 6916       #if MULTIPLE_PROBING > 1
// 6917         // Move away by the retract distance
// 6918         set_destination_from_current();
// 6919         LOOP_XYZ(i) destination[i] += retract_mm[i];
// 6920         endstops.enable(false);
// 6921         prepare_move_to_destination();
// 6922         stepper.synchronize();
// 6923 
// 6924         feedrate_mm_s /= 4;
// 6925 
// 6926         // Bump the target more slowly
// 6927         LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
// 6928 
// 6929         endstops.enable(true);
// 6930         G38_move = true;
// 6931         prepare_move_to_destination();
// 6932         stepper.synchronize();
// 6933         G38_move = false;
// 6934 
// 6935         set_current_from_steppers_for_axis(ALL_AXES);
// 6936         SYNC_PLAN_POSITION_KINEMATIC();
// 6937       #endif
// 6938     }
// 6939 
// 6940     endstops.hit_on_purpose();
// 6941     endstops.not_homing();
// 6942     return G38_pass_fail;
// 6943   }
// 6944 
// 6945   /**
// 6946    * G38.2 - probe toward workpiece, stop on contact, signal error if failure
// 6947    * G38.3 - probe toward workpiece, stop on contact
// 6948    *
// 6949    * Like G28 except uses Z min probe for all axes
// 6950    */
// 6951   inline void gcode_G38(bool is_38_2) {
// 6952     // Get X Y Z E F
// 6953     gcode_get_destination();
// 6954 
// 6955     setup_for_endstop_or_probe_move();
// 6956 
// 6957     // If any axis has enough movement, do the move
// 6958     LOOP_XYZ(i)
// 6959       if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
// 6960         if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
// 6961         // If G38.2 fails throw an error
// 6962         if (!G38_run_probe() && is_38_2) {
// 6963           SERIAL_ERROR_START();
// 6964           SERIAL_ERRORLNPGM("Failed to reach target");
// 6965         }
// 6966         break;
// 6967       }
// 6968 
// 6969     clean_up_after_endstop_or_probe_move();
// 6970   }
// 6971 
// 6972 #endif // G38_PROBE_TARGET
// 6973 
// 6974 #if 1//HAS_MESH
// 6975 
// 6976   /**
// 6977    * G42: Move X & Y axes to mesh coordinates (I & J)
// 6978    */
// 6979   inline void gcode_G42() {
// 6980     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 6981       if (axis_unhomed_error()) return;
// 6982     #endif
// 6983 
// 6984     if (IsRunning()) {
// 6985       const bool hasI = parser.seenval('I');
// 6986       const int8_t ix = hasI ? parser.value_int() : 0;
// 6987       const bool hasJ = parser.seenval('J');
// 6988       const int8_t iy = hasJ ? parser.value_int() : 0;
// 6989 
// 6990       if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
// 6991         SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
// 6992         return;
// 6993       }
// 6994 
// 6995       set_destination_from_current();
// 6996       if (hasI) 
// 6997       {
// 6998         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
// 6999             destination[X_AXIS] = _GET_MESH_X_ABL(ix);
// 7000         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
// 7001             destination[X_AXIS] = _GET_MESH_X_UBL(ix);
// 7002         if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
// 7003             destination[X_AXIS] = _GET_MESH_X_MBL(ix);        
// 7004       }
// 7005       if (hasJ) 
// 7006       {
// 7007         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
// 7008             destination[Y_AXIS] = _GET_MESH_Y_ABL (iy);
// 7009         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
// 7010             destination[Y_AXIS] = _GET_MESH_Y_UBL(iy);
// 7011         if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
// 7012             destination[Y_AXIS] = _GET_MESH_Y_MBL(iy);        
// 7013       }         
// 7014       if (parser.boolval('P')) {
// 7015         if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 7016         if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 7017       }
// 7018 
// 7019       const float fval = parser.linearval('F');
// 7020       if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
// 7021 
// 7022       // SCARA kinematic has "safe" XY raw moves
// 7023       //#if IS_SCARA
// 7024       if(MACHINETPYE & IS_SCARA)
// 7025         prepare_uninterpolated_move_to_destination();
// 7026       //#else
// 7027       else
// 7028         prepare_move_to_destination();
// 7029       //#endif
// 7030     }
// 7031   }
// 7032 
// 7033 #endif // HAS_MESH
// 7034 #if 0
// 7035 /**
// 7036  * G92: Set current position to given X Y Z E
// 7037  */
// 7038 inline void gcode_G92() {
// 7039 
// 7040   stepper.synchronize();
// 7041 
// 7042   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7043     switch (parser.subcode) {
// 7044       case 1:
// 7045         // Zero the G92 values and restore current position
// 7046         #if !IS_SCARA
// 7047           LOOP_XYZ(i) {
// 7048             const float v = position_shift[i];
// 7049             if (v) {
// 7050               position_shift[i] = 0;
// 7051               update_software_endstops((AxisEnum)i);
// 7052             }
// 7053           }
// 7054         #endif // Not SCARA
// 7055         return;
// 7056     }
// 7057   #endif
// 7058 
// 7059   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7060     #define IS_G92_0 (parser.subcode == 0)
// 7061   #else
// 7062     #define IS_G92_0 true
// 7063   #endif
// 7064 
// 7065   bool didE = false;
// 7066   bool didXYZ = false;
// 7067   //#if IS_SCARA || !HAS_POSITION_SHIFT
// 7068   if(MACHINETPYE&IS_SCARA) {
// 7069     //bool 
// 7070     didXYZ = false;
// 7071   }
// 7072   //#else
// 7073   else
// 7074   {
// 7075   	#if !HAS_POSITION_SHIFT
// 7076 		//bool 
// 7077 		didXYZ = false;	
// 7078   	#else
// 7079 		//constexpr bool 
// 7080 		didXYZ = false;
// 7081 	#endif
// 7082   }
// 7083   //#endif
// 7084 
// 7085   if (IS_G92_0) LOOP_XYZE(i) {
// 7086     if (parser.seenval(axis_codes[i])) {
// 7087       const float l = parser.value_axis_units((AxisEnum)i),
// 7088                   v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
// 7089                   d = v - current_position[i];
// 7090       if (!NEAR_ZERO(d)) {
// 7091         //#if IS_SCARA || !HAS_POSITION_SHIFT
// 7092         if(MACHINETPYE&IS_SCARA) {
// 7093           if (i == E_AXIS) didE = true; else didXYZ = true;
// 7094           current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
// 7095         }
// 7096 		else
// 7097 		{
// 7098 			#if HAS_POSITION_SHIFT
// 7099 	          if (i == E_AXIS) {
// 7100 	            didE = true;
// 7101 	            current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
// 7102 	          }
// 7103 	          else {
// 7104 	            position_shift[i] += d;       // Other axes simply offset the coordinate space
// 7105 	            update_software_endstops((AxisEnum)i);
// 7106 	          }
// 7107 			
// 7108         	#endif
// 7109 		}
// 7110       }
// 7111     }
// 7112   }
// 7113 
// 7114   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7115     // Apply workspace offset to the active coordinate system
// 7116     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 7117       COPY(coordinate_system[active_coordinate_system], position_shift);
// 7118   #endif
// 7119 
// 7120   if (didXYZ)
// 7121     SYNC_PLAN_POSITION_KINEMATIC();
// 7122   else if (didE)
// 7123     sync_plan_position_e();
// 7124 
// 7125   report_current_position();
// 7126 }
// 7127 #else
// 7128 
// 7129 /**
// 7130  * G92: Set current position to given X Y Z E
// 7131  */
// 7132 inline void gcode_G92() {
// 7133   bool didXYZ = false,
// 7134        didE = parser.seen('E');
// 7135 
// 7136   if (!didE) stepper.synchronize();
// 7137 
// 7138   LOOP_XYZE(i) {
// 7139     if (parser.seenval(axis_codes[i])) {
// 7140       //#if IS_SCARA
// 7141       if(MACHINETPYE&IS_SCARA)
// 7142       {
// 7143         current_position[i] = parser.value_axis_units((AxisEnum)i);
// 7144         if (i != E_AXIS) didXYZ = true;
// 7145       }
// 7146       //#else
// 7147       else
// 7148       {
// 7149         #if HAS_POSITION_SHIFT
// 7150           const float p = current_position[i];
// 7151         #endif
// 7152         float v = parser.value_axis_units((AxisEnum)i);
// 7153 
// 7154         current_position[i] = v;
// 7155 
// 7156         if (i != E_AXIS) {
// 7157           didXYZ = true;
// 7158           #if HAS_POSITION_SHIFT
// 7159             position_shift[i] += v - p; // Offset the coordinate space
// 7160             update_software_endstops((AxisEnum)i);
// 7161           #endif
// 7162         }
// 7163       }
// 7164       //#endif
// 7165     }
// 7166   }
// 7167   if (didXYZ)
// 7168     SYNC_PLAN_POSITION_KINEMATIC();
// 7169   else if (didE)
// 7170     sync_plan_position_e();
// 7171 
// 7172   report_current_position();
// 7173 }
// 7174 
// 7175 #endif
// 7176 #if HAS_RESUME_CONTINUE
// 7177 
// 7178   /**
// 7179    * M0: Unconditional stop - Wait for user button press on LCD
// 7180    * M1: Conditional stop   - Wait for user button press on LCD
// 7181    */
// 7182   inline void gcode_M0_M1() {
// 7183     const char * const args = parser.string_arg;
// 7184 
// 7185     millis_t ms = 0;
// 7186     bool hasP = false, hasS = false;
// 7187     if (parser.seenval('P')) {
// 7188       ms = parser.value_millis(); // milliseconds to wait
// 7189       hasP = ms > 0;
// 7190     }
// 7191     if (parser.seenval('S')) {
// 7192       ms = parser.value_millis_from_seconds(); // seconds to wait
// 7193       hasS = ms > 0;
// 7194     }
// 7195 
// 7196     #if ENABLED(ULTIPANEL)
// 7197 
// 7198       if (!hasP && !hasS && args && *args)
// 7199         lcd_setstatus(args, true);
// 7200       else {
// 7201         LCD_MESSAGEPGM(MSG_USERWAIT);
// 7202         #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
// 7203           dontExpireStatus();
// 7204         #endif
// 7205       }
// 7206 
// 7207     #else
// 7208 
// 7209       if (!hasP && !hasS && args && *args) {
// 7210         SERIAL_ECHO_START();
// 7211         SERIAL_ECHOLN(args);
// 7212       }
// 7213 
// 7214     #endif
// 7215 
// 7216     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7217     wait_for_user = true;
// 7218 
// 7219     stepper.synchronize();
// 7220     refresh_cmd_timeout();
// 7221 
// 7222     if (ms > 0) {
// 7223       ms += previous_cmd_ms;  // wait until this time for a click
// 7224       while (PENDING(millis(), ms) && wait_for_user) idle();
// 7225     }
// 7226     else {
// 7227       #if ENABLED(ULTIPANEL)
// 7228         if (lcd_detected()) {
// 7229           while (wait_for_user) idle();
// 7230           print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
// 7231         }
// 7232       #else
// 7233         while (wait_for_user) idle();
// 7234       #endif
// 7235     }
// 7236 
// 7237     wait_for_user = false;
// 7238     KEEPALIVE_STATE(IN_HANDLER);
// 7239   }
// 7240 
// 7241 #endif // HAS_RESUME_CONTINUE
// 7242 
// 7243 #if ENABLED(SPINDLE_LASER_ENABLE)
// 7244   /**
// 7245    * M3: Spindle Clockwise
// 7246    * M4: Spindle Counter-clockwise
// 7247    *
// 7248    *  S0 turns off spindle.
// 7249    *
// 7250    *  If no speed PWM output is defined then M3/M4 just turns it on.
// 7251    *
// 7252    *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
// 7253    *  Hardware PWM is required. ISRs are too slow.
// 7254    *
// 7255    * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
// 7256    *       No other settings give a PWM signal that goes from 0 to 5 volts.
// 7257    *
// 7258    *       The system automatically sets WGM to Mode 1, so no special
// 7259    *       initialization is needed.
// 7260    *
// 7261    *       WGM bits for timer 2 are automatically set by the system to
// 7262    *       Mode 1. This produces an acceptable 0 to 5 volt signal.
// 7263    *       No special initialization is needed.
// 7264    *
// 7265    * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
// 7266    *       factors for timers 2, 3, 4, and 5 are acceptable.
// 7267    *
// 7268    *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
// 7269    *  the spindle/laser during power-up or when connecting to the host
// 7270    *  (usually goes through a reset which sets all I/O pins to tri-state)
// 7271    *
// 7272    *  PWM duty cycle goes from 0 (off) to 255 (always on).
// 7273    */
// 7274 
// 7275   // Wait for spindle to come up to speed
// 7276   inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
// 7277 
// 7278   // Wait for spindle to stop turning
// 7279   inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
// 7280 
// 7281   /**
// 7282    * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
// 7283    *
// 7284    * it accepts inputs of 0-255
// 7285    */
// 7286 
// 7287   inline void ocr_val_mode() {
// 7288     uint8_t spindle_laser_power = parser.value_byte();
// 7289     WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
// 7290     if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
// 7291     analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
// 7292   }
// 7293 
// 7294   inline void gcode_M3_M4(bool is_M3) {
// 7295 
// 7296     stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
// 7297     #if SPINDLE_DIR_CHANGE
// 7298       const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
// 7299       if (SPINDLE_STOP_ON_DIR_CHANGE \ 
// 7300          && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \ 
// 7301          && READ(SPINDLE_DIR_PIN) != rotation_dir
// 7302       ) {
// 7303         WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
// 7304         delay_for_power_down();
// 7305       }
// 7306       WRITE(SPINDLE_DIR_PIN, rotation_dir);
// 7307     #endif
// 7308 
// 7309     /**
// 7310      * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
// 7311      * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
// 7312      * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
// 7313      */
// 7314     #if ENABLED(SPINDLE_LASER_PWM)
// 7315       if (parser.seen('O')) ocr_val_mode();
// 7316       else {
// 7317         const float spindle_laser_power = parser.floatval('S');
// 7318         if (spindle_laser_power == 0) {
// 7319           WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
// 7320           analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
// 7321           delay_for_power_down();
// 7322         }
// 7323         else {
// 7324           int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
// 7325           NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
// 7326           if (spindle_laser_power <= SPEED_POWER_MIN)
// 7327             ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
// 7328           if (spindle_laser_power >= SPEED_POWER_MAX)
// 7329             ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
// 7330           if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
// 7331           WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
// 7332           analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
// 7333           delay_for_power_up();
// 7334         }
// 7335       }
// 7336     #else
// 7337       WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
// 7338       delay_for_power_up();
// 7339     #endif
// 7340   }
// 7341 
// 7342  /**
// 7343   * M5 turn off spindle
// 7344   */
// 7345   inline void gcode_M5() {
// 7346     stepper.synchronize();
// 7347     WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
// 7348     delay_for_power_down();
// 7349   }
// 7350 
// 7351 #endif // SPINDLE_LASER_ENABLE
// 7352 
// 7353 /**
// 7354  * M17: Enable power on all stepper motors
// 7355  */
// 7356 inline void gcode_M17() {
// 7357   LCD_MESSAGEPGM(MSG_NO_MOVE);
// 7358   enable_all_steppers();
// 7359 }
// 7360 
// 7361 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 7362 
// 7363   static float resume_position[XYZE];
// 7364   static bool move_away_flag = false;
// 7365   #if ENABLED(SDSUPPORT)
// 7366     static bool sd_print_paused = false;
// 7367   #endif
// 7368 
// 7369   static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
// 7370     static millis_t next_buzz = 0;
// 7371     static int8_t runout_beep = 0;
// 7372 
// 7373     if (init) next_buzz = runout_beep = 0;
// 7374 
// 7375     const millis_t ms = millis();
// 7376     if (ELAPSED(ms, next_buzz)) {
// 7377       if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
// 7378         next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
// 7379         BUZZ(300, 2000);
// 7380         runout_beep++;
// 7381       }
// 7382     }
// 7383   }
// 7384 
// 7385   static void ensure_safe_temperature() {
// 7386     bool heaters_heating = true;
// 7387 
// 7388     wait_for_heatup = true;    // M108 will clear this
// 7389     while (wait_for_heatup && heaters_heating) {
// 7390       idle();
// 7391       heaters_heating = false;
// 7392       HOTEND_LOOP() {
// 7393         if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
// 7394           heaters_heating = true;
// 7395           #if ENABLED(ULTIPANEL)
// 7396             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
// 7397           #endif
// 7398           break;
// 7399         }
// 7400       }
// 7401     }
// 7402   }
// 7403 
// 7404   #if IS_KINEMATIC
// 7405     #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
// 7406   #else
// 7407     #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
// 7408   #endif
// 7409 
// 7410   void do_pause_e_move(const float &length, const float fr) {
// 7411     current_position[E_AXIS] += length / planner.e_factor[active_extruder];
// 7412     set_destination_from_current();
// 7413     RUNPLAN(fr);
// 7414     stepper.synchronize();
// 7415   }
// 7416 
// 7417   static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
// 7418                           const int8_t max_beep_count = 0, const bool show_lcd = false
// 7419   ) {
// 7420     if (move_away_flag) return false; // already paused
// 7421 
// 7422     #ifdef ACTION_ON_PAUSE
// 7423       SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
// 7424     #endif
// 7425 
// 7426     if (!DEBUGGING(DRYRUN) && unload_length != 0) {
// 7427       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 7428         if (!thermalManager.allow_cold_extrude &&
// 7429             thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
// 7430           SERIAL_ERROR_START();
// 7431           SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
// 7432           return false;
// 7433         }
// 7434       #endif
// 7435 
// 7436       ensure_safe_temperature(); // wait for extruder to heat up before unloading
// 7437     }
// 7438 
// 7439     // Indicate that the printer is paused
// 7440     move_away_flag = true;
// 7441 
// 7442     // Pause the print job and timer
// 7443     #if ENABLED(SDSUPPORT)
// 7444       if (card.sdprinting) {
// 7445         card.pauseSDPrint();
// 7446         sd_print_paused = true;
// 7447       }
// 7448     #endif
// 7449     print_job_timer.pause();
// 7450 
// 7451     // Show initial message and wait for synchronize steppers
// 7452     if (show_lcd) {
// 7453       #if ENABLED(ULTIPANEL)
// 7454         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
// 7455       #endif
// 7456     }
// 7457 
// 7458     // Save current position
// 7459     stepper.synchronize();
// 7460     COPY(resume_position, current_position);
// 7461 
// 7462     // Initial retract before move to filament change position
// 7463     if (retract && !thermalManager.tooColdToExtrude(active_extruder))
// 7464       do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
// 7465 
// 7466     // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
// 7467     Nozzle::park(2, park_point);
// 7468 
// 7469     if (unload_length != 0) {
// 7470       if (show_lcd) {
// 7471         #if ENABLED(ULTIPANEL)
// 7472           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
// 7473           idle();
// 7474         #endif
// 7475       }
// 7476 
// 7477       // Unload filament
// 7478       do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
// 7479     }
// 7480 
// 7481     if (show_lcd) {
// 7482       #if ENABLED(ULTIPANEL)
// 7483         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7484       #endif
// 7485     }
// 7486 
// 7487     #if HAS_BUZZER
// 7488       filament_change_beep(max_beep_count, true);
// 7489     #endif
// 7490 
// 7491     idle();
// 7492 
// 7493     // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
// 7494     #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
// 7495       disable_e_steppers();
// 7496       safe_delay(100);
// 7497     #endif
// 7498 
// 7499     // Start the heater idle timers
// 7500     const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 7501 
// 7502     HOTEND_LOOP()
// 7503       thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 7504 
// 7505     return true;
// 7506   }
// 7507 
// 7508   static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
// 7509     bool nozzle_timed_out = false;
// 7510 
// 7511     // Wait for filament insert by user and press button
// 7512     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7513     wait_for_user = true;    // LCD click or M108 will clear this
// 7514     while (wait_for_user) {
// 7515       #if HAS_BUZZER
// 7516         filament_change_beep(max_beep_count);
// 7517       #endif
// 7518 
// 7519       // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
// 7520       // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
// 7521       if (!nozzle_timed_out)
// 7522         HOTEND_LOOP()
// 7523           nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 7524 
// 7525       if (nozzle_timed_out) {
// 7526         #if ENABLED(ULTIPANEL)
// 7527           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
// 7528         #endif
// 7529 
// 7530         // Wait for LCD click or M108
// 7531         while (wait_for_user) idle(true);
// 7532 
// 7533         // Re-enable the heaters if they timed out
// 7534         HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
// 7535 
// 7536         // Wait for the heaters to reach the target temperatures
// 7537         ensure_safe_temperature();
// 7538 
// 7539         #if ENABLED(ULTIPANEL)
// 7540           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7541         #endif
// 7542 
// 7543         // Start the heater idle timers
// 7544         const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 7545 
// 7546         HOTEND_LOOP()
// 7547           thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 7548 
// 7549         wait_for_user = true; /* Wait for user to load filament */
// 7550         nozzle_timed_out = false;
// 7551 
// 7552         #if HAS_BUZZER
// 7553           filament_change_beep(max_beep_count, true);
// 7554         #endif
// 7555       }
// 7556 
// 7557       idle(true);
// 7558     }
// 7559     KEEPALIVE_STATE(IN_HANDLER);
// 7560   }
// 7561 
// 7562   static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
// 7563     bool nozzle_timed_out = false;
// 7564 
// 7565     if (!move_away_flag) return;
// 7566 
// 7567     // Re-enable the heaters if they timed out
// 7568     HOTEND_LOOP() {
// 7569       nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 7570       thermalManager.reset_heater_idle_timer(e);
// 7571     }
// 7572 
// 7573     if (nozzle_timed_out) ensure_safe_temperature();
// 7574 
// 7575     #if HAS_BUZZER
// 7576       filament_change_beep(max_beep_count, true);
// 7577     #endif
// 7578 
// 7579     set_destination_from_current();
// 7580 
// 7581     if (load_length != 0) {
// 7582       #if ENABLED(ULTIPANEL)
// 7583         // Show "insert filament"
// 7584         if (nozzle_timed_out)
// 7585           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7586       #endif
// 7587 
// 7588       KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7589       wait_for_user = true;    // LCD click or M108 will clear this
// 7590       while (wait_for_user && nozzle_timed_out) {
// 7591         #if HAS_BUZZER
// 7592           filament_change_beep(max_beep_count);
// 7593         #endif
// 7594         idle(true);
// 7595       }
// 7596       KEEPALIVE_STATE(IN_HANDLER);
// 7597 
// 7598       #if ENABLED(ULTIPANEL)
// 7599         // Show "load" message
// 7600         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
// 7601       #endif
// 7602 
// 7603       // Load filament
// 7604       do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
// 7605     }
// 7606 
// 7607     #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
// 7608 
// 7609       if (!thermalManager.tooColdToExtrude(active_extruder)) {
// 7610         float extrude_length = initial_extrude_length;
// 7611 
// 7612         do {
// 7613           if (extrude_length > 0) {
// 7614             // "Wait for filament extrude"
// 7615             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
// 7616 
// 7617             // Extrude filament to get into hotend
// 7618             do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
// 7619           }
// 7620 
// 7621           // Show "Extrude More" / "Resume" menu and wait for reply
// 7622           KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7623           wait_for_user = false;
// 7624           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
// 7625           while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
// 7626           KEEPALIVE_STATE(IN_HANDLER);
// 7627 
// 7628           extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
// 7629 
// 7630           // Keep looping if "Extrude More" was selected
// 7631         } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
// 7632       }
// 7633 
// 7634     #endif
// 7635 
// 7636     #if ENABLED(ULTIPANEL)
// 7637       // "Wait for print to resume"
// 7638       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
// 7639     #endif
// 7640 
// 7641     // Set extruder to saved position
// 7642     destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
// 7643     planner.set_e_position_mm(current_position[E_AXIS]);
// 7644 
// 7645     // Move XY to starting position, then Z
// 7646     do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
// 7647     do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
// 7648 
// 7649     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 7650       filament_ran_out = false;
// 7651     #endif
// 7652 
// 7653     #if ENABLED(ULTIPANEL)
// 7654       // Show status screen
// 7655       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
// 7656     #endif
// 7657 
// 7658     #ifdef ACTION_ON_RESUME
// 7659       SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
// 7660     #endif
// 7661 
// 7662     #if ENABLED(SDSUPPORT)
// 7663       if (sd_print_paused) {
// 7664         card.startFileprint();
// 7665         sd_print_paused = false;
// 7666       }
// 7667     #endif
// 7668 
// 7669     move_away_flag = false;
// 7670   }
// 7671 #endif // ADVANCED_PAUSE_FEATURE
// 7672 
// 7673 #if ENABLED(SDSUPPORT)
// 7674 
// 7675   /**
// 7676    * M20: List SD card to serial output
// 7677    */
// 7678   inline void gcode_M20() {
// 7679     SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
// 7680     card.ls();
// 7681     SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
// 7682   }
// 7683 
// 7684   /**
// 7685    * M21: Init SD Card
// 7686    */
// 7687   inline void gcode_M21() { card.initsd(); }
// 7688 
// 7689   /**
// 7690    * M22: Release SD Card
// 7691    */
// 7692   inline void gcode_M22() { card.release(); }
// 7693 
// 7694   /**
// 7695    * M23: Open a file
// 7696    */
// 7697    #ifdef USE_MKS_WIFI    
// 7698   inline void gcode_M23() { 
// 7699   	if(card.openFile(parser.command_ptr, true) < 0)
// 7700   	{
// 7701   		/*for 8.3 principle*/
// 7702 		char *gSuffix = strstr((char *)parser.command_ptr, ".g");
// 7703 		if(!gSuffix)
// 7704 		{
// 7705 			gSuffix = strstr((char *)parser.command_ptr, ".G");		
// 7706 		}
// 7707 		if(gSuffix)
// 7708 		{
// 7709 			*(gSuffix + 2) = '\0';
// 7710 			if((uint32_t)gSuffix - (uint32_t)parser.command_ptr > 8)
// 7711 			{
// 7712 				parser.command_ptr[7] = '~';
// 7713 				parser.command_ptr[8] = '.';
// 7714 				parser.command_ptr[9] = 'g';
// 7715 				parser.command_ptr[10] = '\0';
// 7716 			}
// 7717 			card.openFile(parser.command_ptr, true) ;
// 7718 		}
// 7719   	}
// 7720   }
// 7721 #else
// 7722   inline void gcode_M23() {
// 7723     // Simplify3D includes the size, so zero out all spaces (#7227)
// 7724     for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
// 7725     card.openFile(parser.string_arg, true);
// 7726     strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
// 7727   }
// 7728 #endif
// 7729   /**
// 7730    * M24: Start or Resume SD Print
// 7731    */
// 7732   inline void gcode_M24() {
// 7733   	mks_resumePrint();
// 7734   
// 7735     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7736       resume_print();
// 7737     #endif
// 7738 	
// 7739 	#ifdef USE_MKS_WIFI
// 7740 	if(card.lastOpenOk())
// 7741 	#endif	
// 7742 		if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
// 7743 		{
// 7744 
// 7745 	    	card.startFileprint();
// 7746 	    	print_job_timer.start();
// 7747 		}
// 7748   }
// 7749 
// 7750   /**
// 7751    * M25: Pause SD Print
// 7752    */
// 7753   inline void gcode_M25() {
// 7754     card.pauseSDPrint();
// 7755     print_job_timer.pause();
// 7756 
// 7757     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7758       enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
// 7759     #endif
// 7760 	
// 7761 	mksReprint.mks_printer_state = MKS_PAUSING;
// 7762   }
// 7763 /**
// 7764 	 * M998: Stop SD Print
// 7765 */
// 7766 	inline void gcode_M998() {
// 7767 		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
// 7768 		return;
// 7769 			
// 7770 		mksReprint.mks_printer_state = MKS_IDLE;
// 7771         if(gCfgItems.pwroff_save_mode != 1)
// 7772 		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
// 7773 
// 7774 		card.stopSDPrint();
// 7775 		clear_command_queue();
// 7776 		quickstop_stepper();
// 7777 		print_job_timer.stop();
// 7778 		thermalManager.disable_all_heaters();
// 7779 		#if FAN_COUNT > 0
// 7780 			for (uint8_t i = 0; i < FAN_COUNT; i++) 
// 7781             {         
// 7782                 fanSpeeds[i] = 0;
// 7783                 #if 1
// 7784                 MKS_FAN_TIM = 0 ;
// 7785                 #endif
// 7786              }
// 7787 		#endif
// 7788 		wait_for_heatup = false;
// 7789 	}
// 7790 
// 7791   /**
// 7792    * M26: Set SD Card file index
// 7793    */
// 7794   inline void gcode_M26() {
// 7795     if (card.cardOK && parser.seenval('S'))
// 7796       card.setIndex(parser.value_long());
// 7797   }
// 7798 
// 7799   /**
// 7800    * M27: Get SD Card status
// 7801    */
// 7802   inline void gcode_M27() { card.getStatus(); }
// 7803 
// 7804   /**
// 7805    * M28: Start SD Write
// 7806    */
// 7807   inline void gcode_M28() { card.openFile(parser.string_arg, false); }
// 7808 
// 7809   /**
// 7810    * M29: Stop SD Write
// 7811    * Processed in write to file routine above
// 7812    */
// 7813   inline void gcode_M29() {
// 7814     // card.saving = false;
// 7815   }
// 7816 
// 7817   /**
// 7818    * M30 <filename>: Delete SD Card file
// 7819    */
// 7820   inline void gcode_M30() {
// 7821     if (card.cardOK) {
// 7822       card.closefile();
// 7823       card.removeFile(parser.string_arg);
// 7824     }
// 7825   }
// 7826 
// 7827 #endif // SDSUPPORT
// 7828 
// 7829 /**
// 7830  * M31: Get the time since the start of SD Print (or last M109)
// 7831  */
// 7832 inline void gcode_M31() {
// 7833   char buffer[21];
// 7834   duration_t elapsed = print_job_timer.duration();
// 7835   elapsed.toString(buffer);
// 7836   lcd_setstatus(buffer);
// 7837 
// 7838   SERIAL_ECHO_START();
// 7839   SERIAL_ECHOLNPAIR("Print time: ", buffer);
// 7840 }
// 7841 
// 7842 #if ENABLED(SDSUPPORT)
// 7843 
// 7844   /**
// 7845    * M32: Select file and start SD Print
// 7846    *
// 7847    * Examples:
// 7848    *
// 7849    *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
// 7850    *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
// 7851    *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
// 7852    *
// 7853    */
// 7854   inline void gcode_M32() {
// 7855     if (card.sdprinting) stepper.synchronize();
// 7856 
// 7857     if (card.cardOK|| card.usbOK) {
// 7858       const bool call_procedure = parser.boolval('P');
// 7859 
// 7860       card.openFile(parser.string_arg, true, call_procedure);
// 7861 
// 7862       if (parser.seenval('S')) card.setIndex(parser.value_long());
// 7863 
// 7864       card.startFileprint();
// 7865 
// 7866       // Procedure calls count as normal print time.
// 7867       if (!call_procedure) print_job_timer.start();
// 7868     }
// 7869   }
// 7870 
// 7871   #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 7872 
// 7873     /**
// 7874      * M33: Get the long full path of a file or folder
// 7875      *
// 7876      * Parameters:
// 7877      *   <dospath> Case-insensitive DOS-style path to a file or folder
// 7878      *
// 7879      * Example:
// 7880      *   M33 miscel~1/armchair/armcha~1.gco
// 7881      *
// 7882      * Output:
// 7883      *   /Miscellaneous/Armchair/Armchair.gcode
// 7884      */
// 7885     inline void gcode_M33() {
// 7886       card.printLongPath(parser.string_arg);
// 7887     }
// 7888 
// 7889   #endif
// 7890 
// 7891   #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 7892     /**
// 7893      * M34: Set SD Card Sorting Options
// 7894      */
// 7895     inline void gcode_M34() {
// 7896       if (parser.seen('S')) card.setSortOn(parser.value_bool());
// 7897       if (parser.seenval('F')) {
// 7898         const int v = parser.value_long();
// 7899         card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
// 7900       }
// 7901       //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
// 7902     }
// 7903   #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 7904 
// 7905   /**
// 7906    * M928: Start SD Write
// 7907    */
// 7908   inline void gcode_M928() {
// 7909     card.openLogFile(parser.string_arg);
// 7910   }
// 7911 
// 7912 #endif // SDSUPPORT
// 7913 
// 7914 /**
// 7915  * Sensitive pin test for M42, M226
// 7916  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function _Z16pin_is_protecteda
          CFI NoCalls
        THUMB
// 7917 static bool pin_is_protected(const int8_t pin) {
// 7918   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
// 7919   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
_Z16pin_is_protecteda:
        MOVS     R1,#+0
        B.N      ??pin_is_protected_0
??pin_is_protected_1:
        ADDS     R1,R1,#+1
??pin_is_protected_0:
        UXTB     R1,R1
        CMP      R1,#+51
        BCS.N    ??pin_is_protected_2
// 7920     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
        ADR.W    R2,??sensitive_pins
        LDRSB    R2,[R1, R2]
        CMP      R0,R2
        BNE.N    ??pin_is_protected_1
        MOVS     R0,#+1
        BX       LR
// 7921   return false;
??pin_is_protected_2:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock61
// 7922 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??sensitive_pins:
        DC8 0, 1, 1, 0, 2, 3, 3, 6, 5, 7, 8, 8, 11, 10, 12, 13, 14, 14, -1, 21
        DC8 17, -1, -1, -1, 16, 15, 17, -1, -1, 19, 18, 20, -1, -1, 21, 78, 22
        DC8 -1, 79, 23, -1, 80, 19, 18, 20, -1, -1, -1, -1, -1, -1, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        SECTION_GROUP _ZTI5Print
// __absolute char const <Typeinfo for Print>
_ZTI5Print:
        DATA
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs
// __absolute char const <_ZZNK10duration_t8toStringEPcEs>[20]
_ZZNK10duration_t8toStringEPcEs:
        DATA
        DC8 "%iy %id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_0
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_0>[16]
_ZZNK10duration_t8toStringEPcEs_0:
        DATA
        DC8 "%id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_1
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_1>[12]
_ZZNK10duration_t8toStringEPcEs_1:
        DATA
        DC8 "%ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_2
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_2>[8]
_ZZNK10duration_t8toStringEPcEs_2:
        DATA
        DC8 "%im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_3
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_3>[4]
_ZZNK10duration_t8toStringEPcEs_3:
        DATA
        DC8 "%is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs
// __absolute char const <_ZZ19get_serial_commandsvEs>[5]
_ZZ19get_serial_commandsvEs:
        DATA
        DC8 "M110"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_0
// __absolute char const <_ZZ19get_serial_commandsvEs_0>[51]
_ZZ19get_serial_commandsvEs_0:
        DATA
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 20H, 69H, 73H, 20H, 6EH
        DC8 6FH, 74H, 20H, 4CH, 61H, 73H, 74H, 20H
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 2BH, 31H, 2CH, 20H, 4CH
        DC8 61H, 73H, 74H, 20H, 4CH, 69H, 6EH, 65H
        DC8 3AH, 20H, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_1
// __absolute char const <_ZZ19get_serial_commandsvEs_1>[31]
_ZZ19get_serial_commandsvEs_1:
        DATA
        DC8 "checksum mismatch, Last Line: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_2
// __absolute char const <_ZZ19get_serial_commandsvEs_2>[42]
_ZZ19get_serial_commandsvEs_2:
        DATA
        DC8 "No Checksum with line number, Last Line: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_3
// __absolute char const <_ZZ19get_serial_commandsvEs_3>[119]
_ZZ19get_serial_commandsvEs_3:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_4
// __absolute char const <_ZZ19get_serial_commandsvEs_4>[10]
_ZZ19get_serial_commandsvEs_4:
        DATA
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_5
// __absolute char const <_ZZ19get_serial_commandsvEs_5>[5]
_ZZ19get_serial_commandsvEs_5:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_6
// __absolute char const <_ZZ19get_serial_commandsvEs_6>[5]
_ZZ19get_serial_commandsvEs_6:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_7
// __absolute char const <_ZZ19get_serial_commandsvEs_7>[9]
_ZZ19get_serial_commandsvEs_7:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_8
// __absolute char const <_ZZ19get_serial_commandsvEs_8>[5]
_ZZ19get_serial_commandsvEs_8:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs
// __absolute char const <_ZZ19get_sdcard_commandsvEs>[20]
_ZZ19get_sdcard_commandsvEs:
        DATA
        DC8 "Done printing file\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs_0
// __absolute char const <_ZZ19get_sdcard_commandsvEs_0>[15]
_ZZ19get_sdcard_commandsvEs_0:
        DATA
        DC8 "SD read error\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs
// __absolute char const <_ZZ17get_wifi_commandsvEs>[119]
_ZZ17get_wifi_commandsvEs:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_0
// __absolute char const <_ZZ17get_wifi_commandsvEs_0>[10]
_ZZ17get_wifi_commandsvEs_0:
        DATA
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_1
// __absolute char const <_ZZ17get_wifi_commandsvEs_1>[5]
_ZZ17get_wifi_commandsvEs_1:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_2
// __absolute char const <_ZZ17get_wifi_commandsvEs_2>[5]
_ZZ17get_wifi_commandsvEs_2:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_3
// __absolute char const <_ZZ17get_wifi_commandsvEs_3>[9]
_ZZ17get_wifi_commandsvEs_3:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_4
// __absolute char const <_ZZ17get_wifi_commandsvEs_4>[5]
_ZZ17get_wifi_commandsvEs_4:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ24get_homing_bump_feedrate8AxisEnumEs
// __absolute char const <_ZZ24get_homing_bump_feedrate8AxisEnumEs>[34]
_ZZ24get_homing_bump_feedrate8AxisEnumEs:
        DATA
        DC8 "Warning: Homing Bump Divisor < 1\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ11gcode_G2_G3bEs
// __absolute char const <_ZZ11gcode_G2_G3bEs>[22]
_ZZ11gcode_G2_G3bEs:
        DATA
        DC8 "G2/G3 bad parameters\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ8gcode_G4vEs
// __absolute char const <_ZZ8gcode_G4vEs>[9]
_ZZ8gcode_G4vEs:
        DATA
        DC8 "Sleep..."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10home_deltavEs
// __absolute char const <_ZZ10home_deltavEs>[14]
_ZZ10home_deltavEs:
        DATA
        DC8 "Homing failed"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10home_deltavEs_0
// __absolute char const <_ZZ10home_deltavEs_0>[15]
_ZZ10home_deltavEs_0:
        DATA
        DC8 "Homing failed\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs>[23]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs:
        DATA
        DC8 "S out of range (0-5).\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0>[8]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0:
        DATA
        DC8 "State: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1>[4]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2>[4]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3>[32]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3:
        DATA
        DC8 "Mesh bed leveling has no data.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4>[7]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4:
        DATA
        DC8 "G29 S2"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5>[11]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5:
        DATA
        DC8 "G28\012G29 S2"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6>[41]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6:
        DATA
        DC8 "Start mesh probing with \"G29 S1\" first.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7>[20]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7:
        DATA
        DC8 "Mesh probing done.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8:
        DATA
        DC8 "X out of range (1-mksCfg.grid_max_points_x).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9:
        DATA
        DC8 "Y out of range (1-mksCfg.grid_max_points_y).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_>[15]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_:
        DATA
        DC8 "MBL G29 point "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_>[5]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_:
        DATA
        DC8 " of "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs
// __absolute char const <_ZZ9gcode_G29vEs>[23]
_ZZ9gcode_G29vEs:
        DATA
        DC8 "malloc eqnAMatrix err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_0
// __absolute char const <_ZZ9gcode_G29vEs_0>[23]
_ZZ9gcode_G29vEs_0:
        DATA
        DC8 "malloc eqnBVector err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_1
// __absolute char const <_ZZ9gcode_G29vEs_1>[18]
_ZZ9gcode_G29vEs_1:
        DATA
        DC8 "No bilinear grid\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_2
// __absolute char const <_ZZ9gcode_G29vEs_2>[13]
_ZZ9gcode_G29vEs_2:
        DATA
        DC8 "Bad Z value\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_3
// __absolute char const <_ZZ9gcode_G29vEs_3>[40]
_ZZ9gcode_G29vEs_3:
        DATA
        DC8 "?(V)erbose level is implausible (0-4).\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_4
// __absolute char const <_ZZ9gcode_G29vEs_4>[53]
_ZZ9gcode_G29vEs_4:
        DATA
        DC8 3FH, 4EH, 75H, 6DH, 62H, 65H, 72H, 20H
        DC8 6FH, 66H, 20H, 70H, 72H, 6FH, 62H, 65H
        DC8 20H, 70H, 6FH, 69H, 6EH, 74H, 73H, 20H
        DC8 69H, 73H, 20H, 69H, 6DH, 70H, 6CH, 61H
        DC8 75H, 73H, 69H, 62H, 6CH, 65H, 20H, 28H
        DC8 32H, 20H, 6DH, 69H, 6EH, 69H, 6DH, 75H
        DC8 6DH, 29H, 2EH, 0AH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_5
// __absolute char const <_ZZ9gcode_G29vEs_5>[7]
_ZZ9gcode_G29vEs_5:
        DATA
        DC8 "(L)eft"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_6
// __absolute char const <_ZZ9gcode_G29vEs_6>[8]
_ZZ9gcode_G29vEs_6:
        DATA
        DC8 "(R)ight"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_7
// __absolute char const <_ZZ9gcode_G29vEs_7>[8]
_ZZ9gcode_G29vEs_7:
        DATA
        DC8 "(F)ront"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_8
// __absolute char const <_ZZ9gcode_G29vEs_8>[7]
_ZZ9gcode_G29vEs_8:
        DATA
        DC8 "(B)ack"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_9
// __absolute char const <_ZZ9gcode_G29vEs_9>[22]
_ZZ9gcode_G29vEs_9:
        DATA
        DC8 "G29 Auto Bed Leveling"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__10_
// __absolute char const <_ZZ9gcode_G29vEs__10_>[10]
_ZZ9gcode_G29vEs__10_:
        DATA
        DC8 " (DRYRUN)"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__11_
// __absolute char const <_ZZ9gcode_G29vEs__11_>[22]
_ZZ9gcode_G29vEs__11_:
        DATA
        DC8 "Eqn coefficients: a: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__12_
// __absolute char const <_ZZ9gcode_G29vEs__12_>[5]
_ZZ9gcode_G29vEs__12_:
        DATA
        DC8 " b: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__13_
// __absolute char const <_ZZ9gcode_G29vEs__13_>[5]
_ZZ9gcode_G29vEs__13_:
        DATA
        DC8 " d: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__14_
// __absolute char const <_ZZ9gcode_G29vEs__14_>[25]
_ZZ9gcode_G29vEs__14_:
        DATA
        DC8 "Mean of sampled points: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__15_
// __absolute char const <_ZZ9gcode_G29vEs__15_>[195]
_ZZ9gcode_G29vEs__15_:
        DATA
        DC8 0AH, 42H, 65H, 64H, 20H, 48H, 65H, 69H
        DC8 67H, 68H, 74H, 20H, 54H, 6FH, 70H, 6FH
        DC8 67H, 72H, 61H, 70H, 68H, 79H, 3AH, 0AH
        DC8 20H, 20H, 20H, 2BH, 2DH, 2DH, 2DH, 20H
        DC8 42H, 41H, 43H, 4BH, 20H, 2DH, 2DH, 2BH
        DC8 0AH, 20H, 20H, 20H, 7CH, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 7CH, 0AH, 20H, 4CH, 20H, 7CH, 20H, 20H
        DC8 20H, 20H, 28H, 2BH, 29H, 20H, 20H, 20H
        DC8 20H, 7CH, 20H, 52H, 0AH, 20H, 45H, 20H
        DC8 7CH, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 7CH, 20H, 49H, 0AH
        DC8 20H, 46H, 20H, 7CH, 20H, 28H, 2DH, 29H
        DC8 20H, 4EH, 20H, 28H, 2BH, 29H, 20H, 7CH
        DC8 20H, 47H, 0AH, 20H, 54H, 20H, 7CH, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 20H, 20H, 7CH, 20H, 48H, 0AH, 20H, 20H
        DC8 20H, 7CH, 20H, 20H, 20H, 20H, 28H, 2DH
        DC8 29H, 20H, 20H, 20H, 20H, 7CH, 20H, 54H
        DC8 0AH, 20H, 20H, 20H, 7CH, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 7CH, 0AH, 20H, 20H, 20H, 4FH, 2DH, 2DH
        DC8 20H, 46H, 52H, 4FH, 4EH, 54H, 20H, 2DH
        DC8 2DH, 2BH, 0AH, 20H, 28H, 30H, 2CH, 30H
        DC8 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__16_
// __absolute char const <_ZZ9gcode_G29vEs__16_>[3]
_ZZ9gcode_G29vEs__16_:
        DATA
        DC8 " +"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__17_
// __absolute char const <_ZZ9gcode_G29vEs__17_>[41]
_ZZ9gcode_G29vEs__17_:
        DATA
        DC8 "\012Corrected Bed Height vs. Bed Topology:\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__18_
// __absolute char const <_ZZ9gcode_G29vEs__18_>[31]
_ZZ9gcode_G29vEs__18_:
        DATA
        DC8 "\012\012Bed Level Correction Matrix:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs
// __absolute char const <_ZZ9gcode_G30vEs>[8]
_ZZ9gcode_G30vEs:
        DATA
        DC8 "Bed X: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_0
// __absolute char const <_ZZ9gcode_G30vEs_0>[5]
_ZZ9gcode_G30vEs_0:
        DATA
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_1
// __absolute char const <_ZZ9gcode_G30vEs_1>[5]
_ZZ9gcode_G30vEs_1:
        DATA
        DC8 " Z: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G42vEs
// __absolute char const <_ZZ9gcode_G42vEs>[31]
_ZZ9gcode_G42vEs:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M17vEs
// __absolute char const <_ZZ9gcode_M17vEs>[9]
_ZZ9gcode_M17vEs:
        DATA
        DC8 "No move."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs
// __absolute char const <_ZZ9gcode_M20vEs>[17]
_ZZ9gcode_M20vEs:
        DATA
        DC8 "Begin file list\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs_0
// __absolute char const <_ZZ9gcode_M20vEs_0>[15]
_ZZ9gcode_M20vEs_0:
        DATA
        DC8 "End file list\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M31vEs
// __absolute char const <_ZZ9gcode_M31vEs>[13]
_ZZ9gcode_M31vEs:
        DATA
        DC8 "Print time: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M42vEs
// __absolute char const <_ZZ9gcode_M42vEs>[15]
_ZZ9gcode_M42vEs:
        DATA
        DC8 "Protected Pin\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs
// __absolute char const <_ZZ9gcode_M49vEs>[11]
_ZZ9gcode_M49vEs:
        DATA
        DC8 "G26 Debug "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_0
// __absolute char const <_ZZ9gcode_M49vEs_0>[5]
_ZZ9gcode_M49vEs_0:
        DATA
        DC8 "on.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_1
// __absolute char const <_ZZ9gcode_M49vEs_1>[6]
_ZZ9gcode_M49vEs_1:
        DATA
        DC8 "off.\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs
// __absolute char const <_ZZ10gcode_M104vEs>[18]
_ZZ10gcode_M104vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_0
// __absolute char const <_ZZ10gcode_M104vEs_0>[14]
_ZZ10gcode_M104vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_1
// __absolute char const <_ZZ10gcode_M104vEs_1>[14]
_ZZ10gcode_M104vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_2
// __absolute char const <_ZZ10gcode_M104vEs_2>[14]
_ZZ10gcode_M104vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_3
// __absolute char const <_ZZ10gcode_M104vEs_3>[14]
_ZZ10gcode_M104vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_4
// __absolute char const <_ZZ10gcode_M104vEs_4>[14]
_ZZ10gcode_M104vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M105vEs
// __absolute char const <_ZZ10gcode_M105vEs>[3]
_ZZ10gcode_M105vEs:
        DATA
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M112vEs
// __absolute char const <_ZZ10gcode_M112vEs>[9]
_ZZ10gcode_M112vEs:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs
// __absolute char const <_ZZ10gcode_M109vEs>[18]
_ZZ10gcode_M109vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_0
// __absolute char const <_ZZ10gcode_M109vEs_0>[14]
_ZZ10gcode_M109vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_1
// __absolute char const <_ZZ10gcode_M109vEs_1>[14]
_ZZ10gcode_M109vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_2
// __absolute char const <_ZZ10gcode_M109vEs_2>[14]
_ZZ10gcode_M109vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_3
// __absolute char const <_ZZ10gcode_M109vEs_3>[14]
_ZZ10gcode_M109vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_4
// __absolute char const <_ZZ10gcode_M109vEs_4>[14]
_ZZ10gcode_M109vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_5
// __absolute char const <_ZZ10gcode_M109vEs_5>[4]
_ZZ10gcode_M109vEs_5:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_6
// __absolute char const <_ZZ10gcode_M109vEs_6>[14]
_ZZ10gcode_M109vEs_6:
        DATA
        DC8 "Heating done."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs
// __absolute char const <_ZZ10gcode_M190vEs>[13]
_ZZ10gcode_M190vEs:
        DATA
        DC8 "Bed Heating."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs_0
// __absolute char const <_ZZ10gcode_M190vEs_0>[4]
_ZZ10gcode_M190vEs_0:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs_1
// __absolute char const <_ZZ10gcode_M190vEs_1>[10]
_ZZ10gcode_M190vEs_1:
        DATA
        DC8 "Bed done."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_4
// __absolute char const <_ZZ10gcode_M111vEs_4>[7]
_ZZ10gcode_M111vEs_4:
        DATA
        DC8 "DEBUG:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_5
// __absolute char const <_ZZ10gcode_M111vEs_5>[4]
_ZZ10gcode_M111vEs_5:
        DATA
        DC8 "off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M113vEs
// __absolute char const <_ZZ10gcode_M113vEs>[7]
_ZZ10gcode_M113vEs:
        DATA
        DC8 "M113 S"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs
// __absolute char const <_ZZ10gcode_M115vEs>[198]
_ZZ10gcode_M115vEs:
        DATA
        DC8 46H, 49H, 52H, 4DH, 57H, 41H, 52H, 45H
        DC8 5FH, 4EH, 41H, 4DH, 45H, 3AH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 31H, 2EH, 30H
        DC8 2EH, 30H, 20H, 28H, 47H, 69H, 74H, 68H
        DC8 75H, 62H, 29H, 20H, 53H, 4FH, 55H, 52H
        DC8 43H, 45H, 5FH, 43H, 4FH, 44H, 45H, 5FH
        DC8 55H, 52H, 4CH, 3AH, 68H, 74H, 74H, 70H
        DC8 73H, 3AH, 2FH, 2FH, 67H, 69H, 74H, 68H
        DC8 75H, 62H, 2EH, 63H, 6FH, 6DH, 2FH, 4DH
        DC8 61H, 72H, 6CH, 69H, 6EH, 46H, 69H, 72H
        DC8 6DH, 77H, 61H, 72H, 65H, 2FH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 50H, 52H, 4FH
        DC8 54H, 4FH, 43H, 4FH, 4CH, 5FH, 56H, 45H
        DC8 52H, 53H, 49H, 4FH, 4EH, 3AH, 31H, 2EH
        DC8 30H, 20H, 4DH, 41H, 43H, 48H, 49H, 4EH
        DC8 45H, 5FH, 54H, 59H, 50H, 45H, 3AH, 33H
        DC8 44H, 20H, 50H, 72H, 69H, 6EH, 74H, 65H
        DC8 72H, 20H, 45H, 58H, 54H, 52H, 55H, 44H
        DC8 45H, 52H, 5FH, 43H, 4FH, 55H, 4EH, 54H
        DC8 3AH, 32H, 20H, 55H, 55H, 49H, 44H, 3AH
        DC8 63H, 65H, 64H, 65H, 32H, 61H, 32H, 66H
        DC8 2DH, 34H, 31H, 61H, 32H, 2DH, 34H, 37H
        DC8 34H, 38H, 2DH, 39H, 62H, 31H, 32H, 2DH
        DC8 63H, 35H, 35H, 63H, 36H, 32H, 66H, 33H
        DC8 36H, 37H, 66H, 66H, 0AH, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_0
// __absolute char const <_ZZ10gcode_M115vEs_0>[16]
_ZZ10gcode_M115vEs_0:
        DATA
        DC8 "SERIAL_XON_XOFF"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_1
// __absolute char const <_ZZ10gcode_M115vEs_1>[7]
_ZZ10gcode_M115vEs_1:
        DATA
        DC8 "EEPROM"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_2
// __absolute char const <_ZZ10gcode_M115vEs_2>[11]
_ZZ10gcode_M115vEs_2:
        DATA
        DC8 "VOLUMETRIC"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_3
// __absolute char const <_ZZ10gcode_M115vEs_3>[16]
_ZZ10gcode_M115vEs_3:
        DATA
        DC8 "AUTOREPORT_TEMP"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_4
// __absolute char const <_ZZ10gcode_M115vEs_4>[9]
_ZZ10gcode_M115vEs_4:
        DATA
        DC8 "PROGRESS"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_5
// __absolute char const <_ZZ10gcode_M115vEs_5>[10]
_ZZ10gcode_M115vEs_5:
        DATA
        DC8 "PRINT_JOB"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_6
// __absolute char const <_ZZ10gcode_M115vEs_6>[10]
_ZZ10gcode_M115vEs_6:
        DATA
        DC8 "AUTOLEVEL"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_7
// __absolute char const <_ZZ10gcode_M115vEs_7>[8]
_ZZ10gcode_M115vEs_7:
        DATA
        DC8 "Z_PROBE"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_8
// __absolute char const <_ZZ10gcode_M115vEs_8>[14]
_ZZ10gcode_M115vEs_8:
        DATA
        DC8 "LEVELING_DATA"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_9
// __absolute char const <_ZZ10gcode_M115vEs_9>[14]
_ZZ10gcode_M115vEs_9:
        DATA
        DC8 "BUILD_PERCENT"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__10_
// __absolute char const <_ZZ10gcode_M115vEs__10_>[15]
_ZZ10gcode_M115vEs__10_:
        DATA
        DC8 "SOFTWARE_POWER"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__11_
// __absolute char const <_ZZ10gcode_M115vEs__11_>[14]
_ZZ10gcode_M115vEs__11_:
        DATA
        DC8 "TOGGLE_LIGHTS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__12_
// __absolute char const <_ZZ10gcode_M115vEs__12_>[22]
_ZZ10gcode_M115vEs__12_:
        DATA
        DC8 "CASE_LIGHT_BRIGHTNESS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__13_
// __absolute char const <_ZZ10gcode_M115vEs__13_>[17]
_ZZ10gcode_M115vEs__13_:
        DATA
        DC8 "EMERGENCY_PARSER"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M118vEs
// __absolute char const <_ZZ10gcode_M118vEs>[4]
_ZZ10gcode_M118vEs:
        DATA
        DC8 "// "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs
// __absolute char const <_ZZ10gcode_M204vEs>[40]
_ZZ10gcode_M204vEs:
        DATA
        DC8 "Setting Print and Travel Acceleration: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_0
// __absolute char const <_ZZ10gcode_M204vEs_0>[29]
_ZZ10gcode_M204vEs_0:
        DATA
        DC8 "Setting Print Acceleration: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_1
// __absolute char const <_ZZ10gcode_M204vEs_1>[31]
_ZZ10gcode_M204vEs_1:
        DATA
        DC8 "Setting Retract Acceleration: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_2
// __absolute char const <_ZZ10gcode_M204vEs_2>[30]
_ZZ10gcode_M204vEs_2:
        DATA
        DC8 "Setting Travel Acceleration: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ15gcode_M666_dualvEs
// __absolute char const <_ZZ15gcode_M666_dualvEs>[31]
_ZZ15gcode_M666_dualvEs:
        DATA
        DC8 "Dual Endstop Adjustment (mm): "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ15gcode_M666_dualvEs_0
// __absolute char const <_ZZ15gcode_M666_dualvEs_0>[3]
_ZZ15gcode_M666_dualvEs_0:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs
// __absolute char const <_ZZ10gcode_M211vEs>[16]
_ZZ10gcode_M211vEs:
        DATA
        DC8 "Soft endstops: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_0
// __absolute char const <_ZZ10gcode_M211vEs_0>[4]
_ZZ10gcode_M211vEs_0:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_1
// __absolute char const <_ZZ10gcode_M211vEs_1>[4]
_ZZ10gcode_M211vEs_1:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_2
// __absolute char const <_ZZ10gcode_M211vEs_2>[8]
_ZZ10gcode_M211vEs_2:
        DATA
        DC8 "  Min: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        SECTION_GROUP _ZZ10gcode_M211vEs_3
// __absolute char const <_ZZ10gcode_M211vEs_3>[2]
_ZZ10gcode_M211vEs_3:
        DATA
        DC8 "X"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_4
// __absolute char const <_ZZ10gcode_M211vEs_4>[3]
_ZZ10gcode_M211vEs_4:
        DATA
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_5
// __absolute char const <_ZZ10gcode_M211vEs_5>[3]
_ZZ10gcode_M211vEs_5:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_6
// __absolute char const <_ZZ10gcode_M211vEs_6>[8]
_ZZ10gcode_M211vEs_6:
        DATA
        DC8 "  Max: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M218vEs
// __absolute char const <_ZZ10gcode_M218vEs>[16]
_ZZ10gcode_M218vEs:
        DATA
        DC8 "Hotend offsets:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs
// __absolute char const <_ZZ10gcode_M280vEs>[8]
_ZZ10gcode_M280vEs:
        DATA
        DC8 " Servo "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs_0
// __absolute char const <_ZZ10gcode_M280vEs_0>[15]
_ZZ10gcode_M280vEs_0:
        DATA
        DC8 " out of range\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs_1
// __absolute char const <_ZZ10gcode_M280vEs_1>[7]
_ZZ10gcode_M280vEs_1:
        DATA
        DC8 "Servo "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs
// __absolute char const <_ZZ10gcode_M301vEs>[4]
_ZZ10gcode_M301vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_0
// __absolute char const <_ZZ10gcode_M301vEs_0>[4]
_ZZ10gcode_M301vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_1
// __absolute char const <_ZZ10gcode_M301vEs_1>[4]
_ZZ10gcode_M301vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_2
// __absolute char const <_ZZ10gcode_M301vEs_2>[17]
_ZZ10gcode_M301vEs_2:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs
// __absolute char const <_ZZ10gcode_M304vEs>[4]
_ZZ10gcode_M304vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_0
// __absolute char const <_ZZ10gcode_M304vEs_0>[4]
_ZZ10gcode_M304vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_1
// __absolute char const <_ZZ10gcode_M304vEs_1>[4]
_ZZ10gcode_M304vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs
// __absolute char const <_ZZ10gcode_M302vEs>[19]
_ZZ10gcode_M302vEs:
        DATA
        DC8 "Cold extrudes are "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_0
// __absolute char const <_ZZ10gcode_M302vEs_0>[3]
_ZZ10gcode_M302vEs_0:
        DATA
        DC8 "en"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_1
// __absolute char const <_ZZ10gcode_M302vEs_1>[4]
_ZZ10gcode_M302vEs_1:
        DATA
        DC8 "dis"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_2
// __absolute char const <_ZZ10gcode_M302vEs_2>[17]
_ZZ10gcode_M302vEs_2:
        DATA
        DC8 "abled (min temp "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_3
// __absolute char const <_ZZ10gcode_M302vEs_3>[4]
_ZZ10gcode_M302vEs_3:
        DATA
        DC8 "C)\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M303vEs
// __absolute char const <_ZZ10gcode_M303vEs>[18]
_ZZ10gcode_M303vEs:
        DATA
        DC8 "PIDTEMP disabled\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M360vEs
// __absolute char const <_ZZ10gcode_M360vEs>[15]
_ZZ10gcode_M360vEs:
        DATA
        DC8 " Cal: Theta 0\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M361vEs
// __absolute char const <_ZZ10gcode_M361vEs>[16]
_ZZ10gcode_M361vEs:
        DATA
        DC8 " Cal: Theta 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M362vEs
// __absolute char const <_ZZ10gcode_M362vEs>[13]
_ZZ10gcode_M362vEs:
        DATA
        DC8 " Cal: Psi 0\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M363vEs
// __absolute char const <_ZZ10gcode_M363vEs>[14]
_ZZ10gcode_M363vEs:
        DATA
        DC8 " Cal: Psi 90\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M364vEs
// __absolute char const <_ZZ10gcode_M364vEs>[20]
_ZZ10gcode_M364vEs:
        DATA
        DC8 " Cal: Theta-Psi 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs
// __absolute char const <_ZZ10gcode_M420vEs>[32]
_ZZ10gcode_M420vEs:
        DATA
        DC8 "?EEPROM storage not available.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_0
// __absolute char const <_ZZ10gcode_M420vEs_0>[24]
_ZZ10gcode_M420vEs_0:
        DATA
        DC8 "?Invalid storage slot.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_1
// __absolute char const <_ZZ10gcode_M420vEs_1>[11]
_ZZ10gcode_M420vEs_1:
        DATA
        DC8 "?Use 0 to "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_2
// __absolute char const <_ZZ10gcode_M420vEs_2>[21]
_ZZ10gcode_M420vEs_2:
        DATA
        DC8 "ubl.mesh_is_valid = "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_3
// __absolute char const <_ZZ10gcode_M420vEs_3>[20]
_ZZ10gcode_M420vEs_3:
        DATA
        DC8 "ubl.storage_slot = "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_4
// __absolute char const <_ZZ10gcode_M420vEs_4>[29]
_ZZ10gcode_M420vEs_4:
        DATA
        DC8 "Bed Level Correction Matrix:"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_5
// __absolute char const <_ZZ10gcode_M420vEs_5>[22]
_ZZ10gcode_M420vEs_5:
        DATA
        DC8 "Mesh Bed Level data:\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_6
// __absolute char const <_ZZ10gcode_M420vEs_6>[31]
_ZZ10gcode_M420vEs_6:
        DATA
        DC8 "Failed to enable Bed Leveling\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_7
// __absolute char const <_ZZ10gcode_M420vEs_7>[14]
_ZZ10gcode_M420vEs_7:
        DATA
        DC8 "Bed Leveling "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_8
// __absolute char const <_ZZ10gcode_M420vEs_8>[4]
_ZZ10gcode_M420vEs_8:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_9
// __absolute char const <_ZZ10gcode_M420vEs_9>[4]
_ZZ10gcode_M420vEs_9:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs__10_
// __absolute char const <_ZZ10gcode_M420vEs__10_>[13]
_ZZ10gcode_M420vEs__10_:
        DATA
        DC8 "Fade Height "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs__11_
// __absolute char const <_ZZ10gcode_M420vEs__11_>[5]
_ZZ10gcode_M420vEs__11_:
        DATA
        DC8 "Off\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs>[32]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0>[31]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
// __absolute char const <_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs>[32]
_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
// __absolute char const <_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0>[31]
_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
// __absolute char const <_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs>[32]
_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
// __absolute char const <_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0>[31]
_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs
// __absolute char const <_ZZ10gcode_M428vEs>[30]
_ZZ10gcode_M428vEs:
        DATA
        DC8 "Too far from reference point\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_0
// __absolute char const <_ZZ10gcode_M428vEs_0>[14]
_ZZ10gcode_M428vEs_0:
        DATA
        DC8 "Err: Too far!"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_1
// __absolute char const <_ZZ10gcode_M428vEs_1>[16]
_ZZ10gcode_M428vEs_1:
        DATA
        DC8 "Offsets applied"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs
// __absolute char const <_ZZ10gcode_M851vEs>[15]
_ZZ10gcode_M851vEs:
        DATA
        DC8 "Probe Z Offset"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_0
// __absolute char const <_ZZ10gcode_M851vEs_0>[25]
_ZZ10gcode_M851vEs_0:
        DATA
        DC8 " z_min:  -20 z_max:  20\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_1
// __absolute char const <_ZZ10gcode_M851vEs_1>[3]
_ZZ10gcode_M851vEs_1:
        DATA
        DC8 ": "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M355vEs
// __absolute char const <_ZZ10gcode_M355vEs>[15]
_ZZ10gcode_M355vEs:
        DATA
        DC8 "No case light\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ22invalid_extruder_errorhEs
// __absolute char const <_ZZ22invalid_extruder_errorhEs>[17]
_ZZ22invalid_extruder_errorhEs:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0
// 7923 
// 7924 /**
// 7925  * M42: Change pin status via GCode
// 7926  *
// 7927  *  P<pin>  Pin number (LED if omitted)
// 7928  *  S<byte> Pin status from 0 - 255
// 7929  */
// 7930 inline void gcode_M42() {
// 7931   if (!parser.seenval('S')) return;
// 7932   const byte pin_status = parser.value_byte();
// 7933 
// 7934   const int pin_number = parser.intval('P', LED_PIN);
// 7935   if (pin_number < 0) return;
// 7936 
// 7937   if (pin_is_protected(pin_number)) {
// 7938     SERIAL_ERROR_START();
// 7939     SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
// 7940     return;
// 7941   }
// 7942 
// 7943   pinMode(pin_number, OUTPUT);
// 7944   digitalWrite(pin_number, pin_status);
// 7945   //analogWrite(pin_number, pin_status);
// 7946 
// 7947   #if FAN_COUNT > 0
// 7948     switch (pin_number) {
// 7949       #if HAS_FAN0
// 7950         case FAN_PIN: fanSpeeds[0] = pin_status; break;
// 7951       #endif
// 7952       #if HAS_FAN1
// 7953         case FAN1_PIN: fanSpeeds[1] = pin_status; break;
// 7954       #endif
// 7955       #if HAS_FAN2
// 7956         case FAN2_PIN: fanSpeeds[2] = pin_status; break;
// 7957       #endif
// 7958     }
// 7959   #endif
// 7960 }
// 7961 
// 7962 #if ENABLED(PINS_DEBUGGING)
// 7963 
// 7964   #include "pinsDebug.h"
// 7965 
// 7966   inline void toggle_pins() {
// 7967     const bool I_flag = parser.boolval('I');
// 7968     const int repeat = parser.intval('R', 1),
// 7969               start = parser.intval('S'),
// 7970               end = parser.intval('L', NUM_DIGITAL_PINS - 1),
// 7971               wait = parser.intval('W', 500);
// 7972 
// 7973     for (uint8_t pin = start; pin <= end; pin++) {
// 7974       //report_pin_state_extended(pin, I_flag, false);
// 7975 
// 7976       if (!I_flag && pin_is_protected(pin)) {
// 7977         report_pin_state_extended(pin, I_flag, true, "Untouched ");
// 7978         SERIAL_EOL();
// 7979       }
// 7980       else {
// 7981         report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
// 7982         #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
// 7983           if (pin == TEENSY_E2) {
// 7984             SET_OUTPUT(TEENSY_E2);
// 7985             for (int16_t j = 0; j < repeat; j++) {
// 7986               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7987               WRITE(TEENSY_E2, HIGH); safe_delay(wait);
// 7988               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7989             }
// 7990           }
// 7991           else if (pin == TEENSY_E3) {
// 7992             SET_OUTPUT(TEENSY_E3);
// 7993             for (int16_t j = 0; j < repeat; j++) {
// 7994               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7995               WRITE(TEENSY_E3, HIGH); safe_delay(wait);
// 7996               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7997             }
// 7998           }
// 7999           else
// 8000         #endif
// 8001         {
// 8002           pinMode(pin, OUTPUT);
// 8003           for (int16_t j = 0; j < repeat; j++) {
// 8004             digitalWrite(pin, 0); safe_delay(wait);
// 8005             digitalWrite(pin, 1); safe_delay(wait);
// 8006             digitalWrite(pin, 0); safe_delay(wait);
// 8007           }
// 8008         }
// 8009 
// 8010       }
// 8011       SERIAL_EOL();
// 8012     }
// 8013     SERIAL_ECHOLNPGM("Done.");
// 8014 
// 8015   } // toggle_pins
// 8016 
// 8017   inline void servo_probe_test() {
// 8018     #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
// 8019 
// 8020       SERIAL_ERROR_START();
// 8021       SERIAL_ERRORLNPGM("SERVO not setup");
// 8022 
// 8023     #elif !HAS_Z_SERVO_ENDSTOP
// 8024 
// 8025       SERIAL_ERROR_START();
// 8026       SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
// 8027 
// 8028     #else // HAS_Z_SERVO_ENDSTOP
// 8029 
// 8030       const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
// 8031 
// 8032       SERIAL_PROTOCOLLNPGM("Servo probe test");
// 8033       SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
// 8034       SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
// 8035       SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
// 8036 
// 8037       bool probe_inverting;
// 8038 
// 8039       //#if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 8040       uint8_t PROBE_TEST_PIN = 0;
// 8041 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 8042 	  {
// 8043 
// 8044        // #define PROBE_TEST_PIN Z_MIN_PIN
// 8045 	   PROBE_TEST_PIN = Z_MIN_PIN;
// 8046 
// 8047         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
// 8048         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
// 8049         SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
// 8050 /*
// 8051         #if Z_MIN_ENDSTOP_INVERTING
// 8052           SERIAL_PROTOCOLLNPGM("true");
// 8053         #else
// 8054           SERIAL_PROTOCOLLNPGM("false");
// 8055         #endif
// 8056 */		if(Z_MIN_ENDSTOP_INVERTING)
// 8057 			SERIAL_PROTOCOLLNPGM("true");
// 8058 		else
// 8059 			SERIAL_PROTOCOLLNPGM("false");
// 8060 		/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 8061 
// 8062         probe_inverting = Z_MIN_ENDSTOP_INVERTING;
// 8063 	  }
// 8064       //#elif ENABLED(Z_MIN_PROBE_ENDSTOP)
// 8065 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
// 8066 	  {
// 8067         //#define PROBE_TEST_PIN Z_MIN_PROBE_PIN
// 8068         PROBE_TEST_PIN = Z_MAX_PIN;
// 8069         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
// 8070         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
// 8071         SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
// 8072 /*
// 8073         #if Z_MIN_PROBE_ENDSTOP_INVERTING
// 8074           SERIAL_PROTOCOLLNPGM("true");
// 8075         #else
// 8076           SERIAL_PROTOCOLLNPGM("false");
// 8077         #endif
// 8078 */
// 8079 		if(Z_MIN_PROBE_ENDSTOP_INVERTING)
// 8080 			SERIAL_PROTOCOLLNPGM("true");
// 8081 		else
// 8082 			SERIAL_PROTOCOLLNPGM("false");
// 8083 	/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 8084 
// 8085         probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
// 8086 	  }
// 8087       //#endif
// 8088 
// 8089       SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
// 8090       SET_INPUT_PULLUP(PROBE_TEST_PIN);
// 8091       bool deploy_state, stow_state;
// 8092       for (uint8_t i = 0; i < 4; i++) {
// 8093         MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
// 8094         safe_delay(500);
// 8095         deploy_state = READ(PROBE_TEST_PIN);
// 8096         MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 8097         safe_delay(500);
// 8098         stow_state = READ(PROBE_TEST_PIN);
// 8099       }
// 8100       if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
// 8101 
// 8102       refresh_cmd_timeout();
// 8103 
// 8104       if (deploy_state != stow_state) {
// 8105         SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
// 8106         if (deploy_state) {
// 8107           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
// 8108           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
// 8109         }
// 8110         else {
// 8111           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
// 8112           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
// 8113         }
// 8114         //#if ENABLED(BLTOUCH)
// 8115         if(MKSTOUCH == 1)
// 8116           SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
// 8117         //#endif
// 8118 
// 8119       }
// 8120       else {                                           // measure active signal length
// 8121         MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
// 8122         safe_delay(500);
// 8123         SERIAL_PROTOCOLLNPGM("please trigger probe");
// 8124         uint16_t probe_counter = 0;
// 8125 
// 8126         // Allow 30 seconds max for operator to trigger probe
// 8127         for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
// 8128 
// 8129           safe_delay(2);
// 8130 
// 8131           if (0 == j % (500 * 1)) // keep cmd_timeout happy
// 8132             refresh_cmd_timeout();
// 8133 
// 8134           if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
// 8135 
// 8136             for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
// 8137               safe_delay(2);
// 8138 
// 8139             if (probe_counter == 50)
// 8140               SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
// 8141             else if (probe_counter >= 2)
// 8142               SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
// 8143             else
// 8144               SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
// 8145 
// 8146             MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 8147 
// 8148           }  // pulse detected
// 8149 
// 8150         } // for loop waiting for trigger
// 8151 
// 8152         if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
// 8153 
// 8154       } // measure active signal length
// 8155 
// 8156     #endif
// 8157 
// 8158   } // servo_probe_test
// 8159 
// 8160   /**
// 8161    * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
// 8162    *
// 8163    *  M43         - report name and state of pin(s)
// 8164    *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
// 8165    *                  I       Flag to ignore Marlin's pin protection.
// 8166    *
// 8167    *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
// 8168    *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
// 8169    *                  I       Flag to ignore Marlin's pin protection.
// 8170    *
// 8171    *  M43 E<bool> - Enable / disable background endstop monitoring
// 8172    *                  - Machine continues to operate
// 8173    *                  - Reports changes to endstops
// 8174    *                  - Toggles LED_PIN when an endstop changes
// 8175    *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
// 8176    *
// 8177    *  M43 T       - Toggle pin(s) and report which pin is being toggled
// 8178    *                  S<pin>  - Start Pin number.   If not given, will default to 0
// 8179    *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
// 8180    *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
// 8181    *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
// 8182    *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
// 8183    *
// 8184    *  M43 S       - Servo probe test
// 8185    *                  P<index> - Probe index (optional - defaults to 0
// 8186    */
// 8187   inline void gcode_M43() {
// 8188 
// 8189     if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
// 8190       toggle_pins();
// 8191       return;
// 8192     }
// 8193 
// 8194     // Enable or disable endstop monitoring
// 8195     if (parser.seen('E')) {
// 8196       endstop_monitor_flag = parser.value_bool();
// 8197       SERIAL_PROTOCOLPGM("endstop monitor ");
// 8198       serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
// 8199       SERIAL_PROTOCOLLNPGM("abled");
// 8200       return;
// 8201     }
// 8202 
// 8203     if (parser.seen('S')) {
// 8204       servo_probe_test();
// 8205       return;
// 8206     }
// 8207 
// 8208     // Get the range of pins to test or watch
// 8209     const uint8_t first_pin = parser.byteval('P'),
// 8210                   last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
// 8211 
// 8212     if (first_pin > last_pin) return;
// 8213 
// 8214     const bool ignore_protection = parser.boolval('I');
// 8215 
// 8216     // Watch until click, M108, or reset
// 8217     if (parser.boolval('W')) {
// 8218       SERIAL_PROTOCOLLNPGM("Watching pins");
// 8219       byte pin_state[last_pin - first_pin + 1];
// 8220       for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 8221         if (pin_is_protected(pin) && !ignore_protection) continue;
// 8222         pinMode(pin, INPUT_PULLUP);
// 8223         delay(1);
// 8224         /*
// 8225           if (IS_ANALOG(pin))
// 8226             pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
// 8227           else
// 8228         //
// 8229         */
// 8230             pin_state[pin - first_pin] = digitalRead(pin);
// 8231       }
// 8232 
// 8233       #if HAS_RESUME_CONTINUE
// 8234         wait_for_user = true;
// 8235         KEEPALIVE_STATE(PAUSED_FOR_USER);
// 8236       #endif
// 8237 
// 8238       for (;;) {
// 8239         for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 8240           if (pin_is_protected(pin) && !ignore_protection) continue;
// 8241           const byte val =
// 8242             /*
// 8243               IS_ANALOG(pin)
// 8244                 ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
// 8245                 :
// 8246             //
// 8247             */
// 8248               digitalRead(pin);
// 8249           if (val != pin_state[pin - first_pin]) {
// 8250             report_pin_state_extended(pin, ignore_protection, false);
// 8251             pin_state[pin - first_pin] = val;
// 8252           }
// 8253         }
// 8254 
// 8255         #if HAS_RESUME_CONTINUE
// 8256           if (!wait_for_user) {
// 8257             KEEPALIVE_STATE(IN_HANDLER);
// 8258             break;
// 8259           }
// 8260         #endif
// 8261 
// 8262         safe_delay(200);
// 8263       }
// 8264       return;
// 8265     }
// 8266 
// 8267     // Report current state of selected pin(s)
// 8268     for (uint8_t pin = first_pin; pin <= last_pin; pin++)
// 8269       report_pin_state_extended(pin, ignore_protection, true);
// 8270   }
// 8271 
// 8272 #endif // PINS_DEBUGGING
// 8273 
// 8274 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 8275 
// 8276   /**
// 8277    * M48: Z probe repeatability measurement function.
// 8278    *
// 8279    * Usage:
// 8280    *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
// 8281    *     P = Number of sampled points (4-50, default 10)
// 8282    *     X = Sample X position
// 8283    *     Y = Sample Y position
// 8284    *     V = Verbose level (0-4, default=1)
// 8285    *     E = Engage Z probe for each reading
// 8286    *     L = Number of legs of movement before probe
// 8287    *     S = Schizoid (Or Star if you prefer)
// 8288    *
// 8289    * This function requires the machine to be homed before invocation.
// 8290    */
// 8291   inline void gcode_M48() {
// 8292 
// 8293     if (axis_unhomed_error()) return;
// 8294 
// 8295     const int8_t verbose_level = parser.byteval('V', 1);
// 8296     if (!WITHIN(verbose_level, 0, 4)) {
// 8297       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 8298       return;
// 8299     }
// 8300 
// 8301     if (verbose_level > 0)
// 8302       SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
// 8303 
// 8304     const int8_t n_samples = parser.byteval('P', 10);
// 8305     if (!WITHIN(n_samples, 4, 50)) {
// 8306       SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
// 8307       return;
// 8308     }
// 8309 
// 8310     const bool stow_probe_after_each = parser.boolval('E');
// 8311 
// 8312     float X_current = current_position[X_AXIS],
// 8313           Y_current = current_position[Y_AXIS];
// 8314 
// 8315     const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
// 8316                 Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 8317 
// 8318     //#if DISABLED(DELTA)
// 8319     if(MACHINETPYE != DELTA)
// 8320     {
// 8321       if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
// 8322         out_of_range_error(PSTR("X"));
// 8323         return;
// 8324       }
// 8325       if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
// 8326         out_of_range_error(PSTR("Y"));
// 8327         return;
// 8328       }
// 8329     }
// 8330     //#else
// 8331     else
// 8332      {
// 8333      if(MACHINETPYE & IS_KINEMATIC)
// 8334         {
// 8335       if (!position_is_reachable_by_probe_IS_KINEMATIC(X_probe_location, Y_probe_location)) {
// 8336         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 8337         return;
// 8338       }
// 8339         }
// 8340      else
// 8341         {
// 8342       if (!position_is_reachable_by_probe_IS_CARTESIAN(X_probe_location, Y_probe_location)) {
// 8343         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 8344         return;
// 8345       }
// 8346         }        
// 8347      }
// 8348     //#endif
// 8349 
// 8350     bool seen_L = parser.seen('L');
// 8351     uint8_t n_legs = seen_L ? parser.value_byte() : 0;
// 8352     if (n_legs > 15) {
// 8353       SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
// 8354       return;
// 8355     }
// 8356     if (n_legs == 1) n_legs = 2;
// 8357 
// 8358     const bool schizoid_flag = parser.boolval('S');
// 8359     if (schizoid_flag && !seen_L) n_legs = 7;
// 8360 
// 8361     /**
// 8362      * Now get everything to the specified probe point So we can safely do a
// 8363      * probe to get us close to the bed.  If the Z-Axis is far from the bed,
// 8364      * we don't want to use that as a starting point for each probe.
// 8365      */
// 8366     if (verbose_level > 2)
// 8367       SERIAL_PROTOCOLLNPGM("Positioning the probe...");
// 8368 
// 8369     // Disable bed level correction in M48 because we want the raw data when we probe
// 8370 /*
// 8371     #if HAS_LEVELING
// 8372       const bool was_enabled = planner.leveling_active;
// 8373       set_bed_leveling_enabled(false);
// 8374     #endif
// 8375 */
// 8376 	bool was_enabled;
// 8377 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 8378 		was_enabled = ubl.state.active;
// 8379 	else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 8380 		was_enabled = mbl.active();
// 8381 	else if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 8382 		was_enabled = planner.leveling_active;
// 8383 
// 8384 	if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 8385 		set_bed_leveling_enabled(false);
// 8386 
// 8387     setup_for_endstop_or_probe_move();
// 8388 
// 8389     double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
// 8390 
// 8391     // Move to the first point, deploy, and probe
// 8392     const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
// 8393     bool probing_good = !isnan(t);
// 8394 
// 8395     if (probing_good) {
// 8396       //randomSeed(millis());
// 8397 	  srand(millis());
// 8398 
// 8399       for (uint8_t n = 0; n < n_samples; n++) {
// 8400         if (n_legs) {
// 8401           const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
// 8402           float angle = random(0.0, 360.0);
// 8403           const float radius = random(
// 8404             #if ENABLED(DELTA)
// 8405               0.1250000000 * (DELTA_PROBEABLE_RADIUS),
// 8406               0.3333333333 * (DELTA_PROBEABLE_RADIUS)
// 8407             #else
// 8408               5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
// 8409             #endif
// 8410           );
// 8411 
// 8412           if (verbose_level > 3) {
// 8413             SERIAL_ECHOPAIR("Starting radius: ", radius);
// 8414             SERIAL_ECHOPAIR("   angle: ", angle);
// 8415             SERIAL_ECHOPGM(" Direction: ");
// 8416             if (dir > 0) SERIAL_ECHOPGM("Counter-");
// 8417             SERIAL_ECHOLNPGM("Clockwise");
// 8418           }
// 8419 
// 8420           for (uint8_t l = 0; l < n_legs - 1; l++) {
// 8421             double delta_angle;
// 8422 
// 8423             if (schizoid_flag)
// 8424               // The points of a 5 point star are 72 degrees apart.  We need to
// 8425               // skip a point and go to the next one on the star.
// 8426               delta_angle = dir * 2.0 * 72.0;
// 8427 
// 8428             else
// 8429               // If we do this line, we are just trying to move further
// 8430               // around the circle.
// 8431               delta_angle = dir * (float) random(25, 45);
// 8432 
// 8433             angle += delta_angle;
// 8434 
// 8435             while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
// 8436               angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
// 8437             while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
// 8438               angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
// 8439 
// 8440             X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
// 8441             Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
// 8442 
// 8443             //#if DISABLED(DELTA)
// 8444             if(MACHINETPYE != DELTA)
// 8445             {
// 8446               X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
// 8447               Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
// 8448             }
// 8449             //#else
// 8450             else
// 8451             {
// 8452               // If we have gone out too far, we can do a simple fix and scale the numbers
// 8453               // back in closer to the origin.
// 8454               if(MACHINETPYE & IS_KINEMATIC)
// 8455                 {
// 8456               while (!position_is_reachable_by_probe_IS_KINEMATIC(X_current, Y_current)) {
// 8457                 X_current *= 0.8;
// 8458                 Y_current *= 0.8;
// 8459                 if (verbose_level > 3) {
// 8460                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 8461                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 8462                 }
// 8463               }
// 8464                 }
// 8465               else
// 8466                  {
// 8467               while (!position_is_reachable_by_probe_IS_CARTESIAN(X_current, Y_current)) {
// 8468                 X_current *= 0.8;
// 8469                 Y_current *= 0.8;
// 8470                 if (verbose_level > 3) {
// 8471                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 8472                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 8473                 }
// 8474               }
// 8475                 }               
// 8476             }
// 8477             //#endif
// 8478             if (verbose_level > 3) {
// 8479               SERIAL_PROTOCOLPGM("Going to:");
// 8480               SERIAL_ECHOPAIR(" X", X_current);
// 8481               SERIAL_ECHOPAIR(" Y", Y_current);
// 8482               SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
// 8483             }
// 8484             do_blocking_move_to_xy(X_current, Y_current);
// 8485           } // n_legs loop
// 8486         } // n_legs
// 8487 
// 8488         // Probe a single point
// 8489         sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
// 8490 
// 8491         // Break the loop if the probe fails
// 8492         probing_good = !isnan(sample_set[n]);
// 8493         if (!probing_good) break;
// 8494 
// 8495         /**
// 8496          * Get the current mean for the data points we have so far
// 8497          */
// 8498         double sum = 0.0;
// 8499         for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
// 8500         mean = sum / (n + 1);
// 8501 
// 8502         NOMORE(min, sample_set[n]);
// 8503         NOLESS(max, sample_set[n]);
// 8504 
// 8505         /**
// 8506          * Now, use that mean to calculate the standard deviation for the
// 8507          * data points we have so far
// 8508          */
// 8509         sum = 0.0;
// 8510         for (uint8_t j = 0; j <= n; j++)
// 8511           sum += sq(sample_set[j] - mean);
// 8512 
// 8513         sigma = SQRT(sum / (n + 1));
// 8514         if (verbose_level > 0) {
// 8515           if (verbose_level > 1) {
// 8516             SERIAL_PROTOCOL(n + 1);
// 8517             SERIAL_PROTOCOLPGM(" of ");
// 8518             SERIAL_PROTOCOL((int)n_samples);
// 8519             SERIAL_PROTOCOLPGM(": z: ");
// 8520             SERIAL_PROTOCOL_F(sample_set[n], 3);
// 8521             if (verbose_level > 2) {
// 8522               SERIAL_PROTOCOLPGM(" mean: ");
// 8523               SERIAL_PROTOCOL_F(mean, 4);
// 8524               SERIAL_PROTOCOLPGM(" sigma: ");
// 8525               SERIAL_PROTOCOL_F(sigma, 6);
// 8526               SERIAL_PROTOCOLPGM(" min: ");
// 8527               SERIAL_PROTOCOL_F(min, 3);
// 8528               SERIAL_PROTOCOLPGM(" max: ");
// 8529               SERIAL_PROTOCOL_F(max, 3);
// 8530               SERIAL_PROTOCOLPGM(" range: ");
// 8531               SERIAL_PROTOCOL_F(max-min, 3);
// 8532             }
// 8533             SERIAL_EOL();
// 8534           }
// 8535         }
// 8536 
// 8537       } // n_samples loop
// 8538     }
// 8539 
// 8540     STOW_PROBE();
// 8541 
// 8542     if (probing_good) {
// 8543       SERIAL_PROTOCOLLNPGM("Finished!");
// 8544 
// 8545       if (verbose_level > 0) {
// 8546         SERIAL_PROTOCOLPGM("Mean: ");
// 8547         SERIAL_PROTOCOL_F(mean, 6);
// 8548         SERIAL_PROTOCOLPGM(" Min: ");
// 8549         SERIAL_PROTOCOL_F(min, 3);
// 8550         SERIAL_PROTOCOLPGM(" Max: ");
// 8551         SERIAL_PROTOCOL_F(max, 3);
// 8552         SERIAL_PROTOCOLPGM(" Range: ");
// 8553         SERIAL_PROTOCOL_F(max-min, 3);
// 8554         SERIAL_EOL();
// 8555       }
// 8556 
// 8557       SERIAL_PROTOCOLPGM("Standard Deviation: ");
// 8558       SERIAL_PROTOCOL_F(sigma, 6);
// 8559       SERIAL_EOL();
// 8560       SERIAL_EOL();
// 8561     }
// 8562 
// 8563     clean_up_after_endstop_or_probe_move();
// 8564 
// 8565     // Re-enable bed level correction if it had been on
// 8566     //#if HAS_LEVELING
// 8567     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 8568       set_bed_leveling_enabled(was_enabled);
// 8569     //#endif
// 8570 
// 8571     report_current_position();
// 8572   }
// 8573 
// 8574 #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 8575 
// 8576 #if 1//ENABLED(G26_MESH_VALIDATION)
// 8577 
// 8578   inline void gcode_M49() {
// 8579     g26_debug_flag ^= true;
// 8580     SERIAL_PROTOCOLPGM("G26 Debug ");
// 8581     serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
// 8582   }
// 8583 
// 8584 #endif // G26_MESH_VALIDATION
// 8585 
// 8586 #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 8587   /**
// 8588    * M73: Set percentage complete (for display on LCD)
// 8589    *
// 8590    * Example:
// 8591    *   M73 P25 ; Set progress to 25%
// 8592    *
// 8593    * Notes:
// 8594    *   This has no effect during an SD print job
// 8595    */
// 8596   inline void gcode_M73() {
// 8597     if (!IS_SD_PRINTING && parser.seen('P')) {
// 8598       progress_bar_percent = parser.value_byte();
// 8599       NOMORE(progress_bar_percent, 100);
// 8600     }
// 8601   }
// 8602 #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
// 8603 
// 8604 /**
// 8605  * M75: Start print timer
// 8606  */
// 8607 inline void gcode_M75() { print_job_timer.start(); }
// 8608 
// 8609 /**
// 8610  * M76: Pause print timer
// 8611  */
// 8612 inline void gcode_M76() { print_job_timer.pause(); }
// 8613 
// 8614 /**
// 8615  * M77: Stop print timer
// 8616  */
// 8617 inline void gcode_M77() { print_job_timer.stop(); }
// 8618 
// 8619 #if ENABLED(PRINTCOUNTER)
// 8620   /**
// 8621    * M78: Show print statistics
// 8622    */
// 8623   inline void gcode_M78() {
// 8624     // "M78 S78" will reset the statistics
// 8625     if (parser.intval('S') == 78)
// 8626       print_job_timer.initStats();
// 8627     else
// 8628       print_job_timer.showStats();
// 8629   }
// 8630 #endif
// 8631 
// 8632 /**
// 8633  * M104: Set hot end temperature
// 8634  */
// 8635 inline void gcode_M104() {
// 8636   if (get_target_extruder_from_command(104)) return;
// 8637   if (DEBUGGING(DRYRUN)) return;
// 8638 
// 8639   #if ENABLED(SINGLENOZZLE)
// 8640     if (target_extruder != active_extruder) return;
// 8641   #endif
// 8642 
// 8643   if (parser.seenval('S')) {
// 8644     const int16_t temp = parser.value_celsius();
// 8645     thermalManager.setTargetHotend(temp, target_extruder);
// 8646 
// 8647     #if ENABLED(DUAL_X_CARRIAGE)
// 8648       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8649         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8650     #endif
// 8651 
// 8652     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8653       /**
// 8654        * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
// 8655        * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
// 8656        * standby mode, for instance in a dual extruder setup, without affecting
// 8657        * the running print timer.
// 8658        */
// 8659       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8660         print_job_timer.stop();
// 8661         LCD_MESSAGEPGM(WELCOME_MSG);
// 8662       }
// 8663     #endif
// 8664 
// 8665     //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8666     //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8667 		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8668 		{
// 8669 		switch(target_extruder)
// 8670 			{
// 8671 			case 0:
// 8672 				LCD_MESSAGEPGM("E1 Heating...");
// 8673 				break;
// 8674 			case 1:
// 8675 				LCD_MESSAGEPGM("E2 Heating...");
// 8676 				break;
// 8677 			case 2:
// 8678 				LCD_MESSAGEPGM("E3 Heating...");
// 8679 				break;
// 8680 			case 3:
// 8681 				LCD_MESSAGEPGM("E4 Heating...");
// 8682 				break;
// 8683 			case 4:
// 8684 				LCD_MESSAGEPGM("E5 Heating...");
// 8685 				break;
// 8686 			default: break;
// 8687 				
// 8688 			}
// 8689 		}    
// 8690   }
// 8691 
// 8692   #if ENABLED(AUTOTEMP)
// 8693     planner.autotemp_M104_M109();
// 8694   #endif
// 8695 }
// 8696 
// 8697 /**
// 8698  * M105: Read hot end and bed temperature
// 8699  */
// 8700 inline void gcode_M105() {
// 8701   if (get_target_extruder_from_command(105)) return;
// 8702 /*
// 8703   #if HAS_TEMP_HOTEND || HAS_TEMP_BED
// 8704     SERIAL_PROTOCOLPGM(MSG_OK);
// 8705     thermalManager.print_heaterstates();
// 8706   #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
// 8707     SERIAL_ERROR_START();
// 8708     SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
// 8709   #endif
// 8710 */
// 8711   SERIAL_PROTOCOLPGM(MSG_OK);
// 8712   thermalManager.print_heaterstates();
// 8713 
// 8714   SERIAL_EOL();
// 8715 }
// 8716 
// 8717 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND /*|| HAS_TEMP_BED*/)
// 8718 
// 8719   /**
// 8720    * M155: Set temperature auto-report interval. M155 S<seconds>
// 8721    */
// 8722   inline void gcode_M155() {
// 8723     if (parser.seenval('S'))
// 8724       thermalManager.set_auto_report_interval(parser.value_byte());
// 8725   }
// 8726 
// 8727 #endif // AUTO_REPORT_TEMPERATURES
// 8728 
// 8729 #if FAN_COUNT > 0
// 8730 
// 8731   /**
// 8732    * M106: Set Fan Speed
// 8733    *
// 8734    *  S<int>   Speed between 0-255
// 8735    *  P<index> Fan index, if more than one fan
// 8736    *
// 8737    * With EXTRA_FAN_SPEED enabled:
// 8738    *
// 8739    *  T<int>   Restore/Use/Set Temporary Speed:
// 8740    *           1     = Restore previous speed after T2
// 8741    *           2     = Use temporary speed set with T3-255
// 8742    *           3-255 = Set the speed for use with T2
// 8743    */
// 8744   inline void gcode_M106() {
// 8745     const uint8_t p = parser.byteval('P');
// 8746     if (p < FAN_COUNT) {
// 8747       #if ENABLED(EXTRA_FAN_SPEED)
// 8748         const int16_t t = parser.intval('T');
// 8749         if (t > 0) {
// 8750           switch (t) {
// 8751             case 1:
// 8752               fanSpeeds[p] = old_fanSpeeds[p];
// 8753               break;
// 8754             case 2:
// 8755               old_fanSpeeds[p] = fanSpeeds[p];
// 8756               fanSpeeds[p] = new_fanSpeeds[p];
// 8757               break;
// 8758             default:
// 8759               new_fanSpeeds[p] = min(t, 255);
// 8760               break;
// 8761           }
// 8762           return;
// 8763         }
// 8764       #endif // EXTRA_FAN_SPEED
// 8765       const uint16_t s = parser.ushortval('S', 255);
// 8766       fanSpeeds[p] = min(s, 255);
// 8767 	  MKS_FAN_TIM = s*10000/255;
// 8768     }
// 8769   }
// 8770 
// 8771   /**
// 8772    * M107: Fan Off
// 8773    */
// 8774   inline void gcode_M107() {
// 8775     const uint16_t p = parser.ushortval('P');
// 8776     if (p < FAN_COUNT) 
// 8777     {
// 8778 		fanSpeeds[p] = 0;
// 8779 		MKS_FAN_TIM = 0 ;
// 8780     }
// 8781   }
// 8782 
// 8783 #endif // FAN_COUNT > 0
// 8784 
// 8785 #if DISABLED(EMERGENCY_PARSER)
// 8786 
// 8787   /**
// 8788    * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
// 8789    */
// 8790   inline void gcode_M108() { wait_for_heatup = false; }
// 8791 
// 8792 
// 8793   /**
// 8794    * M112: Emergency Stop
// 8795    */
// 8796   inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
// 8797 
// 8798 
// 8799   /**
// 8800    * M410: Quickstop - Abort all planned moves
// 8801    *
// 8802    * This will stop the carriages mid-move, so most likely they
// 8803    * will be out of sync with the stepper position after this.
// 8804    */
// 8805   inline void gcode_M410() { quickstop_stepper(); }
// 8806 
// 8807 #endif
// 8808 
// 8809 /**
// 8810  * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
// 8811  *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
// 8812  */
// 8813 
// 8814 #ifndef MIN_COOLING_SLOPE_DEG
// 8815   #define MIN_COOLING_SLOPE_DEG 1.50
// 8816 #endif
// 8817 #ifndef MIN_COOLING_SLOPE_TIME
// 8818   #define MIN_COOLING_SLOPE_TIME 60
// 8819 #endif
// 8820 
// 8821 inline void gcode_M109() {
// 8822 
// 8823   if (get_target_extruder_from_command(109)) return;
// 8824   if (DEBUGGING(DRYRUN)) return;
// 8825 
// 8826   #if ENABLED(SINGLENOZZLE)
// 8827     if (target_extruder != active_extruder) return;
// 8828   #endif
// 8829 
// 8830   const bool no_wait_for_cooling = parser.seenval('S');
// 8831   if (no_wait_for_cooling || parser.seenval('R')) {
// 8832     const int16_t temp = parser.value_celsius();
// 8833     thermalManager.setTargetHotend(temp, target_extruder);
// 8834 
// 8835     #if ENABLED(DUAL_X_CARRIAGE)
// 8836       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8837         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8838     #endif
// 8839 
// 8840     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8841       /**
// 8842        * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
// 8843        * standby mode, (e.g., in a dual extruder setup) without affecting
// 8844        * the running print timer.
// 8845        */
// 8846       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8847         print_job_timer.stop();
// 8848         LCD_MESSAGEPGM(WELCOME_MSG);
// 8849       }
// 8850       else
// 8851         print_job_timer.start();
// 8852     #endif
// 8853 
// 8854     //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8855 	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8856 	{
// 8857 			switch(target_extruder)
// 8858 			{
// 8859 			case 0:
// 8860 				LCD_MESSAGEPGM("E1 Heating...");
// 8861 				break;
// 8862 			case 1:
// 8863 				LCD_MESSAGEPGM("E2 Heating...");
// 8864 				break;
// 8865 			case 2:
// 8866 				LCD_MESSAGEPGM("E3 Heating...");
// 8867 				break;
// 8868 			case 3:
// 8869 				LCD_MESSAGEPGM("E4 Heating...");
// 8870 				break;
// 8871 			case 4:
// 8872 				LCD_MESSAGEPGM("E5 Heating...");
// 8873 				break;
// 8874 			default: break;
// 8875 			}
// 8876 	}
// 8877 
// 8878   }
// 8879   else return;
// 8880 
// 8881   #if ENABLED(AUTOTEMP)
// 8882     planner.autotemp_M104_M109();
// 8883   #endif
// 8884 
// 8885   #if TEMP_RESIDENCY_TIME > 0
// 8886     millis_t residency_start_ms = 0;
// 8887     // Loop until the temperature has stabilized
// 8888     #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
// 8889   #else
// 8890     // Loop until the temperature is very close target
// 8891     #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
// 8892   #endif
// 8893 
// 8894   float target_temp = -1.0, old_temp = 9999.0;
// 8895   bool wants_to_cool = false;
// 8896   wait_for_heatup = true;
// 8897   millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 8898 
// 8899   #if DISABLED(BUSY_WHILE_HEATING)
// 8900     KEEPALIVE_STATE(NOT_BUSY);
// 8901   #endif
// 8902 
// 8903   #if ENABLED(PRINTER_EVENT_LEDS)
// 8904     const float start_temp = thermalManager.degHotend(target_extruder);
// 8905     uint8_t old_blue = 0;
// 8906   #endif
// 8907   
// 8908   #if WATCH_HOTENDS
// 8909     thermalManager.start_watching_heater(target_extruder);
// 8910   #endif
// 8911       
// 8912   mks_heating_busy = 1;
// 8913 
// 8914   do {
// 8915     // Target temperature might be changed during the loop
// 8916     if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
// 8917       wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
// 8918       target_temp = thermalManager.degTargetHotend(target_extruder);
// 8919 
// 8920       // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 8921       if (no_wait_for_cooling && wants_to_cool) break;
// 8922     }
// 8923 
// 8924     now = millis();
// 8925     if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
// 8926       next_temp_ms = now + 1000UL;
// 8927       thermalManager.print_heaterstates();
// 8928       #if TEMP_RESIDENCY_TIME > 0
// 8929         SERIAL_PROTOCOLPGM(" W:");
// 8930         if (residency_start_ms)
// 8931           SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 8932         else
// 8933           SERIAL_PROTOCOLCHAR('?');
// 8934       #endif
// 8935       SERIAL_EOL();
// 8936     }
// 8937 
// 8938     idle();
// 8939     refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8940 
// 8941     const float temp = thermalManager.degHotend(target_extruder);
// 8942 
// 8943     #if ENABLED(PRINTER_EVENT_LEDS)
// 8944       // Gradually change LED strip from violet to red as nozzle heats up
// 8945       if (!wants_to_cool) {
// 8946         const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
// 8947         if (blue != old_blue) {
// 8948           old_blue = blue;
// 8949           leds.set_color(
// 8950             MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
// 8951             #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 8952               , true
// 8953             #endif
// 8954           );
// 8955         }
// 8956       }
// 8957     #endif
// 8958 
// 8959     #if TEMP_RESIDENCY_TIME > 0
// 8960 
// 8961       const float temp_diff = FABS(target_temp - temp);
// 8962 
// 8963       if (!residency_start_ms) {
// 8964         // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8965         if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
// 8966       }
// 8967       else if (temp_diff > TEMP_HYSTERESIS) {
// 8968         // Restart the timer whenever the temperature falls outside the hysteresis.
// 8969         residency_start_ms = now;
// 8970       }
// 8971 
// 8972     #endif
// 8973 
// 8974     // Prevent a wait-forever situation if R is misused i.e. M109 R0
// 8975     if (wants_to_cool) {
// 8976       // break after MIN_COOLING_SLOPE_TIME seconds
// 8977       // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
// 8978       if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8979         if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
// 8980         next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
// 8981         old_temp = temp;
// 8982       }
// 8983     }
// 8984 
// 8985   } while (wait_for_heatup && TEMP_CONDITIONS);
// 8986   
// 8987   mks_heating_busy = 0;
// 8988 
// 8989   if (wait_for_heatup) {
// 8990     LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
// 8991     #if ENABLED(PRINTER_EVENT_LEDS)
// 8992       leds.set_white();
// 8993     #endif
// 8994   }
// 8995 
// 8996   #if DISABLED(BUSY_WHILE_HEATING)
// 8997     KEEPALIVE_STATE(IN_HANDLER);
// 8998   #endif
// 8999 }
// 9000 
// 9001 #if 1//HAS_TEMP_BED
// 9002 
// 9003   #ifndef MIN_COOLING_SLOPE_DEG_BED
// 9004     #define MIN_COOLING_SLOPE_DEG_BED 1.50
// 9005   #endif
// 9006   #ifndef MIN_COOLING_SLOPE_TIME_BED
// 9007     #define MIN_COOLING_SLOPE_TIME_BED 60
// 9008   #endif
// 9009 
// 9010   /**
// 9011    * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
// 9012    *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
// 9013    */
// 9014   inline void gcode_M190() {
// 9015     if (DEBUGGING(DRYRUN)) return;
// 9016 
// 9017     LCD_MESSAGEPGM(MSG_BED_HEATING);
// 9018     const bool no_wait_for_cooling = parser.seenval('S');
// 9019     if (no_wait_for_cooling || parser.seenval('R')) {
// 9020       thermalManager.setTargetBed(parser.value_celsius());
// 9021       #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 9022         if (parser.value_celsius() > BED_MINTEMP)
// 9023           print_job_timer.start();
// 9024       #endif
// 9025     }
// 9026     else return;
// 9027 
// 9028     #if TEMP_BED_RESIDENCY_TIME > 0
// 9029       millis_t residency_start_ms = 0;
// 9030       // Loop until the temperature has stabilized
// 9031       #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
// 9032     #else
// 9033       // Loop until the temperature is very close target
// 9034       #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
// 9035     #endif
// 9036 
// 9037     float target_temp = -1.0, old_temp = 9999.0;
// 9038     bool wants_to_cool = false;
// 9039     wait_for_heatup = true;
// 9040     millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 9041 
// 9042     #if DISABLED(BUSY_WHILE_HEATING)
// 9043       KEEPALIVE_STATE(NOT_BUSY);
// 9044     #endif
// 9045 
// 9046     target_extruder = active_extruder; // for print_heaterstates
// 9047 
// 9048     #if ENABLED(PRINTER_EVENT_LEDS)
// 9049       const float start_temp = thermalManager.degBed();
// 9050       uint8_t old_red = 255;
// 9051     #endif
// 9052 	mks_heating_busy = 1;
// 9053 
// 9054     do {
// 9055       // Target temperature might be changed during the loop
// 9056       if (target_temp != thermalManager.degTargetBed()) {
// 9057         wants_to_cool = thermalManager.isCoolingBed();
// 9058         target_temp = thermalManager.degTargetBed();
// 9059 
// 9060         // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 9061         if (no_wait_for_cooling && wants_to_cool) break;
// 9062       }
// 9063 
// 9064       now = millis();
// 9065       if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
// 9066         next_temp_ms = now + 1000UL;
// 9067         thermalManager.print_heaterstates();
// 9068         #if TEMP_BED_RESIDENCY_TIME > 0
// 9069           SERIAL_PROTOCOLPGM(" W:");
// 9070           if (residency_start_ms)
// 9071             SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 9072           else
// 9073             SERIAL_PROTOCOLCHAR('?');
// 9074         #endif
// 9075         SERIAL_EOL();
// 9076       }
// 9077 
// 9078       idle();
// 9079       refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 9080 
// 9081       const float temp = thermalManager.degBed();
// 9082 
// 9083       #if ENABLED(PRINTER_EVENT_LEDS)
// 9084         // Gradually change LED strip from blue to violet as bed heats up
// 9085         if (!wants_to_cool) {
// 9086           const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
// 9087           if (red != old_red) {
// 9088             old_red = red;
// 9089             leds.set_color(
// 9090               MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
// 9091               #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 9092                 , true
// 9093               #endif
// 9094             );
// 9095           }
// 9096         }
// 9097       #endif
// 9098 
// 9099       #if TEMP_BED_RESIDENCY_TIME > 0
// 9100 
// 9101         const float temp_diff = FABS(target_temp - temp);
// 9102 
// 9103         if (!residency_start_ms) {
// 9104           // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
// 9105           if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
// 9106         }
// 9107         else if (temp_diff > TEMP_BED_HYSTERESIS) {
// 9108           // Restart the timer whenever the temperature falls outside the hysteresis.
// 9109           residency_start_ms = now;
// 9110         }
// 9111 
// 9112       #endif // TEMP_BED_RESIDENCY_TIME > 0
// 9113 
// 9114       // Prevent a wait-forever situation if R is misused i.e. M190 R0
// 9115       if (wants_to_cool) {
// 9116         // Break after MIN_COOLING_SLOPE_TIME_BED seconds
// 9117         // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
// 9118         if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 9119           if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
// 9120           next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
// 9121           old_temp = temp;
// 9122         }
// 9123       }
// 9124 
// 9125     } while (wait_for_heatup && TEMP_BED_CONDITIONS);
// 9126 
// 9127 	mks_heating_busy = 0;
// 9128 
// 9129     if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
// 9130     #if DISABLED(BUSY_WHILE_HEATING)
// 9131       KEEPALIVE_STATE(IN_HANDLER);
// 9132     #endif
// 9133   }
// 9134 
// 9135 #endif // HAS_TEMP_BED
// 9136 
// 9137 /**
// 9138  * M110: Set Current Line Number
// 9139  */
// 9140 inline void gcode_M110() {
// 9141   if (parser.seenval('N')) gcode_LastN = parser.value_long();
// 9142 }
// 9143 
// 9144 /**
// 9145  * M111: Set the debug level
// 9146  */
// 9147 inline void gcode_M111() {
// 9148   if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
// 9149 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_1
// 9150   const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
_ZZ10gcode_M111vE11str_debug_1:
        DATA
        DC8 "ECHO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_2
// 9151                     str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
_ZZ10gcode_M111vE11str_debug_2:
        DATA
        DC8 "INFO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_4
// 9152                     str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
_ZZ10gcode_M111vE11str_debug_4:
        DATA
        DC8 "ERRORS"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_8
// 9153                     str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
_ZZ10gcode_M111vE11str_debug_8:
        DATA
        DC8 "DRYRUN"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE12str_debug_16
// 9154                     str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
_ZZ10gcode_M111vE12str_debug_16:
        DATA
        DC8 "COMMUNICATION"
        DC8 0, 0
// 9155                     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9156                       , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
// 9157                     #endif
// 9158                     ;
// 9159 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE13debug_strings
// 9160   const static char* const debug_strings[] PROGMEM = {
_ZZ10gcode_M111vE13debug_strings:
        DATA
        DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
        DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
        DC32 _ZZ10gcode_M111vE12str_debug_16

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "mks_pft.sys">`:
        DC8 "mks_pft.sys"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "X">`:
        DC8 "X"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Y">`:
        DC8 "Y"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Z">`:
        DC8 "Z"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F)}>`:
        DC32 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "X:">`:
        DC8 "X:"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y:">`:
        DC8 " Y:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Z:">`:
        DC8 " Z:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " E:">`:
        DC8 " E:"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant ":">`:
        DC8 ":"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "bed leveling hasn\\'t d...">`:
        DC8 "bed leveling hasn't defined!"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "ok">`:
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F), (0.0F)}>`:
        DC32 0H, 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_1`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M29">`:
        DC8 "M29"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%d">`:
        DC8 "%d"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%f">`:
        DC8 "%f"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y">`:
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G28">`:
        DC8 "G28"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "/">`:
        DC8 "/"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_2`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "\\n">`:
        DC8 "\012"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "end">`:
        DC8 "end"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_3`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_4`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
L1:
        DC32 43160000H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
L2:
        DC32 43160000H
// 9161     str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
// 9162     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9163       , str_debug_32
// 9164     #endif
// 9165   };
// 9166 
// 9167   SERIAL_ECHO_START();
// 9168   SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
// 9169   if (marlin_debug_flags) {
// 9170     uint8_t comma = 0;
// 9171     for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
// 9172       if (TEST(marlin_debug_flags, i)) {
// 9173         if (comma++) SERIAL_CHAR(',');
// 9174         //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
// 9175         serialprintPGM((char*)&(debug_strings[i]));
// 9176       }
// 9177     }
// 9178   }
// 9179   else {
// 9180     SERIAL_ECHOPGM(MSG_DEBUG_OFF);
// 9181   }
// 9182   SERIAL_EOL();
// 9183 }
// 9184 
// 9185 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 9186 
// 9187   /**
// 9188    * M113: Get or set Host Keepalive interval (0 to disable)
// 9189    *
// 9190    *   S<seconds> Optional. Set the keepalive interval.
// 9191    */
// 9192   inline void gcode_M113() {
// 9193     if (parser.seenval('S')) {
// 9194       host_keepalive_interval = parser.value_byte();
// 9195       NOMORE(host_keepalive_interval, 60);
// 9196     }
// 9197     else {
// 9198       SERIAL_ECHO_START();
// 9199       SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
// 9200     }
// 9201   }
// 9202 
// 9203 #endif
// 9204 
// 9205 #if ENABLED(BARICUDA)
// 9206 
// 9207   #if HAS_HEATER_1
// 9208     /**
// 9209      * M126: Heater 1 valve open
// 9210      */
// 9211     inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
// 9212     /**
// 9213      * M127: Heater 1 valve close
// 9214      */
// 9215     inline void gcode_M127() { baricuda_valve_pressure = 0; }
// 9216   #endif
// 9217 
// 9218   #if HAS_HEATER_2
// 9219     /**
// 9220      * M128: Heater 2 valve open
// 9221      */
// 9222     inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
// 9223     /**
// 9224      * M129: Heater 2 valve close
// 9225      */
// 9226     inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
// 9227   #endif
// 9228 
// 9229 #endif // BARICUDA
// 9230 
// 9231 /**
// 9232  * M140: Set bed temperature
// 9233  */
// 9234 inline void gcode_M140() {
// 9235   if (DEBUGGING(DRYRUN)) return;
// 9236   if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
// 9237 }
// 9238 
// 9239 #if ENABLED(ULTIPANEL)
// 9240 
// 9241   /**
// 9242    * M145: Set the heatup state for a material in the LCD menu
// 9243    *
// 9244    *   S<material> (0=PLA, 1=ABS)
// 9245    *   H<hotend temp>
// 9246    *   B<bed temp>
// 9247    *   F<fan speed>
// 9248    */
// 9249   inline void gcode_M145() {
// 9250     const uint8_t material = (uint8_t)parser.intval('S');
// 9251     if (material >= COUNT(lcd_preheat_hotend_temp)) {
// 9252       SERIAL_ERROR_START();
// 9253       SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
// 9254     }
// 9255     else {
// 9256       int v;
// 9257       if (parser.seenval('H')) {
// 9258         v = parser.value_int();
// 9259         lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
// 9260       }
// 9261       if (parser.seenval('F')) {
// 9262         v = parser.value_int();
// 9263         lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
// 9264       }
// 9265       #if TEMP_SENSOR_BED != 0
// 9266         if (parser.seenval('B')) {
// 9267           v = parser.value_int();
// 9268           lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
// 9269         }
// 9270       #endif
// 9271     }
// 9272   }
// 9273 
// 9274 #endif // ULTIPANEL
// 9275 
// 9276 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 9277   /**
// 9278    * M149: Set temperature units
// 9279    */
// 9280   inline void gcode_M149() {
// 9281          if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
// 9282     else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
// 9283     else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
// 9284   }
// 9285 #endif
// 9286 
// 9287 #if HAS_POWER_SWITCH
// 9288 
// 9289   /**
// 9290    * M80   : Turn on the Power Supply
// 9291    * M80 S : Report the current state and exit
// 9292    */
// 9293   inline void gcode_M80() {
// 9294 
// 9295     // S: Report the current power supply state and exit
// 9296     if (parser.seen('S')) {
// 9297       serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
// 9298       return;
// 9299     }
// 9300 
// 9301     OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
// 9302 
// 9303     /**
// 9304      * If you have a switch on suicide pin, this is useful
// 9305      * if you want to start another print with suicide feature after
// 9306      * a print without suicide...
// 9307      */
// 9308     #if HAS_SUICIDE
// 9309       OUT_WRITE(SUICIDE_PIN, HIGH);
// 9310     #endif
// 9311 
// 9312     #if ENABLED(HAVE_TMC2130)
// 9313       delay(100);
// 9314       tmc2130_init(); // Settings only stick when the driver has power
// 9315     #endif
// 9316 
// 9317     powersupply_on = true;
// 9318 
// 9319     #if ENABLED(ULTIPANEL)
// 9320       LCD_MESSAGEPGM(WELCOME_MSG);
// 9321     #endif
// 9322 
// 9323     #if ENABLED(HAVE_TMC2208)
// 9324       delay(100);
// 9325       tmc2208_init();
// 9326     #endif
// 9327   }
// 9328 
// 9329 #endif // HAS_POWER_SWITCH
// 9330 
// 9331 /**
// 9332  * M81: Turn off Power, including Power Supply, if there is one.
// 9333  *
// 9334  *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
// 9335  */
// 9336 inline void gcode_M81() {
// 9337   thermalManager.disable_all_heaters();
// 9338   stepper.finish_and_disable();
// 9339 
// 9340   #if FAN_COUNT > 0
// 9341     for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
// 9342     #if ENABLED(PROBING_FANS_OFF)
// 9343       fans_paused = false;
// 9344       ZERO(paused_fanSpeeds);
// 9345     #endif
// 9346   #endif
// 9347 
// 9348   safe_delay(1000); // Wait 1 second before switching off
// 9349 
// 9350   #if HAS_SUICIDE
// 9351     stepper.synchronize();
// 9352     suicide();
// 9353   #elif HAS_POWER_SWITCH
// 9354     OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 9355     powersupply_on = false;
// 9356   #endif
// 9357 
// 9358   #if ENABLED(ULTIPANEL)
// 9359     //LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
// 9360       if(LCD_LANGUAGE)
// 9361         LCD_MESSAGEPGM(MACHINE_NAME " " "\xb5 " ".");
// 9362       else
// 9363         LCD_MESSAGEPGM(MACHINE_NAME " " "Off" ".");    
// 9364   #endif
// 9365 }
// 9366 
// 9367 /**
// 9368  * M82: Set E codes absolute (default)
// 9369  */
// 9370 inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
// 9371 
// 9372 /**
// 9373  * M83: Set E codes relative while in Absolute Coordinates (G90) mode
// 9374  */
// 9375 inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
// 9376 
// 9377 /**
// 9378  * M18, M84: Disable stepper motors
// 9379  */
// 9380 inline void gcode_M18_M84() {
// 9381   if (parser.seenval('S')) {
// 9382     stepper_inactive_time = parser.value_millis_from_seconds();
// 9383   }
// 9384   else {
// 9385     bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
// 9386     if (all_axis) {
// 9387       stepper.finish_and_disable();
// 9388     }
// 9389     else {
// 9390       stepper.synchronize();
// 9391       if (parser.seen('X')) disable_X();
// 9392       if (parser.seen('Y')) disable_Y();
// 9393       if (parser.seen('Z')) disable_Z();
// 9394       #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
// 9395         if (parser.seen('E')) disable_e_steppers();
// 9396       #endif
// 9397     }
// 9398 
// 9399     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 9400       ubl.lcd_map_control = defer_return_to_status = false;
// 9401     #endif
// 9402   }
// 9403 }
// 9404 
// 9405 /**
// 9406  * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
// 9407  */
// 9408 inline void gcode_M85() {
// 9409   if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
// 9410 }
// 9411 
// 9412 /**
// 9413  * Multi-stepper support for M92, M201, M203
// 9414  */
// 9415 #if ENABLED(DISTINCT_E_FACTORS)
// 9416   #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
// 9417   #define TARGET_EXTRUDER target_extruder
// 9418 #else
// 9419   #define GET_TARGET_EXTRUDER(CMD) NOOP
// 9420   #define TARGET_EXTRUDER 0
// 9421 #endif
// 9422 
// 9423 /**
// 9424  * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
// 9425  *      (Follows the same syntax as G92)
// 9426  *
// 9427  *      With multiple extruders use T to specify which one.
// 9428  */
// 9429 inline void gcode_M92() {
// 9430 
// 9431   GET_TARGET_EXTRUDER(92);
// 9432 
// 9433   LOOP_XYZE(i) {
// 9434     if (parser.seen(axis_codes[i])) {
// 9435       if (i == E_AXIS) {
// 9436         const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
// 9437         if (value < 20.0) {
// 9438           float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
// 9439           planner.max_jerk[E_AXIS] *= factor;
// 9440           planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
// 9441           planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
// 9442         }
// 9443         planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
// 9444       }
// 9445       else {
// 9446         planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
// 9447       }
// 9448     }
// 9449   }
// 9450   planner.refresh_positioning();
// 9451 }
// 9452 
// 9453 /**
// 9454  * Output the current position to serial
// 9455  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function _Z23report_current_positionv
        THUMB
// 9456 void report_current_position() {
_Z23report_current_positionv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 9457   SERIAL_PROTOCOLPGM("X:");
        ADR.N    R0,??DataTable156_3  ;; 0x58, 0x3A, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9458   SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
        LDR.N    R4,??DataTable156_2
        LDR.W    R5,??DataTable158_1
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9459   SERIAL_PROTOCOLPGM(" Y:");
        ADR.N    R0,??DataTable156_4  ;; " Y:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9460   SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9461   SERIAL_PROTOCOLPGM(" Z:");
        ADR.N    R0,??DataTable156_6  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9462   SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+16]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9463   SERIAL_PROTOCOLPGM(" E:");
        ADR.N    R0,??DataTable157  ;; " E:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9464   SERIAL_PROTOCOL(current_position[E_AXIS]);
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+20]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9465 
// 9466   stepper.report_positions();
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
// 9467 
// 9468   //#if IS_SCARA
// 9469   if(MACHINETPYE&IS_SCARA)  
        LDR.W    R0,??DataTable160
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??report_current_position_0
// 9470   {
// 9471     SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        MOV      R1,R0
        ADR.W    R0,`?<Constant "SCARA Theta:">`
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
// 9472     SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        MOV      R1,R0
        ADR.W    R0,`?<Constant "   Psi+Theta:">`
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 9473     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 9474   }
// 9475   //#endif
// 9476 }
??report_current_position_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock62

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154:
        DC32     mks_heating_busy+0x8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_1:
        DC32     _ZN7Planner13z_fade_heightE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "SCARA Theta:">`:
        DC8 "SCARA Theta:"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "   Psi+Theta:">`:
        DC8 "   Psi+Theta:"
        DC8 0, 0
// 9477 
// 9478 #ifdef M114_DETAIL
// 9479 
// 9480   void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
// 9481     char str[12];
// 9482     for (uint8_t i = 0; i < n; i++) {
// 9483       SERIAL_CHAR(' ');
// 9484       SERIAL_CHAR(axis_codes[i]);
// 9485       SERIAL_CHAR(':');
// 9486       SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
// 9487     }
// 9488     SERIAL_EOL();
// 9489   }
// 9490 
// 9491   inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
// 9492 
// 9493   void report_current_position_detail() {
// 9494 
// 9495     stepper.synchronize();
// 9496 
// 9497     SERIAL_PROTOCOLPGM("\nLogical:");
// 9498     const float logical[XYZ] = {
// 9499       LOGICAL_X_POSITION(current_position[X_AXIS]),
// 9500       LOGICAL_Y_POSITION(current_position[Y_AXIS]),
// 9501       LOGICAL_Z_POSITION(current_position[Z_AXIS])
// 9502     };
// 9503     report_xyze(logical);
// 9504 
// 9505     SERIAL_PROTOCOLPGM("Raw:    ");
// 9506     report_xyz(current_position);
// 9507 
// 9508     float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 9509 
// 9510     #if PLANNER_LEVELING
// 9511       SERIAL_PROTOCOLPGM("Leveled:");
// 9512       planner.apply_leveling(leveled);
// 9513       report_xyz(leveled);
// 9514 
// 9515       SERIAL_PROTOCOLPGM("UnLevel:");
// 9516       float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
// 9517       planner.unapply_leveling(unleveled);
// 9518       report_xyz(unleveled);
// 9519     #endif
// 9520 
// 9521     #if IS_KINEMATIC
// 9522       #if IS_SCARA
// 9523         SERIAL_PROTOCOLPGM("ScaraK: ");
// 9524       #else
// 9525         SERIAL_PROTOCOLPGM("DeltaK: ");
// 9526       #endif
// 9527       inverse_kinematics(leveled);  // writes delta[]
// 9528       report_xyz(delta);
// 9529     #endif
// 9530 
// 9531     SERIAL_PROTOCOLPGM("Stepper:");
// 9532     LOOP_XYZE(i) {
// 9533       SERIAL_CHAR(' ');
// 9534       SERIAL_CHAR(axis_codes[i]);
// 9535       SERIAL_CHAR(':');
// 9536       SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
// 9537     }
// 9538     SERIAL_EOL();
// 9539 
// 9540     #if IS_SCARA
// 9541       const float deg[XYZ] = {
// 9542         stepper.get_axis_position_degrees(A_AXIS),
// 9543         stepper.get_axis_position_degrees(B_AXIS)
// 9544       };
// 9545       SERIAL_PROTOCOLPGM("Degrees:");
// 9546       report_xyze(deg, 2);
// 9547     #endif
// 9548 
// 9549     SERIAL_PROTOCOLPGM("FromStp:");
// 9550     get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
// 9551     const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
// 9552     report_xyze(from_steppers);
// 9553 
// 9554     const float diff[XYZE] = {
// 9555       from_steppers[X_AXIS] - leveled[X_AXIS],
// 9556       from_steppers[Y_AXIS] - leveled[Y_AXIS],
// 9557       from_steppers[Z_AXIS] - leveled[Z_AXIS],
// 9558       from_steppers[E_AXIS] - current_position[E_AXIS]
// 9559     };
// 9560     SERIAL_PROTOCOLPGM("Differ: ");
// 9561     report_xyze(diff);
// 9562   }
// 9563 #endif // M114_DETAIL
// 9564 
// 9565 /**
// 9566  * M114: Report current position to host
// 9567  */
// 9568 inline void gcode_M114() {
// 9569 
// 9570   #ifdef M114_DETAIL
// 9571     if (parser.seen('D')) {
// 9572       report_current_position_detail();
// 9573       return;
// 9574     }
// 9575   #endif
// 9576 
// 9577   stepper.synchronize();
// 9578   report_current_position();
// 9579 }
// 9580 
// 9581 /**
// 9582  * M115: Capabilities string
// 9583  */
// 9584 
// 9585 #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function _Z8cap_linePKcb
        THUMB
// 9586   static void cap_line(const char * const name, bool ena=false) {
_Z8cap_linePKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 9587     SERIAL_PROTOCOLPGM("Cap:");
        ADR.W    R0,`?<Constant "Cap:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9588     serialprintPGM(name);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9589     SERIAL_PROTOCOLPGM(":");
        ADR.N    R0,??DataTable157_1  ;; ":"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9590     SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
        LDR.N    R4,??DataTable156_2
        MOVS     R2,#+10
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock63
// 9591   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Cap:">`:
        DC8 "Cap:"
        DC8 0, 0, 0
// 9592 #endif
// 9593 
// 9594 inline void gcode_M115() {
// 9595   SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
// 9596 
// 9597   #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
// 9598 
// 9599     // SERIAL_XON_XOFF
// 9600     cap_line(PSTR("SERIAL_XON_XOFF")
// 9601       #if ENABLED(SERIAL_XON_XOFF)
// 9602         , true
// 9603       #endif
// 9604     );
// 9605 
// 9606     // EEPROM (M500, M501)
// 9607     cap_line(PSTR("EEPROM")
// 9608       #if ENABLED(EEPROM_SETTINGS)
// 9609         , true
// 9610       #endif
// 9611     );
// 9612 
// 9613     // Volumetric Extrusion (M200)
// 9614     cap_line(PSTR("VOLUMETRIC")
// 9615       #if DISABLED(NO_VOLUMETRICS)
// 9616         , true
// 9617       #endif
// 9618     );
// 9619 
// 9620     // AUTOREPORT_TEMP (M155)
// 9621     cap_line(PSTR("AUTOREPORT_TEMP")
// 9622       #if ENABLED(AUTO_REPORT_TEMPERATURES)
// 9623         , true
// 9624       #endif
// 9625     );
// 9626 
// 9627     // PROGRESS (M530 S L, M531 <file>, M532 X L)
// 9628     cap_line(PSTR("PROGRESS"));
// 9629 
// 9630     // Print Job timer M75, M76, M77
// 9631     cap_line(PSTR("PRINT_JOB"), true);
// 9632 
// 9633     // AUTOLEVEL (G29)
// 9634     cap_line(PSTR("AUTOLEVEL")
// 9635       #if HAS_AUTOLEVEL
// 9636         , true
// 9637       #endif
// 9638     );
// 9639 
// 9640     // Z_PROBE (G30)
// 9641     cap_line(PSTR("Z_PROBE")
// 9642       #if HAS_BED_PROBE
// 9643         , true
// 9644       #endif
// 9645     );
// 9646 
// 9647     // MESH_REPORT (M420 V)
// 9648     cap_line(PSTR("LEVELING_DATA")
// 9649       #if HAS_LEVELING
// 9650         , true
// 9651       #endif
// 9652     );
// 9653 
// 9654     // BUILD_PERCENT (M73)
// 9655     cap_line(PSTR("BUILD_PERCENT")
// 9656       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 9657         , true
// 9658       #endif
// 9659     );
// 9660 
// 9661     // SOFTWARE_POWER (M80, M81)
// 9662     cap_line(PSTR("SOFTWARE_POWER")
// 9663       #if HAS_POWER_SWITCH
// 9664         , true
// 9665       #endif
// 9666     );
// 9667 
// 9668     // CASE LIGHTS (M355)
// 9669     cap_line(PSTR("TOGGLE_LIGHTS")
// 9670       #if HAS_CASE_LIGHT
// 9671         , true
// 9672       #endif
// 9673     );
// 9674     cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
// 9675       #if HAS_CASE_LIGHT
// 9676         , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
// 9677       #endif
// 9678     );
// 9679 
// 9680     // EMERGENCY_PARSER (M108, M112, M410)
// 9681     cap_line(PSTR("EMERGENCY_PARSER")
// 9682       #if ENABLED(EMERGENCY_PARSER)
// 9683         , true
// 9684       #endif
// 9685     );
// 9686 
// 9687   #endif // EXTENDED_CAPABILITIES_REPORT
// 9688 }
// 9689 
// 9690 /**
// 9691  * M117: Set LCD Status Message
// 9692  */
// 9693 inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
// 9694 
// 9695 /**
// 9696  * M118: Display a message in the host console.
// 9697  *
// 9698  *  A1  Append '// ' for an action command, as in OctoPrint
// 9699  *  E1  Have the host 'echo:' the text
// 9700  */
// 9701 inline void gcode_M118() {
// 9702   if (parser.boolval('E')) SERIAL_ECHO_START();
// 9703   if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
// 9704   SERIAL_ECHOLN(parser.string_arg);
// 9705 }
// 9706 
// 9707 /**
// 9708  * M119: Output endstop states to serial output
// 9709  */
// 9710 inline void gcode_M119() { endstops.M119(); }
// 9711 
// 9712 /**
// 9713  * M120: Enable endstops and set non-homing endstop state to "enabled"
// 9714  */
// 9715 inline void gcode_M120() { endstops.enable_globally(true); }
// 9716 
// 9717 /**
// 9718  * M121: Disable endstops and set non-homing endstop state to "disabled"
// 9719  */
// 9720 inline void gcode_M121() { endstops.enable_globally(false); }
// 9721 
// 9722 #if ENABLED(PARK_HEAD_ON_PAUSE)
// 9723 
// 9724   /**
// 9725    * M125: Store current position and move to filament change position.
// 9726    *       Called on pause (by M25) to prevent material leaking onto the
// 9727    *       object. On resume (M24) the head will be moved back and the
// 9728    *       print will resume.
// 9729    *
// 9730    *       If Marlin is compiled without SD Card support, M125 can be
// 9731    *       used directly to pause the print and move to park position,
// 9732    *       resuming with a button click or M108.
// 9733    *
// 9734    *    L = override retract length
// 9735    *    X = override X
// 9736    *    Y = override Y
// 9737    *    Z = override Z raise
// 9738    */
// 9739   inline void gcode_M125() {
// 9740 
// 9741     // Initial retract before move to filament change position
// 9742     const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 9743       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 9744         - (PAUSE_PARK_RETRACT_LENGTH)
// 9745       #endif
// 9746     ;
// 9747 
// 9748     point_t park_point = NOZZLE_PARK_POINT;
// 9749 
// 9750     // Move XY axes to filament change position or given position
// 9751     if (parser.seenval('X')) park_point.x = parser.linearval('X');
// 9752     if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
// 9753 
// 9754     // Lift Z axis
// 9755     if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
// 9756 
// 9757     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 9758       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 9759       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 9760     #endif
// 9761 
// 9762     #if DISABLED(SDSUPPORT)
// 9763       const bool job_running = print_job_timer.isRunning();
// 9764     #endif
// 9765 
// 9766     if (pause_print(retract, park_point)) {
// 9767       #if DISABLED(SDSUPPORT)
// 9768         // Wait for lcd click or M108
// 9769         wait_for_filament_reload();
// 9770 
// 9771         // Return to print position and continue
// 9772         resume_print();
// 9773 
// 9774         if (job_running) print_job_timer.start();
// 9775       #endif
// 9776     }
// 9777   }
// 9778 
// 9779 #endif // PARK_HEAD_ON_PAUSE
// 9780 
// 9781 #if HAS_COLOR_LEDS
// 9782 
// 9783   /**
// 9784    * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
// 9785    *       and Brightness       - Use P (for NEOPIXEL only)
// 9786    *
// 9787    * Always sets all 3 or 4 components. If a component is left out, set to 0.
// 9788    *                                    If brightness is left out, no value changed
// 9789    *
// 9790    * Examples:
// 9791    *
// 9792    *   M150 R255       ; Turn LED red
// 9793    *   M150 R255 U127  ; Turn LED orange (PWM only)
// 9794    *   M150            ; Turn LED off
// 9795    *   M150 R U B      ; Turn LED white
// 9796    *   M150 W          ; Turn LED white using a white LED
// 9797    *   M150 P127       ; Set LED 50% brightness
// 9798    *   M150 P          ; Set LED full brightness
// 9799    */
// 9800   inline void gcode_M150() {
// 9801     leds.set_color(MakeLEDColor(
// 9802       parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9803       parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9804       parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9805       parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9806       parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
// 9807     ));
// 9808   }
// 9809 
// 9810 #endif // HAS_COLOR_LEDS
// 9811 
// 9812 #if DISABLED(NO_VOLUMETRICS)
// 9813 
// 9814   /**
// 9815    * M200: Set filament diameter and set E axis units to cubic units
// 9816    *
// 9817    *    T<extruder> - Optional extruder number. Current extruder if omitted.
// 9818    *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
// 9819    */
// 9820   inline void gcode_M200() {
// 9821 
// 9822     if (get_target_extruder_from_command(200)) return;
// 9823 
// 9824     if (parser.seen('D')) {
// 9825       // setting any extruder filament size disables volumetric on the assumption that
// 9826       // slicers either generate in extruder values as cubic mm or as as filament feeds
// 9827       // for all extruders
// 9828       if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
// 9829         planner.set_filament_size(target_extruder, parser.value_linear_units());
// 9830     }
// 9831     planner.calculate_volumetric_multipliers();
// 9832   }
// 9833 
// 9834 #endif // !NO_VOLUMETRICS
// 9835 
// 9836 /**
// 9837  * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
// 9838  *
// 9839  *       With multiple extruders use T to specify which one.
// 9840  */
// 9841 inline void gcode_M201() {
// 9842 
// 9843   GET_TARGET_EXTRUDER(201);
// 9844 
// 9845   LOOP_XYZE(i) {
// 9846     if (parser.seen(axis_codes[i])) {
// 9847       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9848       planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
// 9849     }
// 9850   }
// 9851   // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
// 9852   planner.reset_acceleration_rates();
// 9853 }
// 9854 
// 9855 #if 0 // Not used for Sprinter/grbl gen6
// 9856   inline void gcode_M202() {
// 9857     LOOP_XYZE(i) {
// 9858       if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
// 9859     }
// 9860   }
// 9861 #endif
// 9862 
// 9863 
// 9864 /**
// 9865  * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
// 9866  *
// 9867  *       With multiple extruders use T to specify which one.
// 9868  */
// 9869 inline void gcode_M203() {
// 9870 
// 9871   GET_TARGET_EXTRUDER(203);
// 9872 
// 9873   LOOP_XYZE(i)
// 9874     if (parser.seen(axis_codes[i])) {
// 9875       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9876       planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
// 9877     }
// 9878 }
// 9879 
// 9880 /**
// 9881  * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
// 9882  *
// 9883  *    P = Printing moves
// 9884  *    R = Retract only (no X, Y, Z) moves
// 9885  *    T = Travel (non printing) moves
// 9886  *
// 9887  *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
// 9888  */
// 9889 inline void gcode_M204() {
// 9890   if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
// 9891     planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
// 9892     SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
// 9893   }
// 9894   if (parser.seen('P')) {
// 9895     planner.acceleration = parser.value_linear_units();
// 9896     SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
// 9897   }
// 9898   if (parser.seen('R')) {
// 9899     planner.retract_acceleration = parser.value_linear_units();
// 9900     SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
// 9901   }
// 9902   if (parser.seen('T')) {
// 9903     planner.travel_acceleration = parser.value_linear_units();
// 9904     SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
// 9905   }
// 9906 }
// 9907 
// 9908 /**
// 9909  * M205: Set Advanced Settings
// 9910  *
// 9911  *    S = Min Feed Rate (units/s)
// 9912  *    T = Min Travel Feed Rate (units/s)
// 9913  *    B = Min Segment Time (¬µs)
// 9914  *    X = Max X Jerk (units/sec^2)
// 9915  *    Y = Max Y Jerk (units/sec^2)
// 9916  *    Z = Max Z Jerk (units/sec^2)
// 9917  *    E = Max E Jerk (units/sec^2)
// 9918  */
// 9919 inline void gcode_M205() {
// 9920   if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
// 9921   if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
// 9922   if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
// 9923   if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
// 9924   if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
// 9925   if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
// 9926   if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
// 9927 }
// 9928 
// 9929 #if 1//HAS_M206_COMMAND
// 9930 
// 9931   /**
// 9932    * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
// 9933    *
// 9934    * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
// 9935    * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
// 9936    * ***              In the next 1.2 release, it will simply be disabled by default.
// 9937    */
// 9938   inline void gcode_M206() {
// 9939   if(MACHINETPYE == DELTA) return;
// 9940     LOOP_XYZ(i)
// 9941       if (parser.seen(axis_codes[i]))
// 9942         set_home_offset((AxisEnum)i, parser.value_linear_units());
// 9943 
// 9944     //#if ENABLED(MORGAN_SCARA)
// 9945     if(MACHINETPYE == MORGAN_SCARA)
// 9946     {
// 9947       if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
// 9948       if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
// 9949     }
// 9950     //#endif
// 9951 
// 9952     report_current_position();
// 9953   }
// 9954 
// 9955 #endif // HAS_M206_COMMAND
// 9956 
// 9957 #if 1//ENABLED(DELTA)
// 9958   /**
// 9959    * M665: Set delta configurations
// 9960    *
// 9961    *    H = delta height
// 9962    *    L = diagonal rod
// 9963    *    R = delta radius
// 9964    *    S = segments per second
// 9965    *    B = delta calibration radius
// 9966    *    X = Alpha (Tower 1) angle trim
// 9967    *    Y = Beta (Tower 2) angle trim
// 9968    *    Z = Rotate A and B by this angle
// 9969    */
// 9970   inline void gcode_M665() {
// 9971     if (parser.seen('H')) delta_height                   = parser.value_linear_units();
// 9972     if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
// 9973     if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
// 9974     if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
// 9975     if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
// 9976     if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
// 9977     if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
// 9978     if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
// 9979     recalc_delta_settings();
// 9980   }
// 9981   /**
// 9982    * M666: Set delta endstop adjustment
// 9983    */
// 9984   inline void gcode_M666() {
// 9985     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9986       if (DEBUGGING(LEVELING)) {
// 9987         SERIAL_ECHOLNPGM(">>> gcode_M666");
// 9988       }
// 9989     #endif
// 9990     LOOP_XYZ(i) {
// 9991       if (parser.seen(axis_codes[i])) {
// 9992         if (parser.value_linear_units() * Z_HOME_DIR <= 0)
// 9993           delta_endstop_adj[i] = parser.value_linear_units();
// 9994         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9995           if (DEBUGGING(LEVELING)) {
// 9996             SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
// 9997             SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
// 9998           }
// 9999         #endif
// 10000       }
// 10001     }
// 10002     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10003       if (DEBUGGING(LEVELING)) {
// 10004         SERIAL_ECHOLNPGM("<<< gcode_M666");
// 10005       }
// 10006     #endif
// 10007   }
// 10008 
// 10009 #elif IS_SCARA
// 10010 
// 10011   /**
// 10012    * M665: Set SCARA settings
// 10013    *
// 10014    * Parameters:
// 10015    *
// 10016    *   S[segments-per-second] - Segments-per-second
// 10017    *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
// 10018    *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
// 10019    *
// 10020    *   A, P, and X are all aliases for the shoulder angle
// 10021    *   B, T, and Y are all aliases for the elbow angle
// 10022    */
// 10023   inline void gcode_M665() {
// 10024     if (parser.seen('S')) delta_segments_per_second = parser.value_float();
// 10025 
// 10026     const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
// 10027     const uint8_t sumAPX = hasA + hasP + hasX;
// 10028     if (sumAPX == 1)
// 10029       home_offset[A_AXIS] = parser.value_float();
// 10030     else if (sumAPX > 1) {
// 10031       SERIAL_ERROR_START();
// 10032       SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
// 10033       return;
// 10034     }
// 10035 
// 10036     const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
// 10037     const uint8_t sumBTY = hasB + hasT + hasY;
// 10038     if (sumBTY == 1)
// 10039       home_offset[B_AXIS] = parser.value_float();
// 10040     else if (sumBTY > 1) {
// 10041       SERIAL_ERROR_START();
// 10042       SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
// 10043       return;
// 10044     }
// 10045   }
// 10046 
// 10047 
// 10048 #endif
// 10049 //#elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 10050 
// 10051   /**
// 10052    * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
// 10053    */
// 10054   inline void gcode_M666_dual() {
// 10055     SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
// 10056     #if ENABLED(X_DUAL_ENDSTOPS)
// 10057       if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
// 10058       SERIAL_ECHOPAIR(" X", x_endstop_adj);
// 10059     #endif
// 10060     #if ENABLED(Y_DUAL_ENDSTOPS)
// 10061       if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
// 10062       SERIAL_ECHOPAIR(" Y", y_endstop_adj);
// 10063     #endif
// 10064     //#if ENABLED(Z_DUAL_ENDSTOPS)
// 10065     if(Z_DUAL_ENDSTOPS==1)
// 10066     {
// 10067       if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
// 10068       SERIAL_ECHOPAIR(" Z", z_endstop_adj);
// 10069     }
// 10070     //#endif
// 10071     SERIAL_EOL();
// 10072   }
// 10073 
// 10074 //#endif // !DELTA && Z_DUAL_ENDSTOPS
// 10075 
// 10076 #if ENABLED(FWRETRACT)
// 10077 
// 10078   /**
// 10079    * M207: Set firmware retraction values
// 10080    *
// 10081    *   S[+units]    retract_length
// 10082    *   W[+units]    swap_retract_length (multi-extruder)
// 10083    *   F[units/min] retract_feedrate_mm_s
// 10084    *   Z[units]     retract_zlift
// 10085    */
// 10086   inline void gcode_M207() {
// 10087     if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
// 10088     if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10089     if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
// 10090     if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
// 10091   }
// 10092 
// 10093   /**
// 10094    * M208: Set firmware un-retraction values
// 10095    *
// 10096    *   S[+units]    retract_recover_length (in addition to M207 S*)
// 10097    *   W[+units]    swap_retract_recover_length (multi-extruder)
// 10098    *   F[units/min] retract_recover_feedrate_mm_s
// 10099    *   R[units/min] swap_retract_recover_feedrate_mm_s
// 10100    */
// 10101   inline void gcode_M208() {
// 10102     if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
// 10103     if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10104     if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10105     if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
// 10106   }
// 10107 
// 10108   /**
// 10109    * M209: Enable automatic retract (M209 S1)
// 10110    *   For slicers that don't support G10/11, reversed extrude-only
// 10111    *   moves will be classified as retraction.
// 10112    */
// 10113   inline void gcode_M209() {
// 10114     if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 10115       if (parser.seen('S')) {
// 10116         autoretract_enabled = parser.value_bool();
// 10117         for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
// 10118       }
// 10119     }
// 10120   }
// 10121 
// 10122 #endif // FWRETRACT
// 10123 
// 10124 /**
// 10125  * M211: Enable, Disable, and/or Report software endstops
// 10126  *
// 10127  * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
// 10128  */
// 10129 inline void gcode_M211() {
// 10130   SERIAL_ECHO_START();
// 10131   #if HAS_SOFTWARE_ENDSTOPS
// 10132     if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
// 10133     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 10134     serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
// 10135   #else
// 10136     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 10137     SERIAL_ECHOPGM(MSG_OFF);
// 10138   #endif
// 10139   SERIAL_ECHOPGM(MSG_SOFT_MIN);
// 10140   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
// 10141   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
// 10142   SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
// 10143   SERIAL_ECHOPGM(MSG_SOFT_MAX);
// 10144   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
// 10145   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
// 10146   SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
// 10147 }
// 10148 
// 10149 #if HOTENDS > 1
// 10150 
// 10151   /**
// 10152    * M218 - set hotend offset (in linear units)
// 10153    *
// 10154    *   T<tool>
// 10155    *   X<xoffset>
// 10156    *   Y<yoffset>
// 10157    *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
// 10158    */
// 10159   inline void gcode_M218() {
// 10160     if (get_target_extruder_from_command(218) || target_extruder == 0) return;
// 10161 
// 10162     if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
// 10163     if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
// 10164 
// 10165     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 10166       if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
// 10167     #endif
// 10168 
// 10169     SERIAL_ECHO_START();
// 10170     SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 10171     HOTEND_LOOP() {
// 10172       SERIAL_CHAR(' ');
// 10173       SERIAL_ECHO(hotend_offset[X_AXIS][e]);
// 10174       SERIAL_CHAR(',');
// 10175       SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
// 10176       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 10177         SERIAL_CHAR(',');
// 10178         SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
// 10179       #endif
// 10180     }
// 10181     SERIAL_EOL();
// 10182   }
// 10183 
// 10184 #endif // HOTENDS > 1
// 10185 
// 10186 /**
// 10187  * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
// 10188  */
// 10189 inline void gcode_M220() {
// 10190   if (parser.seenval('S')) feedrate_percentage = parser.value_int();
// 10191 }
// 10192 
// 10193 /**
// 10194  * M221: Set extrusion percentage (M221 T0 S95)
// 10195  */
// 10196 inline void gcode_M221() {
// 10197   if (get_target_extruder_from_command(221)) return;
// 10198   if (parser.seenval('S')) {
// 10199     planner.flow_percentage[target_extruder] = parser.value_int();
// 10200     planner.refresh_e_factor(target_extruder);
// 10201   }
// 10202 }
// 10203 
// 10204 /**
// 10205  * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
// 10206  */
// 10207 inline void gcode_M226() {
// 10208   if (parser.seen('P')) {
// 10209     const int pin_number = parser.value_int(),
// 10210               pin_state = parser.intval('S', -1); // required pin state - default is inverted
// 10211 
// 10212     if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
// 10213 
// 10214       int target = LOW;
// 10215 
// 10216       stepper.synchronize();
// 10217 
// 10218       pinMode(pin_number, INPUT);
// 10219       switch (pin_state) {
// 10220         case 1:
// 10221           target = HIGH;
// 10222           break;
// 10223         case 0:
// 10224           target = LOW;
// 10225           break;
// 10226         case -1:
// 10227           target = !digitalRead(pin_number);
// 10228           break;
// 10229       }
// 10230 
// 10231       while (digitalRead(pin_number) != target) idle();
// 10232 
// 10233     } // pin_state -1 0 1 && pin_number > -1
// 10234   } // parser.seen('P')
// 10235 }
// 10236 
// 10237 #if ENABLED(EXPERIMENTAL_I2CBUS)
// 10238 
// 10239   /**
// 10240    * M260: Send data to a I2C slave device
// 10241    *
// 10242    * This is a PoC, the formating and arguments for the GCODE will
// 10243    * change to be more compatible, the current proposal is:
// 10244    *
// 10245    *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
// 10246    *
// 10247    *  M260 B<byte-1 value in base 10>
// 10248    *  M260 B<byte-2 value in base 10>
// 10249    *  M260 B<byte-3 value in base 10>
// 10250    *
// 10251    *  M260 S1 ; Send the buffered data and reset the buffer
// 10252    *  M260 R1 ; Reset the buffer without sending data
// 10253    *
// 10254    */
// 10255   inline void gcode_M260() {
// 10256     // Set the target address
// 10257     if (parser.seen('A')) i2c.address(parser.value_byte());
// 10258 
// 10259     // Add a new byte to the buffer
// 10260     if (parser.seen('B')) i2c.addbyte(parser.value_byte());
// 10261 
// 10262     // Flush the buffer to the bus
// 10263     if (parser.seen('S')) i2c.send();
// 10264 
// 10265     // Reset and rewind the buffer
// 10266     else if (parser.seen('R')) i2c.reset();
// 10267   }
// 10268 
// 10269   /**
// 10270    * M261: Request X bytes from I2C slave device
// 10271    *
// 10272    * Usage: M261 A<slave device address base 10> B<number of bytes>
// 10273    */
// 10274   inline void gcode_M261() {
// 10275     if (parser.seen('A')) i2c.address(parser.value_byte());
// 10276 
// 10277     uint8_t bytes = parser.byteval('B', 1);
// 10278 
// 10279     if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
// 10280       i2c.relay(bytes);
// 10281     }
// 10282     else {
// 10283       SERIAL_ERROR_START();
// 10284       SERIAL_ERRORLN("Bad i2c request");
// 10285     }
// 10286   }
// 10287 
// 10288 #endif // EXPERIMENTAL_I2CBUS
// 10289 
// 10290 //#if HAS_SERVOS
// 10291 
// 10292   /**
// 10293    * M280: Get or set servo position. P<index> [S<angle>]
// 10294    */
// 10295   inline void gcode_M280() {
// 10296   	int mksAngle;
// 10297   #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
// 10298     if (!parser.seen('P')) return;
// 10299     const int servo_index = parser.value_int();
// 10300     if (WITHIN(servo_index, 0, 0/*NUM_SERVOS - 1*/)) {
// 10301     if (parser.seen('S'))
// 10302     //MOVE_SERVO(servo_index, parser.value_int());
// 10303     {
// 10304      switch(parser.value_int())
// 10305     	{
// 10306     	case 10:
// 10307 			mksAngle = 700/2;
// 10308 			break;
// 10309 		case 90:
// 10310 			mksAngle = 1500/2;
// 10311 			break;
// 10312 			case 120:
// 10313 			mksAngle = 1800/2;
// 10314 			break;
// 10315 		case 160:
// 10316 			mksAngle = 2200/2;
// 10317 			break;
// 10318 		case 60:
// 10319 			mksAngle = 1200/2;
// 10320 			break;
// 10321 		default:
// 10322 			mksAngle = 2200/2;
// 10323 			break;
// 10324 			
// 10325     	}
// 10326 		MKS_TOUCH_TIM = mksAngle;
// 10327     }        
// 10328       else {
// 10329         SERIAL_ECHO_START();
// 10330         SERIAL_ECHOPAIR(" Servo ", servo_index);
// 10331 		SERIAL_ECHOLNPGM(" out of range");
// 10332         //SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
// 10333       }
// 10334     }
// 10335     else {
// 10336       SERIAL_ERROR_START();
// 10337       SERIAL_ECHOPAIR("Servo ", servo_index);
// 10338       SERIAL_ECHOLNPGM(" out of range");
// 10339     }
// 10340     #endif
// 10341   }
// 10342 
// 10343 //#endif // HAS_SERVOS
// 10344 
// 10345 #if ENABLED(BABYSTEPPING)
// 10346 
// 10347   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10348     FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
// 10349       zprobe_zoffset += offs;
// 10350       SERIAL_ECHO_START();
// 10351       SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
// 10352     }
// 10353   #endif
// 10354 
// 10355   /**
// 10356    * M290: Babystepping
// 10357    */
// 10358   inline void gcode_M290() {
// 10359     #if ENABLED(BABYSTEP_XY)
// 10360       for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
// 10361         if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
// 10362           const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
// 10363           thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
// 10364           #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10365             if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
// 10366           #endif
// 10367         }
// 10368     #else
// 10369       if (parser.seenval('Z') || parser.seenval('S')) {
// 10370         const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
// 10371         thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
// 10372         #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10373           if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
// 10374         #endif
// 10375       }
// 10376     #endif
// 10377   }
// 10378 
// 10379 #endif // BABYSTEPPING
// 10380 
// 10381 #if HAS_BUZZER
// 10382 
// 10383   /**
// 10384    * M300: Play beep sound S<frequency Hz> P<duration ms>
// 10385    */
// 10386   inline void gcode_M300() {
// 10387     uint16_t const frequency = parser.ushortval('S', 260);
// 10388     uint16_t duration = parser.ushortval('P', 1000);
// 10389 
// 10390     // Limits the tone duration to 0-5 seconds.
// 10391     NOMORE(duration, 5000);
// 10392 
// 10393     BUZZ(duration, frequency);
// 10394   }
// 10395 
// 10396 #endif // HAS_BUZZER
// 10397 
// 10398 #if 1//ENABLED(PIDTEMP)
// 10399 
// 10400   /**
// 10401    * M301: Set PID parameters P I D (and optionally C, L)
// 10402    *
// 10403    *   P[float] Kp term
// 10404    *   I[float] Ki term (unscaled)
// 10405    *   D[float] Kd term (unscaled)
// 10406    *
// 10407    * With PID_EXTRUSION_SCALING:
// 10408    *
// 10409    *   C[float] Kc term
// 10410    *   L[float] LPQ length
// 10411    */
// 10412   inline void gcode_M301() {
// 10413 
// 10414     // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
// 10415     // default behaviour (omitting E parameter) is to update for extruder 0 only
// 10416     const uint8_t e = parser.byteval('E'); // extruder being updated
// 10417 
// 10418     if (e < HOTENDS) { // catch bad input value
// 10419       if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
// 10420       if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
// 10421       if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
// 10422       #if ENABLED(PID_EXTRUSION_SCALING)
// 10423         if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
// 10424         if (parser.seen('L')) lpq_len = parser.value_float();
// 10425         NOMORE(lpq_len, LPQ_MAX_LEN);
// 10426       #endif
// 10427 
// 10428       thermalManager.updatePID();
// 10429       SERIAL_ECHO_START();
// 10430       #if ENABLED(PID_PARAMS_PER_HOTEND)
// 10431         SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
// 10432       #endif // PID_PARAMS_PER_HOTEND
// 10433       SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
// 10434       SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
// 10435       SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
// 10436       #if ENABLED(PID_EXTRUSION_SCALING)
// 10437         //Kc does not have scaling applied above, or in resetting defaults
// 10438         SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
// 10439       #endif
// 10440       SERIAL_EOL();
// 10441     }
// 10442     else {
// 10443       SERIAL_ERROR_START();
// 10444       SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
// 10445     }
// 10446   }
// 10447 
// 10448 #endif // PIDTEMP
// 10449 
// 10450 #if 1//ENABLED(PIDTEMPBED)
// 10451 
// 10452   inline void gcode_M304() {
// 10453     if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
// 10454     if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
// 10455     if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
// 10456 
// 10457     SERIAL_ECHO_START();
// 10458     SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
// 10459     SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
// 10460     SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
// 10461   }
// 10462 
// 10463 #endif // PIDTEMPBED
// 10464 
// 10465 #if defined(CHDK) || HAS_PHOTOGRAPH
// 10466 
// 10467   /**
// 10468    * M240: Trigger a camera by emulating a Canon RC-1
// 10469    *       See http://www.doc-diy.net/photo/rc-1_hacked/
// 10470    */
// 10471   inline void gcode_M240() {
// 10472     #ifdef CHDK
// 10473 
// 10474       OUT_WRITE(CHDK, HIGH);
// 10475       chdkHigh = millis();
// 10476       chdkActive = true;
// 10477 
// 10478     #elif HAS_PHOTOGRAPH
// 10479 
// 10480       const uint8_t NUM_PULSES = 16;
// 10481       const float PULSE_LENGTH = 0.01524;
// 10482       for (int i = 0; i < NUM_PULSES; i++) {
// 10483         WRITE(PHOTOGRAPH_PIN, HIGH);
// 10484         _delay_ms(PULSE_LENGTH);
// 10485         WRITE(PHOTOGRAPH_PIN, LOW);
// 10486         _delay_ms(PULSE_LENGTH);
// 10487       }
// 10488       delay(7.33);
// 10489       for (int i = 0; i < NUM_PULSES; i++) {
// 10490         WRITE(PHOTOGRAPH_PIN, HIGH);
// 10491         _delay_ms(PULSE_LENGTH);
// 10492         WRITE(PHOTOGRAPH_PIN, LOW);
// 10493         _delay_ms(PULSE_LENGTH);
// 10494       }
// 10495 
// 10496     #endif // !CHDK && HAS_PHOTOGRAPH
// 10497   }
// 10498 
// 10499 #endif // CHDK || PHOTOGRAPH_PIN
// 10500 
// 10501 #if HAS_LCD_CONTRAST
// 10502 
// 10503   /**
// 10504    * M250: Read and optionally set the LCD contrast
// 10505    */
// 10506   inline void gcode_M250() {
// 10507     if (parser.seen('C')) set_lcd_contrast(parser.value_int());
// 10508     SERIAL_PROTOCOLPGM("lcd contrast value: ");
// 10509     SERIAL_PROTOCOL(lcd_contrast);
// 10510     SERIAL_EOL();
// 10511   }
// 10512 
// 10513 #endif // HAS_LCD_CONTRAST
// 10514 
// 10515 #if ENABLED(PREVENT_COLD_EXTRUSION)
// 10516 
// 10517   /**
// 10518    * M302: Allow cold extrudes, or set the minimum extrude temperature
// 10519    *
// 10520    *       S<temperature> sets the minimum extrude temperature
// 10521    *       P<bool> enables (1) or disables (0) cold extrusion
// 10522    *
// 10523    *  Examples:
// 10524    *
// 10525    *       M302         ; report current cold extrusion state
// 10526    *       M302 P0      ; enable cold extrusion checking
// 10527    *       M302 P1      ; disables cold extrusion checking
// 10528    *       M302 S0      ; always allow extrusion (disables checking)
// 10529    *       M302 S170    ; only allow extrusion above 170
// 10530    *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
// 10531    */
// 10532   inline void gcode_M302() {
// 10533     const bool seen_S = parser.seen('S');
// 10534     if (seen_S) {
// 10535       thermalManager.extrude_min_temp = parser.value_celsius();
// 10536       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
// 10537     }
// 10538 
// 10539     if (parser.seen('P'))
// 10540       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
// 10541     else if (!seen_S) {
// 10542       // Report current state
// 10543       SERIAL_ECHO_START();
// 10544       SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
// 10545       SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
// 10546       SERIAL_ECHOLNPGM("C)");
// 10547     }
// 10548   }
// 10549 
// 10550 #endif // PREVENT_COLD_EXTRUSION
// 10551 
// 10552 /**
// 10553  * M303: PID relay autotune
// 10554  *
// 10555  *       S<temperature> sets the target temperature. (default 150C)
// 10556  *       E<extruder> (-1 for the bed) (default 0)
// 10557  *       C<cycles>
// 10558  *       U<bool> with a non-zero value will apply the result to current settings
// 10559  */
// 10560 inline void gcode_M303() {
// 10561   //#if HAS_PID_HEATING
// 10562   if(HAS_PID_HEATING) {
// 10563     const int e = parser.intval('E'), c = parser.intval('C', 5);
// 10564     const bool u = parser.boolval('U');
// 10565 
// 10566     int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
// 10567 
// 10568     if (WITHIN(e, 0, HOTENDS - 1))
// 10569       target_extruder = e;
// 10570 
// 10571     #if DISABLED(BUSY_WHILE_HEATING)
// 10572       KEEPALIVE_STATE(NOT_BUSY);
// 10573     #endif
// 10574 
// 10575     thermalManager.PID_autotune(temp, e, c, u);
// 10576 
// 10577     #if DISABLED(BUSY_WHILE_HEATING)
// 10578       KEEPALIVE_STATE(IN_HANDLER);
// 10579     #endif
// 10580   }
// 10581   //#else
// 10582   else
// 10583   {
// 10584     SERIAL_ERROR_START();
// 10585     SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
// 10586   }
// 10587   //#endif
// 10588 }
// 10589 
// 10590 #if 1//ENABLED(MORGAN_SCARA)
// 10591 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function _Z17SCARA_move_to_calhh
        THUMB
// 10592   bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
_Z17SCARA_move_to_calhh:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
// 10593     if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??SCARA_move_to_cal_0
// 10594       forward_kinematics_SCARA(delta_a, delta_b);
        MOV      R0,R4
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+4]
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 10595       destination[X_AXIS] = cartes[X_AXIS];
        LDR.W    R0,??DataTable158_1
        LDR.W    R1,??DataTable158
        LDR      R2,[R1, #+72]
        STR      R2,[R0, #+24]
// 10596       destination[Y_AXIS] = cartes[Y_AXIS];
        LDR      R1,[R1, #+76]
        STR      R1,[R0, #+28]
// 10597       destination[Z_AXIS] = current_position[Z_AXIS];
        LDR      R1,[R0, #+16]
        STR      R1,[R0, #+32]
// 10598       prepare_move_to_destination();
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 10599       return true;
        MOVS     R0,#+1
        POP      {R1-R5,PC}
// 10600     }
// 10601     return false;
??SCARA_move_to_cal_0:
        MOVS     R0,#+0
        POP      {R1-R5,PC}       ;; return
          CFI EndBlock cfiBlock64
// 10602   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_1:
        DC32     _ZN7Planner16bed_level_matrixE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_2:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_3:
        DC8      0x58, 0x3A, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_4:
        DC8      " Y:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_5:
        DC32     _ZN17mesh_bed_leveling8z_valuesE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_6:
        DC8      " Z:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_7:
        DC32     axis_relative_modes
// 10603 
// 10604   /**
// 10605    * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
// 10606    */
// 10607   inline bool gcode_M360() {
// 10608     SERIAL_ECHOLNPGM(" Cal: Theta 0");
// 10609     return SCARA_move_to_cal(0, 120);
// 10610   }
// 10611 
// 10612   /**
// 10613    * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
// 10614    */
// 10615   inline bool gcode_M361() {
// 10616     SERIAL_ECHOLNPGM(" Cal: Theta 90");
// 10617     return SCARA_move_to_cal(90, 130);
// 10618   }
// 10619 
// 10620   /**
// 10621    * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
// 10622    */
// 10623   inline bool gcode_M362() {
// 10624     SERIAL_ECHOLNPGM(" Cal: Psi 0");
// 10625     return SCARA_move_to_cal(60, 180);
// 10626   }
// 10627 
// 10628   /**
// 10629    * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
// 10630    */
// 10631   inline bool gcode_M363() {
// 10632     SERIAL_ECHOLNPGM(" Cal: Psi 90");
// 10633     return SCARA_move_to_cal(50, 90);
// 10634   }
// 10635 
// 10636   /**
// 10637    * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
// 10638    */
// 10639   inline bool gcode_M364() {
// 10640     SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
// 10641     return SCARA_move_to_cal(45, 135);
// 10642   }
// 10643 
// 10644 #endif // SCARA
// 10645 
// 10646 #if ENABLED(EXT_SOLENOID)
// 10647 
// 10648   void enable_solenoid(const uint8_t num) {
// 10649     switch (num) {
// 10650       case 0:
// 10651         OUT_WRITE(SOL0_PIN, HIGH);
// 10652         break;
// 10653         #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10654           case 1:
// 10655             OUT_WRITE(SOL1_PIN, HIGH);
// 10656             break;
// 10657         #endif
// 10658         #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10659           case 2:
// 10660             OUT_WRITE(SOL2_PIN, HIGH);
// 10661             break;
// 10662         #endif
// 10663         #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10664           case 3:
// 10665             OUT_WRITE(SOL3_PIN, HIGH);
// 10666             break;
// 10667         #endif
// 10668         #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10669           case 4:
// 10670             OUT_WRITE(SOL4_PIN, HIGH);
// 10671             break;
// 10672         #endif
// 10673       default:
// 10674         SERIAL_ECHO_START();
// 10675         SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
// 10676         break;
// 10677     }
// 10678   }
// 10679 
// 10680   void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
// 10681 
// 10682   void disable_all_solenoids() {
// 10683     OUT_WRITE(SOL0_PIN, LOW);
// 10684     #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10685       OUT_WRITE(SOL1_PIN, LOW);
// 10686     #endif
// 10687     #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10688       OUT_WRITE(SOL2_PIN, LOW);
// 10689     #endif
// 10690     #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10691       OUT_WRITE(SOL3_PIN, LOW);
// 10692     #endif
// 10693     #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10694       OUT_WRITE(SOL4_PIN, LOW);
// 10695     #endif
// 10696   }
// 10697 
// 10698   /**
// 10699    * M380: Enable solenoid on the active extruder
// 10700    */
// 10701   inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
// 10702 
// 10703   /**
// 10704    * M381: Disable all solenoids
// 10705    */
// 10706   inline void gcode_M381() { disable_all_solenoids(); }
// 10707 
// 10708 #endif // EXT_SOLENOID
// 10709 
// 10710 /**
// 10711  * M400: Finish all moves
// 10712  */
// 10713 inline void gcode_M400() { stepper.synchronize(); }
// 10714 
// 10715 #if HAS_BED_PROBE
// 10716 
// 10717   /**
// 10718    * M401: Engage Z Servo endstop if available
// 10719    */
// 10720   inline void gcode_M401() { DEPLOY_PROBE(); }
// 10721 
// 10722   /**
// 10723    * M402: Retract Z Servo endstop if enabled
// 10724    */
// 10725   inline void gcode_M402() { STOW_PROBE(); }
// 10726 
// 10727 #endif // HAS_BED_PROBE
// 10728 
// 10729 #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 10730 
// 10731   /**
// 10732    * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
// 10733    */
// 10734   inline void gcode_M404() {
// 10735     if (parser.seen('W')) {
// 10736       filament_width_nominal = parser.value_linear_units();
// 10737       planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
// 10738     }
// 10739     else {
// 10740       SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
// 10741       SERIAL_PROTOCOLLN(filament_width_nominal);
// 10742     }
// 10743   }
// 10744 
// 10745   /**
// 10746    * M405: Turn on filament sensor for control
// 10747    */
// 10748   inline void gcode_M405() {
// 10749     // This is technically a linear measurement, but since it's quantized to centimeters and is a different
// 10750     // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
// 10751     if (parser.seen('D')) {
// 10752       meas_delay_cm = parser.value_byte();
// 10753       NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
// 10754     }
// 10755 
// 10756     if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
// 10757       const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
// 10758 
// 10759       for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
// 10760         measurement_delay[i] = temp_ratio;
// 10761 
// 10762       filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
// 10763     }
// 10764 
// 10765     filament_sensor = true;
// 10766   }
// 10767 
// 10768   /**
// 10769    * M406: Turn off filament sensor for control
// 10770    */
// 10771   inline void gcode_M406() {
// 10772     filament_sensor = false;
// 10773     planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
// 10774   }
// 10775 
// 10776   /**
// 10777    * M407: Get measured filament diameter on serial output
// 10778    */
// 10779   inline void gcode_M407() {
// 10780     SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
// 10781     SERIAL_PROTOCOLLN(filament_width_meas);
// 10782   }
// 10783 
// 10784 #endif // FILAMENT_WIDTH_SENSOR
// 10785 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function _Z17quickstop_stepperv
        THUMB
// 10786 void quickstop_stepper() {
_Z17quickstop_stepperv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 10787   stepper.quick_stop();
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
// 10788   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 10789   set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 10790   SYNC_PLAN_POSITION_KINEMATIC();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
          CFI EndBlock cfiBlock65
// 10791 }
// 10792 
// 10793 #if 1//HAS_LEVELING
// 10794   /**
// 10795    * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
// 10796    *
// 10797    *   S[bool]   Turns leveling on or off
// 10798    *   Z[height] Sets the Z fade height (0 or none to disable)
// 10799    *   V[bool]   Verbose - Print the leveling grid
// 10800    *
// 10801    * With AUTO_BED_LEVELING_UBL only:
// 10802    *
// 10803    *   L[index]  Load UBL mesh from index (0 is default)
// 10804    */
// 10805   inline void gcode_M420() {
// 10806 
// 10807     const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 10808 
// 10809     //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 10810 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	
// 10811 	{
// 10812       // L to load a mesh from the EEPROM
// 10813       if (parser.seen('L')) {
// 10814 
// 10815         #if ENABLED(EEPROM_SETTINGS)
// 10816           const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
// 10817           const int16_t a = settings.calc_num_meshes();
// 10818 
// 10819           if (!a) {
// 10820             SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10821             return;
// 10822           }
// 10823 
// 10824           if (!WITHIN(storage_slot, 0, a - 1)) {
// 10825             SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
// 10826             SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
// 10827             return;
// 10828           }
// 10829 
// 10830           settings.load_mesh(storage_slot);
// 10831           ubl.storage_slot = storage_slot;
// 10832 
// 10833         #else
// 10834 
// 10835           SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10836           return;
// 10837 
// 10838         #endif
// 10839       }
// 10840 
// 10841       // L to load a mesh from the EEPROM
// 10842       if (parser.seen('L') || parser.seen('V')) {
// 10843         ubl.display_map(0);  // Currently only supports one map type
// 10844         SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
// 10845         SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
// 10846       }
// 10847 	}
// 10848     //#endif // AUTO_BED_LEVELING_UBL
// 10849 
// 10850     // V to print the matrix or mesh
// 10851     if (parser.seen('V')) {
// 10852       //#if ABL_PLANAR
// 10853       if(BED_LEVELING_METHOD&ABL_PLANAR)
// 10854         planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
// 10855 	  else
// 10856 	  {
// 10857       //#else
// 10858         if (leveling_is_valid()) {
// 10859           //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10860           if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 10861           {
// 10862             print_bilinear_leveling_grid();
// 10863             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10864               print_bilinear_leveling_grid_virt();
// 10865             #endif
// 10866           }
// 10867          //#elif ENABLED(MESH_BED_LEVELING)
// 10868          else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 10869          {
// 10870             SERIAL_ECHOLNPGM("Mesh Bed Level data:");
// 10871             mbl_mesh_report();
// 10872          }
// 10873          // #endif
// 10874         }
// 10875 	  }
// 10876       //#endif
// 10877     }
// 10878 
// 10879     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10880 	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
// 10881 	{
// 10882       if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
// 10883 	}
// 10884     #endif
// 10885 
// 10886     bool to_enable = false;
// 10887     if (parser.seen('S')) {
// 10888       to_enable = parser.value_bool();
// 10889       set_bed_leveling_enabled(to_enable);
// 10890     }
// 10891 
// 10892     const bool new_status = planner.leveling_active;
// 10893 
// 10894     if (to_enable && !new_status) {
// 10895       SERIAL_ERROR_START();
// 10896       SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
// 10897     }
// 10898 
// 10899     SERIAL_ECHO_START();
// 10900     SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
// 10901 
// 10902     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10903       SERIAL_ECHO_START();
// 10904       SERIAL_ECHOPGM("Fade Height ");
// 10905       if (planner.z_fade_height > 0.0)
// 10906         SERIAL_ECHOLN(planner.z_fade_height);
// 10907       else
// 10908         SERIAL_ECHOLNPGM(MSG_OFF);
// 10909     #endif
// 10910 
// 10911     // Report change in position
// 10912     if (memcmp(oldpos, current_position, sizeof(oldpos)))
// 10913       report_current_position();
// 10914   }
// 10915 #endif
// 10916 
// 10917 #if 1//ENABLED(MESH_BED_LEVELING)
// 10918 
// 10919   /**
// 10920    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10921    *
// 10922    * Usage:
// 10923    *   M421 X<linear> Y<linear> Z<linear>
// 10924    *   M421 X<linear> Y<linear> Q<offset>
// 10925    *   M421 I<xindex> J<yindex> Z<linear>
// 10926    *   M421 I<xindex> J<yindex> Q<offset>
// 10927    */
// 10928   inline void gcode_M421_MESH_BED_LEVELING() {
// 10929     const bool hasX = parser.seen('X'), hasI = parser.seen('I');
// 10930     const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
// 10931     const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
// 10932     const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
// 10933     const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
// 10934 
// 10935     if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
// 10936       SERIAL_ERROR_START();
// 10937       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10938     }
// 10939     else if (ix < 0 || iy < 0) {
// 10940       SERIAL_ERROR_START();
// 10941       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10942     }
// 10943     else
// 10944       mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
// 10945   }
// 10946 #endif
// 10947 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10948 
// 10949   /**
// 10950    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10951    *
// 10952    * Usage:
// 10953    *   M421 I<xindex> J<yindex> Z<linear>
// 10954    *   M421 I<xindex> J<yindex> Q<offset>
// 10955    */
// 10956   inline void gcode_M421_AUTO_BED_LEVELING_BILINEAR() {
// 10957     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10958     const bool hasI = ix >= 0,
// 10959                hasJ = iy >= 0,
// 10960                hasZ = parser.seen('Z'),
// 10961                hasQ = !hasZ && parser.seen('Q');
// 10962 
// 10963     if (!hasI || !hasJ || !(hasZ || hasQ)) {
// 10964       SERIAL_ERROR_START();
// 10965       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10966     }
// 10967     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10968       SERIAL_ERROR_START();
// 10969       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10970     }
// 10971     else {
// 10972       z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
// 10973       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10974         bed_level_virt_interpolate();
// 10975       #endif
// 10976     }
// 10977   }
// 10978 #endif
// 10979 #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
// 10980 
// 10981   /**
// 10982    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10983    *
// 10984    * Usage:
// 10985    *   M421 I<xindex> J<yindex> Z<linear>
// 10986    *   M421 I<xindex> J<yindex> Q<offset>
// 10987    *   M421 C Z<linear>
// 10988    *   M421 C Q<offset>
// 10989    */
// 10990   inline void gcode_M421_AUTO_BED_LEVELING_UBL() {
// 10991     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10992     const bool hasI = ix >= 0,
// 10993                hasJ = iy >= 0,
// 10994                hasC = parser.seen('C'),
// 10995                hasZ = parser.seen('Z'),
// 10996                hasQ = !hasZ && parser.seen('Q');
// 10997 
// 10998     if (hasC) {
// 10999       const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
// 11000       ix = location.x_index;
// 11001       iy = location.y_index;
// 11002     }
// 11003 
// 11004     if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
// 11005       SERIAL_ERROR_START();
// 11006       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 11007     }
// 11008     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 11009       SERIAL_ERROR_START();
// 11010       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 11011     }
// 11012     else
// 11013       ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
// 11014   }
// 11015 
// 11016 #endif // AUTO_BED_LEVELING_UBL
// 11017 
// 11018 #if 1//HAS_M206_COMMAND
// 11019 
// 11020   /**
// 11021    * M428: Set home_offset based on the distance between the
// 11022    *       current_position and the nearest "reference point."
// 11023    *       If an axis is past center its endstop position
// 11024    *       is the reference-point. Otherwise it uses 0. This allows
// 11025    *       the Z offset to be set near the bed when using a max endstop.
// 11026    *
// 11027    *       M428 can't be used more than 2cm away from 0 or an endstop.
// 11028    *
// 11029    *       Use M206 to set these values directly.
// 11030    */
// 11031   inline void gcode_M428() {
// 11032   
// 11033   	if(MACHINETPYE == DELTA) return;
// 11034 	
// 11035     if (axis_unhomed_error()) return;
// 11036 
// 11037     float diff[XYZ];
// 11038     LOOP_XYZ(i) {
// 11039       diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
// 11040       if (!WITHIN(diff[i], -20, 20) && home_dir((AxisEnum)i) > 0)
// 11041         diff[i] = -current_position[i];
// 11042       if (!WITHIN(diff[i], -20, 20)) {
// 11043         SERIAL_ERROR_START();
// 11044         SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
// 11045         LCD_ALERTMESSAGEPGM("Err: Too far!");
// 11046         BUZZ(200, 40);
// 11047         return;
// 11048       }
// 11049     }
// 11050 
// 11051     LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
// 11052     report_current_position();
// 11053     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
// 11054     BUZZ(100, 659);
// 11055     BUZZ(100, 698);
// 11056   }
// 11057 
// 11058 #endif // HAS_M206_COMMAND
// 11059 
// 11060 /**
// 11061  * M500: Store settings in EEPROM
// 11062  */
// 11063 inline void gcode_M500() {
// 11064   (void)settings.save();
// 11065 }
// 11066 
// 11067 /**
// 11068  * M501: Read settings from EEPROM
// 11069  */
// 11070 inline void gcode_M501() {
// 11071   (void)settings.load();
// 11072 }
// 11073 
// 11074 /**
// 11075  * M502: Revert to default settings
// 11076  */
// 11077 inline void gcode_M502() {
// 11078   (void)settings.reset();
// 11079 }
// 11080 
// 11081 #if DISABLED(DISABLE_M503)
// 11082   /**
// 11083    * M503: print settings currently in memory
// 11084    */
// 11085   inline void gcode_M503() {
// 11086     (void)settings.report(parser.seen('S') && !parser.value_bool());
// 11087   }
// 11088 #endif
// 11089 
// 11090 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 11091 
// 11092   /**
// 11093    * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
// 11094    */
// 11095   inline void gcode_M540() {
// 11096     if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
// 11097   }
// 11098 
// 11099 #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
// 11100 
// 11101 #if HAS_BED_PROBE
// 11102 
// 11103   inline void gcode_M851() {
// 11104     SERIAL_ECHO_START();
// 11105     SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
// 11106     if (parser.seen('Z')) {
// 11107       const float value = parser.value_linear_units();
// 11108       if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
// 11109         SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
// 11110         return;
// 11111       }
// 11112       zprobe_zoffset = value;
// 11113     }
// 11114     SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
// 11115   }
// 11116 
// 11117 #endif // HAS_BED_PROBE
// 11118 
// 11119 #if ENABLED(SKEW_CORRECTION_GCODE)
// 11120 
// 11121   /**
// 11122    * M852: Get or set the machine skew factors. Reports current values with no arguments.
// 11123    *
// 11124    *  S[xy_factor] - Alias for 'I'
// 11125    *  I[xy_factor] - New XY skew factor
// 11126    *  J[xz_factor] - New XZ skew factor
// 11127    *  K[yz_factor] - New YZ skew factor
// 11128    */
// 11129   inline void gcode_M852() {
// 11130     uint8_t ijk = 0, badval = 0, setval = 0;
// 11131 
// 11132     if (parser.seen('I') || parser.seen('S')) {
// 11133       ++ijk;
// 11134       const float value = parser.value_linear_units();
// 11135       if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11136         if (planner.xy_skew_factor != value) {
// 11137           planner.xy_skew_factor = value;
// 11138           ++setval;
// 11139         }
// 11140       }
// 11141       else
// 11142         ++badval;
// 11143     }
// 11144 
// 11145     #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 11146 
// 11147       if (parser.seen('J')) {
// 11148         ++ijk;
// 11149         const float value = parser.value_linear_units();
// 11150         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11151           if (planner.xz_skew_factor != value) {
// 11152             planner.xz_skew_factor = value;
// 11153             ++setval;
// 11154           }
// 11155         }
// 11156         else
// 11157           ++badval;
// 11158       }
// 11159 
// 11160       if (parser.seen('K')) {
// 11161         ++ijk;
// 11162         const float value = parser.value_linear_units();
// 11163         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11164           if (planner.yz_skew_factor != value) {
// 11165             planner.yz_skew_factor = value;
// 11166             ++setval;
// 11167           }
// 11168         }
// 11169         else
// 11170           ++badval;
// 11171       }
// 11172 
// 11173     #endif
// 11174 
// 11175     if (badval)
// 11176       SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
// 11177 
// 11178     // When skew is changed the current position changes
// 11179     if (setval) {
// 11180       set_current_from_steppers_for_axis(ALL_AXES);
// 11181       SYNC_PLAN_POSITION_KINEMATIC();
// 11182       report_current_position();
// 11183     }
// 11184 
// 11185     if (!ijk) {
// 11186       SERIAL_ECHO_START();
// 11187       SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
// 11188       #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 11189         SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
// 11190         SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
// 11191       #else
// 11192         SERIAL_EOL();
// 11193       #endif
// 11194     }
// 11195   }
// 11196 
// 11197 #endif // SKEW_CORRECTION_GCODE
// 11198 
// 11199 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 11200 
// 11201   /**
// 11202    * M600: Pause for filament change
// 11203    *
// 11204    *  E[distance] - Retract the filament this far (negative value)
// 11205    *  Z[distance] - Move the Z axis by this distance
// 11206    *  X[position] - Move to this X position, with Y
// 11207    *  Y[position] - Move to this Y position, with X
// 11208    *  U[distance] - Retract distance for removal (negative value) (manual reload)
// 11209    *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
// 11210    *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
// 11211    *
// 11212    *  Default values are used for omitted arguments.
// 11213    *
// 11214    */
// 11215   inline void gcode_M600() {
// 11216     point_t park_point = NOZZLE_PARK_POINT;
// 11217 
// 11218     #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
// 11219       // Don't allow filament change without homing first
// 11220       if (axis_unhomed_error()) home_all_axes();
// 11221     #endif
// 11222 
// 11223     // Initial retract before move to filament change position
// 11224     const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
// 11225       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 11226         - (PAUSE_PARK_RETRACT_LENGTH)
// 11227       #endif
// 11228     ;
// 11229 
// 11230     // Lift Z axis
// 11231     if (parser.seenval('Z'))
// 11232       park_point.z = parser.linearval('Z');
// 11233 
// 11234     // Move XY axes to filament change position or given position
// 11235     if (parser.seenval('X'))
// 11236       park_point.x = parser.linearval('X');
// 11237 
// 11238     if (parser.seenval('Y'))
// 11239       park_point.y = parser.linearval('Y');
// 11240 
// 11241     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 11242       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 11243       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 11244     #endif
// 11245 
// 11246     // Unload filament
// 11247     const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
// 11248       #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
// 11249         - (FILAMENT_CHANGE_UNLOAD_LENGTH)
// 11250       #endif
// 11251     ;
// 11252 
// 11253     // Load filament
// 11254     const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 11255       #ifdef FILAMENT_CHANGE_LOAD_LENGTH
// 11256         + FILAMENT_CHANGE_LOAD_LENGTH
// 11257       #endif
// 11258     ;
// 11259 
// 11260     const int beep_count = parser.intval('B',
// 11261       #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 11262         FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 11263       #else
// 11264         -1
// 11265       #endif
// 11266     );
// 11267 
// 11268     const bool job_running = print_job_timer.isRunning();
// 11269 
// 11270     if (pause_print(retract, park_point, unload_length, beep_count, true)) {
// 11271       wait_for_filament_reload(beep_count);
// 11272       resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
// 11273     }
// 11274 
// 11275     // Resume the print job timer if it was running
// 11276     if (job_running) print_job_timer.start();
// 11277   }
// 11278 
// 11279 #endif // ADVANCED_PAUSE_FEATURE
// 11280 
// 11281 #if ENABLED(MK2_MULTIPLEXER)
// 11282 
// 11283   inline void select_multiplexed_stepper(const uint8_t e) {
// 11284     stepper.synchronize();
// 11285     disable_e_steppers();
// 11286     WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 11287     WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 11288     WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
// 11289     safe_delay(100);
// 11290   }
// 11291 
// 11292   /**
// 11293    * M702: Unload all extruders
// 11294    */
// 11295   inline void gcode_M702() {
// 11296     for (uint8_t s = 0; s < E_STEPPERS; s++) {
// 11297       select_multiplexed_stepper(e);
// 11298       // TODO: standard unload filament function
// 11299       // MK2 firmware behavior:
// 11300       //  - Make sure temperature is high enough
// 11301       //  - Raise Z to at least 15 to make room
// 11302       //  - Extrude 1cm of filament in 1 second
// 11303       //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
// 11304       //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
// 11305       //  - Restore E max feedrate to 50
// 11306     }
// 11307     // Go back to the last active extruder
// 11308     select_multiplexed_stepper(active_extruder);
// 11309     disable_e_steppers();
// 11310   }
// 11311 
// 11312 #endif // MK2_MULTIPLEXER
// 11313 
// 11314 #if ENABLED(DUAL_X_CARRIAGE)
// 11315 
// 11316   /**
// 11317    * M605: Set dual x-carriage movement mode
// 11318    *
// 11319    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
// 11320    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
// 11321    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
// 11322    *                         units x-offset and an optional differential hotend temperature of
// 11323    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
// 11324    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
// 11325    *
// 11326    *    Note: the X axis should be homed after changing dual x-carriage mode.
// 11327    */
// 11328   inline void gcode_M605() {
// 11329     stepper.synchronize();
// 11330     if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
// 11331     switch (dual_x_carriage_mode) {
// 11332       case DXC_FULL_CONTROL_MODE:
// 11333       case DXC_AUTO_PARK_MODE:
// 11334         break;
// 11335       case DXC_DUPLICATION_MODE:
// 11336         if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
// 11337         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
// 11338         SERIAL_ECHO_START();
// 11339         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 11340         SERIAL_CHAR(' ');
// 11341         SERIAL_ECHO(hotend_offset[X_AXIS][0]);
// 11342         SERIAL_CHAR(',');
// 11343         SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
// 11344         SERIAL_CHAR(' ');
// 11345         SERIAL_ECHO(duplicate_extruder_x_offset);
// 11346         SERIAL_CHAR(',');
// 11347         SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
// 11348         break;
// 11349       default:
// 11350         dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 11351         break;
// 11352     }
// 11353     active_extruder_parked = false;
// 11354     extruder_duplication_enabled = false;
// 11355     delayed_move_time = 0;
// 11356   }
// 11357 
// 11358 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 11359 
// 11360   inline void gcode_M605() {
// 11361     stepper.synchronize();
// 11362     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
// 11363     SERIAL_ECHO_START();
// 11364     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
// 11365   }
// 11366 
// 11367 #endif // DUAL_NOZZLE_DUPLICATION_MODE
// 11368 
// 11369 #if ENABLED(LIN_ADVANCE)
// 11370   /**
// 11371    * M900: Set and/or Get advance K factor and WH/D ratio
// 11372    *
// 11373    *  K<factor>                  Set advance K factor
// 11374    *  R<ratio>                   Set ratio directly (overrides WH/D)
// 11375    *  W<width> H<height> D<diam> Set ratio from WH/D
// 11376    */
// 11377   inline void gcode_M900() {
// 11378     stepper.synchronize();
// 11379 
// 11380     const float newK = parser.floatval('K', -1);
// 11381     if (newK >= 0) planner.extruder_advance_k = newK;
// 11382 
// 11383     float newR = parser.floatval('R', -1);
// 11384     if (newR < 0) {
// 11385       const float newD = parser.floatval('D', -1),
// 11386                   newW = parser.floatval('W', -1),
// 11387                   newH = parser.floatval('H', -1);
// 11388       if (newD >= 0 && newW >= 0 && newH >= 0)
// 11389         newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
// 11390     }
// 11391     if (newR >= 0) planner.advance_ed_ratio = newR;
// 11392 
// 11393     SERIAL_ECHO_START();
// 11394     SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
// 11395     SERIAL_ECHOPGM(" E/D=");
// 11396     const float ratio = planner.advance_ed_ratio;
// 11397     if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
// 11398     SERIAL_EOL();
// 11399   }
// 11400 #endif // LIN_ADVANCE
// 11401 
// 11402 #if HAS_TRINAMIC
// 11403   static bool report_tmc_status = false;
// 11404   const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
// 11405   enum TMC_AxisEnum {
// 11406     TMC_X,
// 11407     TMC_X2,
// 11408     TMC_Y,
// 11409     TMC_Y2,
// 11410     TMC_Z,
// 11411     TMC_Z2,
// 11412     TMC_E0,
// 11413     TMC_E1,
// 11414     TMC_E2,
// 11415     TMC_E3,
// 11416     TMC_E4
// 11417   };
// 11418   #if ENABLED(TMC_DEBUG)
// 11419     enum TMC_debug_enum {
// 11420       TMC_CODES,
// 11421       TMC_ENABLED,
// 11422       TMC_CURRENT,
// 11423       TMC_RMS_CURRENT,
// 11424       TMC_MAX_CURRENT,
// 11425       TMC_IRUN,
// 11426       TMC_IHOLD,
// 11427       TMC_CS_ACTUAL,
// 11428       TMC_PWM_SCALE,
// 11429       TMC_VSENSE,
// 11430       TMC_STEALTHCHOP,
// 11431       TMC_MICROSTEPS,
// 11432       TMC_TSTEP,
// 11433       TMC_TPWMTHRS,
// 11434       TMC_TPWMTHRS_MMS,
// 11435       TMC_OTPW,
// 11436       TMC_OTPW_TRIGGERED,
// 11437       TMC_TOFF,
// 11438       TMC_TBL,
// 11439       TMC_HEND,
// 11440       TMC_HSTRT,
// 11441       TMC_SGT
// 11442     };
// 11443     enum TMC_drv_status_enum {
// 11444       TMC_DRV_CODES,
// 11445       TMC_STST,
// 11446       TMC_OLB,
// 11447       TMC_OLA,
// 11448       TMC_S2GB,
// 11449       TMC_S2GA,
// 11450       TMC_DRV_OTPW,
// 11451       TMC_OT,
// 11452       TMC_STALLGUARD,
// 11453       TMC_DRV_CS_ACTUAL,
// 11454       TMC_FSACTIVE,
// 11455       TMC_SG_RESULT,
// 11456       TMC_DRV_STATUS_HEX,
// 11457       TMC_T157,
// 11458       TMC_T150,
// 11459       TMC_T143,
// 11460       TMC_T120,
// 11461       TMC_STEALTH,
// 11462       TMC_S2VSB,
// 11463       TMC_S2VSA
// 11464     };
// 11465     static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
// 11466       SERIAL_ECHO(name);
// 11467       SERIAL_ECHOPGM(" = 0x");
// 11468       for(int B=24; B>=8; B-=8){
// 11469         MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
// 11470         MYSERIAL.print((drv_status>>B)&0xF, HEX);
// 11471         MYSERIAL.print(':');
// 11472       }
// 11473       MYSERIAL.print((drv_status>>4)&0xF, HEX);
// 11474       MYSERIAL.print((drv_status)&0xF, HEX);
// 11475       SERIAL_EOL();
// 11476     }
// 11477 
// 11478     #if ENABLED(HAVE_TMC2130)
// 11479       static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
// 11480         switch(i) {
// 11481           case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
// 11482           case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
// 11483           case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
// 11484           case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
// 11485           default: break;
// 11486         }
// 11487       }
// 11488       static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
// 11489         switch(i) {
// 11490           case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
// 11491           case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
// 11492           case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
// 11493           default: break;
// 11494         }
// 11495       }
// 11496     #endif
// 11497     #if ENABLED(HAVE_TMC2208)
// 11498       static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
// 11499         switch(i) {
// 11500           case TMC_TSTEP:
// 11501             {
// 11502               uint32_t data = 0;
// 11503               st.TSTEP(&data);
// 11504               MYSERIAL.print(data);
// 11505               break;
// 11506             }
// 11507           case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
// 11508           case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
// 11509           case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
// 11510           case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
// 11511           default: break;
// 11512         }
// 11513       }
// 11514       static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
// 11515         switch(i) {
// 11516           case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
// 11517           case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
// 11518           case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
// 11519           case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
// 11520           default: break;
// 11521         }
// 11522       }
// 11523     #endif
// 11524     template <typename TMC>
// 11525     static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
// 11526       SERIAL_ECHO('\t');
// 11527       switch(i) {
// 11528         case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
// 11529         case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
// 11530         case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
// 11531         case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
// 11532         case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
// 11533         case TMC_IRUN:
// 11534           MYSERIAL.print(st.irun(), DEC);
// 11535           SERIAL_ECHOPGM("/31");
// 11536           break;
// 11537         case TMC_IHOLD:
// 11538           MYSERIAL.print(st.ihold(), DEC);
// 11539           SERIAL_ECHOPGM("/31");
// 11540           break;
// 11541         case TMC_CS_ACTUAL:
// 11542           MYSERIAL.print(st.cs_actual(), DEC);
// 11543           SERIAL_ECHOPGM("/31");
// 11544           break;
// 11545 
// 11546         case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
// 11547 
// 11548         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
// 11549         case TMC_TPWMTHRS:
// 11550           {
// 11551             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 11552             SERIAL_ECHO(tpwmthrs_val);
// 11553           }
// 11554           break;
// 11555         case TMC_TPWMTHRS_MMS:
// 11556           {
// 11557             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 11558             tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
// 11559           }
// 11560           break;
// 11561         case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
// 11562         case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
// 11563         case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
// 11564         case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
// 11565         case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
// 11566         case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
// 11567         default: tmc_status(st, i); break;
// 11568       }
// 11569     }
// 11570     template <typename TMC>
// 11571     static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
// 11572       SERIAL_ECHOPGM("\t");
// 11573       switch(i) {
// 11574         case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
// 11575         case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
// 11576         case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
// 11577         case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
// 11578         case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
// 11579         case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
// 11580         case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
// 11581         case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
// 11582         case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
// 11583         case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
// 11584         default: tmc_parse_drv_status(st, i); break;
// 11585       }
// 11586     }
// 11587 
// 11588     static void tmc_debug_loop(const TMC_debug_enum i) {
// 11589       #if X_IS_TRINAMIC
// 11590         tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
// 11591       #endif
// 11592       #if X2_IS_TRINAMIC
// 11593         tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
// 11594       #endif
// 11595 
// 11596       #if Y_IS_TRINAMIC
// 11597         tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
// 11598       #endif
// 11599       #if Y2_IS_TRINAMIC
// 11600         tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
// 11601       #endif
// 11602 
// 11603       #if Z_IS_TRINAMIC
// 11604         tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
// 11605       #endif
// 11606       #if Z2_IS_TRINAMIC
// 11607         tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
// 11608       #endif
// 11609 
// 11610       #if E0_IS_TRINAMIC
// 11611         tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
// 11612       #endif
// 11613       #if E1_IS_TRINAMIC
// 11614         tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
// 11615       #endif
// 11616       #if E2_IS_TRINAMIC
// 11617         tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
// 11618       #endif
// 11619       #if E3_IS_TRINAMIC
// 11620         tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
// 11621       #endif
// 11622       #if E4_IS_TRINAMIC
// 11623         tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
// 11624       #endif
// 11625 
// 11626       SERIAL_EOL();
// 11627     }
// 11628 
// 11629     static void drv_status_loop(const TMC_drv_status_enum i) {
// 11630       #if X_IS_TRINAMIC
// 11631         tmc_parse_drv_status(stepperX, TMC_X, i);
// 11632       #endif
// 11633       #if X2_IS_TRINAMIC
// 11634         tmc_parse_drv_status(stepperX2, TMC_X2, i);
// 11635       #endif
// 11636 
// 11637       #if Y_IS_TRINAMIC
// 11638         tmc_parse_drv_status(stepperY, TMC_Y, i);
// 11639       #endif
// 11640       #if Y2_IS_TRINAMIC
// 11641         tmc_parse_drv_status(stepperY2, TMC_Y2, i);
// 11642       #endif
// 11643 
// 11644       #if Z_IS_TRINAMIC
// 11645         tmc_parse_drv_status(stepperZ, TMC_Z, i);
// 11646       #endif
// 11647       #if Z2_IS_TRINAMIC
// 11648         tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
// 11649       #endif
// 11650 
// 11651       #if E0_IS_TRINAMIC
// 11652         tmc_parse_drv_status(stepperE0, TMC_E0, i);
// 11653       #endif
// 11654       #if E1_IS_TRINAMIC
// 11655         tmc_parse_drv_status(stepperE1, TMC_E1, i);
// 11656       #endif
// 11657       #if E2_IS_TRINAMIC
// 11658         tmc_parse_drv_status(stepperE2, TMC_E2, i);
// 11659       #endif
// 11660       #if E3_IS_TRINAMIC
// 11661         tmc_parse_drv_status(stepperE3, TMC_E3, i);
// 11662       #endif
// 11663       #if E4_IS_TRINAMIC
// 11664         tmc_parse_drv_status(stepperE4, TMC_E4, i);
// 11665       #endif
// 11666 
// 11667       SERIAL_EOL();
// 11668     }
// 11669 
// 11670     inline void gcode_M122() {
// 11671       if (parser.seen('S')) {
// 11672         if (parser.value_bool()) {
// 11673           SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
// 11674           report_tmc_status = true;
// 11675         } else
// 11676           report_tmc_status = false;
// 11677       } else {
// 11678         SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
// 11679         SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
// 11680         SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
// 11681         SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
// 11682         SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
// 11683         SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
// 11684         SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
// 11685         SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
// 11686         SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
// 11687         SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
// 11688         SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
// 11689         SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
// 11690         SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
// 11691         SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
// 11692         SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
// 11693         SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
// 11694         SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
// 11695         SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
// 11696         SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
// 11697         SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
// 11698         SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
// 11699         SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
// 11700 
// 11701         SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
// 11702         #if ENABLED(HAVE_TMC2130)
// 11703           SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
// 11704           SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
// 11705           SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
// 11706         #endif
// 11707         SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
// 11708         SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
// 11709         SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
// 11710         SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
// 11711         SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
// 11712         SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
// 11713         SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
// 11714         #if ENABLED(HAVE_TMC2208)
// 11715           SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
// 11716           SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
// 11717           SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
// 11718           SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
// 11719           SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
// 11720           SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
// 11721         #endif
// 11722         SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
// 11723       }
// 11724     }
// 11725   #endif
// 11726 
// 11727   template<typename TMC>
// 11728   static void tmc_get_current(TMC &st, const char name[]) {
// 11729     SERIAL_ECHO(name);
// 11730     SERIAL_ECHOPGM(" axis driver current: ");
// 11731     SERIAL_ECHOLN(st.getCurrent());
// 11732   }
// 11733   template<typename TMC>
// 11734   static void tmc_set_current(TMC &st, const char name[], const int mA) {
// 11735     st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
// 11736     tmc_get_current(st, name);
// 11737   }
// 11738 
// 11739   template<typename TMC>
// 11740   static void tmc_report_otpw(TMC &st, const char name[]) {
// 11741     SERIAL_ECHO(name);
// 11742     SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
// 11743     serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
// 11744     SERIAL_EOL();
// 11745   }
// 11746   template<typename TMC>
// 11747   static void tmc_clear_otpw(TMC &st, const char name[]) {
// 11748     st.clear_otpw();
// 11749     SERIAL_ECHO(name);
// 11750     SERIAL_ECHOLNPGM(" prewarn flag cleared");
// 11751   }
// 11752 
// 11753   template<typename TMC>
// 11754   static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
// 11755     SERIAL_ECHO(name);
// 11756     SERIAL_ECHOPGM(" stealthChop max speed set to ");
// 11757     SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
// 11758   }
// 11759   template<typename TMC>
// 11760   static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
// 11761     st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
// 11762     tmc_get_pwmthrs(st, name, spmm);
// 11763   }
// 11764 
// 11765   template<typename TMC>
// 11766   static void tmc_get_sgt(TMC &st, const char name[]) {
// 11767     SERIAL_ECHO(name);
// 11768     SERIAL_ECHOPGM(" driver homing sensitivity set to ");
// 11769     MYSERIAL.println(st.sgt(), DEC);
// 11770   }
// 11771   template<typename TMC>
// 11772   static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
// 11773     st.sgt(sgt_val);
// 11774     tmc_get_sgt(st, name);
// 11775   }
// 11776 
// 11777   /**
// 11778    * M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 11779    * Report driver currents when no axis specified
// 11780    */
// 11781   inline void gcode_M906() {
// 11782     uint16_t values[XYZE];
// 11783     LOOP_XYZE(i)
// 11784       values[i] = parser.intval(axis_codes[i]);
// 11785 
// 11786     #if X_IS_TRINAMIC
// 11787       if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
// 11788       else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
// 11789     #endif
// 11790     #if X2_IS_TRINAMIC
// 11791       if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
// 11792       else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
// 11793     #endif
// 11794     #if Y_IS_TRINAMIC
// 11795       if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
// 11796       else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
// 11797     #endif
// 11798     #if Y2_IS_TRINAMIC
// 11799       if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
// 11800       else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
// 11801     #endif
// 11802     #if Z_IS_TRINAMIC
// 11803       if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
// 11804       else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
// 11805     #endif
// 11806     #if Z2_IS_TRINAMIC
// 11807       if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
// 11808       else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
// 11809     #endif
// 11810     #if E0_IS_TRINAMIC
// 11811       if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
// 11812       else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
// 11813     #endif
// 11814     #if E1_IS_TRINAMIC
// 11815       if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
// 11816       else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
// 11817     #endif
// 11818     #if E2_IS_TRINAMIC
// 11819       if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
// 11820       else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
// 11821     #endif
// 11822     #if E3_IS_TRINAMIC
// 11823       if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
// 11824       else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
// 11825     #endif
// 11826     #if E4_IS_TRINAMIC
// 11827       if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
// 11828       else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
// 11829     #endif
// 11830 
// 11831   }
// 11832 
// 11833   /**
// 11834    * M911: Report TMC stepper driver overtemperature pre-warn flag
// 11835    * The flag is held by the library and persist until manually cleared by M912
// 11836    */
// 11837   inline void gcode_M911() {
// 11838     #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11839       tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11840     #endif
// 11841     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11842       tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11843     #endif
// 11844     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11845       tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11846     #endif
// 11847     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11848       tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11849     #endif
// 11850   }
// 11851 
// 11852   /**
// 11853    * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
// 11854    */
// 11855   inline void gcode_M912() {
// 11856     const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
// 11857              clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
// 11858     #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11859       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11860     #endif
// 11861     #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11862       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11863     #endif
// 11864 
// 11865     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
// 11866       if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11867     #endif
// 11868 
// 11869     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
// 11870       if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11871     #endif
// 11872 
// 11873     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
// 11874       if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11875     #endif
// 11876   }
// 11877 
// 11878   /**
// 11879    * M913: Set HYBRID_THRESHOLD speed.
// 11880    */
// 11881   #if ENABLED(HYBRID_THRESHOLD)
// 11882     inline void gcode_M913() {
// 11883       uint16_t values[XYZE];
// 11884       LOOP_XYZE(i)
// 11885         values[i] = parser.intval(axis_codes[i]);
// 11886 
// 11887       #if X_IS_TRINAMIC
// 11888         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11889         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
// 11890       #endif
// 11891       #if X2_IS_TRINAMIC
// 11892         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11893         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
// 11894       #endif
// 11895 
// 11896       #if Y_IS_TRINAMIC
// 11897         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11898         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
// 11899       #endif
// 11900       #if Y2_IS_TRINAMIC
// 11901         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11902         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
// 11903       #endif
// 11904 
// 11905       #if Z_IS_TRINAMIC
// 11906         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11907         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
// 11908       #endif
// 11909       #if Z2_IS_TRINAMIC
// 11910         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11911         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
// 11912       #endif
// 11913 
// 11914       #if E0_IS_TRINAMIC
// 11915         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11916         else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
// 11917       #endif
// 11918       #if E1_IS_TRINAMIC
// 11919         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11920         else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
// 11921       #endif
// 11922       #if E2_IS_TRINAMIC
// 11923         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11924         else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
// 11925       #endif
// 11926       #if E3_IS_TRINAMIC
// 11927         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11928         else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
// 11929       #endif
// 11930       #if E4_IS_TRINAMIC
// 11931         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11932         else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
// 11933       #endif
// 11934     }
// 11935   #endif // HYBRID_THRESHOLD
// 11936 
// 11937   /**
// 11938    * M914: Set SENSORLESS_HOMING sensitivity.
// 11939    */
// 11940   #if ENABLED(SENSORLESS_HOMING)
// 11941     inline void gcode_M914() {
// 11942       #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11943         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
// 11944         else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
// 11945       #endif
// 11946       #if ENABLED(X2_IS_TMC2130)
// 11947         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
// 11948         else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
// 11949       #endif
// 11950       #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11951         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
// 11952         else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
// 11953       #endif
// 11954       #if ENABLED(Y2_IS_TMC2130)
// 11955         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
// 11956         else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
// 11957       #endif
// 11958     }
// 11959   #endif // SENSORLESS_HOMING
// 11960 
// 11961   /**
// 11962    * TMC Z axis calibration routine
// 11963    */
// 11964   #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 11965     inline void gcode_M915() {
// 11966       uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
// 11967       uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
// 11968 
// 11969       if (!axis_known_position[Z_AXIS]) {
// 11970         SERIAL_ECHOLNPGM("\nPlease home Z axis first");
// 11971         return;
// 11972       }
// 11973 
// 11974       uint16_t Z_current_1 = stepperZ.getCurrent();
// 11975       uint16_t Z2_current_1 = stepperZ.getCurrent();
// 11976 
// 11977       stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11978       stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11979       SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
// 11980 
// 11981       soft_endstops_enabled = false;
// 11982 
// 11983       do_blocking_move_to_z(Z_MAX_POS+_z);
// 11984 
// 11985       stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11986       stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11987 
// 11988       do_blocking_move_to_z(Z_MAX_POS);
// 11989       soft_endstops_enabled = true;
// 11990 
// 11991       SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
// 11992       home_z_safely();
// 11993     }
// 11994   #endif
// 11995 
// 11996 #endif // HAS_TRINAMIC
// 11997 
// 11998 /**
// 11999  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
// 12000  */
// 12001 inline void gcode_M907() {
// 12002   #if HAS_DIGIPOTSS
// 12003 
// 12004     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
// 12005     if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
// 12006     if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
// 12007 
// 12008   #elif HAS_MOTOR_CURRENT_PWM
// 12009 
// 12010     #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
// 12011       if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
// 12012     #endif
// 12013     #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
// 12014       if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
// 12015     #endif
// 12016     #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
// 12017       if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
// 12018     #endif
// 12019 
// 12020   #endif
// 12021 
// 12022   #if ENABLED(DIGIPOT_I2C)
// 12023     // this one uses actual amps in floating point
// 12024     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
// 12025     // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
// 12026     for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
// 12027   #endif
// 12028 
// 12029   #if ENABLED(DAC_STEPPER_CURRENT)
// 12030     if (parser.seen('S')) {
// 12031       const float dac_percent = parser.value_float();
// 12032       for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
// 12033     }
// 12034     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
// 12035   #endif
// 12036 }
// 12037 
// 12038 #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 12039 
// 12040   /**
// 12041    * M908: Control digital trimpot directly (M908 P<pin> S<current>)
// 12042    */
// 12043   inline void gcode_M908() {
// 12044     #if HAS_DIGIPOTSS
// 12045       stepper.digitalPotWrite(
// 12046         parser.intval('P'),
// 12047         parser.intval('S')
// 12048       );
// 12049     #endif
// 12050     #ifdef DAC_STEPPER_CURRENT
// 12051       dac_current_raw(
// 12052         parser.byteval('P', -1),
// 12053         parser.ushortval('S', 0)
// 12054       );
// 12055     #endif
// 12056   }
// 12057 
// 12058   #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 12059 
// 12060     inline void gcode_M909() { dac_print_values(); }
// 12061 
// 12062     inline void gcode_M910() { dac_commit_eeprom(); }
// 12063 
// 12064   #endif
// 12065 
// 12066 #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 12067 
// 12068 #if HAS_MICROSTEPS
// 12069 
// 12070   // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 12071   inline void gcode_M350() {
// 12072     if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
// 12073     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
// 12074     if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
// 12075     stepper.microstep_readings();
// 12076   }
// 12077 
// 12078   /**
// 12079    * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
// 12080    *       S# determines MS1 or MS2, X# sets the pin high/low.
// 12081    */
// 12082   inline void gcode_M351() {
// 12083     if (parser.seenval('S')) switch (parser.value_byte()) {
// 12084       case 1:
// 12085         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
// 12086         if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
// 12087         break;
// 12088       case 2:
// 12089         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
// 12090         if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
// 12091         break;
// 12092     }
// 12093     stepper.microstep_readings();
// 12094   }
// 12095 
// 12096 #endif // HAS_MICROSTEPS
// 12097 
// 12098 #if HAS_CASE_LIGHT
// 12099   #ifndef INVERT_CASE_LIGHT
// 12100     #define INVERT_CASE_LIGHT false
// 12101   #endif
// 12102   uint8_t case_light_brightness;  // LCD routine wants INT
// 12103   bool case_light_on;
// 12104 
// 12105   void update_case_light() {
// 12106     pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
// 12107     if (case_light_on) {
// 12108       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 12109         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
// 12110       else
// 12111         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
// 12112     }
// 12113     else {
// 12114       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 12115         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
// 12116       else
// 12117         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
// 12118     }
// 12119   }
// 12120 #endif // HAS_CASE_LIGHT
// 12121 
// 12122 /**
// 12123  * M355: Turn case light on/off and set brightness
// 12124  *
// 12125  *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
// 12126  *
// 12127  *   S<bool>  Set case light on/off
// 12128  *
// 12129  *   When S turns on the light on a PWM pin then the current brightness level is used/restored
// 12130  *
// 12131  *   M355 P200 S0 turns off the light & sets the brightness level
// 12132  *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
// 12133  */
// 12134 inline void gcode_M355() {
// 12135   #if HAS_CASE_LIGHT
// 12136     uint8_t args = 0;
// 12137     if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
// 12138     if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
// 12139     if (args) update_case_light();
// 12140 
// 12141     // always report case light status
// 12142     SERIAL_ECHO_START();
// 12143     if (!case_light_on) {
// 12144       SERIAL_ECHOLN("Case light: off");
// 12145     }
// 12146     else {
// 12147       if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
// 12148       else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
// 12149     }
// 12150 
// 12151   #else
// 12152     SERIAL_ERROR_START();
// 12153     SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
// 12154   #endif // HAS_CASE_LIGHT
// 12155 }
// 12156 
// 12157 #if ENABLED(MIXING_EXTRUDER)
// 12158 
// 12159   /**
// 12160    * M163: Set a single mix factor for a mixing extruder
// 12161    *       This is called "weight" by some systems.
// 12162    *
// 12163    *   S[index]   The channel index to set
// 12164    *   P[float]   The mix value
// 12165    *
// 12166    */
// 12167   inline void gcode_M163() {
// 12168     const int mix_index = parser.intval('S');
// 12169     if (mix_index < MIXING_STEPPERS) {
// 12170       float mix_value = parser.floatval('P');
// 12171       NOLESS(mix_value, 0.0);
// 12172       mixing_factor[mix_index] = RECIPROCAL(mix_value);
// 12173     }
// 12174   }
// 12175 
// 12176   #if MIXING_VIRTUAL_TOOLS > 1
// 12177 
// 12178     /**
// 12179      * M164: Store the current mix factors as a virtual tool.
// 12180      *
// 12181      *   S[index]   The virtual tool to store
// 12182      *
// 12183      */
// 12184     inline void gcode_M164() {
// 12185       const int tool_index = parser.intval('S');
// 12186       if (tool_index < MIXING_VIRTUAL_TOOLS) {
// 12187         normalize_mix();
// 12188         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 12189           mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
// 12190       }
// 12191     }
// 12192 
// 12193   #endif
// 12194 
// 12195   #if ENABLED(DIRECT_MIXING_IN_G1)
// 12196     /**
// 12197      * M165: Set multiple mix factors for a mixing extruder.
// 12198      *       Factors that are left out will be set to 0.
// 12199      *       All factors together must add up to 1.0.
// 12200      *
// 12201      *   A[factor] Mix factor for extruder stepper 1
// 12202      *   B[factor] Mix factor for extruder stepper 2
// 12203      *   C[factor] Mix factor for extruder stepper 3
// 12204      *   D[factor] Mix factor for extruder stepper 4
// 12205      *   H[factor] Mix factor for extruder stepper 5
// 12206      *   I[factor] Mix factor for extruder stepper 6
// 12207      *
// 12208      */
// 12209     inline void gcode_M165() { gcode_get_mix(); }
// 12210   #endif
// 12211 
// 12212 #endif // MIXING_EXTRUDER
// 12213 
// 12214 /**
// 12215  * M999: Restart after being stopped
// 12216  *
// 12217  * Default behaviour is to flush the serial buffer and request
// 12218  * a resend to the host starting on the last N line received.
// 12219  *
// 12220  * Sending "M999 S1" will resume printing without flushing the
// 12221  * existing command buffer.
// 12222  *
// 12223  */
// 12224 inline void gcode_M999() {
// 12225   Running = true;
// 12226   lcd_reset_alert_level();
// 12227 
// 12228   if (parser.boolval('S')) return;
// 12229 
// 12230   // gcode_LastN = Stopped_gcode_LastN;
// 12231   FlushSerialRequestResend();
// 12232 }
// 12233 
// 12234 #if ENABLED(SWITCHING_EXTRUDER)
// 12235   #if EXTRUDERS > 3
// 12236     #define REQ_ANGLES 4
// 12237     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
// 12238   #else
// 12239     #define REQ_ANGLES 2
// 12240     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
// 12241   #endif
// 12242   inline void move_extruder_servo(const uint8_t e) {
// 12243     constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
// 12244     static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
// 12245     stepper.synchronize();
// 12246     #if EXTRUDERS & 1
// 12247       if (e < EXTRUDERS - 1)
// 12248     #endif
// 12249     {
// 12250       MOVE_SERVO(_SERVO_NR, angles[e]);
// 12251       safe_delay(500);
// 12252     }
// 12253   }
// 12254 #endif // SWITCHING_EXTRUDER
// 12255 
// 12256 #if ENABLED(SWITCHING_NOZZLE)
// 12257   inline void move_nozzle_servo(const uint8_t e) {
// 12258     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
// 12259     stepper.synchronize();
// 12260     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
// 12261     safe_delay(500);
// 12262   }
// 12263 #endif
// 12264 
// 12265 inline void invalid_extruder_error(const uint8_t e) {
// 12266   SERIAL_ECHO_START();
// 12267   SERIAL_CHAR('T');
// 12268   SERIAL_ECHO_F(e, DEC);
// 12269   SERIAL_CHAR(' ');
// 12270   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
// 12271 }
// 12272 
// 12273 #if ENABLED(PARKING_EXTRUDER)
// 12274 
// 12275   #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12276     #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 12277   #else
// 12278     #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 12279   #endif
// 12280 
// 12281   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
// 12282     switch (extruder_num) {
// 12283       case 1: OUT_WRITE(SOL1_PIN, state); break;
// 12284       default: OUT_WRITE(SOL0_PIN, state); break;
// 12285     }
// 12286     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
// 12287       dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
// 12288     #endif
// 12289   }
// 12290 
// 12291   inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
// 12292   inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
// 12293 
// 12294 #endif // PARKING_EXTRUDER
// 12295 
// 12296 #if HAS_FANMUX
// 12297 
// 12298   void fanmux_switch(const uint8_t e) {
// 12299     WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 12300     #if PIN_EXISTS(FANMUX1)
// 12301       WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 12302       #if PIN_EXISTS(FANMUX2)
// 12303         WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
// 12304       #endif
// 12305     #endif
// 12306   }
// 12307 
// 12308   FORCE_INLINE void fanmux_init(void) {
// 12309     SET_OUTPUT(FANMUX0_PIN);
// 12310     #if PIN_EXISTS(FANMUX1)
// 12311       SET_OUTPUT(FANMUX1_PIN);
// 12312       #if PIN_EXISTS(FANMUX2)
// 12313         SET_OUTPUT(FANMUX2_PIN);
// 12314       #endif
// 12315     #endif
// 12316     fanmux_switch(0);
// 12317   }
// 12318 
// 12319 #endif // HAS_FANMUX
// 12320 
// 12321 /**
// 12322  * Perform a tool-change, which may result in moving the
// 12323  * previous tool out of the way and the new tool into place.
// 12324  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function _Z11tool_changehfb
        THUMB
// 12325 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
_Z11tool_changehfb:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+100
          CFI CFA R13+136
        MOV      R6,R0
        MOV      R0,R1
        MOV      R5,R2
// 12326   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 12327 
// 12328     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
// 12329       return invalid_extruder_error(tmp_extruder);
// 12330 
// 12331     // T0-Tnnn: Switch virtual tool by changing the mix
// 12332     for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
// 12333       mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
// 12334 
// 12335   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 12336 
// 12337     if (tmp_extruder >= EXTRUDERS)
        MOV      R10,R6
        CMP      R10,#+2
        BLT.N    ??tool_change_0
// 12338       return invalid_extruder_error(tmp_extruder);
        MOV      R0,R6
          CFI FunCall _Z22invalid_extruder_errorh
        BL       _Z22invalid_extruder_errorh
        B.N      ??tool_change_1
// 12339 
// 12340     #if HOTENDS > 1
// 12341 
// 12342       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
??tool_change_0:
        LDR.W    R4,??DataTable158_1
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??tool_change_2
        STR      R0,[SP, #+24]
        B.N      ??tool_change_3
??tool_change_2:
        LDR      R1,[R4, #+92]
        STR      R1,[SP, #+24]
// 12343 
// 12344       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??tool_change_3:
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??tool_change_4
        STR      R0,[R4, #+92]
        B.N      ??tool_change_5
??tool_change_4:
        LDR      R0,[R4, #+116]
        STR      R0,[R4, #+92]
// 12345 
// 12346       if (tmp_extruder != active_extruder) {
??tool_change_5:
        LDRB     R0,[R4, #+3]
        CMP      R6,R0
        BEQ.W    ??tool_change_6
// 12347         if (!no_move && axis_unhomed_error()) {
        CMP      R5,#+0
        BNE.N    ??tool_change_7
        MOVS     R2,#+1
        MOV      R1,R2
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BEQ.N    ??tool_change_7
// 12348           no_move = true;
        MOVS     R5,#+1
// 12349           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12350             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
// 12351           #endif
// 12352         }
// 12353 
// 12354         // Save current position to destination, for use later
// 12355         //if(gCfgItems.breakpoint_flg!=1)
// 12356             set_destination_from_current();
??tool_change_7:
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
// 12357 
// 12358         #if ENABLED(DUAL_X_CARRIAGE)
// 12359 
// 12360           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12361             if (DEBUGGING(LEVELING)) {
// 12362               SERIAL_ECHOPGM("Dual X Carriage Mode ");
// 12363               switch (dual_x_carriage_mode) {
// 12364                 case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
// 12365                 case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
// 12366                 case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
// 12367               }
// 12368             }
// 12369           #endif
// 12370 
// 12371           const float xhome = x_home_pos(active_extruder);
// 12372           if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
// 12373               && IsRunning()
// 12374               && (delayed_move_time || current_position[X_AXIS] != xhome)
// 12375           ) {
// 12376             float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
// 12377             //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 12378             if(mksCfg.max_software_endstops){
// 12379               NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
// 12380             }
// 12381             //#endif
// 12382             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12383               if (DEBUGGING(LEVELING)) {
// 12384                 SERIAL_ECHOLNPAIR("Raise to ", raised_z);
// 12385                 SERIAL_ECHOLNPAIR("MoveX to ", xhome);
// 12386                 SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
// 12387               }
// 12388             #endif
// 12389             // Park old head: 1) raise 2) move to park position 3) lower
// 12390             for (uint8_t i = 0; i < 3; i++)
// 12391               planner.buffer_line(
// 12392                 i == 0 ? current_position[X_AXIS] : xhome,
// 12393                 current_position[Y_AXIS],
// 12394                 i == 2 ? current_position[Z_AXIS] : raised_z,
// 12395                 current_position[E_AXIS],
// 12396                 planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
// 12397                 active_extruder
// 12398               );
// 12399             stepper.synchronize();
// 12400           }
// 12401 
// 12402           // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
// 12403           current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
// 12404           current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 12405 
// 12406           // Activate the new extruder ahead of calling set_axis_is_at_home!
// 12407           active_extruder = tmp_extruder;
// 12408 
// 12409           // This function resets the max/min values - the current position may be overwritten below.
// 12410           set_axis_is_at_home(X_AXIS);
// 12411 
// 12412           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12413             if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
// 12414           #endif
// 12415 
// 12416           // Only when auto-parking are carriages safe to move
// 12417           if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
// 12418 
// 12419           switch (dual_x_carriage_mode) {
// 12420             case DXC_FULL_CONTROL_MODE:
// 12421               // New current position is the position of the activated extruder
// 12422               current_position[X_AXIS] = inactive_extruder_x_pos;
// 12423               // Save the inactive extruder's position (from the old current_position)
// 12424               inactive_extruder_x_pos = destination[X_AXIS];
// 12425               break;
// 12426             case DXC_AUTO_PARK_MODE:
// 12427               // record raised toolhead position for use by unpark
// 12428               COPY(raised_parked_position, current_position);
// 12429               raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
// 12430               //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 12431               if(mksCfg.max_software_endstops){
// 12432                 NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
// 12433               }
// 12434               //#endif
// 12435               active_extruder_parked = true;
// 12436               delayed_move_time = 0;
// 12437               break;
// 12438             case DXC_DUPLICATION_MODE:
// 12439               // If the new extruder is the left one, set it "parked"
// 12440               // This triggers the second extruder to move into the duplication position
// 12441               active_extruder_parked = (active_extruder == 0);
// 12442 
// 12443               if (active_extruder_parked)
// 12444                 current_position[X_AXIS] = inactive_extruder_x_pos;
// 12445               else
// 12446                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
// 12447               inactive_extruder_x_pos = destination[X_AXIS];
// 12448               extruder_duplication_enabled = false;
// 12449               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12450                 if (DEBUGGING(LEVELING)) {
// 12451                   SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
// 12452                   SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
// 12453                 }
// 12454               #endif
// 12455               break;
// 12456           }
// 12457 
// 12458           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12459             if (DEBUGGING(LEVELING)) {
// 12460               SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
// 12461               DEBUG_POS("New extruder (parked)", current_position);
// 12462             }
// 12463           #endif
// 12464 
// 12465           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
// 12466 
// 12467         #else // !DUAL_X_CARRIAGE
// 12468 
// 12469           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
// 12470             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 12471             float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
// 12472             if (!no_move) {
// 12473 
// 12474               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
// 12475                           midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
// 12476                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
// 12477                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
// 12478               /**
// 12479                *  Steps:
// 12480                *    1. Raise Z-Axis to give enough clearance
// 12481                *    2. Move to park position of old extruder
// 12482                *    3. Disengage magnetic field, wait for delay
// 12483                *    4. Move near new extruder
// 12484                *    5. Engage magnetic field for new extruder
// 12485                *    6. Move to parking incl. offset of new extruder
// 12486                *    7. Lower Z-Axis
// 12487                */
// 12488 
// 12489               // STEP 1
// 12490               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12491                 SERIAL_ECHOLNPGM("Starting Autopark");
// 12492                 if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
// 12493               #endif
// 12494               current_position[Z_AXIS] += z_raise;
// 12495               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12496                 SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
// 12497                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
// 12498               #endif
// 12499               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 12500               stepper.synchronize();
// 12501 
// 12502               // STEP 2
// 12503               current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
// 12504               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12505                 SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
// 12506                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
// 12507               #endif
// 12508               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12509               stepper.synchronize();
// 12510 
// 12511               // STEP 3
// 12512               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12513                 SERIAL_ECHOLNPGM("(3) Disengage magnet ");
// 12514               #endif
// 12515               pe_deactivate_magnet(active_extruder);
// 12516 
// 12517               // STEP 4
// 12518               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12519                 SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
// 12520               #endif
// 12521               current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
// 12522 
// 12523               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12524                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
// 12525               #endif
// 12526               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12527               stepper.synchronize();
// 12528 
// 12529               // STEP 5
// 12530               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12531                 SERIAL_ECHOLNPGM("(5) Engage magnetic field");
// 12532               #endif
// 12533 
// 12534               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12535                 pe_activate_magnet(active_extruder); //just save power for inverted magnets
// 12536               #endif
// 12537               pe_activate_magnet(tmp_extruder);
// 12538 
// 12539               // STEP 6
// 12540               current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
// 12541               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12542               current_position[X_AXIS] = grabpos;
// 12543               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12544                 SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
// 12545                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
// 12546               #endif
// 12547               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
// 12548               stepper.synchronize();
// 12549 
// 12550               // Step 7
// 12551               current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
// 12552               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12553                 SERIAL_ECHOLNPGM("(7) Move midway between hotends");
// 12554                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
// 12555               #endif
// 12556               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12557               stepper.synchronize();
// 12558               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12559                 SERIAL_ECHOLNPGM("Autopark done.");
// 12560               #endif
// 12561             }
// 12562             else { // nomove == true
// 12563               // Only engage magnetic field for new extruder
// 12564               pe_activate_magnet(tmp_extruder);
// 12565               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12566                 pe_activate_magnet(active_extruder); // Just save power for inverted magnets
// 12567               #endif
// 12568             }
// 12569             current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
// 12570 
// 12571             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12572               if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
// 12573             #endif
// 12574 
// 12575           #endif // dualParking extruder
// 12576 
// 12577           #if ENABLED(SWITCHING_NOZZLE)
// 12578             #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
// 12579             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
// 12580             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
// 12581                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
// 12582 
// 12583             // Always raise by some amount (destination copied from current_position earlier)
// 12584             current_position[Z_AXIS] += z_raise;
// 12585             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 12586             move_nozzle_servo(tmp_extruder);
// 12587           #endif
// 12588 
// 12589           /**
// 12590            * Set current_position to the position of the new nozzle.
// 12591            * Offsets are based on linear distance, so we need to get
// 12592            * the resulting position in coordinate space.
// 12593            *
// 12594            * - With grid or 3-point leveling, offset XYZ by a tilted vector
// 12595            * - With mesh leveling, update Z for the new position
// 12596            * - Otherwise, just use the raw linear distance
// 12597            *
// 12598            * Software endstops are altered here too. Consider a case where:
// 12599            *   E0 at X=0 ... E1 at X=10
// 12600            * When we switch to E1 now X=10, but E1 can't move left.
// 12601            * To express this we apply the change in XY to the software endstops.
// 12602            * E1 can move farther right than E0, so the right limit is extended.
// 12603            *
// 12604            * Note that we don't adjust the Z software endstops. Why not?
// 12605            * Consider a case where Z=0 (here) and switching to E1 makes Z=1
// 12606            * because the bed is 1mm lower at the new position. As long as
// 12607            * the first nozzle is out of the way, the carriage should be
// 12608            * allowed to move 1mm lower. This technically "breaks" the
// 12609            * Z software endstop. But this is technically correct (and
// 12610            * there is no viable alternative).
// 12611            */
// 12612           //#if ABL_PLANAR
// 12613           float xydiff[2]={0};
        MOV      R8,#+0
        MOV      R9,R8
        LDR.W    R7,??DataTable162_1
        LDR.W    R0,??DataTable160
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??tool_change_8
// 12614 		  if(BED_LEVELING_METHOD&ABL_PLANAR)
// 12615 		  	{
// 12616             // Offset extruder, make sure to apply the bed level rotation matrix
// 12617             vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
// 12618                                                hotend_offset[Y_AXIS][tmp_extruder],
// 12619                                                0),
        LDR.W    R9,??DataTable162_2
        MOV      R3,R8
        ADD      R0,R9,R10, LSL #+2
        LDR      R2,[R0, #+8]
        LDR      R1,[R9, R10, LSL #+2]
        ADD      R0,SP,#+52
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDRB     R0,[R4, #+3]
        MOV      R3,R8
        ADD      R1,R9,R0, LSL #+2
        LDR      R2,[R1, #+8]
        LDR      R1,[R9, R0, LSL #+2]
        ADD      R0,SP,#+40
// 12620                      act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
// 12621                                                hotend_offset[Y_AXIS][active_extruder],
// 12622                                                0),
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        ADD      R0,SP,#+40
        SUB      SP,SP,#+8
          CFI CFA R13+144
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+136
        ADD      R1,SP,#+52
        ADD      R0,SP,#+4
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
// 12623                      offset_vec = tmp_offset_vec - act_offset_vec;
        ADD      R0,SP,#+28
        ADD      R1,SP,#+4
        LDM      R1!,{R2,R3,R12}
        STM      R0!,{R2,R3,R12}
// 12624 
// 12625             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12626               if (DEBUGGING(LEVELING)) {
// 12627                 tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
// 12628                 act_offset_vec.debug(PSTR("act_offset_vec"));
// 12629                 offset_vec.debug(PSTR("offset_vec (BEFORE)"));
// 12630               }
// 12631             #endif
// 12632 
// 12633             offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
        LDR.W    R1,??DataTable162_3
        SUB      SP,SP,#+12
          CFI CFA R13+148
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R1-R3}
          CFI CFA R13+136
        ADD      R0,SP,#+64
          CFI FunCall _ZN10matrix_3x39transposeES_
        BL       _ZN10matrix_3x39transposeES_
        ADD      R1,SP,#+64
        SUB      SP,SP,#+12
          CFI CFA R13+148
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R1-R3}
          CFI CFA R13+136
        ADD      R0,SP,#+28
          CFI FunCall _ZN8vector_314apply_rotationE10matrix_3x3
        BL       _ZN8vector_314apply_rotationE10matrix_3x3
// 12634 
// 12635             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12636               if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
// 12637             #endif
// 12638 
// 12639             // Adjustments to the current position
// 12640             //const float xydiff[2] = { offset_vec.x, offset_vec.y };
// 12641 			xydiff[0] = offset_vec.x;
        LDR      R8,[SP, #+28]
// 12642 			xydiff[1] = offset_vec.y;
        LDR      R9,[SP, #+32]
// 12643             current_position[Z_AXIS] += offset_vec.z;
        LDR      R1,[R4, #+16]
        LDR      R0,[SP, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
        B.N      ??tool_change_9
// 12644 		  }
// 12645           //#else // !ABL_PLANAR
// 12646 			else
// 12647 			{
// 12648 				/*
// 12649             		const float xydiff[2] = {
// 12650               			hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
// 12651              	 		hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
// 12652             		};*/
// 12653             if(gCfgItems.breakpoint_flg!=1)
??tool_change_8:
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_10
        LDRB     R11,[R4, #+3]
        LDR.W    R9,??DataTable162_2
        LDR      R0,[R9, R10, LSL #+2]
        LDR      R1,[R9, R11, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
// 12654             {
// 12655 			    xydiff[0] = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
// 12656 			    xydiff[1] = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
        ADD      R0,R9,R10, LSL #+2
        LDR      R0,[R0, #+8]
        ADD      R1,R9,R11, LSL #+2
        LDR      R1,[R1, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 12657             }
// 12658 				
// 12659             //#if ENABLED(MESH_BED_LEVELING)
// 12660 			if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
??tool_change_10:
        LDR.W    R0,??DataTable160
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??tool_change_9
// 12661 			{
// 12662               if (planner.leveling_active) {
        LDR.W    R0,??DataTable162_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??tool_change_9
// 12663                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12664                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
// 12665                 #endif
// 12666                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
        LDR      R0,[R4, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+12]
// 12667                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
        LDR      R0,[R4, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+8]
// 12668                       z1 = current_position[Z_AXIS], z2 = z1;
        LDR      R0,[R4, #+16]
        STR      R0,[SP, #+0]
        STR      R0,[SP, #+4]
// 12669                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
        ADD      R2,SP,#+0
        ADD      R1,R4,#+12
        ADD      R0,R4,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 12670                 planner.apply_leveling(x2, y2, z2);
        ADD      R2,SP,#+4
        ADD      R1,SP,#+8
        ADD      R0,SP,#+12
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 12671                 current_position[Z_AXIS] += z2 - z1;
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
// 12672                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12673                   if (DEBUGGING(LEVELING))
// 12674                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
// 12675                 #endif
// 12676               }
// 12677 			}
// 12678             //#endif // MESH_BED_LEVELING
// 12679 				}
// 12680           //#endif // !HAS_ABL
// 12681 
// 12682           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12683             if (DEBUGGING(LEVELING)) {
// 12684               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
// 12685               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
// 12686               SERIAL_ECHOLNPGM(" }");
// 12687             }
// 12688           #endif
// 12689 
// 12690           // The newly-selected extruder XY is actually at...
// 12691           if(gCfgItems.breakpoint_flg!=1)
??tool_change_9:
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_11
// 12692           {
// 12693             current_position[X_AXIS] += xydiff[X_AXIS];
        LDR      R0,[R4, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+8]
// 12694             current_position[Y_AXIS] += xydiff[Y_AXIS];
        LDR      R0,[R4, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+12]
// 12695           }
// 12696           // Set the new active extruder
// 12697           active_extruder = tmp_extruder;
??tool_change_11:
        STRB     R6,[R4, #+3]
// 12698 
// 12699         #endif // !DUAL_X_CARRIAGE
// 12700 
// 12701         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12702           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
// 12703         #endif
// 12704 
// 12705         // Tell the planner the new "current position"
// 12706         if(gCfgItems.breakpoint_flg!=1)
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_12
// 12707             SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 12708 
// 12709         // Move to the "old position" (move the extruder into place)
// 12710         #if ENABLED(SWITCHING_NOZZLE)
// 12711           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
// 12712         #endif
// 12713         if (!no_move && IsRunning()) {
??tool_change_12:
        CMP      R5,#+0
        BNE.N    ??tool_change_6
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??tool_change_6
// 12714           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12715             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
// 12716           #endif
// 12717           // Move back to the original (or tweaked) position
// 12718           if(gCfgItems.breakpoint_flg!=1)
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_6
// 12719             do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,R4,#+32
        ADD      R1,R4,#+28
        ADD      R0,R4,#+24
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 12720         }
// 12721         #if ENABLED(SWITCHING_NOZZLE)
// 12722           else {
// 12723             // Move back down. (Including when the new tool is higher.)
// 12724             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
// 12725           }
// 12726         #endif
// 12727       } // (tmp_extruder != active_extruder)
// 12728 
// 12729       stepper.synchronize();
??tool_change_6:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 12730 
// 12731       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
// 12732         disable_all_solenoids();
// 12733         enable_solenoid_on_active_extruder();
// 12734       #endif // EXT_SOLENOID
// 12735 
// 12736       feedrate_mm_s = old_feedrate_mm_s;
        LDR      R0,[SP, #+24]
        STR      R0,[R4, #+92]
// 12737 
// 12738     #else // HOTENDS <= 1
// 12739 
// 12740       UNUSED(fr_mm_s);
// 12741       UNUSED(no_move);
// 12742 
// 12743       #if ENABLED(MK2_MULTIPLEXER)
// 12744         if (tmp_extruder >= E_STEPPERS)
// 12745           return invalid_extruder_error(tmp_extruder);
// 12746 
// 12747         select_multiplexed_stepper(tmp_extruder);
// 12748       #endif
// 12749 
// 12750       // Set the new active extruder
// 12751       active_extruder = tmp_extruder;
// 12752 
// 12753     #endif // HOTENDS <= 1
// 12754 
// 12755     #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 12756       stepper.synchronize();
// 12757       move_extruder_servo(active_extruder);
// 12758     #endif
// 12759 
// 12760     #if HAS_FANMUX
// 12761       fanmux_switch(active_extruder);
// 12762     #endif
// 12763 
// 12764     SERIAL_ECHO_START();
        LDR.N    R0,??DataTable157_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12765     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
        LDRB     R1,[R4, #+3]
        ADR.W    R0,`?<Constant "Active Extruder: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.W    R0,??DataTable163
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 12766 
// 12767   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 12768 }
??tool_change_1:
        ADD      SP,SP,#+100
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock66

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157:
        DC8      " E:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_1:
        DC8      ":",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_2:
        DC32     0x40400000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_3:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_4:
        DC32     0x3ff80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_5:
        DC32     z_endstop_adj

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_6:
        DC32     0x9999999a

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_7:
        DC32     0x3fb99999

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_8:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Active Extruder: ">`:
        DC8 "Active Extruder: "
        DC8 0, 0
// 12769 
// 12770 /**
// 12771  * T0-T3: Switch tool, usually switching extruders
// 12772  *
// 12773  *   F[units/min] Set the movement feedrate
// 12774  *   S1           Don't move the tool in XY after change
// 12775  */
// 12776 inline void gcode_T(const uint8_t tmp_extruder) {
// 12777 
// 12778   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12779     if (DEBUGGING(LEVELING)) {
// 12780       SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
// 12781       SERIAL_CHAR(')');
// 12782       SERIAL_EOL();
// 12783       DEBUG_POS("BEFORE", current_position);
// 12784     }
// 12785   #endif
// 12786 
// 12787   #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
// 12788 
// 12789     tool_change(tmp_extruder);
// 12790 
// 12791   #elif HOTENDS > 1
// 12792 
// 12793     tool_change(
// 12794       tmp_extruder,
// 12795       MMM_TO_MMS(parser.linearval('F')),
// 12796       (tmp_extruder == active_extruder) || parser.boolval('S')
// 12797     );
// 12798 
// 12799   #endif
// 12800 
// 12801   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12802     if (DEBUGGING(LEVELING)) {
// 12803       DEBUG_POS("AFTER", current_position);
// 12804       SERIAL_ECHOLNPGM("<<< gcode_T");
// 12805     }
// 12806   #endif
// 12807 }
// 12808 
// 12809 /**
// 12810  * Process the parsed command and dispatch it to its handler
// 12811  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function _Z22process_parsed_commandv
        THUMB
// 12812 void process_parsed_command() {
_Z22process_parsed_commandv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 12813   KEEPALIVE_STATE(IN_HANDLER);
        LDR.W    R4,??DataTable163_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+6]
// 12814 
// 12815   // Handle a known G, M, or T
// 12816   switch (parser.command_letter) {
        LDR.W    R0,??DataTable162_5
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+71
        BEQ.N    ??process_parsed_command_0
        CMP      R0,#+77
        BEQ.W    ??process_parsed_command_1
        CMP      R0,#+84
        BEQ.W    ??process_parsed_command_2
        B.N      ??process_parsed_command_3
// 12817     case 'G': switch (parser.codenum) {
??process_parsed_command_0:
        LDR.W    R0,??DataTable163_2
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+1
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+2
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+3
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+4
        BEQ.N    ??process_parsed_command_6
        CMP      R1,#+26
        BEQ.N    ??process_parsed_command_7
        CMP      R1,#+28
        BEQ.N    ??process_parsed_command_8
        CMP      R1,#+29
        BEQ.N    ??process_parsed_command_9
        CMP      R1,#+30
        BEQ.W    ??process_parsed_command_10
        CMP      R1,#+42
        BEQ.W    ??process_parsed_command_11
        CMP      R1,#+90
        BEQ.W    ??process_parsed_command_12
        CMP      R1,#+91
        BEQ.W    ??process_parsed_command_13
        CMP      R1,#+92
        BEQ.W    ??process_parsed_command_14
        B.N      ??process_parsed_command_15
// 12818 
// 12819       // G0, G1
// 12820       case 0:
// 12821       case 1:
// 12822         //#if IS_SCARA
// 12823         if(MACHINETPYE&IS_SCARA)
??process_parsed_command_4:
        LDR.W    R1,??DataTable163_3
        LDRH     R1,[R1, #+36]
        MOV      R2,#+768
        TST      R1,R2
        BEQ.N    ??process_parsed_command_16
// 12824           gcode_G0_G1_SCARA(parser.codenum == 0);
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
          CFI FunCall _Z17gcode_G0_G1_SCARAb
        BL       _Z17gcode_G0_G1_SCARAb
        B.N      ??process_parsed_command_15
// 12825         //#else
// 12826         else
// 12827           gcode_G0_G1();
??process_parsed_command_16:
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
        B.N      ??process_parsed_command_15
// 12828         //#endif
// 12829         break;
// 12830 
// 12831       // G2, G3
// 12832       #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
// 12833         case 2: // G2: CW ARC
// 12834         case 3: // G3: CCW ARC
// 12835           gcode_G2_G3(parser.codenum == 2);
??process_parsed_command_5:
        CMP      R0,#+2
        BNE.N    ??process_parsed_command_17
        MOVS     R0,#+1
        B.N      ??process_parsed_command_18
??process_parsed_command_17:
        MOVS     R0,#+0
??process_parsed_command_18:
          CFI FunCall _Z11gcode_G2_G3b
        BL       _Z11gcode_G2_G3b
// 12836           break;
        B.N      ??process_parsed_command_15
// 12837       #endif
// 12838 
// 12839       // G4 Dwell
// 12840       case 4:
// 12841         gcode_G4();
??process_parsed_command_6:
          CFI FunCall _Z8gcode_G4v
        BL       _Z8gcode_G4v
// 12842         break;
        B.N      ??process_parsed_command_15
// 12843 
// 12844       #if ENABLED(BEZIER_CURVE_SUPPORT)
// 12845         case 5: // G5: Cubic B_spline
// 12846           gcode_G5();
// 12847           break;
// 12848       #endif // BEZIER_CURVE_SUPPORT
// 12849 
// 12850       #if ENABLED(FWRETRACT)
// 12851         case 10: // G10: retract
// 12852           gcode_G10();
// 12853           break;
// 12854         case 11: // G11: retract_recover
// 12855           gcode_G11();
// 12856           break;
// 12857       #endif // FWRETRACT
// 12858 
// 12859       #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 12860         case 12:
// 12861           gcode_G12(); // G12: Nozzle Clean
// 12862           break;
// 12863       #endif // NOZZLE_CLEAN_FEATURE
// 12864 
// 12865       #if ENABLED(CNC_WORKSPACE_PLANES)
// 12866         case 17: // G17: Select Plane XY
// 12867           gcode_G17();
// 12868           break;
// 12869         case 18: // G18: Select Plane ZX
// 12870           gcode_G18();
// 12871           break;
// 12872         case 19: // G19: Select Plane YZ
// 12873           gcode_G19();
// 12874           break;
// 12875       #endif // CNC_WORKSPACE_PLANES
// 12876 
// 12877       #if ENABLED(INCH_MODE_SUPPORT)
// 12878         case 20: // G20: Inch Mode
// 12879           gcode_G20();
// 12880           break;
// 12881 
// 12882         case 21: // G21: MM Mode
// 12883           gcode_G21();
// 12884           break;
// 12885       #endif // INCH_MODE_SUPPORT
// 12886 
// 12887       //#if ENABLED(G26_MESH_VALIDATION)
// 12888         case 26: // G26: Mesh Validation Pattern generation
// 12889         if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_parsed_command_7:
        LDR.W    R0,??DataTable163_3
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_15
// 12890           gcode_G26();
          CFI FunCall _Z9gcode_G26v
        BL       _Z9gcode_G26v
        B.N      ??process_parsed_command_15
// 12891           break;
// 12892       //#endif // G26_MESH_VALIDATION
// 12893 
// 12894       #if ENABLED(NOZZLE_PARK_FEATURE)
// 12895         case 27: // G27: Nozzle Park
// 12896           gcode_G27();
// 12897           break;
// 12898       #endif // NOZZLE_PARK_FEATURE
// 12899 
// 12900       case 28: // G28: Home all axes, one at a time
// 12901         #if 1
// 12902       	if (gCfgItems.breakpoint_reprint_flg == 1) break;
??process_parsed_command_8:
        LDR.W    R0,??DataTable162_1
        LDRB     R0,[R0, #+328]
        CMP      R0,#+1
        BEQ.W    ??process_parsed_command_15
// 12903         #endif
// 12904         gcode_G28(false);
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
// 12905 		if((BED_LEVELING_METHOD & HAS_LEVELING) && (BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL))
        LDR.W    R0,??DataTable160
        ADD      R5,R0,#+52
        LDRB     R0,[R5, #+12]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.W    ??process_parsed_command_15
        CMP      R0,#+16
        BEQ.W    ??process_parsed_command_15
// 12906 		{
// 12907 			 set_bed_leveling_enabled(true);
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 12908 			#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 12909 				if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
        LDRSH    R0,[R5, #+36]
        CMP      R0,#+2
        BEQ.W    ??process_parsed_command_15
        LDRB     R0,[R5, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_15
// 12910 				 { 
// 12911 				 	if (parser.seenval('Z')) set_z_fade_height(parser.value_linear_units()/*code_value_linear_units()*/);
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+1
          CFI FunCall _Z17set_z_fade_heightfb
        BL       _Z17set_z_fade_heightfb
        B.N      ??process_parsed_command_15
// 12912 				 }
// 12913 			#endif
// 12914           }
// 12915         break;
// 12916 
// 12917       //#if HAS_LEVELING
// 12918         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
// 12919                  // or provides access to the UBL System if enabled.
// 12920 		if(BED_LEVELING_METHOD&HAS_LEVELING)	 
??process_parsed_command_9:
        LDR.W    R0,??DataTable160
        ADD      R5,R0,#+52
        LDRB     R0,[R5, #+12]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??process_parsed_command_19
// 12921 		{
// 12922 			switch(BED_LEVELING_METHOD)	 /*--mks cfg-- MESH_BED_LEVELING */ 
        CMP      R0,#+2
        BEQ.N    ??process_parsed_command_20
        CMP      R0,#+4
        BEQ.N    ??process_parsed_command_20
        CMP      R0,#+8
        BEQ.N    ??process_parsed_command_20
        CMP      R0,#+16
        BEQ.N    ??process_parsed_command_21
        CMP      R0,#+32
        BNE.N    ??process_parsed_command_19
// 12923 			{
// 12924 				case MESH_BED_LEVELING:
// 12925 					gcode_G29_MESH_BED_LEVELING();
          CFI FunCall _Z27gcode_G29_MESH_BED_LEVELINGv
        BL       _Z27gcode_G29_MESH_BED_LEVELINGv
// 12926 					(void)settings.save();
          CFI FunCall _ZN14MarlinSettings4saveEv
        BL       _ZN14MarlinSettings4saveEv
// 12927 				break;
        B.N      ??process_parsed_command_15
// 12928 				case AUTO_BED_LEVELING_3POINT:
// 12929 				case AUTO_BED_LEVELING_LINEAR:
// 12930 				case AUTO_BED_LEVELING_BILINEAR:
// 12931 					gcode_G29();
??process_parsed_command_20:
          CFI FunCall _Z9gcode_G29v
        BL       _Z9gcode_G29v
// 12932 					(void)settings.save();
          CFI FunCall _ZN14MarlinSettings4saveEv
        BL       _ZN14MarlinSettings4saveEv
// 12933 				break;
        B.N      ??process_parsed_command_15
// 12934 				case AUTO_BED_LEVELING_UBL:
// 12935 					gcode_G29_UBL();
??process_parsed_command_21:
          CFI FunCall _Z13gcode_G29_UBLv
        BL       _Z13gcode_G29_UBLv
// 12936 				break;
        B.N      ??process_parsed_command_15
// 12937 				default:
// 12938 					SERIAL_PROTOCOL("bed leveling hasn't defined!");
// 12939 					SERIAL_EOL();
// 12940 				break;
// 12941 			}
// 12942 		}
// 12943 		else
// 12944 		{
// 12945 			SERIAL_PROTOCOL("bed leveling hasn't defined!");
??process_parsed_command_19:
        LDR.W    R5,??DataTable163
        LDR.W    R1,??DataTable163_4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
// 12946 			SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??process_parsed_command_15
// 12947 		}
// 12948 
// 12949         break;
// 12950       //#endif // HAS_LEVELING
// 12951 
// 12952       #if HAS_BED_PROBE
// 12953 
// 12954         case 30: // G30 Single Z probe
// 12955           gcode_G30();
??process_parsed_command_10:
          CFI FunCall _Z9gcode_G30v
        BL       _Z9gcode_G30v
// 12956           break;
        B.N      ??process_parsed_command_15
// 12957 
// 12958         #if ENABLED(Z_PROBE_SLED)
// 12959 
// 12960             case 31: // G31: dock the sled
// 12961               gcode_G31();
// 12962               break;
// 12963 
// 12964             case 32: // G32: undock the sled
// 12965               gcode_G32();
// 12966               break;
// 12967 
// 12968         #endif // Z_PROBE_SLED
// 12969 
// 12970       #endif // HAS_BED_PROBE
// 12971 
// 12972       #if ENABLED(DELTA_AUTO_CALIBRATION)
// 12973 
// 12974         case 33: // G33: Delta Auto-Calibration
// 12975           gcode_G33();
// 12976           break;
// 12977 
// 12978       #endif // DELTA_AUTO_CALIBRATION
// 12979 
// 12980       #if ENABLED(G38_PROBE_TARGET)
// 12981         case 38: // G38.2 & G38.3
// 12982           if (parser.subcode == 2 || parser.subcode == 3)
// 12983             gcode_G38(parser.subcode == 2);
// 12984           break;
// 12985       #endif
// 12986 
// 12987       case 90: // G90
// 12988         relative_mode = false;
??process_parsed_command_12:
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
// 12989         break;
        B.N      ??process_parsed_command_15
// 12990       case 91: // G91
// 12991         relative_mode = true;
??process_parsed_command_13:
        MOVS     R0,#+1
        STRB     R0,[R4, #+5]
// 12992         break;
        B.N      ??process_parsed_command_15
// 12993 
// 12994       case 92: // G92
// 12995         gcode_G92();
??process_parsed_command_14:
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
// 12996         break;
        B.N      ??process_parsed_command_15
// 12997 
// 12998       #if HAS_MESH
// 12999         case 42:
// 13000           gcode_G42();
??process_parsed_command_11:
          CFI FunCall _Z9gcode_G42v
        BL       _Z9gcode_G42v
// 13001           break;
        B.N      ??process_parsed_command_15
// 13002       #endif
// 13003 
// 13004       #if ENABLED(DEBUG_GCODE_PARSER)
// 13005         case 800:
// 13006           parser.debug(); // GCode Parser Test for G
// 13007           break;
// 13008       #endif
// 13009     }
// 13010     break;
// 13011 
// 13012     case 'M': switch (parser.codenum) {
??process_parsed_command_1:
        LDR.W    R0,??DataTable163_2
        LDR      R0,[R0, #+0]
        SUBS     R0,R0,#+17
        BEQ.W    ??process_parsed_command_22
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_23
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_24
        SUBS     R0,R0,#+1
        CMP      R0,#+1
        BLS.W    ??process_parsed_command_25
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_26
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_27
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_28
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_29
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_30
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_31
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_32
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_33
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_34
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_35
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_36
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_37
        SUBS     R0,R0,#+26
        BEQ.W    ??process_parsed_command_38
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_39
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_40
        SUBS     R0,R0,#+4
        BEQ.W    ??process_parsed_command_41
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_42
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_43
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_23
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_44
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_45
        SUBS     R0,R0,#+12
        BEQ.W    ??process_parsed_command_46
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_47
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_48
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_49
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_50
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_51
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_52
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_53
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_54
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_55
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_56
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_57
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_58
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_59
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_60
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_61
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_62
        SUBS     R0,R0,#+19
        BEQ.W    ??process_parsed_command_63
        SUBS     R0,R0,#+15
        BEQ.W    ??process_parsed_command_64
        SUBS     R0,R0,#+35
        BEQ.W    ??process_parsed_command_65
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_66
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_67
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_68
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_69
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_70
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_71
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_72
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_73
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_74
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_75
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_76
        SUBS     R0,R0,#+54
        BEQ.W    ??process_parsed_command_77
        SUBS     R0,R0,#+21
        BEQ.W    ??process_parsed_command_78
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_79
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_80
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_81
        SUBS     R0,R0,#+51
        BEQ.W    ??process_parsed_command_82
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_83
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_84
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_85
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_86
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_87
        SUBS     R0,R0,#+36
        BEQ.W    ??process_parsed_command_88
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_89
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_90
        SUBS     R0,R0,#+8
        BEQ.W    ??process_parsed_command_91
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_92
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_93
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_94
        SUBS     R0,R0,#+72
        BEQ.W    ??process_parsed_command_95
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_96
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_97
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_98
        SUBS     R0,R0,#+162
        BEQ.W    ??process_parsed_command_99
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_100
        SUBS     R0,R0,#+185
        BEQ.W    ??process_parsed_command_101
        SUBS     R0,R0,#+56
        BEQ.W    ??process_parsed_command_102
        SUBS     R0,R0,#+21
        BEQ.N    ??process_parsed_command_103
        SUBS     R0,R0,#+70
        BEQ.N    ??process_parsed_command_104
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_105
        B.N      ??process_parsed_command_15
// 13013       #if HAS_RESUME_CONTINUE
// 13014         case 0: // M0: Unconditional stop - Wait for user button press on LCD
// 13015         case 1: // M1: Conditional stop - Wait for user button press on LCD
// 13016           gcode_M0_M1();
// 13017           break;
// 13018       #endif // ULTIPANEL
// 13019 
// 13020       #if ENABLED(SPINDLE_LASER_ENABLE)
// 13021         case 3:
// 13022           gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
// 13023           break;               // synchronizes with movement commands
// 13024         case 4:
// 13025           gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
// 13026           break;               // synchronizes with movement commands
// 13027         case 5:
// 13028           gcode_M5();     // M5 - turn spindle/laser off
// 13029           break;          // synchronizes with movement commands
// 13030       #endif
// 13031       case 17: // M17: Enable all stepper motors
// 13032         gcode_M17();
??process_parsed_command_22:
          CFI FunCall _Z9gcode_M17v
        BL       _Z9gcode_M17v
// 13033         break;
        B.N      ??process_parsed_command_15
// 13034 
// 13035       #if ENABLED(SDSUPPORT)
// 13036         case 20: // M20: list SD card
// 13037           gcode_M20(); break;
??process_parsed_command_24:
          CFI FunCall _Z9gcode_M20v
        BL       _Z9gcode_M20v
        B.N      ??process_parsed_command_15
// 13038         case 21: // M21: init SD card
// 13039           //gcode_M21(); break;
// 13040         case 22: // M22: release SD card
// 13041           gcode_M22(); break;
??process_parsed_command_25:
          CFI FunCall _Z9gcode_M22v
        BL       _Z9gcode_M22v
        B.N      ??process_parsed_command_15
// 13042         case 23: // M23: Select file
// 13043           gcode_M23(); break;
??process_parsed_command_26:
          CFI FunCall _Z9gcode_M23v
        BL       _Z9gcode_M23v
        B.N      ??process_parsed_command_15
// 13044         case 24: // M24: Start SD print
// 13045           gcode_M24(); 
??process_parsed_command_27:
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
// 13046 
// 13047           if(mksReprint.mks_printer_state == MKS_WORKING)
        LDR.W    R0,??DataTable165
        LDRB     R0,[R0, #+2076]
        CMP      R0,#+167
        BNE.W    ??process_parsed_command_15
// 13048           {
// 13049             clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 13050             reset_file_info();
          CFI FunCall reset_file_info
        BL       reset_file_info
// 13051             reset_print_time();
          CFI FunCall reset_print_time
        BL       reset_print_time
// 13052             start_print_time();
          CFI FunCall start_print_time
        BL       start_print_time
// 13053             #if defined(TFT35)
// 13054             preview_gcode_prehandle(curFileName);
        LDR.W    R0,??DataTable165_1
          CFI FunCall preview_gcode_prehandle
        BL       preview_gcode_prehandle
// 13055             #endif
// 13056             draw_printing();            
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_15
// 13057            }
// 13058           break;
// 13059         case 25: // M25: Pause SD print
// 13060             gcode_M25(); 
??process_parsed_command_28:
          CFI FunCall _Z9gcode_M25v
        BL       _Z9gcode_M25v
// 13061             if(mksReprint.mks_printer_state == MKS_PAUSING)
        LDR.W    R5,??DataTable165
        LDRB     R0,[R5, #+2076]
        CMP      R0,#+169
        BNE.W    ??process_parsed_command_15
// 13062             {
// 13063             	stop_print_time();							
          CFI FunCall stop_print_time
        BL       stop_print_time
// 13064             	clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 13065             
// 13066             	card.pauseSDPrint();
        MOV      R0,R5
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
// 13067             	print_job_timer.pause();
        ADDW     R0,R5,#+2792
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
// 13068 		#if defined(TFT35)
// 13069             	if(from_flash_pic==1)
        LDR.W    R0,??DataTable165_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??process_parsed_command_106
// 13070             		flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable165_3
        STRB     R0,[R1, #+0]
        B.N      ??process_parsed_command_107
// 13071             	else
// 13072             		default_preview_flg = 1;							
??process_parsed_command_106:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable165_4
        STRB     R0,[R1, #+0]
// 13073 
// 13074             	draw_printing();
??process_parsed_command_107:
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_15
// 13075                #else
// 13076                draw_pause();
// 13077 		#endif
// 13078             }          
// 13079           break;
// 13080         case 998:	//M998: Stop SD print
// 13081           gcode_M998(); break;			  
??process_parsed_command_104:
          CFI FunCall _Z10gcode_M998v
        BL       _Z10gcode_M998v
        B.N      ??process_parsed_command_15
// 13082         case 26: // M26: Set SD index
// 13083           gcode_M26(); break;
??process_parsed_command_29:
          CFI FunCall _Z9gcode_M26v
        BL       _Z9gcode_M26v
        B.N      ??process_parsed_command_15
// 13084         case 27: // M27: Get SD status
// 13085           gcode_M27(); break;
??process_parsed_command_30:
          CFI FunCall _Z9gcode_M27v
        BL       _Z9gcode_M27v
        B.N      ??process_parsed_command_15
// 13086         case 28: // M28: Start SD write
// 13087           gcode_M28(); break;
??process_parsed_command_31:
          CFI FunCall _Z9gcode_M28v
        BL       _Z9gcode_M28v
        B.N      ??process_parsed_command_15
// 13088         case 29: // M29: Stop SD write
// 13089           gcode_M29(); break;
??process_parsed_command_32:
          CFI FunCall _Z9gcode_M29v
        BL       _Z9gcode_M29v
        B.N      ??process_parsed_command_15
// 13090         case 30: // M30 <filename> Delete File
// 13091           gcode_M30(); break;
??process_parsed_command_33:
          CFI FunCall _Z9gcode_M30v
        BL       _Z9gcode_M30v
        B.N      ??process_parsed_command_15
// 13092         case 32: // M32: Select file and start SD print
// 13093           gcode_M32(); break;
??process_parsed_command_35:
          CFI FunCall _Z9gcode_M32v
        BL       _Z9gcode_M32v
        B.N      ??process_parsed_command_15
// 13094 
// 13095         #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 13096           case 33: // M33: Get the long full path to a file or folder
// 13097             gcode_M33(); break;
// 13098         #endif
// 13099 
// 13100         #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 13101           case 34: // M34: Set SD card sorting options
// 13102             gcode_M34(); break;
// 13103         #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 13104 
// 13105         case 928: // M928: Start SD write
// 13106           gcode_M928(); break;
??process_parsed_command_103:
          CFI FunCall _Z10gcode_M928v
        BL       _Z10gcode_M928v
        B.N      ??process_parsed_command_15
// 13107       #endif // SDSUPPORT
// 13108 
// 13109       case 31: // M31: Report time since the start of SD print or last M109
// 13110         gcode_M31(); break;
??process_parsed_command_34:
          CFI FunCall _Z9gcode_M31v
        BL       _Z9gcode_M31v
        B.N      ??process_parsed_command_15
// 13111 
// 13112       case 42: // M42: Change pin state
// 13113         gcode_M42(); break;
??process_parsed_command_36:
          CFI FunCall _Z9gcode_M42v
        BL       _Z9gcode_M42v
        B.N      ??process_parsed_command_15
// 13114 
// 13115       #if ENABLED(PINS_DEBUGGING)
// 13116         case 43: // M43: Read pin state
// 13117           gcode_M43(); break;
// 13118       #endif
// 13119 
// 13120 
// 13121       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 13122         case 48: // M48: Z probe repeatability test
// 13123           gcode_M48();
// 13124           break;
// 13125       #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 13126 
// 13127       //#if ENABLED(G26_MESH_VALIDATION)
// 13128         case 49: // M49: Turn on or off G26 debug flag for verbose output
// 13129         if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_parsed_command_37:
        LDR.W    R0,??DataTable163_3
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_15
// 13130           gcode_M49();
          CFI FunCall _Z9gcode_M49v
        BL       _Z9gcode_M49v
        B.N      ??process_parsed_command_15
// 13131           break;
// 13132       //#endif // G26_MESH_VALIDATION
// 13133 
// 13134       #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 13135         case 73: // M73: Set print progress percentage
// 13136           gcode_M73(); break;
// 13137       #endif
// 13138 
// 13139       case 75: // M75: Start print timer
// 13140         gcode_M75(); break;
??process_parsed_command_38:
          CFI FunCall _Z9gcode_M75v
        BL       _Z9gcode_M75v
        B.N      ??process_parsed_command_15
// 13141       case 76: // M76: Pause print timer
// 13142         gcode_M76(); break;
??process_parsed_command_39:
          CFI FunCall _Z9gcode_M76v
        BL       _Z9gcode_M76v
        B.N      ??process_parsed_command_15
// 13143       case 77: // M77: Stop print timer
// 13144         gcode_M77(); break;
??process_parsed_command_40:
          CFI FunCall _Z9gcode_M77v
        BL       _Z9gcode_M77v
        B.N      ??process_parsed_command_15
// 13145 
// 13146       #if ENABLED(PRINTCOUNTER)
// 13147         case 78: // M78: Show print statistics
// 13148           gcode_M78(); break;
// 13149       #endif
// 13150 
// 13151       #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 13152         case 100: // M100: Free Memory Report
// 13153           gcode_M100();
// 13154           break;
// 13155       #endif
// 13156 
// 13157       case 104: // M104: Set hot end temperature
// 13158         gcode_M104();
??process_parsed_command_46:
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
// 13159         break;
        B.N      ??process_parsed_command_15
// 13160 
// 13161       case 110: // M110: Set Current Line Number
// 13162         gcode_M110();
??process_parsed_command_52:
          CFI FunCall _Z10gcode_M110v
        BL       _Z10gcode_M110v
// 13163         break;
        B.N      ??process_parsed_command_15
// 13164 
// 13165       case 111: // M111: Set debug level
// 13166         gcode_M111();
??process_parsed_command_53:
          CFI FunCall _Z10gcode_M111v
        BL       _Z10gcode_M111v
// 13167         break;
        B.N      ??process_parsed_command_15
// 13168 
// 13169       #if DISABLED(EMERGENCY_PARSER)
// 13170 
// 13171         case 108: // M108: Cancel Waiting
// 13172           gcode_M108();
??process_parsed_command_50:
          CFI FunCall _Z10gcode_M108v
        BL       _Z10gcode_M108v
// 13173           break;
        B.N      ??process_parsed_command_15
// 13174 
// 13175         case 112: // M112: Emergency Stop
// 13176           gcode_M112();
??process_parsed_command_54:
          CFI FunCall _Z10gcode_M112v
        BL       _Z10gcode_M112v
// 13177           break;
        B.N      ??process_parsed_command_15
// 13178 
// 13179         case 410: // M410 quickstop - Abort all the planned moves.
// 13180           gcode_M410();
??process_parsed_command_91:
          CFI FunCall _Z10gcode_M410v
        BL       _Z10gcode_M410v
// 13181           break;
        B.N      ??process_parsed_command_15
// 13182 
// 13183       #endif
// 13184 
// 13185       #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 13186         case 113: // M113: Set Host Keepalive interval
// 13187           gcode_M113();
??process_parsed_command_55:
          CFI FunCall _Z10gcode_M113v
        BL       _Z10gcode_M113v
// 13188           break;
        B.N      ??process_parsed_command_15
// 13189       #endif
// 13190 
// 13191       case 140: // M140: Set bed temperature
// 13192       if(HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
??process_parsed_command_63:
        LDR.W    R0,??DataTable163_3
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_108
// 13193         gcode_M140();
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
        B.N      ??process_parsed_command_15
// 13194         else
// 13195           SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!"); 	  
??process_parsed_command_108:
        ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??process_parsed_command_15
// 13196         break;
// 13197 
// 13198       case 105: // M105: Report current temperature
// 13199         gcode_M105();
??process_parsed_command_47:
          CFI FunCall _Z10gcode_M105v
        BL       _Z10gcode_M105v
// 13200         KEEPALIVE_STATE(NOT_BUSY);
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 13201         return; // "ok" already printed
        POP      {R0,R4,R5,PC}
// 13202 
// 13203      // #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 13204      #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)
// 13205         case 155: // M155: Set temperature auto-report interval
// 13206           gcode_M155();
??process_parsed_command_64:
          CFI FunCall _Z10gcode_M155v
        BL       _Z10gcode_M155v
// 13207           break;
        B.N      ??process_parsed_command_15
// 13208       #endif
// 13209 
// 13210       case 109: // M109: Wait for hotend temperature to reach target
// 13211         gcode_M109();
??process_parsed_command_51:
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
// 13212         break;
        B.N      ??process_parsed_command_15
// 13213 
// 13214       //#if HAS_TEMP_BED
// 13215         case 190: // M190: Wait for bed temperature to reach target
// 13216         if(HAS_TEMP_BED) 
??process_parsed_command_65:
        LDR.W    R0,??DataTable163_3
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_109
// 13217           gcode_M190();
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
        B.N      ??process_parsed_command_15
// 13218 		else
// 13219           SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!");
??process_parsed_command_109:
        ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??process_parsed_command_15
// 13220           break;
// 13221       //#endif // HAS_TEMP_BED
// 13222 
// 13223       #if FAN_COUNT > 0
// 13224         case 106: // M106: Fan On
// 13225           gcode_M106();
??process_parsed_command_48:
          CFI FunCall _Z10gcode_M106v
        BL       _Z10gcode_M106v
// 13226           break;
        B.N      ??process_parsed_command_15
// 13227         case 107: // M107: Fan Off
// 13228           gcode_M107();
??process_parsed_command_49:
          CFI FunCall _Z10gcode_M107v
        BL       _Z10gcode_M107v
// 13229           break;
        B.N      ??process_parsed_command_15
// 13230       #endif // FAN_COUNT > 0
// 13231 
// 13232       #if ENABLED(PARK_HEAD_ON_PAUSE)
// 13233         case 125: // M125: Store current position and move to filament change position
// 13234           gcode_M125(); break;
// 13235       #endif
// 13236 
// 13237       #if ENABLED(BARICUDA)
// 13238         // PWM for HEATER_1_PIN
// 13239         #if HAS_HEATER_1
// 13240           case 126: // M126: valve open
// 13241             gcode_M126();
// 13242             break;
// 13243           case 127: // M127: valve closed
// 13244             gcode_M127();
// 13245             break;
// 13246         #endif // HAS_HEATER_1
// 13247 
// 13248         // PWM for HEATER_2_PIN
// 13249         #if HAS_HEATER_2
// 13250           case 128: // M128: valve open
// 13251             gcode_M128();
// 13252             break;
// 13253           case 129: // M129: valve closed
// 13254             gcode_M129();
// 13255             break;
// 13256         #endif // HAS_HEATER_2
// 13257       #endif // BARICUDA
// 13258 
// 13259       #if HAS_POWER_SWITCH
// 13260 
// 13261         case 80: // M80: Turn on Power Supply
// 13262           gcode_M80();
// 13263           break;
// 13264 
// 13265       #endif // HAS_POWER_SWITCH
// 13266 
// 13267       case 81: // M81: Turn off Power, including Power Supply, if possible
// 13268         gcode_M81();
??process_parsed_command_41:
          CFI FunCall _Z9gcode_M81v
        BL       _Z9gcode_M81v
// 13269         break;
        B.N      ??process_parsed_command_15
// 13270 
// 13271       case 82: // M82: Set E axis normal mode (same as other axes)
// 13272         gcode_M82();
??process_parsed_command_42:
          CFI FunCall _Z9gcode_M82v
        BL       _Z9gcode_M82v
// 13273         break;
        B.N      ??process_parsed_command_15
// 13274       case 83: // M83: Set E axis relative mode
// 13275         gcode_M83();
??process_parsed_command_43:
          CFI FunCall _Z9gcode_M83v
        BL       _Z9gcode_M83v
// 13276         break;
        B.N      ??process_parsed_command_15
// 13277       case 18: // M18 => M84
// 13278       case 84: // M84: Disable all steppers or set timeout
// 13279         gcode_M18_M84();
??process_parsed_command_23:
          CFI FunCall _Z13gcode_M18_M84v
        BL       _Z13gcode_M18_M84v
// 13280         break;
        B.N      ??process_parsed_command_15
// 13281       case 85: // M85: Set inactivity stepper shutdown timeout
// 13282         gcode_M85();
??process_parsed_command_44:
          CFI FunCall _Z9gcode_M85v
        BL       _Z9gcode_M85v
// 13283         break;
        B.N      ??process_parsed_command_15
// 13284       case 92: // M92: Set the steps-per-unit for one or more axes
// 13285         gcode_M92();
??process_parsed_command_45:
          CFI FunCall _Z9gcode_M92v
        BL       _Z9gcode_M92v
// 13286         break;
        B.N      ??process_parsed_command_15
// 13287       case 114: // M114: Report current position
// 13288         gcode_M114();
??process_parsed_command_56:
          CFI FunCall _Z10gcode_M114v
        BL       _Z10gcode_M114v
// 13289         break;
        B.N      ??process_parsed_command_15
// 13290       case 115: // M115: Report capabilities
// 13291         gcode_M115();
??process_parsed_command_57:
          CFI FunCall _Z10gcode_M115v
        BL       _Z10gcode_M115v
// 13292         break;
        B.N      ??process_parsed_command_15
// 13293       case 117: // M117: Set LCD message text, if possible
// 13294         gcode_M117();
??process_parsed_command_58:
          CFI FunCall _Z10gcode_M117v
        BL       _Z10gcode_M117v
// 13295         break;
        B.N      ??process_parsed_command_15
// 13296       case 118: // M118: Display a message in the host console
// 13297         gcode_M118();
??process_parsed_command_59:
          CFI FunCall _Z10gcode_M118v
        BL       _Z10gcode_M118v
// 13298         break;
        B.N      ??process_parsed_command_15
// 13299       case 119: // M119: Report endstop states
// 13300         gcode_M119();
??process_parsed_command_60:
          CFI FunCall _Z10gcode_M119v
        BL       _Z10gcode_M119v
// 13301         break;
        B.N      ??process_parsed_command_15
// 13302       case 120: // M120: Enable endstops
// 13303         gcode_M120();
??process_parsed_command_61:
          CFI FunCall _Z10gcode_M120v
        BL       _Z10gcode_M120v
// 13304         break;
        B.N      ??process_parsed_command_15
// 13305       case 121: // M121: Disable endstops
// 13306         gcode_M121();
??process_parsed_command_62:
          CFI FunCall _Z10gcode_M121v
        BL       _Z10gcode_M121v
// 13307         break;
        B.N      ??process_parsed_command_15
// 13308 
// 13309       #if ENABLED(ULTIPANEL)
// 13310 
// 13311         case 145: // M145: Set material heatup parameters
// 13312           gcode_M145();
// 13313           break;
// 13314 
// 13315       #endif
// 13316 
// 13317       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 13318         case 149: // M149: Set temperature units
// 13319           gcode_M149();
// 13320           break;
// 13321       #endif
// 13322 
// 13323       #if HAS_COLOR_LEDS
// 13324 
// 13325         case 150: // M150: Set Status LED Color
// 13326           gcode_M150();
// 13327           break;
// 13328 
// 13329       #endif // HAS_COLOR_LEDS
// 13330 
// 13331       #if ENABLED(MIXING_EXTRUDER)
// 13332         case 163: // M163: Set a component weight for mixing extruder
// 13333           gcode_M163();
// 13334           break;
// 13335         #if MIXING_VIRTUAL_TOOLS > 1
// 13336           case 164: // M164: Save current mix as a virtual extruder
// 13337             gcode_M164();
// 13338             break;
// 13339         #endif
// 13340         #if ENABLED(DIRECT_MIXING_IN_G1)
// 13341           case 165: // M165: Set multiple mix weights
// 13342             gcode_M165();
// 13343             break;
// 13344         #endif
// 13345       #endif
// 13346 
// 13347       #if DISABLED(NO_VOLUMETRICS)
// 13348         case 200: // M200: Set filament diameter, E to cubic units
// 13349           gcode_M200();
??process_parsed_command_66:
          CFI FunCall _Z10gcode_M200v
        BL       _Z10gcode_M200v
// 13350           break;
        B.N      ??process_parsed_command_15
// 13351       #endif
// 13352 
// 13353       case 201: // M201: Set max acceleration for print moves (units/s^2)
// 13354         gcode_M201();
??process_parsed_command_67:
          CFI FunCall _Z10gcode_M201v
        BL       _Z10gcode_M201v
// 13355         break;
        B.N      ??process_parsed_command_15
// 13356       #if 0 // Not used for Sprinter/grbl gen6
// 13357         case 202: // M202
// 13358           gcode_M202();
// 13359           break;
// 13360       #endif
// 13361       case 203: // M203: Set max feedrate (units/sec)
// 13362         gcode_M203();
??process_parsed_command_68:
          CFI FunCall _Z10gcode_M203v
        BL       _Z10gcode_M203v
// 13363         break;
        B.N      ??process_parsed_command_15
// 13364       case 204: // M204: Set acceleration
// 13365         gcode_M204();
??process_parsed_command_69:
          CFI FunCall _Z10gcode_M204v
        BL       _Z10gcode_M204v
// 13366         break;
        B.N      ??process_parsed_command_15
// 13367       case 205: // M205: Set advanced settings
// 13368         gcode_M205();
??process_parsed_command_70:
          CFI FunCall _Z10gcode_M205v
        BL       _Z10gcode_M205v
// 13369         break;
        B.N      ??process_parsed_command_15
// 13370 
// 13371       //#if HAS_M206_COMMAND
// 13372         case 206: // M206: Set home offsets
// 13373         if(MACHINETPYE != DELTA)
??process_parsed_command_71:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BEQ.W    ??process_parsed_command_15
// 13374           gcode_M206();
          CFI FunCall _Z10gcode_M206v
        BL       _Z10gcode_M206v
        B.N      ??process_parsed_command_15
// 13375           break;
// 13376       //#endif
// 13377 
// 13378       //#if ENABLED(DELTA)
// 13379         case 665: // M665: Set delta configurations
// 13380         if(MACHINETPYE == DELTA)
??process_parsed_command_99:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BNE.W    ??process_parsed_command_15
// 13381           gcode_M665();
          CFI FunCall _Z10gcode_M665v
        BL       _Z10gcode_M665v
        B.N      ??process_parsed_command_15
// 13382           break;
// 13383       //#endif
// 13384 
// 13385       //#if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 13386         case 666: // M666: Set delta or dual endstop adjustment
// 13387         if(MACHINETPYE == DELTA)
??process_parsed_command_100:
        LDR.N    R0,??DataTable160
        ADD      R1,R0,#+52
        LDRSH    R1,[R1, #+36]
        CMP      R1,#+2
        BNE.N    ??process_parsed_command_110
// 13388           gcode_M666();
          CFI FunCall _Z10gcode_M666v
        BL       _Z10gcode_M666v
        B.N      ??process_parsed_command_15
// 13389         else if(Z_DUAL_ENDSTOPS==1)
??process_parsed_command_110:
        LDRB     R0,[R0, #+258]
        CMP      R0,#+1
        BNE.W    ??process_parsed_command_15
// 13390         {
// 13391           gcode_M666_dual();  
          CFI FunCall _Z15gcode_M666_dualv
        BL       _Z15gcode_M666_dualv
        B.N      ??process_parsed_command_15
// 13392         }
// 13393           break;
// 13394       //#endif
// 13395 
// 13396       #if ENABLED(FWRETRACT)
// 13397         case 207: // M207: Set Retract Length, Feedrate, and Z lift
// 13398           gcode_M207();
// 13399           break;
// 13400         case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
// 13401           gcode_M208();
// 13402           break;
// 13403         case 209: // M209: Turn Automatic Retract Detection on/off
// 13404           if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
// 13405           break;
// 13406       #endif // FWRETRACT
// 13407 
// 13408       case 211: // M211: Enable, Disable, and/or Report software endstops
// 13409         gcode_M211();
??process_parsed_command_72:
          CFI FunCall _Z10gcode_M211v
        BL       _Z10gcode_M211v
// 13410         break;
        B.N      ??process_parsed_command_15
// 13411 
// 13412       #if HOTENDS > 1
// 13413         case 218: // M218: Set a tool offset
// 13414           gcode_M218();
??process_parsed_command_73:
          CFI FunCall _Z10gcode_M218v
        BL       _Z10gcode_M218v
// 13415           break;
        B.N      ??process_parsed_command_15
// 13416       #endif // HOTENDS > 1
// 13417 
// 13418       case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
// 13419         gcode_M220();
??process_parsed_command_74:
          CFI FunCall _Z10gcode_M220v
        BL       _Z10gcode_M220v
// 13420         break;
        B.N      ??process_parsed_command_15
// 13421 
// 13422       case 221: // M221: Set Flow Percentage
// 13423         gcode_M221();
??process_parsed_command_75:
          CFI FunCall _Z10gcode_M221v
        BL       _Z10gcode_M221v
// 13424         break;
        B.N      ??process_parsed_command_15
// 13425 
// 13426       case 226: // M226: Wait until a pin reaches a state
// 13427         gcode_M226();
??process_parsed_command_76:
          CFI FunCall _Z10gcode_M226v
        BL       _Z10gcode_M226v
// 13428         break;
        B.N      ??process_parsed_command_15
// 13429 
// 13430       //#if HAS_SERVOS
// 13431         case 280: // M280: Set servo position absolute
// 13432           gcode_M280();
??process_parsed_command_77:
          CFI FunCall _Z10gcode_M280v
        BL       _Z10gcode_M280v
// 13433           break;
        B.N      ??process_parsed_command_15
// 13434       //#endif // HAS_SERVOS
// 13435 
// 13436       #if ENABLED(BABYSTEPPING)
// 13437         case 290: // M290: Babystepping
// 13438           gcode_M290();
// 13439           break;
// 13440       #endif // BABYSTEPPING
// 13441 
// 13442       #if HAS_BUZZER
// 13443         case 300: // M300: Play beep tone
// 13444           gcode_M300();
// 13445           break;
// 13446       #endif // HAS_BUZZER
// 13447 
// 13448       //#if ENABLED(PIDTEMP)
// 13449         case 301: // M301: Set hotend PID parameters
// 13450         if(PIDTEMP) 
??process_parsed_command_78:
        LDR.N    R0,??DataTable160
        LDRB     R0,[R0, #+52]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
// 13451           gcode_M301();
          CFI FunCall _Z10gcode_M301v
        BL       _Z10gcode_M301v
        B.N      ??process_parsed_command_15
// 13452           break;
// 13453       //#endif // PIDTEMP
// 13454 
// 13455       //#if ENABLED(PIDTEMPBED)
// 13456         case 304: // M304: Set bed PID parameters
// 13457         if(PIDTEMPBED) 
??process_parsed_command_81:
        LDR.W    R0,??DataTable163_3
        LDRB     R0,[R0, #+1]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
// 13458           gcode_M304();
          CFI FunCall _Z10gcode_M304v
        BL       _Z10gcode_M304v
        B.N      ??process_parsed_command_15
// 13459           break;
// 13460       //#endif // PIDTEMPBED
// 13461 
// 13462       #if defined(CHDK) || HAS_PHOTOGRAPH
// 13463         case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
// 13464           gcode_M240();
// 13465           break;
// 13466       #endif // CHDK || PHOTOGRAPH_PIN
// 13467 
// 13468       #if HAS_LCD_CONTRAST
// 13469         case 250: // M250: Set LCD contrast
// 13470           gcode_M250();
// 13471           break;
// 13472       #endif // HAS_LCD_CONTRAST
// 13473 
// 13474       #if ENABLED(EXPERIMENTAL_I2CBUS)
// 13475 
// 13476         case 260: // M260: Send data to an i2c slave
// 13477           gcode_M260();
// 13478           break;
// 13479 
// 13480         case 261: // M261: Request data from an i2c slave
// 13481           gcode_M261();
// 13482           break;
// 13483 
// 13484       #endif // EXPERIMENTAL_I2CBUS
// 13485 
// 13486       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 13487         case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
// 13488           gcode_M302();
??process_parsed_command_79:
          CFI FunCall _Z10gcode_M302v
        BL       _Z10gcode_M302v
// 13489           break;
        B.N      ??process_parsed_command_15
// 13490       #endif // PREVENT_COLD_EXTRUSION
// 13491 
// 13492       case 303: // M303: PID autotune
// 13493         gcode_M303();
??process_parsed_command_80:
          CFI FunCall _Z10gcode_M303v
        BL       _Z10gcode_M303v
// 13494         break;
        B.N      ??process_parsed_command_15
// 13495 
// 13496       //#if ENABLED(MORGAN_SCARA)
// 13497         case 360:  // M360: SCARA Theta pos1
// 13498         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_83:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.W    ??process_parsed_command_15
// 13499           if (gcode_M360()) return;
          CFI FunCall _Z10gcode_M360v
        BL       _Z10gcode_M360v
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13500           break;
// 13501         case 361:  // M361: SCARA Theta pos2
// 13502         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_84:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13503           if (gcode_M361()) return;
          CFI FunCall _Z10gcode_M361v
        BL       _Z10gcode_M361v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13504           break;
// 13505         case 362:  // M362: SCARA Psi pos1
// 13506         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_85:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13507           if (gcode_M362()) return;
          CFI FunCall _Z10gcode_M362v
        BL       _Z10gcode_M362v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13508           break;
// 13509         case 363:  // M363: SCARA Psi pos2
// 13510         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_86:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13511           if (gcode_M363()) return;
          CFI FunCall _Z10gcode_M363v
        BL       _Z10gcode_M363v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13512           break;
// 13513         case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
// 13514         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_87:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13515           if (gcode_M364()) return;
          CFI FunCall _Z10gcode_M364v
        BL       _Z10gcode_M364v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13516           break;
// 13517       //#endif // SCARA
// 13518 
// 13519       case 400: // M400: Finish all moves
// 13520         gcode_M400();
??process_parsed_command_88:
          CFI FunCall _Z10gcode_M400v
        BL       _Z10gcode_M400v
// 13521         break;
        B.N      ??process_parsed_command_15
// 13522 
// 13523       #if HAS_BED_PROBE
// 13524         case 401: // M401: Deploy probe
// 13525           gcode_M401();
??process_parsed_command_89:
          CFI FunCall _Z10gcode_M401v
        BL       _Z10gcode_M401v
// 13526           break;
        B.N      ??process_parsed_command_15
// 13527         case 402: // M402: Stow probe
// 13528           gcode_M402();
??process_parsed_command_90:
          CFI FunCall _Z10gcode_M402v
        BL       _Z10gcode_M402v
// 13529           break;
        B.N      ??process_parsed_command_15
// 13530       #endif // HAS_BED_PROBE
// 13531 
// 13532       #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 13533         case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
// 13534           gcode_M404();
// 13535           break;
// 13536         case 405:  // M405: Turn on filament sensor for control
// 13537           gcode_M405();
// 13538           break;
// 13539         case 406:  // M406: Turn off filament sensor for control
// 13540           gcode_M406();
// 13541           break;
// 13542         case 407:   // M407: Display measured filament diameter
// 13543           gcode_M407();
// 13544           break;
// 13545       #endif // FILAMENT_WIDTH_SENSOR
// 13546 
// 13547       //#if HAS_LEVELING
// 13548         case 420: // M420: Enable/Disable Bed Leveling
// 13549         if(BED_LEVELING_METHOD&HAS_LEVELING)
??process_parsed_command_92:
        LDR.W    R0,??DataTable163_3
        LDRB     R0,[R0, #+12]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??process_parsed_command_15
// 13550           gcode_M420();
          CFI FunCall _Z10gcode_M420v
        BL       _Z10gcode_M420v
        B.N      ??process_parsed_command_15
// 13551           break;
// 13552       //#endif
// 13553 
// 13554       //#if HAS_MESH
// 13555         case 421: // M421: Set a Mesh Bed Leveling Z coordinate
// 13556           if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
??process_parsed_command_93:
        LDR.N    R0,??DataTable160
        ADD      R5,R0,#+52
        LDRB     R0,[R5, #+12]
        LSLS     R1,R0,#+26
        BPL.N    ??process_parsed_command_111
// 13557           	gcode_M421_MESH_BED_LEVELING();
          CFI FunCall _Z28gcode_M421_MESH_BED_LEVELINGv
        BL       _Z28gcode_M421_MESH_BED_LEVELINGv
        B.N      ??process_parsed_command_15
// 13558 		  else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
??process_parsed_command_111:
        LSLS     R1,R0,#+28
        BPL.N    ??process_parsed_command_112
// 13559           	gcode_M421_AUTO_BED_LEVELING_BILINEAR();
          CFI FunCall _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        BL       _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        B.N      ??process_parsed_command_15
// 13560           else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
??process_parsed_command_112:
        LSLS     R0,R0,#+27
        BPL.N    ??process_parsed_command_15
// 13561             gcode_M421_AUTO_BED_LEVELING_UBL();
          CFI FunCall _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        BL       _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        B.N      ??process_parsed_command_15
// 13562           break;
// 13563       //#endif
// 13564 
// 13565       //#if HAS_M206_COMMAND
// 13566         case 428: // M428: Apply current_position to home_offset
// 13567         if(MACHINETPYE != DELTA)
??process_parsed_command_94:
        LDR.W    R0,??DataTable163_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BEQ.N    ??process_parsed_command_15
// 13568           gcode_M428();
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
        B.N      ??process_parsed_command_15
// 13569           break;
// 13570       //#endif
// 13571 
// 13572       case 500: // M500: Store settings in EEPROM
// 13573         gcode_M500();
??process_parsed_command_95:
          CFI FunCall _Z10gcode_M500v
        BL       _Z10gcode_M500v
// 13574         break;
        B.N      ??process_parsed_command_15
// 13575       case 501: // M501: Read settings from EEPROM
// 13576         gcode_M501();
??process_parsed_command_96:
          CFI FunCall _Z10gcode_M501v
        BL       _Z10gcode_M501v
// 13577         break;
        B.N      ??process_parsed_command_15
// 13578       case 502: // M502: Revert to default settings
// 13579         gcode_M502();
??process_parsed_command_97:
          CFI FunCall _Z10gcode_M502v
        BL       _Z10gcode_M502v
// 13580         break;
        B.N      ??process_parsed_command_15
// 13581 
// 13582       #if DISABLED(DISABLE_M503)
// 13583         case 503: // M503: print settings currently in memory
// 13584           gcode_M503();
??process_parsed_command_98:
          CFI FunCall _Z10gcode_M503v
        BL       _Z10gcode_M503v
// 13585           break;
        B.N      ??process_parsed_command_15
// 13586       #endif
// 13587 
// 13588       #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 13589         case 540: // M540: Set abort on endstop hit for SD printing
// 13590           gcode_M540();
// 13591           break;
// 13592       #endif
// 13593 
// 13594       #if HAS_BED_PROBE
// 13595         case 851: // M851: Set Z Probe Z Offset
// 13596           gcode_M851();
??process_parsed_command_101:
          CFI FunCall _Z10gcode_M851v
        BL       _Z10gcode_M851v
// 13597           break;
        B.N      ??process_parsed_command_15
// 13598       #endif // HAS_BED_PROBE
// 13599 
// 13600       #if ENABLED(SKEW_CORRECTION_GCODE)
// 13601         case 852: // M852: Set Skew factors
// 13602           gcode_M852();
// 13603           break;
// 13604       #endif
// 13605 
// 13606       #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 13607         case 600: // M600: Pause for filament change
// 13608           gcode_M600();
// 13609           break;
// 13610       #endif // ADVANCED_PAUSE_FEATURE
// 13611 
// 13612       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 13613         case 605: // M605: Set Dual X Carriage movement mode
// 13614           gcode_M605();
// 13615           break;
// 13616       #endif // DUAL_X_CARRIAGE
// 13617 
// 13618       #if ENABLED(MK2_MULTIPLEXER)
// 13619         case 702: // M702: Unload all extruders
// 13620           gcode_M702();
// 13621           break;
// 13622       #endif
// 13623 
// 13624       #if ENABLED(LIN_ADVANCE)
// 13625         case 900: // M900: Set advance K factor.
// 13626           gcode_M900();
// 13627           break;
// 13628       #endif
// 13629 
// 13630       case 907: // M907: Set digital trimpot motor current using axis codes.
// 13631         gcode_M907();
??process_parsed_command_102:
          CFI FunCall _Z10gcode_M907v
        BL       _Z10gcode_M907v
// 13632         break;
        B.N      ??process_parsed_command_15
// 13633 
// 13634       #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 13635 
// 13636         case 908: // M908: Control digital trimpot directly.
// 13637           gcode_M908();
// 13638           break;
// 13639 
// 13640         #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 13641 
// 13642           case 909: // M909: Print digipot/DAC current value
// 13643             gcode_M909();
// 13644             break;
// 13645 
// 13646           case 910: // M910: Commit digipot/DAC value to external EEPROM
// 13647             gcode_M910();
// 13648             break;
// 13649 
// 13650         #endif
// 13651 
// 13652       #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 13653 
// 13654       #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
// 13655         case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 13656           gcode_M906();
// 13657           break;
// 13658 
// 13659         case 911: // M911: Report TMC prewarn triggered flags
// 13660           gcode_M911();
// 13661           break;
// 13662 
// 13663         case 912: // M911: Clear TMC prewarn triggered flags
// 13664           gcode_M912();
// 13665           break;
// 13666 
// 13667         #if ENABLED(TMC_DEBUG)
// 13668           case 122:  // Debug TMC steppers
// 13669             gcode_M122();
// 13670             break;
// 13671         #endif
// 13672 
// 13673         #if ENABLED(HYBRID_THRESHOLD)
// 13674           case 913: // M913: Set HYBRID_THRESHOLD speed.
// 13675             gcode_M913();
// 13676             break;
// 13677         #endif
// 13678 
// 13679         #if ENABLED(SENSORLESS_HOMING)
// 13680           case 914: // M914: Set SENSORLESS_HOMING sensitivity.
// 13681             gcode_M914();
// 13682             break;
// 13683         #endif
// 13684 
// 13685         #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 13686           case 915: // M915: TMC Z axis calibration routine
// 13687             gcode_M915();
// 13688             break;
// 13689         #endif
// 13690       #endif
// 13691 
// 13692       #if HAS_MICROSTEPS
// 13693 
// 13694         case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 13695           gcode_M350();
// 13696           break;
// 13697 
// 13698         case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
// 13699           gcode_M351();
// 13700           break;
// 13701 
// 13702       #endif // HAS_MICROSTEPS
// 13703 
// 13704       case 355: // M355 set case light brightness
// 13705         gcode_M355();
??process_parsed_command_82:
          CFI FunCall _Z10gcode_M355v
        BL       _Z10gcode_M355v
// 13706         break;
        B.N      ??process_parsed_command_15
// 13707 
// 13708       #if ENABLED(DEBUG_GCODE_PARSER)
// 13709         case 800:
// 13710           parser.debug(); // GCode Parser Test for M
// 13711           break;
// 13712       #endif
// 13713 
// 13714       #if ENABLED(I2C_POSITION_ENCODERS)
// 13715 
// 13716         case 860: // M860 Report encoder module position
// 13717           gcode_M860();
// 13718           break;
// 13719 
// 13720         case 861: // M861 Report encoder module status
// 13721           gcode_M861();
// 13722           break;
// 13723 
// 13724         case 862: // M862 Perform axis test
// 13725           gcode_M862();
// 13726           break;
// 13727 
// 13728         case 863: // M863 Calibrate steps/mm
// 13729           gcode_M863();
// 13730           break;
// 13731 
// 13732         case 864: // M864 Change module address
// 13733           gcode_M864();
// 13734           break;
// 13735 
// 13736         case 865: // M865 Check module firmware version
// 13737           gcode_M865();
// 13738           break;
// 13739 
// 13740         case 866: // M866 Report axis error count
// 13741           gcode_M866();
// 13742           break;
// 13743 
// 13744         case 867: // M867 Toggle error correction
// 13745           gcode_M867();
// 13746           break;
// 13747 
// 13748         case 868: // M868 Set error correction threshold
// 13749           gcode_M868();
// 13750           break;
// 13751 
// 13752         case 869: // M869 Report axis error
// 13753           gcode_M869();
// 13754           break;
// 13755 
// 13756       #endif // I2C_POSITION_ENCODERS
// 13757 
// 13758       case 999: // M999: Restart after being Stopped
// 13759         gcode_M999();
??process_parsed_command_105:
          CFI FunCall _Z10gcode_M999v
        BL       _Z10gcode_M999v
// 13760         break;
        B.N      ??process_parsed_command_15
// 13761     }
// 13762     break;
// 13763 
// 13764     case 'T':
// 13765       gcode_T(parser.codenum);
??process_parsed_command_2:
        LDR.W    R0,??DataTable163_2
        LDR      R0,[R0, #+0]
        UXTB     R0,R0
          CFI FunCall _Z7gcode_Th
        BL       _Z7gcode_Th
// 13766       break;
        B.N      ??process_parsed_command_15
// 13767 
// 13768     default: parser.unknown_command_error();
??process_parsed_command_3:
        LDR.W    R0,??DataTable168
          CFI FunCall _ZN11GCodeParser21unknown_command_errorEv
        BL       _ZN11GCodeParser21unknown_command_errorEv
// 13769   }
// 13770 
// 13771   KEEPALIVE_STATE(NOT_BUSY);
??process_parsed_command_15:
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 13772 
// 13773   ok_to_send();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10ok_to_sendv
        B.N      _Z10ok_to_sendv
          CFI EndBlock cfiBlock67
// 13774 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable158:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable158_1:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "HAS_NO_TEMP_BED!\\n">`:
        DC8 "HAS_NO_TEMP_BED!\012"
        DC8 0, 0
// 13775 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function _Z20process_next_commandv
        THUMB
// 13776 void process_next_command() 
// 13777 {
_Z20process_next_commandv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 13778   char * const current_command = command_queue[cmd_queue_index_r];
        LDR.W    R0,??DataTable168_1
        LDRB     R0,[R0, #+7]
        ADD      R1,R0,R0, LSL #+1
        LDR.W    R0,??DataTable168_2
        ADD      R4,R0,R1, LSL #+5
// 13779 
// 13780   if (DEBUGGING(ECHO)) {
        LDR.W    R0,??DataTable168_3
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+31
        BPL.N    ??process_next_command_0
// 13781     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable162_6
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13782     SERIAL_ECHOLN(current_command);
        LDR.W    R5,??DataTable163
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13783     #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 13784       SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
// 13785       M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
// 13786     #endif
// 13787   }
// 13788 
// 13789   // Parse the next command in the queue
// 13790   parser.parse(current_command);
??process_next_command_0:
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
// 13791   process_parsed_command();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z22process_parsed_commandv
        B.N      _Z22process_parsed_commandv
          CFI EndBlock cfiBlock68
// 13792 }
// 13793 
// 13794 /**
// 13795  * Send a "Resend: nnn" message to the host to
// 13796  * indicate that a command needs to be re-sent.
// 13797  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function _Z24FlushSerialRequestResendv
          CFI FunCall _Z10ok_to_sendv
        THUMB
// 13798 void FlushSerialRequestResend() {
_Z24FlushSerialRequestResendv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13799   //char command_queue[cmd_queue_index_r][100]="Resend:";
// 13800   MYSERIAL.flush();
        LDR.W    R4,??DataTable163
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5flushEv
        BL       _ZN10USARTClass5flushEv
// 13801   SERIAL_PROTOCOLPGM(MSG_RESEND);
        ADR.W    R0,`?<Constant "Resend: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13802   SERIAL_PROTOCOLLN(gcode_LastN + 1);
        MOVS     R2,#+10
        LDR.W    R0,??DataTable163_1
        LDR      R0,[R0, #+44]
        ADDS     R1,R0,#+1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13803   ok_to_send();
        POP      {R4,LR}
          CFI EndBlock cfiBlock69
        REQUIRE _Z10ok_to_sendv
        ;; // Fall through to label ok_to_send()
// 13804 }
// 13805 
// 13806 /**
// 13807  * Send an "ok" message to the host, indicating
// 13808  * that a command was successfully processed.
// 13809  *
// 13810  * If ADVANCED_OK is enabled also include:
// 13811  *   N<int>  Line number of the command, if any
// 13812  *   P<int>  Planner space remaining
// 13813  *   B<int>  Block queue space remaining
// 13814  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function _Z10ok_to_sendv
        THUMB
// 13815 void ok_to_send() {
_Z10ok_to_sendv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 13816   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 13817   if (!send_ok[cmd_queue_index_r]) return;
        LDR.W    R0,??DataTable168_1
        LDRB     R1,[R0, #+7]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+20]
        CMP      R0,#+0
        BEQ.N    ??ok_to_send_0
// 13818   SERIAL_PROTOCOLPGM(MSG_OK);
        ADR.N    R0,??DataTable162  ;; 0x6F, 0x6B, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13819   #if ENABLED(ADVANCED_OK)
// 13820     char* p = command_queue[cmd_queue_index_r];
// 13821     if (*p == 'N') {
// 13822       SERIAL_PROTOCOL(' ');
// 13823       SERIAL_ECHO(*p++);
// 13824       while (NUMERIC_SIGNED(*p))
// 13825         SERIAL_ECHO(*p++);
// 13826     }
// 13827     SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
// 13828     SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
// 13829   #endif
// 13830   SERIAL_EOL();
        MOVS     R1,#+10
        LDR.W    R0,??DataTable163
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??ok_to_send_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock70
// 13831 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resend: ">`:
        DC8 "Resend: "
        DC8 0, 0, 0
// 13832 
// 13833 #if HAS_SOFTWARE_ENDSTOPS
// 13834 
// 13835   /**
// 13836    * Constrain the given coordinates to the software endstops.
// 13837    *
// 13838    * For DELTA/SCARA the XY constraint is based on the smallest
// 13839    * radius within the set software endstops.
// 13840    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function _Z26clamp_to_software_endstopsPf
        THUMB
// 13841   void clamp_to_software_endstops(float target[XYZ]) {
_Z26clamp_to_software_endstopsPf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
// 13842     if (!soft_endstops_enabled) return;
        LDR.W    R5,??DataTable168_4
        LDRB     R0,[R5, #+8]
        CMP      R0,#+0
        BEQ.W    ??clamp_to_software_endstops_0
// 13843     //#if IS_KINEMATIC
// 13844     if(MACHINETPYE & IS_KINEMATIC )
        LDR.W    R6,??DataTable168_5
        ADD      R7,R6,#+32
        LDRH     R0,[R7, #+56]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??clamp_to_software_endstops_1
// 13845     {
// 13846       const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
        LDR      R10,[R4, #+0]
        MOV      R9,#+2
        MOV      R11,#+1065353216
        MOV      R8,R11
        B.N      ??clamp_to_software_endstops_2
??clamp_to_software_endstops_3:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??clamp_to_software_endstops_2:
        LSLS     R0,R9,#+31
        BPL.N    ??clamp_to_software_endstops_4
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??clamp_to_software_endstops_4:
        LSRS     R9,R9,#+1
        BNE.N    ??clamp_to_software_endstops_3
        LDR      R9,[R4, #+4]
        MOV      R10,#+2
        B.N      ??clamp_to_software_endstops_5
??clamp_to_software_endstops_6:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??clamp_to_software_endstops_5:
        LSLS     R0,R10,#+31
        BPL.N    ??clamp_to_software_endstops_7
        MOV      R0,R11
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??clamp_to_software_endstops_7:
        LSRS     R10,R10,#+1
        BNE.N    ??clamp_to_software_endstops_6
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
// 13847       if (dist_2 > soft_endstop_radius_2) {
        LDR      R0,[R5, #+88]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_8
// 13848         const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
        MOV      R0,R1
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R5, #+84]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 13849         target[X_AXIS] *= ratio;
        LDR      R0,[R4, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+0]
// 13850         target[Y_AXIS] *= ratio;
        LDR      R0,[R4, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+4]
        B.N      ??clamp_to_software_endstops_8
// 13851       }
// 13852     }
// 13853     //#else
// 13854     else
// 13855     {
// 13856 		if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_1:
        LDRB     R0,[R6, #+32]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_9
// 13857 		{
// 13858       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
// 13859        	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
        LDR.W    R2,??DataTable168_3
        LDR      R1,[R2, #+68]
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_10
        STR      R1,[R4, #+0]
// 13860       		//#endif
// 13861       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
// 13862         	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
??clamp_to_software_endstops_10:
        LDR      R1,[R2, #+72]
        LDR      R0,[R4, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_9
        STR      R1,[R4, #+4]
// 13863       		//#endif
// 13864 		}
// 13865 		if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_9:
        LDRB     R0,[R7, #+1]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_8
// 13866 		{	
// 13867       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
// 13868         	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
        LDR      R0,[R5, #+36]
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_11
        STR      R0,[R4, #+0]
// 13869       		//#endif
// 13870       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
// 13871         	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
??clamp_to_software_endstops_11:
        LDR      R0,[R5, #+40]
        LDR      R1,[R4, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_8
        STR      R0,[R4, #+4]
// 13872       		//#endif
// 13873 		}
// 13874     }
// 13875     //#endif
// 13876 	if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_8:
        LDRB     R0,[R6, #+32]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_12
// 13877 	{
// 13878     //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
// 13879       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
        LDR.W    R2,??DataTable168_3
        LDR      R1,[R2, #+76]
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_12
        STR      R1,[R4, #+8]
// 13880     //#endif
// 13881 	}
// 13882 	if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_12:
        LDRB     R0,[R7, #+1]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_0
// 13883 	{
// 13884     //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
// 13885       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
        LDR      R0,[R5, #+44]
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_0
        STR      R0,[R4, #+8]
// 13886     //#endif
// 13887 	}
// 13888   }
??clamp_to_software_endstops_0:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock71

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable161:
        DC32     _ZN17mesh_bed_leveling8z_offsetE
// 13889 
// 13890 #endif
// 13891 
// 13892 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13893 
// 13894   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 13895     #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
// 13896     #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
// 13897     #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
// 13898     #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
// 13899     #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
// 13900   #else
// 13901     #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
// 13902     #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
// 13903     #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
// 13904     #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
// 13905     #define ABL_BG_GRID(X,Y)  z_values[X][Y]
// 13906   #endif
// 13907 
// 13908   // Get the Z adjustment for non-linear bed leveling

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock72 Using cfiCommon0
          CFI Function _Z17bilinear_z_offsetPKf
        THUMB
// 13909   float bilinear_z_offset(const float raw[XYZ]) {
_Z17bilinear_z_offsetPKf:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R5,R0
// 13910 
// 13911     static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
// 13912                  last_x = -999.999, last_y = -999.999;
// 13913 
// 13914     // Whole units for the grid line indices. Constrained within bounds.
// 13915     static int8_t gridx, gridy, nextx, nexty,
// 13916                   last_gridx = -99, last_gridy = -99;
// 13917 
// 13918     // XY relative to the probed area
// 13919     const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
        LDR.W    R4,??DataTable163_1
        LDR      R0,[R4, #+24]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 13920                 ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
        LDR      R0,[R4, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 13921 
// 13922     #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
// 13923       // Keep using the last grid box
// 13924       #define FAR_EDGE_OR_BOX 2
// 13925     #else
// 13926       // Just use the grid far edge
// 13927       #define FAR_EDGE_OR_BOX 1
// 13928     #endif
// 13929 
// 13930     if (last_x != rx) {
        LDR      R0,[R4, #+96]
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??bilinear_z_offset_0
// 13931       last_x = rx;
        STR      R6,[R4, #+96]
// 13932       ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
        LDR      R0,[R4, #+32]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
        STR      R7,[R4, #+88]
// 13933       const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
        LDR.W    R6,??DataTable168_5
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_1
        MOV      R8,R1
        B.N      ??bilinear_z_offset_2
??bilinear_z_offset_1:
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R9,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R8,R0
        MOV      R1,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??bilinear_z_offset_2
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R8,R0
// 13934       ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
??bilinear_z_offset_2:
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+88]
// 13935 
// 13936       #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13937         // Beyond the grid maintain height at grid edges
// 13938         NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_3
        MOV      R0,R1
        STR      R0,[R4, #+88]
// 13939       #endif
// 13940 
// 13941       gridx = gx;
??bilinear_z_offset_3:
        MOV      R0,R8
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRB     R0,[R4, #+10]
// 13942       nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
        LDRB     R1,[R6, #+96]
        SXTB     R0,R0
        ADDS     R2,R0,#+1
        SUBS     R3,R1,#+1
        CMP      R2,R3
        BGE.N    ??bilinear_z_offset_4
        ADDS     R0,R0,#+1
        B.N      ??bilinear_z_offset_5
??bilinear_z_offset_4:
        SUBS     R0,R1,#+1
??bilinear_z_offset_5:
        STRB     R0,[R4, #+12]
// 13943     }
// 13944 
// 13945     if (last_y != ry || last_gridx != gridx) {
??bilinear_z_offset_0:
        LDR      R2,[R4, #+100]
        MOV      R0,R2
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??bilinear_z_offset_6
        LDRSB    R0,[R4, #+14]
        LDRSB    R1,[R4, #+10]
        CMP      R0,R1
        BEQ.W    ??bilinear_z_offset_7
// 13946 
// 13947       if (last_y != ry) {
??bilinear_z_offset_6:
        MOV      R0,R2
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??bilinear_z_offset_8
// 13948         last_y = ry;
        STR      R5,[R4, #+100]
// 13949         ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
        LDR      R0,[R4, #+36]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        STR      R5,[R4, #+92]
// 13950         const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_9
        MOV      R6,R1
        B.N      ??bilinear_z_offset_10
??bilinear_z_offset_9:
        MOV      R0,R5
          CFI FunCall floorf
        BL       floorf
        MOV      R7,R0
        LDR.W    R6,??DataTable168_5
        ADD      R1,R6,#+96
        LDRB     R0,[R1, #+1]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R6,R0
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??bilinear_z_offset_10
        MOV      R0,R5
          CFI FunCall floorf
        BL       floorf
        MOV      R6,R0
// 13951         ratio_y -= gy;
??bilinear_z_offset_10:
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+92]
// 13952 
// 13953         #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13954           // Beyond the grid maintain height at grid edges
// 13955           NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_11
        MOV      R0,R1
        STR      R0,[R4, #+92]
// 13956         #endif
// 13957 
// 13958         gridy = gy;
??bilinear_z_offset_11:
        MOV      R0,R6
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRB     R0,[R4, #+11]
// 13959         nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
        LDR.W    R6,??DataTable168_5
        ADD      R1,R6,#+96
        LDRB     R1,[R1, #+1]
        SXTB     R0,R0
        ADDS     R2,R0,#+1
        SUBS     R3,R1,#+1
        CMP      R2,R3
        BGE.N    ??bilinear_z_offset_12
        ADDS     R0,R0,#+1
        B.N      ??bilinear_z_offset_13
??bilinear_z_offset_12:
        SUBS     R0,R1,#+1
??bilinear_z_offset_13:
        STRB     R0,[R4, #+13]
// 13960       }
// 13961 
// 13962       if (last_gridx != gridx || last_gridy != gridy) {
??bilinear_z_offset_8:
        LDRSB    R5,[R4, #+11]
        LDRSB    R0,[R4, #+10]
        LDRSB    R1,[R4, #+14]
        CMP      R1,R0
        BNE.N    ??bilinear_z_offset_14
        LDRSB    R1,[R4, #+15]
        CMP      R1,R5
        BEQ.N    ??bilinear_z_offset_15
// 13963         last_gridx = gridx;
??bilinear_z_offset_14:
        STRB     R0,[R4, #+14]
// 13964         last_gridy = gridy;
        STRB     R5,[R4, #+15]
// 13965         // Z at the box corners
// 13966         z1 = ABL_BG_GRID(gridx, gridy);       // left-front
        MOVS     R7,#+48
        LDR.W    R8,??DataTable170
        MLA      R0,R7,R0,R8
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+64]
        LDRSB    R6,[R4, #+13]
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+68]
// 13967         d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
// 13968         z3 = ABL_BG_GRID(nextx, gridy);       // right-front
        LDRSB    R0,[R4, #+12]
        MLA      R0,R7,R0,R8
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+72]
// 13969         d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+76]
// 13970       }
// 13971 
// 13972       // Bilinear interpolate. Needed since ry or gridx has changed.
// 13973                   L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
??bilinear_z_offset_15:
        LDR      R5,[R4, #+92]
        LDR      R0,[R4, #+68]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        STR      R6,[R4, #+80]
// 13974       const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
// 13975 
// 13976       D = R - L;
        LDR      R0,[R4, #+76]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+84]
// 13977     }
// 13978 
// 13979     const float offset = L + ratio_x * D;   // the offset almost always changes
// 13980 
// 13981     /*
// 13982     static float last_offset = 0;
// 13983     if (FABS(last_offset - offset) > 0.2) {
// 13984       SERIAL_ECHOPGM("Sudden Shift at ");
// 13985       SERIAL_ECHOPAIR("x=", rx);
// 13986       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
// 13987       SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
// 13988       SERIAL_ECHOPAIR(" y=", ry);
// 13989       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
// 13990       SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
// 13991       SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
// 13992       SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
// 13993       SERIAL_ECHOPAIR(" z1=", z1);
// 13994       SERIAL_ECHOPAIR(" z2=", z2);
// 13995       SERIAL_ECHOPAIR(" z3=", z3);
// 13996       SERIAL_ECHOLNPAIR(" z4=", z4);
// 13997       SERIAL_ECHOPAIR(" L=", L);
// 13998       SERIAL_ECHOPAIR(" R=", R);
// 13999       SERIAL_ECHOLNPAIR(" offset=", offset);
// 14000     }
// 14001     last_offset = offset;
// 14002     //*/
// 14003 
// 14004     return offset;
??bilinear_z_offset_7:
        LDR      R1,[R4, #+88]
        LDR      R0,[R4, #+84]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+80]
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI EndBlock cfiBlock72
// 14005   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162:
        DC8      0x6F, 0x6B, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162_1:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162_2:
        DC32     hotend_offset

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162_3:
        DC32     _ZN7Planner16bed_level_matrixE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162_4:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162_5:
        DC32     _ZN11GCodeParser14command_letterE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162_6:
        DC32     echomagic

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_relative_modes:
        DATA
        DC8 0, 0, 0, 0
Running:
        DC8 1
        DC8 0
busy_state:
        DC8 0
host_keepalive_interval:
        DC8 2
serial_wait_tick:
        DC8 0
from_wifi_flag:
        DC8 0
        DC8 0
        DC8 0
        DC8 0
        DC8 0
        DC8 -99
        DC8 -99
bilinear_grid_spacing:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_start:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_grid_factor:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0
        DC32 0
        DC32 0
        DC32 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0C479FFF0H
        DC32 0C479FFF0H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_homed:
        DATA
        DC8 0, 0, 0, 0
axis_known_position:
        DC8 0, 0, 0, 0
soft_endstops_enabled:
        DC8 1
lcd_wait_for_move:
        DC8 0
        DC8 0, 0
delta_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_max:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
delta_tower_angle_trim:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
delta_diagonal_rod_2_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
cartes:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_radius:
        DC8 0, 0, 0, 0
soft_endstop_radius_2:
        DC8 0, 0, 0, 0
previous_cmd_ms:
        DC32 0
        DC32 0
        DC32 120000
delta_radius:
        DC8 0, 0, 0, 0
delta_diagonal_rod:
        DC8 0, 0, 0, 0
delta_calibration_radius:
        DC8 0, 0, 0, 0
delta_segments_per_second:
        DC8 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
home_bump_mm_P:
        DATA
        DC32 40A00000H, 40A00000H, 40A00000H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
_ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index:
        DATA
        DC32 -1
// 14006 
// 14007 #endif // AUTO_BED_LEVELING_BILINEAR
// 14008 
// 14009 #if 1//ENABLED(DELTA)
// 14010 
// 14011   /**
// 14012    * Recalculate factors used for delta kinematics whenever
// 14013    * settings have been changed (e.g., by M665).
// 14014    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function _Z21recalc_delta_settingsv
        THUMB
// 14015   void recalc_delta_settings() {
_Z21recalc_delta_settingsv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
// 14016     const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
// 14017                 drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
// 14018     delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
        LDR.W    R8,??DataTable170_1  ;; 0x54442d18
        LDR.W    R9,??DataTable170_2  ;; 0x400921fb
        LDR.W    R7,??DataTable170_3  ;; 0x43520000
        LDR.W    R6,??DataTable168_4
        LDR      R0,[R6, #+48]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable170_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+12]
// 14019     delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
        LDR      R0,[R6, #+48]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable170_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+16]
// 14020     delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
        LDR.W    R7,??DataTable170_5  ;; 0x43a50000
        LDR      R0,[R6, #+52]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable170_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+20]
// 14021     delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
        LDR      R0,[R6, #+52]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable170_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+24]
// 14022     delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
        LDR.W    R7,??DataTable171  ;; 0x42b40000
        LDR      R0,[R6, #+56]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable170_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+28]
// 14023     delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
        LDR      R0,[R6, #+56]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable170_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+32]
// 14024     delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
        LDR      R1,[R6, #+108]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        MOV      R7,R4
        MOV      R8,#+2
        MOV      R5,#+1065353216
        MOV      R9,R5
        B.N      ??recalc_delta_settings_0
??recalc_delta_settings_1:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??recalc_delta_settings_0:
        LSLS     R0,R8,#+31
        BPL.N    ??recalc_delta_settings_2
        MOV      R0,R9
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_2:
        LSRS     R8,R8,#+1
        BNE.N    ??recalc_delta_settings_1
        STR      R9,[R6, #+60]
// 14025     delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
        MOV      R7,R4
        MOV      R8,#+2
        MOV      R9,R5
        B.N      ??recalc_delta_settings_3
??recalc_delta_settings_4:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??recalc_delta_settings_3:
        LSLS     R0,R8,#+31
        BPL.N    ??recalc_delta_settings_5
        MOV      R0,R9
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_5:
        LSRS     R8,R8,#+1
        BNE.N    ??recalc_delta_settings_4
        STR      R9,[R6, #+64]
// 14026     delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
        MOVS     R7,#+2
        B.N      ??recalc_delta_settings_6
??recalc_delta_settings_7:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??recalc_delta_settings_6:
        LSLS     R0,R7,#+31
        BPL.N    ??recalc_delta_settings_8
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??recalc_delta_settings_8:
        LSRS     R7,R7,#+1
        BNE.N    ??recalc_delta_settings_7
        STR      R5,[R6, #+68]
// 14027     update_software_endstops(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 14028     axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
        MOVS     R0,#+0
        STRB     R0,[R6, #+2]
        STRH     R0,[R6, #+0]
// 14029   }
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock73

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_2:
        DC32     _ZN11GCodeParser7codenumE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_3:
        DC32     mksCfg+0x34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_4:
        DC32     `?<Constant "bed leveling hasn\\'t d...">`
// 14030 
// 14031   #if ENABLED(DELTA_FAST_SQRT)
// 14032     /**
// 14033      * Fast inverse sqrt from Quake III Arena
// 14034      * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
// 14035      */
// 14036     float Q_rsqrt(const float number) {
// 14037       long i;
// 14038       float x2, y;
// 14039       const float threehalfs = 1.5f;
// 14040       x2 = number * 0.5f;
// 14041       y  = number;
// 14042       i  = * ( long * ) &y;                       // evil floating point bit level hacking
// 14043       i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
// 14044       y  = * ( float * ) &i;
// 14045       y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
// 14046       // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
// 14047       return y;
// 14048     }
// 14049 
// 14050   #endif
// 14051 
// 14052   /**
// 14053    * Delta Inverse Kinematics
// 14054    *
// 14055    * Calculate the tower positions for a given machine
// 14056    * position, storing the result in the delta[] array.
// 14057    *
// 14058    * This is an expensive calculation, requiring 3 square
// 14059    * roots per segmented linear move, and strains the limits
// 14060    * of a Mega2560 with a Graphical Display.
// 14061    *
// 14062    * Suggested optimizations include:
// 14063    *
// 14064    * - Disable the home_offset (M206) and/or position_shift (G92)
// 14065    *   features to remove up to 12 float additions.
// 14066    *
// 14067    * - Use a fast-inverse-sqrt function and add the reciprocal.
// 14068    *   (see above)
// 14069    */
// 14070 
// 14071   #define DELTA_DEBUG() do { \ 
// 14072       SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \ 
// 14073       SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \ 
// 14074       SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \ 
// 14075       SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \ 
// 14076       SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \ 
// 14077       SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \ 
// 14078     }while(0)
// 14079 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock74 Using cfiCommon0
          CFI Function _Z18inverse_kinematicsPKf
        THUMB
// 14080   void inverse_kinematics(const float raw[XYZ]) {
_Z18inverse_kinematicsPKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
// 14081     DELTA_IK(raw);
        LDR.W    R6,??DataTable168_4
        LDR      R0,[R6, #+12]
        LDR      R1,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R9,#+2
        MOV      R4,#+1065353216
        MOV      R7,R4
        B.N      ??inverse_kinematics_0
??inverse_kinematics_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_0:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_2
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??inverse_kinematics_2:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_1
        LDR      R0,[R6, #+16]
        LDR      R1,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??inverse_kinematics_3
??inverse_kinematics_4:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_3:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_5
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_5:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_4
        MOV      R0,R7
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        LDR.W    R7,??DataTable168_3
        LDR      R1,[R5, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+80]
        LDR      R0,[R6, #+20]
        LDR      R1,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,R4
        B.N      ??inverse_kinematics_6
??inverse_kinematics_7:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_6:
        LSLS     R0,R10,#+31
        BPL.N    ??inverse_kinematics_8
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_8:
        LSRS     R10,R10,#+1
        BNE.N    ??inverse_kinematics_7
        LDR      R0,[R6, #+24]
        LDR      R1,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??inverse_kinematics_9
??inverse_kinematics_10:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_9:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_11
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_11:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_10
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R5, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+84]
        LDR      R0,[R6, #+28]
        LDR      R1,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,R4
        B.N      ??inverse_kinematics_12
??inverse_kinematics_13:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_12:
        LSLS     R0,R10,#+31
        BPL.N    ??inverse_kinematics_14
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_14:
        LSRS     R10,R10,#+1
        BNE.N    ??inverse_kinematics_13
        LDR      R0,[R6, #+32]
        LDR      R1,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOV      R9,#+2
        B.N      ??inverse_kinematics_15
??inverse_kinematics_16:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_15:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_17
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??inverse_kinematics_17:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_16
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R5, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+88]
// 14082     // DELTA_DEBUG();
// 14083   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock74
// 14084 
// 14085   /**
// 14086    * Calculate the highest Z position where the
// 14087    * effector has the full range of XY motion.
// 14088    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function _Z28delta_safe_distance_from_topv
        THUMB
// 14089   float delta_safe_distance_from_top() {
_Z28delta_safe_distance_from_topv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
// 14090     float cartesian[XYZ] = { 0, 0, 0 };
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOV      R2,R1
        MOV      R3,R1
        STM      R0!,{R1-R3}
// 14091 	if(MACHINETPYE == MORGAN_SCARA)
        LDR.W    R4,??DataTable168_5
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        ADD      R0,SP,#+0
        BNE.N    ??delta_safe_distance_from_top_0
// 14092 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_1
// 14093 	else
// 14094     	inverse_kinematics(cartesian);
??delta_safe_distance_from_top_0:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 14095 	
// 14096     float distance = delta[A_AXIS];
??delta_safe_distance_from_top_1:
        LDR.W    R5,??DataTable168_3
        LDR      R6,[R5, #+80]
// 14097     cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
        LDR      R0,[R4, #+84]
        STR      R0,[SP, #+4]
// 14098 	if(MACHINETPYE == MORGAN_SCARA)
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        ADD      R0,SP,#+0
        BNE.N    ??delta_safe_distance_from_top_2
// 14099 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_3
// 14100 	else
// 14101     	inverse_kinematics(cartesian);
??delta_safe_distance_from_top_2:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 14102     return FABS(distance - delta[A_AXIS]);
??delta_safe_distance_from_top_3:
        MOV      R0,R6
        LDR      R1,[R5, #+80]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock75
// 14103   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165_1:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165_2:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165_3:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165_4:
        DC32     default_preview_flg
// 14104 
// 14105   /**
// 14106    * Delta Forward Kinematics
// 14107    *
// 14108    * See the Wikipedia article "Trilateration"
// 14109    * https://en.wikipedia.org/wiki/Trilateration
// 14110    *
// 14111    * Establish a new coordinate system in the plane of the
// 14112    * three carriage points. This system has its origin at
// 14113    * tower1, with tower2 on the X axis. Tower3 is in the X-Y
// 14114    * plane with a Z component of zero.
// 14115    * We will define unit vectors in this coordinate system
// 14116    * in our original coordinate system. Then when we calculate
// 14117    * the Xnew, Ynew and Znew values, we can translate back into
// 14118    * the original system by moving along those unit vectors
// 14119    * by the corresponding values.
// 14120    *
// 14121    * Variable names matched to Marlin, c-version, and avoid the
// 14122    * use of any vector library.
// 14123    *
// 14124    * by Andreas Hardtung 2016-06-07
// 14125    * based on a Java function from "Delta Robot Kinematics V3"
// 14126    * by Steve Graves
// 14127    *
// 14128    * The result is stored in the cartes[] array.
// 14129    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAfff
        THUMB
// 14130   void forward_kinematics_DELTA(float z1, float z2, float z3) {
_Z24forward_kinematics_DELTAfff:
        PUSH     {R0,R2,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        SUB      SP,SP,#+36
          CFI CFA R13+80
        MOV      R4,R1
        LDR.W    R0,??DataTable168_4
        LDR      R0,[R0, #+20]
        LDR.W    R1,??DataTable168_4
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 14131     // Create a vector in old coordinates along x axis of new coordinate
// 14132     const float p12[] = {
        LDR.W    R0,??DataTable168_4
        LDR      R0,[R0, #+24]
        LDR.W    R1,??DataTable168_4
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R0,R4
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
// 14133       delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 14134       delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 14135       z2 - z1
// 14136     },
// 14137 
// 14138     // Get the Magnitude of vector.
// 14139     d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
        MOV      R8,R6
        MOV      R9,#+2
        MOV      R7,#+1065353216
        B.N      ??forward_kinematics_DELTA_0
??forward_kinematics_DELTA_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_0:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_2
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_2:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_1
        MOV      R9,R5
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_3
??forward_kinematics_DELTA_4:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_3:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_5
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_5:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_4
        MOV      R11,R4
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_6
??forward_kinematics_DELTA_7:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_6:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_8
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_8:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_7
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+20]
// 14140 
// 14141     // Create unit vector by dividing by magnitude.
// 14142     ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
        MOV      R0,R6
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+16]
        MOV      R0,R5
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+12]
        MOV      R0,R4
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+8]
// 14143 
// 14144     // Get the vector from the origin of the new system to the third point.
// 14145     p13[3] = {
        LDR.W    R0,??DataTable168_4
        LDR      R0,[R0, #+28]
        LDR.W    R1,??DataTable168_4
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        LDR.W    R0,??DataTable168_4
        LDR      R0,[R0, #+32]
        LDR.W    R1,??DataTable168_4
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR      R0,[SP, #+40]
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 14146       delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 14147       delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 14148       z3 - z1
// 14149     },
// 14150 
// 14151     // Use the dot product to find the component of this vector on the X axis.
// 14152     i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
        LDR      R0,[SP, #+16]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
// 14153 
// 14154     // Create a vector along the x axis that represents the x component of p13.
// 14155     iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
// 14156 
// 14157     // Subtract the X component from the original vector leaving only Y. We use the
// 14158     // variable that will be the unit vector after we scale it.
// 14159     float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
        LDR      R0,[SP, #+16]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 14160 
// 14161     // The magnitude of Y component
// 14162     const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
        MOV      R8,R5
        MOV      R9,#+2
        MOV      R7,#+1065353216
        B.N      ??forward_kinematics_DELTA_9
??forward_kinematics_DELTA_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_9:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_11
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_11:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_10
        MOV      R9,R6
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_12
??forward_kinematics_DELTA_13:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_12:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_14
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_14:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_13
        LDR      R11,[SP, #+24]
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_15
??forward_kinematics_DELTA_16:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_15:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_17
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_17:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_16
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+4]
// 14163 
// 14164     // Convert to a unit vector
// 14165     ey[0] /= j; ey[1] /= j;  ey[2] /= j;
        MOV      R0,R5
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R5,R0
        MOV      R0,R6
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R6,R0
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
// 14166 
// 14167     // The cross product of the unit x and y is the unit z
// 14168     // float[] ez = vectorCrossProd(ex, ey);
// 14169     const float ez[3] = {
        LDR      R0,[SP, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
        LDR      R0,[SP, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+16]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+32]
        LDR      R0,[SP, #+16]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
// 14170       ex[1] * ey[2] - ex[2] * ey[1],
// 14171       ex[2] * ey[0] - ex[0] * ey[2],
// 14172       ex[0] * ey[1] - ex[1] * ey[0]
// 14173     },
// 14174     // We now have the d, i and j values defined in Wikipedia.
// 14175     // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
// 14176     Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
        LDR      R9,[SP, #+20]
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_18
??forward_kinematics_DELTA_19:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_18:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_20
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_20:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_19
        LDR.N    R0,??DataTable168_4
        LDR      R0,[R0, #+60]
        LDR.N    R1,??DataTable168_4
        LDR      R1,[R1, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R1,[SP, #+20]
        MOV      R0,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
// 14177     Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
        MOV      R9,R4
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_21
??forward_kinematics_DELTA_22:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_21:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_23
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_23:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_22
        LDR      R11,[SP, #+4]
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_24
??forward_kinematics_DELTA_25:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_24:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_26
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_26:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_25
        LDR.N    R0,??DataTable168_4
        LDR      R0,[R0, #+60]
        LDR.N    R1,??DataTable168_4
        LDR      R1,[R1, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R4,R0
// 14178     Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
        LDR      R9,[SP, #+0]
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_27
??forward_kinematics_DELTA_28:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_27:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_29
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_29:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_28
        MOV      R11,R4
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_30
??forward_kinematics_DELTA_31:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_30:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_32
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_32:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_31
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR.N    R0,??DataTable168_4
        LDR      R0,[R0, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
// 14179 
// 14180     // Start from the origin of the old coordinates and add vectors in the
// 14181     // old coords that represent the Xnew, Ynew and Znew to find the point
// 14182     // in the old system.
// 14183     cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
        LDR      R1,[SP, #+16]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.N    R1,??DataTable168_4
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+24]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??DataTable168_4
        STR      R0,[R1, #+72]
// 14184     cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
        LDR      R1,[SP, #+12]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.N    R1,??DataTable168_4
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R6
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+32]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??DataTable168_4
        STR      R0,[R1, #+76]
// 14185     cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
        LDR      R1,[SP, #+8]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R0,[SP, #+28]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??DataTable168_4
        STR      R0,[R1, #+80]
// 14186   }
        ADD      SP,SP,#+44
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock76
// 14187 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock77 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAPf
        THUMB
// 14188   void forward_kinematics_DELTA(float point[ABC]) {
// 14189     forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
_Z24forward_kinematics_DELTAPf:
        LDR      R2,[R0, #+8]
        LDR      R1,[R0, #+4]
        LDR      R0,[R0, #+0]
          CFI FunCall _Z24forward_kinematics_DELTAfff
        B.N      _Z24forward_kinematics_DELTAfff
          CFI EndBlock cfiBlock77
// 14190   }
// 14191 
// 14192 #endif // DELTA
// 14193 
// 14194 /**
// 14195  * Get the stepper positions in the cartes[] array.
// 14196  * Forward kinematics are applied for DELTA and SCARA.
// 14197  *
// 14198  * The result is in the current coordinate space with
// 14199  * leveling applied. The coordinates need to be run through
// 14200  * unapply_leveling to obtain machine coordinates suitable
// 14201  * for current_position, etc.
// 14202  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock78 Using cfiCommon0
          CFI Function _Z27get_cartesian_from_steppersv
        THUMB
// 14203 void get_cartesian_from_steppers() {
_Z27get_cartesian_from_steppersv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
        LDR.N    R0,??DataTable168_5
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??get_cartesian_from_steppers_0
// 14204   //#if ENABLED(DELTA)
// 14205   if(MACHINETPYE == DELTA)  {
// 14206     forward_kinematics_DELTA(
// 14207       stepper.get_axis_position_mm(A_AXIS),
// 14208       stepper.get_axis_position_mm(B_AXIS),
// 14209       stepper.get_axis_position_mm(C_AXIS)
// 14210     );
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R4,R0
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R5,R0
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R2,R4
        MOV      R1,R5
          CFI FunCall _Z24forward_kinematics_DELTAfff
        BL       _Z24forward_kinematics_DELTAfff
        POP      {R0-R2,R4,R5,PC}
// 14211   	}
// 14212   //#else
// 14213   else
// 14214   {
// 14215     //#if IS_SCARA
// 14216 	if(MACHINETPYE&IS_SCARA) {
??get_cartesian_from_steppers_0:
        LDR.N    R4,??DataTable168_4
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??get_cartesian_from_steppers_1
// 14217       forward_kinematics_SCARA(
// 14218         stepper.get_axis_position_degrees(A_AXIS),
// 14219         stepper.get_axis_position_degrees(B_AXIS)
// 14220       );
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+0]
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
        B.N      ??get_cartesian_from_steppers_2
// 14221 	}
// 14222     //#else
// 14223     else
// 14224     {
// 14225       cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
??get_cartesian_from_steppers_1:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+72]
// 14226       cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+76]
// 14227     }
// 14228     //#endif
// 14229     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
??get_cartesian_from_steppers_2:
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+80]
// 14230   }
// 14231   //#endif
// 14232 }
        POP      {R0-R2,R4,R5,PC}  ;; return
          CFI EndBlock cfiBlock78
// 14233 
// 14234 /**
// 14235  * Set the current_position for an axis based on
// 14236  * the stepper positions, removing any leveling that
// 14237  * may have been applied.
// 14238  *
// 14239  * To prevent small shifts in axis position always call
// 14240  * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
// 14241  *
// 14242  * To keep hosts in sync, always call report_current_position
// 14243  * after updating the current_position.
// 14244  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function _Z34set_current_from_steppers_for_axis8AxisEnum
        THUMB
// 14245 void set_current_from_steppers_for_axis(const AxisEnum axis) {
_Z34set_current_from_steppers_for_axis8AxisEnum:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 14246   get_cartesian_from_steppers();
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
// 14247   //#if PLANNER_LEVELING
// 14248   if(BED_LEVELING_METHOD&PLANNER_LEVELING)
        LDR.N    R5,??DataTable168_4
        LDR.N    R0,??DataTable168_5
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+46
        TST      R0,R1
        BEQ.N    ??set_current_from_steppers_for_axis_0
// 14249     planner.unapply_leveling(cartes);
        ADD      R0,R5,#+72
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
// 14250   //#endif
// 14251   if (axis == ALL_AXES)
??set_current_from_steppers_for_axis_0:
        LDR.W    R0,??DataTable179
        CMP      R4,#+100
        BNE.N    ??set_current_from_steppers_for_axis_1
// 14252     COPY(current_position, cartes);
        MOVS     R2,#+12
        ADD      R1,R5,#+72
        ADDS     R0,R0,#+8
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall memcpy
        B.W      memcpy
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 14253   else
// 14254     current_position[axis] = cartes[axis];
??set_current_from_steppers_for_axis_1:
        ADD      R1,R5,R4, LSL #+2
        LDR      R1,[R1, #+72]
        ADD      R0,R0,R4, LSL #+2
        STR      R1,[R0, #+8]
// 14255 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock79

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168:
        DC32     parser

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_1:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_2:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_3:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_4:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_5:
        DC32     mksCfg
// 14256 
// 14257 #if 1//IS_CARTESIAN
// 14258 #if 1//ENABLED(SEGMENT_LEVELED_MOVES)
// 14259 
// 14260   /**
// 14261    * Prepare a segmented move on a CARTESIAN setup.
// 14262    *
// 14263    * This calls planner.buffer_line several times, adding
// 14264    * small incremental moves. This allows the planner to
// 14265    * apply more detailed bed leveling to the full move.
// 14266    */
// 14267   inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
// 14268 
// 14269     const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
// 14270                 ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
// 14271 
// 14272     // If the move is only in Z/E don't split up the move
// 14273     if (!xdiff && !ydiff) {
// 14274       planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 14275       return;
// 14276     }
// 14277 
// 14278     // Remaining cartesian distances
// 14279     const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
// 14280                 ediff = destination[E_AXIS] - current_position[E_AXIS];
// 14281 
// 14282     // Get the linear distance in XYZ
// 14283     // If the move is very short, check the E move distance
// 14284     // No E move either? Game over.
// 14285     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 14286     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 14287     if (UNEAR_ZERO(cartesian_mm)) return;
// 14288 
// 14289     // The length divided by the segment size
// 14290     // At least one segment is required
// 14291     uint16_t segments = cartesian_mm / segment_size;
// 14292     NOLESS(segments, 1);
// 14293 
// 14294     // The approximate length of each segment
// 14295     const float inv_segments = 1.0 / float(segments),
// 14296                 segment_distance[XYZE] = {
// 14297                   xdiff * inv_segments,
// 14298                   ydiff * inv_segments,
// 14299                   zdiff * inv_segments,
// 14300                   ediff * inv_segments
// 14301                 };
// 14302 
// 14303     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 14304     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 14305 
// 14306     // Get the raw current position as starting point
// 14307     float raw[XYZE];
// 14308     COPY(raw, current_position);
// 14309 
// 14310     // Calculate and execute the segments
// 14311     while (--segments) {
// 14312       static millis_t next_idle_ms = millis() + 200UL;
// 14313       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 14314       if (ELAPSED(millis(), next_idle_ms)) {
// 14315         next_idle_ms = millis() + 200UL;
// 14316         idle();
// 14317       }
// 14318       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 14319       planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
// 14320     }
// 14321 
// 14322     // Since segment_distance is only approximate,
// 14323     // the final move must be to the exact destination.
// 14324     planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 14325   }
// 14326 #endif
// 14327 //#elif ENABLED(MESH_BED_LEVELING)
// 14328 #if 1
// 14329   /**
// 14330    * Prepare a mesh-leveled linear move in a Cartesian setup,
// 14331    * splitting the move where it crosses mesh borders.
// 14332    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function _Z24mesh_line_to_destinationfhh
        THUMB
// 14333   void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
_Z24mesh_line_to_destinationfhh:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+16
          CFI CFA R13+56
        MOV      R4,R1
        MOV      R5,R2
// 14334     // Get current and destination cells for this line
// 14335     int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
        LDR.W    R6,??DataTable179
        ADD      R0,R6,#+8
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R7,R0
// 14336         cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
        ADD      R0,R6,#+12
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
        MOV      R8,R0
// 14337         cx2 = mbl.cell_index_x(destination[X_AXIS]),
        ADD      R0,R6,#+24
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R9,R0
// 14338         cy2 = mbl.cell_index_y(destination[Y_AXIS]);
        ADD      R0,R6,#+28
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
// 14339     NOMORE(cx1, GRID_MAX_POINTS_X - 2);
        LDR.W    R1,??DataTable179_1
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R7
        BGE.N    ??mesh_line_to_destination_0
        MOV      R7,R2
??mesh_line_to_destination_0:
        ADDS     R1,R1,#+96
        LDRB     R1,[R1, #+1]
        SUBS     R1,R1,#+2
        CMP      R1,R8
        BGE.N    ??mesh_line_to_destination_1
// 14340     NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
        MOV      R8,R1
// 14341     NOMORE(cx2, GRID_MAX_POINTS_X - 2);
??mesh_line_to_destination_1:
        CMP      R2,R9
        BGE.N    ??mesh_line_to_destination_2
        MOV      R9,R2
// 14342     NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
??mesh_line_to_destination_2:
        CMP      R1,R0
        BGE.N    ??mesh_line_to_destination_3
        MOV      R0,R1
// 14343 
// 14344     // Start and end in the same cell? No split needed.
// 14345     if (cx1 == cx2 && cy1 == cy2) {
??mesh_line_to_destination_3:
        CMP      R7,R9
        BNE.N    ??mesh_line_to_destination_4
        CMP      R8,R0
        BEQ.W    ??mesh_line_to_destination_5
// 14346       buffer_line_to_destination(fr_mm_s);
// 14347       set_current_from_destination();
// 14348       return;
// 14349     }
// 14350 
// 14351     #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 14352 
// 14353     float normalized_dist, end[XYZE];
// 14354     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
??mesh_line_to_destination_4:
        MOV      R10,R9
        CMP      R9,R7
        BGE.N    ??mesh_line_to_destination_6
        MOV      R10,R7
??mesh_line_to_destination_6:
        MOV      R11,R0
        CMP      R0,R8
        BGE.N    ??mesh_line_to_destination_7
        MOV      R11,R8
// 14355 
// 14356     // Crosses on the X and not already split on this X?
// 14357     // The x_splits flags are insurance against rounding errors.
// 14358     if (cx2 != cx1 && TEST(x_splits, gcx)) {
??mesh_line_to_destination_7:
        CMP      R9,R7
        BEQ.N    ??mesh_line_to_destination_8
        MOVS     R1,#+1
        LSL      R2,R1,R10
        MOV      R1,R4
        TST      R1,R2
        BEQ.N    ??mesh_line_to_destination_8
// 14359       // Split on the X grid line
// 14360       CBI(x_splits, gcx);
        BICS     R4,R4,R2
// 14361       COPY(end, destination);
        MOVS     R2,#+16
        ADD      R1,R6,#+24
        ADD      R0,SP,#+0
          CFI FunCall memcpy
        BL       memcpy
// 14362       destination[X_AXIS] = mbl.index_to_xpos[gcx];
        SXTB     R10,R10
        LDR.W    R0,??DataTable179_2
        LDR      R0,[R0, R10, LSL #+2]
        STR      R0,[R6, #+24]
// 14363       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        LDR      R7,[R6, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
// 14364       destination[Y_AXIS] = MBL_SEGMENT_END(Y);
        LDR      R8,[R6, #+12]
        LDR      R0,[R6, #+28]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+28]
// 14365     }
// 14366     // Crosses on the Y and not already split on this Y?
// 14367     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 14368       // Split on the Y grid line
// 14369       CBI(y_splits, gcy);
// 14370       COPY(end, destination);
// 14371       destination[Y_AXIS] = mbl.index_to_ypos[gcy];
// 14372       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 14373       destination[X_AXIS] = MBL_SEGMENT_END(X);
// 14374     }
// 14375     else {
// 14376       // Must already have been split on these border(s)
// 14377       buffer_line_to_destination(fr_mm_s);
// 14378       set_current_from_destination();
// 14379       return;
// 14380     }
// 14381 
// 14382     destination[Z_AXIS] = MBL_SEGMENT_END(Z);
??mesh_line_to_destination_9:
        LDR      R8,[R6, #+16]
        LDR      R0,[R6, #+32]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+32]
// 14383     destination[E_AXIS] = MBL_SEGMENT_END(E);
        LDR      R8,[R6, #+20]
        LDR      R0,[R6, #+36]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+36]
// 14384 
// 14385     // Do the split and look for more borders
// 14386     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R5
        MOV      R1,R4
        LDR      R0,[SP, #+16]
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 14387 
// 14388     // Restore destination from stack
// 14389     COPY(destination, end);
        MOVS     R2,#+16
        ADD      R1,SP,#+0
        ADD      R0,R6,#+24
          CFI FunCall memcpy
        BL       memcpy
// 14390     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R5
        MOV      R1,R4
        LDR      R0,[SP, #+16]
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 14391   }
??mesh_line_to_destination_10:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+56
??mesh_line_to_destination_8:
        CMP      R0,R8
        BEQ.N    ??mesh_line_to_destination_5
        MOVS     R1,#+1
        LSL      R0,R1,R11
        MOV      R1,R5
        TST      R1,R0
        BEQ.N    ??mesh_line_to_destination_5
        BICS     R5,R5,R0
        MOVS     R2,#+16
        ADD      R1,R6,#+24
        ADD      R0,SP,#+0
          CFI FunCall memcpy
        BL       memcpy
        SXTB     R11,R11
        LDR.W    R0,??DataTable184
        LDR      R0,[R0, R11, LSL #+2]
        STR      R0,[R6, #+28]
        LDR      R7,[R6, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
        LDR      R8,[R6, #+8]
        LDR      R0,[R6, #+24]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+24]
        B.N      ??mesh_line_to_destination_9
??mesh_line_to_destination_5:
        LDR      R0,[SP, #+16]
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
        B.N      ??mesh_line_to_destination_10
          CFI EndBlock cfiBlock80
// 14392 #endif
// 14393 //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 14394 #if 1
// 14395   #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
// 14396 
// 14397   /**
// 14398    * Prepare a bilinear-leveled linear move on Cartesian,
// 14399    * splitting the move where it crosses grid borders.
// 14400    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function _Z28bilinear_line_to_destinationftt
        THUMB
// 14401   void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
_Z28bilinear_line_to_destinationftt:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+28
          CFI CFA R13+64
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
// 14402     // Get current and destination cells for this line
// 14403     int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
        LDR.W    R8,??DataTable180
        LDR      R0,[R8, #+24]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R11,R0
        LDR.W    R7,??DataTable179
        LDR      R0,[R7, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+32]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R9,R0
        LDR      R0,[R8, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+36]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R10,R0
// 14404         cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
// 14405         cx2 = CELL_INDEX(X, destination[X_AXIS]),
        LDR      R0,[R7, #+24]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+32]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R11,R0
// 14406         cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
        LDR      R0,[R8, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+36]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
// 14407     cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
        LDR.W    R1,??DataTable179_1
        CMP      R9,#+0
        BPL.N    ??bilinear_line_to_destination_0
        MOV      R9,#+0
        B.N      ??bilinear_line_to_destination_1
??bilinear_line_to_destination_0:
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R9
        BGE.N    ??bilinear_line_to_destination_1
        MOV      R9,R2
// 14408     cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_1:
        CMP      R10,#+0
        BPL.N    ??bilinear_line_to_destination_2
        MOV      R10,#+0
        B.N      ??bilinear_line_to_destination_3
??bilinear_line_to_destination_2:
        ADD      R2,R1,#+96
        LDRB     R2,[R2, #+1]
        SUBS     R2,R2,#+2
        CMP      R2,R10
        BGE.N    ??bilinear_line_to_destination_3
        MOV      R10,R2
// 14409     cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
??bilinear_line_to_destination_3:
        CMP      R11,#+0
        BPL.N    ??bilinear_line_to_destination_4
        MOV      R11,#+0
        B.N      ??bilinear_line_to_destination_5
??bilinear_line_to_destination_4:
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R11
        BGE.N    ??bilinear_line_to_destination_5
        MOV      R11,R2
// 14410     cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_5:
        CMP      R0,#+0
        BPL.N    ??bilinear_line_to_destination_6
        MOVS     R0,#+0
        B.N      ??bilinear_line_to_destination_7
??bilinear_line_to_destination_6:
        ADD      R2,R1,#+96
        LDRB     R1,[R2, #+1]
        SUBS     R2,R1,#+2
        CMP      R2,R0
        BGE.N    ??bilinear_line_to_destination_7
        MOV      R0,R2
// 14411 
// 14412     // Start and end in the same cell? No split needed.
// 14413     if (cx1 == cx2 && cy1 == cy2) {
??bilinear_line_to_destination_7:
        CMP      R9,R11
        BNE.N    ??bilinear_line_to_destination_8
        CMP      R10,R0
        BEQ.W    ??bilinear_line_to_destination_9
// 14414       buffer_line_to_destination(fr_mm_s);
// 14415       set_current_from_destination();
// 14416       return;
// 14417     }
// 14418 
// 14419     #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 14420 
// 14421     float normalized_dist, end[XYZE];
// 14422     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
??bilinear_line_to_destination_8:
        MOV      R1,R11
        CMP      R11,R9
        BGE.N    ??bilinear_line_to_destination_10
        MOV      R1,R9
??bilinear_line_to_destination_10:
        STR      R1,[SP, #+4]
        MOV      R1,R0
        CMP      R0,R10
        BGE.N    ??bilinear_line_to_destination_11
        MOV      R1,R10
??bilinear_line_to_destination_11:
        STR      R1,[SP, #+0]
// 14423 
// 14424     // Crosses on the X and not already split on this X?
// 14425     // The x_splits flags are insurance against rounding errors.
// 14426     if (cx2 != cx1 && TEST(x_splits, gcx)) {
        CMP      R11,R9
        BEQ.N    ??bilinear_line_to_destination_12
        MOVS     R1,#+1
        LDR      R2,[SP, #+4]
        LSL      R2,R1,R2
        MOV      R1,R5
        TST      R1,R2
        BEQ.N    ??bilinear_line_to_destination_12
// 14427       // Split on the X grid line
// 14428       CBI(x_splits, gcx);
        BICS     R5,R5,R2
// 14429       COPY(end, destination);
        MOVS     R2,#+16
        ADD      R1,R7,#+24
        ADD      R0,SP,#+8
          CFI FunCall memcpy
        BL       memcpy
// 14430       destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
        LDR      R0,[R8, #+24]
        LDR      R1,[R8, #+16]
        ADD      R2,SP,#+4
        LDRSB    R2,[R2, #+0]
        MLA      R0,R2,R1,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R7, #+24]
// 14431       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        LDR      R8,[R7, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 14432       destination[Y_AXIS] = LINE_SEGMENT_END(Y);
        LDR      R9,[R7, #+12]
        LDR      R0,[R7, #+28]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+28]
// 14433     }
// 14434     // Crosses on the Y and not already split on this Y?
// 14435     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 14436       // Split on the Y grid line
// 14437       CBI(y_splits, gcy);
// 14438       COPY(end, destination);
// 14439       destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
// 14440       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 14441       destination[X_AXIS] = LINE_SEGMENT_END(X);
// 14442     }
// 14443     else {
// 14444       // Must already have been split on these border(s)
// 14445       buffer_line_to_destination(fr_mm_s);
// 14446       set_current_from_destination();
// 14447       return;
// 14448     }
// 14449 
// 14450     destination[Z_AXIS] = LINE_SEGMENT_END(Z);
??bilinear_line_to_destination_13:
        LDR      R9,[R7, #+16]
        LDR      R0,[R7, #+32]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+32]
// 14451     destination[E_AXIS] = LINE_SEGMENT_END(E);
        LDR      R9,[R7, #+20]
        LDR      R0,[R7, #+36]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+36]
// 14452 
// 14453     // Do the split and look for more borders
// 14454     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 14455 
// 14456     // Restore destination from stack
// 14457     COPY(destination, end);
        MOVS     R2,#+16
        ADD      R1,SP,#+8
        ADD      R0,R7,#+24
          CFI FunCall memcpy
        BL       memcpy
// 14458     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 14459   }
??bilinear_line_to_destination_14:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+64
??bilinear_line_to_destination_12:
        CMP      R0,R10
        BEQ.N    ??bilinear_line_to_destination_9
        MOVS     R1,#+1
        LDR      R0,[SP, #+0]
        LSL      R0,R1,R0
        MOV      R1,R6
        TST      R1,R0
        BEQ.N    ??bilinear_line_to_destination_9
        BICS     R6,R6,R0
        MOVS     R2,#+16
        ADD      R1,R7,#+24
        ADD      R0,SP,#+8
          CFI FunCall memcpy
        BL       memcpy
        LDR      R0,[R8, #+28]
        LDR      R1,[R8, #+20]
        ADD      R2,SP,#+0
        LDRSB    R2,[R2, #+0]
        MLA      R0,R2,R1,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R7, #+28]
        LDR      R8,[R7, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR      R9,[R7, #+8]
        LDR      R0,[R7, #+24]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+24]
        B.N      ??bilinear_line_to_destination_13
??bilinear_line_to_destination_9:
        MOV      R0,R4
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
        B.N      ??bilinear_line_to_destination_14
          CFI EndBlock cfiBlock81

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_1:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_2:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_3:
        DC32     0x43520000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_4:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_5:
        DC32     0x43a50000
// 14460 
// 14461 #endif // AUTO_BED_LEVELING_BILINEAR
// 14462 #endif // IS_CARTESIAN
// 14463 
// 14464 #if 1//!UBL_SEGMENTED
// 14465 #if 1//IS_KINEMATIC
// 14466 
// 14467   /**
// 14468    * Prepare a linear move in a DELTA or SCARA setup.
// 14469    *
// 14470    * This calls planner.buffer_line several times, adding
// 14471    * small incremental moves for DELTA or SCARA.
// 14472    *
// 14473    * For Unified Bed Leveling (Delta or Segmented Cartesian)
// 14474    * the ubl.prepare_segmented_line_to method replaces this.
// 14475    */
// 14476   inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
// 14477 
// 14478     // Get the top feedrate of the move in the XY plane
// 14479     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
// 14480 
// 14481     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
// 14482                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
// 14483 
// 14484     // If the move is only in Z/E don't split up the move
// 14485     if (!xdiff && !ydiff) {
// 14486       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 14487       return false; // caller will update current_position
// 14488     }
// 14489 
// 14490     // Fail if attempting move outside printable radius
// 14491     if(MACHINETPYE & IS_KINEMATIC)
// 14492     {
// 14493         if (!position_is_reachable_IS_KINEMATIC(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 14494     }
// 14495     else
// 14496     {
// 14497         if (!position_is_reachable_IS_CARTESIAN(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 14498     }
// 14499     // Remaining cartesian distances
// 14500     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
// 14501                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
// 14502 
// 14503     // Get the linear distance in XYZ
// 14504     // If the move is very short, check the E move distance
// 14505     // No E move either? Game over.
// 14506     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 14507     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 14508     if (UNEAR_ZERO(cartesian_mm)) return true;
// 14509 
// 14510     // Minimum number of seconds to move the given distance
// 14511     const float seconds = cartesian_mm / _feedrate_mm_s;
// 14512 
// 14513     // The number of segments-per-second times the duration
// 14514     // gives the number of segments
// 14515     uint16_t segments = delta_segments_per_second * seconds;
// 14516 
// 14517     // For SCARA minimum segment size is 0.25mm
// 14518     //#if IS_SCARA
// 14519 	if(MACHINETPYE&IS_SCARA)
// 14520       NOMORE(segments, cartesian_mm * 4);
// 14521     //#endif
// 14522 
// 14523     // At least one segment is required
// 14524     NOLESS(segments, 1);
// 14525 
// 14526     // The approximate length of each segment
// 14527     const float inv_segments = 1.0 / float(segments),
// 14528                 segment_distance[XYZE] = {
// 14529                   xdiff * inv_segments,
// 14530                   ydiff * inv_segments,
// 14531                   zdiff * inv_segments,
// 14532                   ediff * inv_segments
// 14533                 };
// 14534 
// 14535     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 14536     // SERIAL_ECHOPAIR(" seconds=", seconds);
// 14537     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 14538 
// 14539     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14540       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 14541       // i.e., Complete the angular vector in the given time.
// 14542       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
// 14543                   inverse_secs = inv_segment_length * _feedrate_mm_s;
// 14544       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 14545             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 14546     #endif
// 14547 
// 14548     // Get the current position as starting point
// 14549     float raw[XYZE];
// 14550     COPY(raw, current_position);
// 14551 
// 14552 
// 14553     // Calculate and execute the segments
// 14554     while (--segments) {
// 14555 
// 14556       static millis_t next_idle_ms = millis() + 200UL;
// 14557       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 14558       if (ELAPSED(millis(), next_idle_ms)) {
// 14559         next_idle_ms = millis() + 200UL;
// 14560         idle();
// 14561       }
// 14562 
// 14563       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 14564       //#if ENABLED(DELTA)
// 14565       if(MACHINETPYE&DELTA)
// 14566         DELTA_IK(raw); // Delta can inline its kinematics
// 14567       //#else
// 14568       else
// 14569         inverse_kinematics(raw);
// 14570       //#endif
// 14571 
// 14572       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
// 14573 
// 14574       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14575         // For SCARA scale the feed rate from mm/s to degrees/s
// 14576         // i.e., Complete the angular vector in the given time.
// 14577         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14578         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14579       #else
// 14580           if (gCfgItems.breakpoint_reprint_flg == 1) 
// 14581           {
// 14582               if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
// 14583               {
// 14584                   //current_position[Z_AXIS] = rtarget[Z_AXIS];
// 14585                   //current_position[E_AXIS] = destination[E_AXIS];
// 14586 
// 14587                   gCfgItems.had_breakpoint=1;
// 14588                   gCfgItems.breakpoint_e_position=LROUND(raw[E_AXIS] * planner.axis_steps_per_mm[E_AXIS]);
// 14589                                     
// 14590                   return false;
// 14591               }
// 14592           }
// 14593         //gCfgItems.breakpoint_reprint_flg = 0;
// 14594         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
// 14595       #endif
// 14596     }
// 14597 
// 14598     // Ensure last segment arrives at target location.
// 14599     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14600       inverse_kinematics(rtarget);
// 14601       ADJUST_DELTA(rtarget);
// 14602       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14603     #else
// 14604       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 14605     #endif
// 14606 
// 14607     return false; // caller will update current_position
// 14608   }
// 14609 #endif
// 14610 //#else // !IS_KINEMATIC
// 14611 #if 1
// 14612   /**
// 14613    * Prepare a linear move in a Cartesian setup.
// 14614    *
// 14615    * When a mesh-based leveling system is active, moves are segmented
// 14616    * according to the configuration of the leveling system.
// 14617    *
// 14618    * Returns true if current_position[] was set to destination[]
// 14619    */
// 14620   inline bool prepare_move_to_destination_cartesian() {
// 14621     #if 1//HAS_MESH
// 14622       if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
// 14623         //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 14624         if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 14625         {
// 14626           ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
// 14627           return true;     
// 14628 		 }// all moves, including Z-only moves.
// 14629         //#elif ENABLED(SEGMENT_LEVELED_MOVES)
// 14630 		//{
// 14631         //  segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14632         //  return false; // caller will update current_position
// 14633 		//}
// 14634         //#else
// 14635         else
// 14636         {
// 14637           #if ENABLED(SEGMENT_LEVELED_MOVES)
// 14638             segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14639             return false; // caller will update current_position
// 14640           #else
// 14641           /**
// 14642            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
// 14643            * Otherwise fall through to do a direct single move.
// 14644            */
// 14645           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
// 14646             //#if ENABLED(MESH_BED_LEVELING)
// 14647             if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 14648               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14649             //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 14650             else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 14651               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14652             //#endif
// 14653             return true;
// 14654           }
// 14655           #endif
// 14656         }
// 14657         //#endif
// 14658       }
// 14659     #endif // HAS_MESH
// 14660 
// 14661     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14662     return false; // caller will update current_position
// 14663   }
// 14664 
// 14665 #endif // !IS_KINEMATIC
// 14666 #endif // !UBL_SEGMENTED
// 14667 
// 14668 #if ENABLED(DUAL_X_CARRIAGE)
// 14669 
// 14670   /**
// 14671    * Unpark the carriage, if needed
// 14672    */
// 14673   inline bool dual_x_carriage_unpark() {
// 14674     if (active_extruder_parked)
// 14675       switch (dual_x_carriage_mode) {
// 14676 
// 14677         case DXC_FULL_CONTROL_MODE: break;
// 14678 
// 14679         case DXC_AUTO_PARK_MODE:
// 14680           if (current_position[E_AXIS] == destination[E_AXIS]) {
// 14681             // This is a travel move (with no extrusion)
// 14682             // Skip it, but keep track of the current position
// 14683             // (so it can be used as the start of the next non-travel move)
// 14684             if (delayed_move_time != 0xFFFFFFFFUL) {
// 14685               set_current_from_destination();
// 14686               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
// 14687               delayed_move_time = millis();
// 14688               return true;
// 14689             }
// 14690           }
// 14691           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
// 14692           for (uint8_t i = 0; i < 3; i++)
// 14693             planner.buffer_line(
// 14694               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
// 14695               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
// 14696               i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
// 14697               current_position[E_AXIS],
// 14698               i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
// 14699               active_extruder
// 14700             );
// 14701           delayed_move_time = 0;
// 14702           active_extruder_parked = false;
// 14703           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14704             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
// 14705           #endif
// 14706           break;
// 14707 
// 14708         case DXC_DUPLICATION_MODE:
// 14709           if (active_extruder == 0) {
// 14710             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14711               if (DEBUGGING(LEVELING)) {
// 14712                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
// 14713                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
// 14714               }
// 14715             #endif
// 14716             // move duplicate extruder into correct duplication position.
// 14717             planner.set_position_mm(
// 14718               inactive_extruder_x_pos,
// 14719               current_position[Y_AXIS],
// 14720               current_position[Z_AXIS],
// 14721               current_position[E_AXIS]
// 14722             );
// 14723             planner.buffer_line(
// 14724               current_position[X_AXIS] + duplicate_extruder_x_offset,
// 14725               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
// 14726               planner.max_feedrate_mm_s[X_AXIS], 1
// 14727             );
// 14728             SYNC_PLAN_POSITION_KINEMATIC();
// 14729             stepper.synchronize();
// 14730             extruder_duplication_enabled = true;
// 14731             active_extruder_parked = false;
// 14732             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14733               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
// 14734             #endif
// 14735           }
// 14736           else {
// 14737             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14738               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
// 14739             #endif
// 14740           }
// 14741           break;
// 14742       }
// 14743     return false;
// 14744   }
// 14745 
// 14746 #endif // DUAL_X_CARRIAGE
// 14747 
// 14748 /**
// 14749  * Prepare a single move and get ready for the next one
// 14750  *
// 14751  * This may result in several calls to planner.buffer_line to
// 14752  * do smaller moves for DELTA, SCARA, mesh moves, etc.
// 14753  *
// 14754  * Make sure current_position[E] and destination[E] are good
// 14755  * before calling or cold/lengthy extrusion may get missed.
// 14756  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function _Z27prepare_move_to_destinationv
        THUMB
// 14757 void prepare_move_to_destination() {
_Z27prepare_move_to_destinationv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 14758   clamp_to_software_endstops(destination);
        LDR.W    R4,??DataTable179
        ADD      R0,R4,#+24
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14759   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 14760 
// 14761   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 14762 
// 14763     if (!DEBUGGING(DRYRUN)) {
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.N    ??prepare_move_to_destination_0
// 14764       if (destination[E_AXIS] != current_position[E_AXIS]) {
        LDR      R5,[R4, #+36]
        MOV      R0,R5
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_0
// 14765         #if ENABLED(PREVENT_COLD_EXTRUSION)
// 14766           if (thermalManager.tooColdToExtrude(active_extruder)) {
        LDRB     R0,[R4, #+3]
          CFI FunCall _ZN11Temperature16tooColdToExtrudeEh
        BL       _ZN11Temperature16tooColdToExtrudeEh
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_1
// 14767             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        STR      R5,[R4, #+20]
// 14768             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable187
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14769             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
        ADR.W    R0,`?<Constant " cold extrusion preve...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14770           }
// 14771         #endif // PREVENT_COLD_EXTRUSION
// 14772         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 14773           if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
??prepare_move_to_destination_1:
        LDR      R0,[R4, #+36]
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R1,R0,#0x80000000
        LDRB     R0,[R4, #+3]
        LDR.W    R2,??DataTable187_1
        LDR      R0,[R2, R0, LSL #+2]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.W    R1,??DataTable187_2  ;; 0x447a0001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??prepare_move_to_destination_0
// 14774             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        LDR      R0,[R4, #+36]
        STR      R0,[R4, #+20]
// 14775             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable187
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14776             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        ADR.W    R0,`?<Constant " too long extrusion p...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14777           }
// 14778         #endif // PREVENT_LENGTHY_EXTRUDE
// 14779       }
// 14780     }
// 14781 
// 14782   #endif
// 14783 
// 14784   #if ENABLED(DUAL_X_CARRIAGE)
// 14785     if (dual_x_carriage_unpark()) return;
// 14786   #endif
// 14787   
// 14788 #if 0
// 14789   if (
// 14790     #if UBL_SEGMENTED
// 14791       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
// 14792     #elif IS_KINEMATIC
// 14793       prepare_kinematic_move_to(destination)
// 14794     #else
// 14795       prepare_move_to_destination_cartesian()
// 14796     #endif
// 14797   ) return;
// 14798 #endif
// 14799 
// 14800   if((BED_LEVELING_METHOD &AUTO_BED_LEVELING_UBL) && (MACHINETPYE == DELTA /*|| ENABLED(SEGMENT_LEVELED_MOVES)*/))
??prepare_move_to_destination_0:
        LDR.W    R0,??DataTable179_1
        ADD      R1,R0,#+64
        LDRSH    R1,[R1, #+24]
        LDRB     R0,[R0, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??prepare_move_to_destination_2
        CMP      R1,#+2
        BNE.N    ??prepare_move_to_destination_2
// 14801   {
// 14802     if(ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s)))return;
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable187_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable188  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R4,#+24
          CFI FunCall _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        BL       _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_3
        POP      {R0,R4,R5,PC}
// 14803   } 
// 14804   else if(MACHINETPYE & IS_KINEMATIC)
??prepare_move_to_destination_2:
        MOVW     R0,#+770
        TST      R1,R0
        BEQ.N    ??prepare_move_to_destination_4
// 14805   {
// 14806     if(prepare_kinematic_move_to(destination))return;
        ADD      R0,R4,#+24
          CFI FunCall _Z25prepare_kinematic_move_toRA4_Kf
        BL       _Z25prepare_kinematic_move_toRA4_Kf
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_3
        POP      {R0,R4,R5,PC}
// 14807   }  
// 14808   else//if(MACHINETPYE & IS_CARTESIAN)
// 14809   {
// 14810     if(prepare_move_to_destination_cartesian())return;
??prepare_move_to_destination_4:
          CFI FunCall _Z37prepare_move_to_destination_cartesianv
        BL       _Z37prepare_move_to_destination_cartesianv
        CMP      R0,#+0
        BNE.N    ??prepare_move_to_destination_5
// 14811   }
// 14812 
// 14813   set_current_from_destination();
??prepare_move_to_destination_3:
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 14814 }
??prepare_move_to_destination_5:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock82

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171:
        DC32     0x42b40000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " cold extrusion preve...">`:
        DC8 " cold extrusion prevented\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " too long extrusion p...">`:
        DC8 " too long extrusion prevented\012"
        DC8 0
// 14815 
// 14816 #if ENABLED(ARC_SUPPORT)
// 14817 
// 14818   #if N_ARC_CORRECTION < 1
// 14819     #undef N_ARC_CORRECTION
// 14820     #define N_ARC_CORRECTION 1
// 14821   #endif
// 14822 
// 14823   /**
// 14824    * Plan an arc in 2 dimensions
// 14825    *
// 14826    * The arc is approximated by generating many small linear segments.
// 14827    * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
// 14828    * Arcs should only be made relatively large (over 5mm), as larger arcs with
// 14829    * larger segments will tend to be more efficient. Your slicer should have
// 14830    * options for G2/G3 arc generation. In future these options may be GCode tunable.
// 14831    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function _Z8plan_arcRA4_KfRA2_S_b
        THUMB
// 14832   void plan_arc(
// 14833     const float (&cart)[XYZE], // Destination position
// 14834     const float (&offset)[2], // Center of rotation relative to current_position
// 14835     const bool clockwise      // Clockwise?
// 14836   ) {
_Z8plan_arcRA4_KfRA2_S_b:
        PUSH     {R0,R1,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        SUB      SP,SP,#+52
          CFI CFA R13+96
        MOV      R4,R2
// 14837     #if ENABLED(CNC_WORKSPACE_PLANES)
// 14838       AxisEnum p_axis, q_axis, l_axis;
// 14839       switch (workspace_plane) {
// 14840         default:
// 14841         case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
// 14842         case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
// 14843         case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
// 14844       }
// 14845     #else
// 14846       constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
// 14847     #endif
// 14848 
// 14849     // Radius vector from center to current location
// 14850     float r_P = -offset[0], r_Q = -offset[1];
        MOV      R0,R1
        LDR      R5,[R0, #+0]
        EOR      R5,R5,#0x80000000
        LDR      R6,[R0, #+4]
        EOR      R6,R6,#0x80000000
// 14851 
// 14852     const float radius = HYPOT(r_P, r_Q),
        MOV      R9,R5
        MOV      R10,#+2
        MOV      R7,#+1065353216
        MOV      R8,R7
        B.N      ??plan_arc_0
??plan_arc_1:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??plan_arc_0:
        LSLS     R0,R10,#+31
        BPL.N    ??plan_arc_2
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_2:
        LSRS     R10,R10,#+1
        BNE.N    ??plan_arc_1
        MOV      R11,R6
        MOV      R9,#+2
        MOV      R10,R7
        B.N      ??plan_arc_3
??plan_arc_4:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??plan_arc_3:
        LSLS     R0,R9,#+31
        BPL.N    ??plan_arc_5
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_5:
        LSRS     R9,R9,#+1
        BNE.N    ??plan_arc_4
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
        LDR.W    R0,??DataTable179
        LDR      R0,[R0, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 14853                 center_P = current_position[p_axis] - r_P,
// 14854                 center_Q = current_position[q_axis] - r_Q,
        LDR.W    R0,??DataTable179
        LDR      R0,[R0, #+12]
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+20]
// 14855                 rt_X = cart[p_axis] - center_P,
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+0]
        LDR      R1,[SP, #+24]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 14856                 rt_Y = cart[q_axis] - center_Q,
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+4]
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
// 14857                 linear_travel = cart[l_axis] - current_position[l_axis],
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+8]
        LDR.W    R1,??DataTable179
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
// 14858                 extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+12]
        LDR.W    R1,??DataTable179
        LDR      R1,[R1, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
// 14859 
// 14860     // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
// 14861     float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
        MOV      R0,R5
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        MOV      R0,R6
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R11,R1
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R0,R6
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R11
          CFI FunCall atan2f
        BL       atan2f
        MOV      R9,R0
// 14862     if (angular_travel < 0) angular_travel += RADIANS(360);
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??plan_arc_6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable188_1  ;; 0x54442d18
        LDR.W    R3,??DataTable188_2  ;; 0x401921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 14863     if (clockwise) angular_travel -= RADIANS(360);
??plan_arc_6:
        CMP      R4,#+0
        BEQ.N    ??plan_arc_7
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable188_1  ;; 0x54442d18
        LDR.W    R3,??DataTable188_3  ;; 0xc01921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 14864 
// 14865     // Make a circle if the angular rotation is 0 and the target is current position
// 14866     if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
??plan_arc_7:
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        LDR.W    R0,??DataTable179
        LDR      R0,[R0, #+8]
        LDR      R1,[SP, #+52]
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        LDR.W    R0,??DataTable179
        LDR      R0,[R0, #+12]
        LDR      R1,[SP, #+52]
        LDR      R1,[R1, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
// 14867       angular_travel = RADIANS(360);
        LDR.W    R9,??DataTable188_4  ;; 0x40c90fdb
// 14868 
// 14869     const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
??plan_arc_8:
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        MOV      R10,#+2
        MOV      R4,R7
        B.N      ??plan_arc_9
??plan_arc_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_9:
        LSLS     R0,R10,#+31
        BPL.N    ??plan_arc_11
        MOV      R0,R4
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??plan_arc_11:
        LSRS     R10,R10,#+1
        BNE.N    ??plan_arc_10
        LDR      R0,[SP, #+0]
        BIC      R11,R0,#0x80000000
        MOV      R8,#+2
        MOV      R10,R7
        B.N      ??plan_arc_12
??plan_arc_13:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??plan_arc_12:
        LSLS     R0,R8,#+31
        BPL.N    ??plan_arc_14
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_14:
        LSRS     R8,R8,#+1
        BNE.N    ??plan_arc_13
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
// 14870     if (mm_of_travel < 0.001) return;
        LDR.W    R1,??DataTable189  ;; 0x3a83126f
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.W    ??plan_arc_15
// 14871 
// 14872     uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
          CFI FunCall floorf
        BL       floorf
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        UXTH     R0,R0
        STR      R0,[SP, #+12]
// 14873     NOLESS(segments, 1);
        CMP      R0,#+0
        BNE.N    ??plan_arc_16
        MOVS     R0,#+1
        STR      R0,[SP, #+12]
// 14874 
// 14875     /**
// 14876      * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
// 14877      * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
// 14878      *     r_T = [cos(phi) -sin(phi);
// 14879      *            sin(phi)  cos(phi)] * r ;
// 14880      *
// 14881      * For arc generation, the center of the circle is the axis of rotation and the radius vector is
// 14882      * defined from the circle center to the initial position. Each line segment is formed by successive
// 14883      * vector rotations. This requires only two cos() and sin() computations to form the rotation
// 14884      * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
// 14885      * all double numbers are single precision on the Arduino. (True double precision will not have
// 14886      * round off issues for CNC applications.) Single precision error can accumulate to be greater than
// 14887      * tool precision in some cases. Therefore, arc path correction is implemented.
// 14888      *
// 14889      * Small angle approximation may be used to reduce computation overhead further. This approximation
// 14890      * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
// 14891      * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
// 14892      * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
// 14893      * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
// 14894      * issue for CNC machines with the single precision Arduino calculations.
// 14895      *
// 14896      * This approximation also allows plan_arc to immediately insert a line segment into the planner
// 14897      * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
// 14898      * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
// 14899      * This is important when there are successive arc motions.
// 14900      */
// 14901     // Vector rotation matrix values
// 14902     float raw[XYZE];
// 14903     const float theta_per_segment = angular_travel / segments,
??plan_arc_16:
        ADD      R0,SP,#+12
        LDRH     R0,[R0, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R4,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+8]
// 14904                 linear_per_segment = linear_travel / segments,
        LDR      R0,[SP, #+0]
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+32]
// 14905                 extruder_per_segment = extruder_travel / segments,
        LDR      R0,[SP, #+4]
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+28]
// 14906                 sin_T = theta_per_segment,
// 14907                 cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
        LDR      R4,[SP, #+8]
        MOV      R8,#+2
        B.N      ??plan_arc_17
??plan_arc_18:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??plan_arc_17:
        LSLS     R0,R8,#+31
        BPL.N    ??plan_arc_19
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??plan_arc_19:
        LSRS     R8,R8,#+1
        BNE.N    ??plan_arc_18
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable190  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable190_1  ;; 0x3ff00000
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+4]
// 14908 
// 14909     // Initialize the linear axis
// 14910     raw[l_axis] = current_position[l_axis];
        ADD      R4,SP,#+36
        LDR.W    R0,??DataTable179
        LDR      R0,[R0, #+16]
        STR      R0,[R4, #+8]
// 14911 
// 14912     // Initialize the extruder axis
// 14913     raw[E_AXIS] = current_position[E_AXIS];
        LDR.W    R0,??DataTable179
        LDR      R0,[R0, #+20]
        STR      R0,[R4, #+12]
// 14914 
// 14915     const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
        LDR.W    R0,??DataTable179
        LDRSH    R0,[R0, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable179
        LDR      R1,[R1, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable187_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable188  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+16]
// 14916 
// 14917     millis_t next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R7,R0,#+200
// 14918 
// 14919     #if N_ARC_CORRECTION > 1
// 14920       int8_t arc_recalc_count = N_ARC_CORRECTION;
        MOV      R9,#+25
// 14921     #endif
// 14922 
// 14923     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14924       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 14925       const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
// 14926                   inverse_secs = inv_segment_length * fr_mm_s;
// 14927       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 14928             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 14929     #endif
// 14930 
// 14931     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
        MOV      R8,#+1
        B.N      ??plan_arc_20
// 14932 
// 14933       thermalManager.manage_heater();
// 14934       if (ELAPSED(millis(), next_idle_ms)) {
// 14935         next_idle_ms = millis() + 200UL;
// 14936         idle();
// 14937       }
// 14938 
// 14939       #if N_ARC_CORRECTION > 1
// 14940         if (--arc_recalc_count) {
// 14941           // Apply vector rotation matrix to previous r_P / 1
// 14942           const float r_new_Y = r_P * sin_T + r_Q * cos_T;
// 14943           r_P = r_P * cos_T - r_Q * sin_T;
// 14944           r_Q = r_new_Y;
// 14945         }
// 14946         else
// 14947       #endif
// 14948       {
// 14949         #if N_ARC_CORRECTION > 1
// 14950           arc_recalc_count = N_ARC_CORRECTION;
??plan_arc_21:
        MOV      R9,#+25
// 14951         #endif
// 14952 
// 14953         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
// 14954         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
// 14955         // To reduce stuttering, the sin and cos could be computed at different times.
// 14956         // For now, compute both at the same time.
// 14957         const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
        MOV      R0,R8
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
          CFI FunCall cosf
        BL       cosf
        MOV      R6,R0
        MOV      R0,R5
          CFI FunCall sinf
        BL       sinf
        MOV      R10,R0
// 14958         r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
        LDR      R0,[SP, #+56]
        LDR      R0,[R0, #+4]
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+56]
        LDR      R11,[R0, #+0]
        LDR      R0,[SP, #+0]
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        MOV      R0,R11
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 14959         r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        EOR      R0,R0,#0x80000000
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 14960       }
// 14961 
// 14962       // Update raw location
// 14963       raw[p_axis] = center_P + r_P;
??plan_arc_22:
        LDR      R0,[SP, #+24]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+36]
// 14964       raw[q_axis] = center_Q + r_Q;
        LDR      R0,[SP, #+20]
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+4]
// 14965       raw[l_axis] += linear_per_segment;
        LDR      R0,[R4, #+8]
        LDR      R1,[SP, #+32]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+8]
// 14966       raw[E_AXIS] += extruder_per_segment;
        LDR      R0,[R4, #+12]
        LDR      R1,[SP, #+28]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+12]
// 14967 
// 14968       clamp_to_software_endstops(raw);
        ADD      R0,SP,#+36
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14969 
// 14970       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14971         // For SCARA scale the feed rate from mm/s to degrees/s
// 14972         // i.e., Complete the angular vector in the given time.
// 14973         inverse_kinematics(raw);
// 14974         ADJUST_DELTA(raw);
// 14975         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14976         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14977       #else
// 14978         planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
        LDR.W    R0,??DataTable179
        LDRB     R2,[R0, #+3]
        ADD      R1,SP,#+16
        ADD      R0,SP,#+36
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        ADD      R8,R8,#+1
        UXTH     R8,R8
??plan_arc_20:
        LDR      R0,[SP, #+12]
        CMP      R8,R0
        BGE.N    ??plan_arc_23
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R7
        BMI.N    ??plan_arc_24
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R7,R0,#+200
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??plan_arc_24:
        SUB      R9,R9,#+1
        SXTB     R9,R9
        CMP      R9,#+0
        BEQ.N    ??plan_arc_21
        LDR      R0,[SP, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R10,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R6,R10
        B.N      ??plan_arc_22
// 14979       #endif
// 14980     }
// 14981 
// 14982     // Ensure last segment arrives at target location.
// 14983     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14984       inverse_kinematics(cart);
// 14985       ADJUST_DELTA(cart);
// 14986       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14987     #else
// 14988       planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
??plan_arc_23:
        LDR.W    R0,??DataTable179
        LDRB     R2,[R0, #+3]
        ADD      R1,SP,#+16
        LDR      R0,[SP, #+52]
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 14989     #endif
// 14990 
// 14991     // As far as the parser is concerned, the position is now == target. In reality the
// 14992     // motion control system might still be processing the action and the real tool position
// 14993     // in any intermediate location.
// 14994     set_current_from_destination();
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 14995   } // plan_arc
??plan_arc_15:
        ADD      SP,SP,#+60
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock83
// 14996 
// 14997 #endif // ARC_SUPPORT
// 14998 
// 14999 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 15000 
// 15001   void plan_cubic_move(const float (&offset)[4]) {
// 15002     cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
// 15003 
// 15004     // As far as the parser is concerned, the position is now == destination. In reality the
// 15005     // motion control system might still be processing the action and the real tool position
// 15006     // in any intermediate location.
// 15007     set_current_from_destination();
// 15008   }
// 15009 
// 15010 #endif // BEZIER_CURVE_SUPPORT
// 15011 
// 15012 #if ENABLED(USE_CONTROLLER_FAN)
// 15013 
// 15014   void controllerFan() {
// 15015     static millis_t lastMotorOn = 0, // Last time a motor was turned on
// 15016                     nextMotorCheck = 0; // Last time the state was checked
// 15017     const millis_t ms = millis();
// 15018     if (ELAPSED(ms, nextMotorCheck)) {
// 15019       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
// 15020       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
// 15021           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
// 15022           #if E_STEPPERS > 1
// 15023             || E1_ENABLE_READ == E_ENABLE_ON
// 15024             #if HAS_X2_ENABLE
// 15025               || X2_ENABLE_READ == X_ENABLE_ON
// 15026             #endif
// 15027             #if E_STEPPERS > 2
// 15028               || E2_ENABLE_READ == E_ENABLE_ON
// 15029               #if E_STEPPERS > 3
// 15030                 || E3_ENABLE_READ == E_ENABLE_ON
// 15031                 #if E_STEPPERS > 4
// 15032                   || E4_ENABLE_READ == E_ENABLE_ON
// 15033                 #endif // E_STEPPERS > 4
// 15034               #endif // E_STEPPERS > 3
// 15035             #endif // E_STEPPERS > 2
// 15036           #endif // E_STEPPERS > 1
// 15037       ) {
// 15038         lastMotorOn = ms; //... set time to NOW so the fan will turn on
// 15039       }
// 15040 
// 15041       // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
// 15042       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
// 15043 
// 15044       // allows digital or PWM fan output to be used (see M42 handling)
// 15045       WRITE(CONTROLLER_FAN_PIN, speed);
// 15046       analogWrite(CONTROLLER_FAN_PIN, speed);
// 15047     }
// 15048   }
// 15049 
// 15050 #endif // USE_CONTROLLER_FAN
// 15051 
// 15052 #if 1//ENABLED(MORGAN_SCARA)
// 15053 
// 15054   /**
// 15055    * Morgan SCARA Forward Kinematics. Results in cartes[].
// 15056    * Maths and first version by QHARLEY.
// 15057    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 15058    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function _Z24forward_kinematics_SCARARKfS0_
        THUMB
// 15059   void forward_kinematics_SCARA(const float &a, const float &b) {
_Z24forward_kinematics_SCARARKfS0_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R8,R0
        MOV      R10,R1
// 15060 
// 15061     float a_sin = sin(RADIANS(a)) * L1,
        MOVS     R6,#+0
        LDR.W    R7,??DataTable190_3  ;; 0x4062c000
        LDR.W    R4,??DataTable188_1  ;; 0x54442d18
        LDR.W    R5,??DataTable190_4  ;; 0x400921fb
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable190_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 15062           a_cos = cos(RADIANS(a)) * L1,
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable190_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R8,R0
// 15063           b_sin = sin(RADIANS(b)) * L2,
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable190_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R11,R0
// 15064           b_cos = cos(RADIANS(b)) * L2;
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable190_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
// 15065 
// 15066     cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
        LDR.W    R4,??DataTable190_6
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable190_7  ;; 0x42c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+72]
// 15067     cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable191  ;; 0xc2600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+76]
// 15068 
// 15069     /*
// 15070       SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
// 15071       SERIAL_ECHOPAIR(" b=", b);
// 15072       SERIAL_ECHOPAIR(" a_sin=", a_sin);
// 15073       SERIAL_ECHOPAIR(" a_cos=", a_cos);
// 15074       SERIAL_ECHOPAIR(" b_sin=", b_sin);
// 15075       SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
// 15076       SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
// 15077       SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
// 15078     //
// 15079     */
// 15080   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock84
// 15081 
// 15082   /**
// 15083    * Morgan SCARA Inverse Kinematics. Results in delta[].
// 15084    *
// 15085    * See http://forums.reprap.org/read.php?185,283327
// 15086    *
// 15087    * Maths and first version by QHARLEY.
// 15088    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 15089    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function _Z31inverse_kinematics_MORGAN_SCARAPKf
        THUMB
// 15090   void inverse_kinematics_MORGAN_SCARA(const float raw[XYZ]) {
_Z31inverse_kinematics_MORGAN_SCARAPKf:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
// 15091 
// 15092     static float C2, S2, SK1, SK2, THETA, PSI;
// 15093 
// 15094     float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable190_8  ;; 0xc2c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
// 15095           sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
        LDR      R0,[SP, #+0]
        LDR      R1,[R0, #+4]
        LDR.W    R0,??DataTable190_9  ;; 0x42600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
// 15096 
// 15097     if (L1 == L2)
// 15098       C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
        MOV      R7,R5
        MOV      R8,#+2
        MOV      R11,#+1065353216
        MOV      R4,R11
        B.N      ??inverse_kinematics_MORGAN_SCARA_0
??inverse_kinematics_MORGAN_SCARA_1:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??inverse_kinematics_MORGAN_SCARA_0:
        LSLS     R0,R8,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_2
        MOV      R0,R4
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??inverse_kinematics_MORGAN_SCARA_2:
        LSRS     R8,R8,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_1
        MOV      R7,R6
        MOV      R9,#+2
        MOV      R8,R11
        B.N      ??inverse_kinematics_MORGAN_SCARA_3
??inverse_kinematics_MORGAN_SCARA_4:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??inverse_kinematics_MORGAN_SCARA_3:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_5
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_MORGAN_SCARA_5:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_4
        LDR.N    R7,??DataTable179
        MOV      R0,R4
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[R7, #+128]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R1,??DataTable190_10  ;; 0xbf800000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR.W    R4,??DataTable190_11
        STR      R8,[R4, #+0]
// 15099     else
// 15100       C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
// 15101 
// 15102     S2 = SQRT(1 - sq(C2));
        MOV      R9,R8
        MOV      R10,#+2
        B.N      ??inverse_kinematics_MORGAN_SCARA_6
??inverse_kinematics_MORGAN_SCARA_7:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_MORGAN_SCARA_6:
        LSLS     R0,R10,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_8
        MOV      R0,R11
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_MORGAN_SCARA_8:
        LSRS     R10,R10,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_7
        MOV      R0,#+1065353216
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R9,R0
        STR      R9,[R4, #+4]
// 15103 
// 15104     // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
// 15105     SK1 = L1 + L2 * C2;
        LDR.W    R10,??DataTable191_1  ;; 0x43160000
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R11,R0
        STR      R11,[R4, #+8]
// 15106 
// 15107     // Rotated Arm2 gives the distance from Arm1 to Arm2
// 15108     SK2 = L2 * S2;
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+12]
// 15109 
// 15110     // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
// 15111     THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
        MOV      R1,R0
        MOV      R0,R11
          CFI FunCall atan2f
        BL       atan2f
        MOV      R10,R0
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall atan2f
        BL       atan2f
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+16]
// 15112 
// 15113     // Angle of Arm2
// 15114     PSI = ATAN2(S2, C2);
        MOV      R1,R8
        MOV      R0,R9
          CFI FunCall atan2f
        BL       atan2f
        MOV      R6,R0
        STR      R6,[R4, #+20]
// 15115 
// 15116     delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
        LDR      R8,[R4, #+16]
        MOVS     R4,#+0
        LDR.W    R5,??DataTable190_5  ;; 0x40668000
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable188_1  ;; 0x54442d18
        LDR.W    R3,??DataTable190_4  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+80]
// 15117     delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
        MOV      R0,R8
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable188_1  ;; 0x54442d18
        LDR.W    R3,??DataTable190_4  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+84]
// 15118     delta[C_AXIS] = raw[Z_AXIS];
        LDR      R0,[SP, #+0]
        LDR      R0,[R0, #+8]
        STR      R0,[R7, #+88]
// 15119 
// 15120     /*
// 15121       DEBUG_POS("SCARA IK", raw);
// 15122       DEBUG_POS("SCARA IK", delta);
// 15123       SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
// 15124       SERIAL_ECHOPAIR(",", sy);
// 15125       SERIAL_ECHOPAIR(" C2=", C2);
// 15126       SERIAL_ECHOPAIR(" S2=", S2);
// 15127       SERIAL_ECHOPAIR(" Theta=", THETA);
// 15128       SERIAL_ECHOLNPAIR(" Phi=", PHI);
// 15129     //
// 15130     */
// 15131   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock85
// 15132 
// 15133 #endif // MORGAN_SCARA
// 15134 
// 15135 #if ENABLED(TEMP_STAT_LEDS)
// 15136 
// 15137   static bool red_led = false;
// 15138   static millis_t next_status_led_update_ms = 0;
// 15139 
// 15140   void handle_status_leds(void) {
// 15141     if (ELAPSED(millis(), next_status_led_update_ms)) {
// 15142       next_status_led_update_ms += 500; // Update every 0.5s
// 15143       float max_temp = 0.0;
// 15144       //#if HAS_TEMP_BED
// 15145       if(HAS_TEMP_BED)
// 15146         max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
// 15147       //#endif
// 15148       HOTEND_LOOP()
// 15149         max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
// 15150       const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
// 15151       if (new_led != red_led) {
// 15152         red_led = new_led;
// 15153         #if PIN_EXISTS(STAT_LED_RED)
// 15154           WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
// 15155           #if PIN_EXISTS(STAT_LED_BLUE)
// 15156             WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
// 15157           #endif
// 15158         #else
// 15159           WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
// 15160         #endif
// 15161       }
// 15162     }
// 15163   }
// 15164 
// 15165 #endif
// 15166 
// 15167 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15168 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock86 Using cfiCommon0
          CFI Function _Z22handle_filament_runoutv
        THUMB
// 15169   void handle_filament_runout() {
_Z22handle_filament_runoutv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15170     if (!filament_ran_out) {
        LDR.W    R0,??DataTable192
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BNE.N    ??handle_filament_runout_0
// 15171       filament_ran_out = true;
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
// 15172       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
        ADR.W    R0,`?<Constant "M600">`
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        BL       _Z27enqueue_and_echo_commands_PPKc
// 15173       stepper.synchronize();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        B.W      _ZN7Stepper11synchronizeEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15174     }
// 15175   }
??handle_filament_runout_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock86

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M600">`:
        DC8 "M600"
        DC8 0, 0, 0
// 15176 
// 15177 #endif // FILAMENT_RUNOUT_SENSOR
// 15178 
// 15179 #if ENABLED(FAST_PWM_FAN)
// 15180 
// 15181   void setPwmFrequency(uint8_t pin, int val) {
// 15182     val &= 0x07;
// 15183     switch (digitalPinToTimer(pin)) {
// 15184       #ifdef TCCR0A
// 15185         #if !AVR_AT90USB1286_FAMILY
// 15186           case TIMER0A:
// 15187         #endif
// 15188         case TIMER0B:                           //_SET_CS(0, val);
// 15189                                                   break;
// 15190       #endif
// 15191       #ifdef TCCR1A
// 15192         case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
// 15193                                                   break;
// 15194       #endif
// 15195       #if defined(TCCR2) || defined(TCCR2A)
// 15196         #ifdef TCCR2
// 15197           case TIMER2:
// 15198         #endif
// 15199         #ifdef TCCR2A
// 15200           case TIMER2A: case TIMER2B:
// 15201         #endif
// 15202                                                   _SET_CS(2, val); break;
// 15203       #endif
// 15204       #ifdef TCCR3A
// 15205         case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
// 15206       #endif
// 15207       #ifdef TCCR4A
// 15208         case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
// 15209       #endif
// 15210       #ifdef TCCR5A
// 15211         case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
// 15212       #endif
// 15213     }
// 15214   }
// 15215 
// 15216 #endif // FAST_PWM_FAN
// 15217 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function _Z19enable_all_steppersv
        THUMB
// 15218 void enable_all_steppers() {
_Z19enable_all_steppersv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15219   enable_X();
        LDR.W    R4,??DataTable191_2
        LDR.W    R5,??DataTable191_3
        LDR.W    R6,??DataTable192_1
        LDRSB    R2,[R6, #+260]
        LDRH     R1,[R5, #+4]
        LDR      R0,[R4, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15220   enable_Y();
        ADD      R6,R6,#+260
        LDRSB    R2,[R6, #+1]
        LDRH     R1,[R5, #+14]
        LDR      R0,[R4, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15221   enable_Z();
        LDRSB    R2,[R6, #+2]
        LDRH     R1,[R5, #+24]
        LDR      R0,[R4, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRSB    R2,[R6, #+2]
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15222   enable_E0();
        LDRSB    R2,[R6, #+3]
        LDRH     R1,[R5, #+34]
        LDR      R0,[R4, #+68]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15223   enable_E1();
        LDRSB    R2,[R6, #+3]
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI EndBlock cfiBlock87
// 15224   enable_E2();
// 15225   enable_E3();
// 15226   enable_E4();
// 15227 }
// 15228 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function _Z18disable_e_steppersv
        THUMB
// 15229 void disable_e_steppers() {
_Z18disable_e_steppersv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 15230   disable_E0();
        LDR.N    R4,??DataTable179_1
        ADDW     R5,R4,#+257
        LDRB     R0,[R5, #+6]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.W    R6,??DataTable191_2
        LDR.W    R7,??DataTable191_3
        SXTB     R2,R2
        LDRH     R1,[R7, #+34]
        LDR      R0,[R6, #+68]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15231   if(!Z_DUAL_STEPPER_DRIVERS)disable_E1();
        LDRB     R0,[R4, #+257]
        CMP      R0,#+0
        BNE.N    ??disable_e_steppers_0
        LDRB     R0,[R5, #+6]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R7, #+40]
        LDR      R0,[R6, #+80]
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
// 15232   disable_E2();
// 15233   disable_E3();
// 15234   disable_E4();
// 15235 }
??disable_e_steppers_0:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock88
// 15236 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function _Z20disable_all_steppersv
        THUMB
// 15237 void disable_all_steppers() {
_Z20disable_all_steppersv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 15238   disable_X();
        LDR.N    R7,??DataTable179_1
        LDRB     R0,[R7, #+260]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.W    R4,??DataTable191_2
        LDR.W    R5,??DataTable191_3
        SXTB     R2,R2
        LDRH     R1,[R5, #+4]
        LDR      R0,[R4, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.W    R6,??DataTable190_6
        MOVS     R0,#+0
        STRB     R0,[R6, #+4]
// 15239   disable_Y();
        ADD      R7,R7,#+260
        LDRB     R0,[R7, #+1]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R5, #+14]
        LDR      R0,[R4, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+5]
// 15240   disable_Z();
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R5, #+24]
        LDR      R0,[R4, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+6]
// 15241   disable_e_steppers();
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.N      _Z18disable_e_steppersv
          CFI EndBlock cfiBlock89
// 15242 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function _Z20disable_noZ_steppersv
        THUMB
// 15243 void disable_noZ_steppers() {
_Z20disable_noZ_steppersv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 15244   disable_X();
        LDR.N    R4,??DataTable179_1
        LDRB     R0,[R4, #+260]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.W    R5,??DataTable191_2
        LDR.W    R6,??DataTable191_3
        SXTB     R2,R2
        LDRH     R1,[R6, #+4]
        LDR      R0,[R5, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.W    R7,??DataTable190_6
        MOVS     R0,#+0
        STRB     R0,[R7, #+4]
// 15245   disable_Y();
        LDRB     R0,[R4, #+261]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+14]
        LDR      R0,[R5, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R7, #+5]
// 15246   //disable_Z();
// 15247   disable_e_steppers();
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.N      _Z18disable_e_steppersv
          CFI EndBlock cfiBlock90
// 15248 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable179:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable179_1:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable179_2:
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
// 15249 
// 15250 #if ENABLED(MONITOR_DRIVER_STATUS)
// 15251   /*
// 15252    * Check for over temperature or short to ground error flags.
// 15253    * Report and log warning of overtemperature condition.
// 15254    * Reduce driver current in a persistent otpw condition.
// 15255    * Keep track of otpw counter so we don't reduce current on a single instance,
// 15256    * and so we don't repeatedly report warning before the condition is cleared.
// 15257    */
// 15258 
// 15259   struct TMC_driver_data {
// 15260     uint32_t drv_status;
// 15261     bool is_otpw;
// 15262     bool is_ot;
// 15263     bool is_error;
// 15264   };
// 15265   #if ENABLED(HAVE_TMC2130)
// 15266     static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
// 15267     static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
// 15268     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
// 15269       constexpr uint32_t OTPW_bm = 0x4000000UL;
// 15270       constexpr uint8_t OTPW_bp = 26;
// 15271       constexpr uint32_t OT_bm = 0x2000000UL;
// 15272       constexpr uint8_t OT_bp = 25;
// 15273       constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
// 15274       constexpr uint8_t DRIVER_ERROR_bp = 1;
// 15275       TMC_driver_data data;
// 15276       data.drv_status = st.DRV_STATUS();
// 15277       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 15278       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 15279       data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
// 15280       return data;
// 15281     }
// 15282   #endif
// 15283   #if ENABLED(HAVE_TMC2208)
// 15284     static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
// 15285     static uint8_t get_status_response(TMC2208Stepper &st) {
// 15286       uint32_t drv_status = st.DRV_STATUS();
// 15287       uint8_t gstat = st.GSTAT();
// 15288       uint8_t response = 0;
// 15289       response |= (drv_status >> (31-3)) & 0b1000;
// 15290       response |= gstat & 0b11;
// 15291       return response;
// 15292     }
// 15293     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
// 15294       constexpr uint32_t OTPW_bm = 0b1ul;
// 15295       constexpr uint8_t OTPW_bp = 0;
// 15296       constexpr uint32_t OT_bm = 0b10ul;
// 15297       constexpr uint8_t OT_bp = 1;
// 15298       TMC_driver_data data;
// 15299       data.drv_status = st.DRV_STATUS();
// 15300       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 15301       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 15302       data.is_error = st.drv_err();
// 15303       return data;
// 15304     }
// 15305   #endif
// 15306 
// 15307   template<typename TMC>
// 15308   uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
// 15309     TMC_driver_data data = get_driver_data(st);
// 15310 
// 15311     #if ENABLED(STOP_ON_ERROR)
// 15312       if (data.is_error) {
// 15313         SERIAL_EOL();
// 15314         SERIAL_ECHO(axisID);
// 15315         SERIAL_ECHO(" driver error detected:");
// 15316         if (data.is_ot) SERIAL_ECHO("\novertemperature");
// 15317         if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
// 15318         if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
// 15319         SERIAL_EOL();
// 15320         #if ENABLED(TMC_DEBUG)
// 15321           gcode_M122();
// 15322         #endif
// 15323         kill(PSTR("Driver error"));
// 15324       }
// 15325     #endif
// 15326 
// 15327     // Report if a warning was triggered
// 15328     if (data.is_otpw && otpw_cnt==0) {
// 15329       char timestamp[10];
// 15330       duration_t elapsed = print_job_timer.duration();
// 15331       const bool has_days = (elapsed.value > 60*60*24L);
// 15332       (void)elapsed.toDigital(timestamp, has_days);
// 15333       SERIAL_EOL();
// 15334       SERIAL_ECHO(timestamp);
// 15335       SERIAL_ECHOPGM(": ");
// 15336       SERIAL_ECHO(axisID);
// 15337       SERIAL_ECHOPGM(" driver overtemperature warning! (");
// 15338       SERIAL_ECHO(st.getCurrent());
// 15339       SERIAL_ECHOLN("mA)");
// 15340     }
// 15341     #if CURRENT_STEP_DOWN > 0
// 15342       // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
// 15343       if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
// 15344         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
// 15345         #if ENABLED(REPORT_CURRENT_CHANGE)
// 15346           SERIAL_ECHO(axisID);
// 15347           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
// 15348         #endif
// 15349       }
// 15350     #endif
// 15351 
// 15352     if (data.is_otpw) {
// 15353       otpw_cnt++;
// 15354       st.flag_otpw = true;
// 15355     }
// 15356     else if (otpw_cnt>0) otpw_cnt--;
// 15357 
// 15358     if (report_tmc_status) {
// 15359       const uint32_t pwm_scale = get_pwm_scale(st);
// 15360       SERIAL_ECHO(axisID);
// 15361       SERIAL_ECHOPAIR(":", pwm_scale);
// 15362       SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
// 15363       SERIAL_ECHO("| ");
// 15364       if (data.is_error) SERIAL_ECHO('E');
// 15365       else if (data.is_ot) SERIAL_ECHO('O');
// 15366       else if (data.is_otpw) SERIAL_ECHO('W');
// 15367       else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
// 15368       else if (st.flag_otpw) SERIAL_ECHO('F');
// 15369       SERIAL_ECHO("\t");
// 15370     }
// 15371 
// 15372     return otpw_cnt;
// 15373   }
// 15374 
// 15375   void monitor_tmc_driver() {
// 15376     static millis_t next_cOT = 0;
// 15377     if (ELAPSED(millis(), next_cOT)) {
// 15378       next_cOT = millis() + 500;
// 15379       #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15380         static uint8_t x_otpw_cnt = 0;
// 15381         x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
// 15382       #endif
// 15383       #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15384         static uint8_t y_otpw_cnt = 0;
// 15385         y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
// 15386       #endif
// 15387       #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15388         static uint8_t z_otpw_cnt = 0;
// 15389         z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
// 15390       #endif
// 15391       #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
// 15392         static uint8_t x2_otpw_cnt = 0;
// 15393         x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
// 15394       #endif
// 15395       #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
// 15396         static uint8_t y2_otpw_cnt = 0;
// 15397         y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
// 15398       #endif
// 15399       #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
// 15400         static uint8_t z2_otpw_cnt = 0;
// 15401         z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
// 15402       #endif
// 15403       #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15404         static uint8_t e0_otpw_cnt = 0;
// 15405         e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
// 15406       #endif
// 15407       #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
// 15408         static uint8_t e1_otpw_cnt = 0;
// 15409         e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
// 15410       #endif
// 15411       #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
// 15412         static uint8_t e2_otpw_cnt = 0;
// 15413         e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
// 15414       #endif
// 15415       #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
// 15416         static uint8_t e3_otpw_cnt = 0;
// 15417         e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
// 15418       #endif
// 15419       #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
// 15420         static uint8_t e4_otpw_cnt = 0;
// 15421         e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
// 15422       #endif
// 15423 
// 15424       if (report_tmc_status) SERIAL_EOL();
// 15425     }
// 15426   }
// 15427 
// 15428 #endif // MONITOR_DRIVER_STATUS
// 15429 
// 15430 /**
// 15431  * Manage several activities:
// 15432  *  - Check for Filament Runout
// 15433  *  - Keep the command buffer full
// 15434  *  - Check for maximum inactive time between commands
// 15435  *  - Check for maximum inactive time between stepper commands
// 15436  *  - Check if pin CHDK needs to go LOW
// 15437  *  - Check for KILL button held down
// 15438  *  - Check for HOME button held down
// 15439  *  - Check if cooling fan needs to be switched on
// 15440  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
// 15441  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function _Z17manage_inactivityb
        THUMB
// 15442 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
_Z17manage_inactivityb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
// 15443 
// 15444   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15445     if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
        LDR.W    R0,??DataTable192_2
        LDRB     R1,[R0, #+1888]
        CMP      R1,#+0
        BNE.N    ??manage_inactivity_0
        ADDW     R0,R0,#+2792
          CFI FunCall _ZN9Stopwatch9isRunningEv
        BL       _ZN9Stopwatch9isRunningEv
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_1
??manage_inactivity_0:
        LDR.W    R0,??DataTable191_3
        LDRH     R1,[R0, #+54]
        LDR.W    R0,??DataTable191_2
        LDR      R0,[R0, #+108]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDR.W    R1,??DataTable192_1
        LDRB     R1,[R1, #+208]
        CMP      R0,R1
        BNE.N    ??manage_inactivity_1
// 15446       handle_filament_runout();
          CFI FunCall _Z22handle_filament_runoutv
        BL       _Z22handle_filament_runoutv
// 15447   #endif
// 15448 
// 15449   if (commands_in_queue < BUFSIZE) get_available_commands();
??manage_inactivity_1:
        LDR.W    R0,??DataTable192_3
        LDRB     R0,[R0, #+2]
        CMP      R0,#+4
        BGE.N    ??manage_inactivity_2
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 15450 
// 15451   const millis_t ms = millis();
??manage_inactivity_2:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
// 15452 
// 15453   if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
        LDR.W    R4,??DataTable190_6
        LDR      R0,[R4, #+96]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_3
        LDR      R1,[R4, #+92]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_3
// 15454     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable192_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15455     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
        LDR.W    R0,??DataTable192_5
        LDR      R1,[R0, #+0]
        ADR.W    R0,`?<Constant "KILL caused by too mu...">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.W    R0,??DataTable192_6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15456     kill(PSTR(MSG_KILLED));
        ADR.W    R0,`?<Constant "KILLED. ">`
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
// 15457   }
// 15458 
// 15459   // Prevent steppers timing-out in the middle of M600
// 15460   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
// 15461     #define MOVE_AWAY_TEST !move_away_flag
// 15462   #else
// 15463     #define MOVE_AWAY_TEST true
// 15464   #endif
// 15465 
// 15466   if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
// 15467       && !ignore_stepper_queue && !planner.blocks_queued()) {
??manage_inactivity_3:
        LDR      R0,[R4, #+100]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_4
        LDR      R1,[R4, #+92]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_4
        CMP      R5,#+0
        BNE.N    ??manage_inactivity_4
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_4
// 15468     #if ENABLED(DISABLE_INACTIVE_X)
// 15469       disable_X();
        LDR.W    R7,??DataTable192_1
        LDRB     R0,[R7, #+260]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.W    R5,??DataTable191_2
        LDR.W    R6,??DataTable191_3
        SXTB     R2,R2
        LDRH     R1,[R6, #+4]
        LDR      R0,[R5, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
// 15470     #endif
// 15471     #if ENABLED(DISABLE_INACTIVE_Y)
// 15472       disable_Y();
        ADD      R7,R7,#+260
        LDRB     R0,[R7, #+1]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+14]
        LDR      R0,[R5, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
// 15473     #endif
// 15474     #if ENABLED(DISABLE_INACTIVE_Z)
// 15475       disable_Z();
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+24]
        LDR      R0,[R5, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+40]
        LDR      R0,[R5, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 15476     #endif
// 15477     #if ENABLED(DISABLE_INACTIVE_E)
// 15478       disable_e_steppers();
          CFI FunCall _Z18disable_e_steppersv
        BL       _Z18disable_e_steppersv
// 15479     #endif
// 15480     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 15481       ubl.lcd_map_control = defer_return_to_status = false;
// 15482     #endif
// 15483   }
// 15484 
// 15485   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
// 15486     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
// 15487       chdkActive = false;
// 15488       WRITE(CHDK, LOW);
// 15489     }
// 15490   #endif
// 15491 
// 15492   #if HAS_KILL
// 15493 
// 15494     // Check if the kill button was pressed and wait just in case it was an accidental
// 15495     // key kill key press
// 15496     // -------------------------------------------------------------------------------
// 15497     static int killCount = 0;   // make the inactivity button a bit less responsive
// 15498     const int KILL_DELAY = 750;
// 15499     if (!READ(KILL_PIN))
// 15500       killCount++;
// 15501     else if (killCount > 0)
// 15502       killCount--;
// 15503 
// 15504     // Exceeded threshold and we can confirm that it was not accidental
// 15505     // KILL the machine
// 15506     // ----------------------------------------------------------------
// 15507     if (killCount >= KILL_DELAY) {
// 15508       SERIAL_ERROR_START();
// 15509       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
// 15510       kill(PSTR(MSG_KILLED));
// 15511     }
// 15512   #endif
// 15513 
// 15514   #if HAS_HOME
// 15515     // Check to see if we have to home, use poor man's debouncer
// 15516     // ---------------------------------------------------------
// 15517     static int homeDebounceCount = 0;   // poor man's debouncing count
// 15518     const int HOME_DEBOUNCE_DELAY = 2500;
// 15519     if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
// 15520       if (!homeDebounceCount) {
// 15521         enqueue_and_echo_commands_P(PSTR("G28"));
// 15522         LCD_MESSAGEPGM(MSG_AUTO_HOME);
// 15523       }
// 15524       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
// 15525         homeDebounceCount++;
// 15526       else
// 15527         homeDebounceCount = 0;
// 15528     }
// 15529   #endif
// 15530 
// 15531   #if ENABLED(USE_CONTROLLER_FAN)
// 15532     controllerFan(); // Check if fan should be turned on to cool stepper drivers down
// 15533   #endif
// 15534 
// 15535   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
// 15536     if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
// 15537       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
// 15538       #if ENABLED(SWITCHING_EXTRUDER)
// 15539         const bool oldstatus = E0_ENABLE_READ;
// 15540         enable_E0();
// 15541       #else // !SWITCHING_EXTRUDER
// 15542         bool oldstatus;
// 15543         switch (active_extruder) {
// 15544           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
// 15545           #if E_STEPPERS > 1
// 15546             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
// 15547             #if E_STEPPERS > 2
// 15548               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
// 15549               #if E_STEPPERS > 3
// 15550                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
// 15551                 #if E_STEPPERS > 4
// 15552                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
// 15553                 #endif // E_STEPPERS > 4
// 15554               #endif // E_STEPPERS > 3
// 15555             #endif // E_STEPPERS > 2
// 15556           #endif // E_STEPPERS > 1
// 15557         }
// 15558       #endif // !SWITCHING_EXTRUDER
// 15559 
// 15560       previous_cmd_ms = ms; // refresh_cmd_timeout()
// 15561 
// 15562       const float olde = current_position[E_AXIS];
// 15563       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
// 15564       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
// 15565       current_position[E_AXIS] = olde;
// 15566       planner.set_e_position_mm(olde);
// 15567       stepper.synchronize();
// 15568       #if ENABLED(SWITCHING_EXTRUDER)
// 15569         E0_ENABLE_WRITE(oldstatus);
// 15570       #else
// 15571         switch (active_extruder) {
// 15572           case 0: E0_ENABLE_WRITE(oldstatus); break;
// 15573           #if E_STEPPERS > 1
// 15574             case 1: E1_ENABLE_WRITE(oldstatus); break;
// 15575             #if E_STEPPERS > 2
// 15576               case 2: E2_ENABLE_WRITE(oldstatus); break;
// 15577               #if E_STEPPERS > 3
// 15578                 case 3: E3_ENABLE_WRITE(oldstatus); break;
// 15579                 #if E_STEPPERS > 4
// 15580                   case 4: E4_ENABLE_WRITE(oldstatus); break;
// 15581                 #endif // E_STEPPERS > 4
// 15582               #endif // E_STEPPERS > 3
// 15583             #endif // E_STEPPERS > 2
// 15584           #endif // E_STEPPERS > 1
// 15585         }
// 15586       #endif // !SWITCHING_EXTRUDER
// 15587     }
// 15588   #endif // EXTRUDER_RUNOUT_PREVENT
// 15589 
// 15590   #if ENABLED(DUAL_X_CARRIAGE)
// 15591     // handle delayed move timeout
// 15592     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
// 15593       // travel moves have been received so enact them
// 15594       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
// 15595       set_destination_from_current();
// 15596       prepare_move_to_destination();
// 15597     }
// 15598   #endif
// 15599 
// 15600   #if ENABLED(TEMP_STAT_LEDS)
// 15601     handle_status_leds();
// 15602   #endif
// 15603 
// 15604   #if ENABLED(MONITOR_DRIVER_STATUS)
// 15605     monitor_tmc_driver();
// 15606   #endif
// 15607 
// 15608   planner.check_axes_activity();
??manage_inactivity_4:
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19check_axes_activityEv
        B.W      _ZN7Planner19check_axes_activityEv
          CFI EndBlock cfiBlock91
// 15609 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable180:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILL caused by too mu...">`:
        DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
        DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
        DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
        DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
        DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
        DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
        DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
        DC8 20H, 0
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILLED. ">`:
        DC8 "KILLED. "
        DC8 0, 0, 0
// 15610 
// 15611 /**
// 15612  * Standard idle routine keeps the machine alive
// 15613  */
// 15614 //extern uint8_t display_hold;
// 15615 //extern uint32_t display_hold_cnt;
// 15616 //extern uint8_t display_hold_release;
// 15617 
// 15618 uint8_t display_hold=0;
// 15619 uint32_t display_hold_cnt=0;
// 15620 uint8_t display_hold_release=0;
// 15621 uint8_t button_disp_pause_state=0;
// 15622 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock92 Using cfiCommon0
          CFI Function _Z10lcd_reInitv
        THUMB
// 15623 void lcd_reInit()
// 15624 {
_Z10lcd_reInitv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15625    GUI_Init();
          CFI FunCall GUI_Init
        BL       GUI_Init
// 15626    GUI_UC_SetEncodeUTF8();
          CFI FunCall GUI_UC_SetEncodeUTF8
        BL       GUI_UC_SetEncodeUTF8
// 15627    gui_view_init(); 
          CFI FunCall gui_view_init
        BL       gui_view_init
// 15628    clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 15629    disp_state_stack._disp_index += 1;
        LDR.W    R0,??DataTable192_7
        LDRB     R1,[R0, #+100]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+100]
// 15630    if(mksReprint.mks_printer_state == MKS_REPRINTED)
        LDR.W    R4,??DataTable192_8
        LDR.W    R0,??DataTable192_2
        LDRB     R0,[R0, #+2076]
        CMP      R0,#+172
        BNE.N    ??lcd_reInit_0
// 15631    {
// 15632    	button_disp_pause_state=1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
// 15633    }
// 15634    draw_return_ui();
??lcd_reInit_0:
          CFI FunCall draw_return_ui
        BL       draw_return_ui
// 15635    button_disp_pause_state=0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
// 15636    Lcd_Light_ON;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable192_9  ;; 0x422281b4
        STR      R0,[R1, #+0]
// 15637 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock92
// 15638 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function _Z4idlev
        THUMB
// 15639 void idle(
// 15640   #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 15641     bool no_stepper_sleep/*=false*/
// 15642   #endif
// 15643 ) {
_Z4idlev:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15644   #if ENABLED(MAX7219_DEBUG)
// 15645     Max7219_idle_tasks();
// 15646   #endif  // MAX7219_DEBUG
// 15647 
// 15648    if(gCfgItems.standby_mode==1)
        LDR.W    R0,??DataTable193
        LDRB     R1,[R0, #+674]
        CMP      R1,#+1
        BNE.N    ??idle_0
// 15649     {
// 15650         if(display_hold_cnt>=gCfgItems.standby_time)
        LDR.W    R1,??DataTable193_1
        LDR      R2,[R1, #+56]
        LDR      R3,[R0, #+676]
        CMP      R2,R3
        BCC.N    ??idle_1
// 15651         {
// 15652             display_hold_cnt -= gCfgItems.standby_time;
        LDR      R0,[R0, #+676]
        SUBS     R0,R2,R0
        STR      R0,[R1, #+56]
// 15653             display_hold=1;
        MOVS     R0,#+1
        STRB     R0,[R1, #+11]
// 15654             Lcd_Light_OFF;
        MOVS     R0,#+0
        LDR.W    R2,??DataTable192_9  ;; 0x422281b4
        STR      R0,[R2, #+0]
// 15655         }
// 15656         if(display_hold_release==1)
??idle_1:
        LDRB     R0,[R1, #+12]
        CMP      R0,#+1
        BNE.N    ??idle_0
// 15657         {
// 15658             display_hold=0;
        MOVS     R0,#+0
        STRB     R0,[R1, #+11]
// 15659             display_hold_release=0;
        STRB     R0,[R1, #+12]
// 15660             lcd_reInit();
          CFI FunCall _Z10lcd_reInitv
        BL       _Z10lcd_reInitv
// 15661         }
// 15662     }
// 15663 
// 15664   lcd_update();
??idle_0:
          CFI FunCall _Z10lcd_updatev
        BL       _Z10lcd_updatev
// 15665 
// 15666   host_keepalive();
          CFI FunCall _Z14host_keepalivev
        BL       _Z14host_keepalivev
// 15667 
// 15668   //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 15669    #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)	
// 15670     thermalManager.auto_report_temperatures();
          CFI FunCall _ZN11Temperature24auto_report_temperaturesEv
        BL       _ZN11Temperature24auto_report_temperaturesEv
// 15671   #endif
// 15672 
// 15673   manage_inactivity(
// 15674     #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 15675       no_stepper_sleep
// 15676     #endif
// 15677   );
        MOVS     R0,#+0
          CFI FunCall _Z17manage_inactivityb
        BL       _Z17manage_inactivityb
// 15678 
// 15679   thermalManager.manage_heater();
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
// 15680 
// 15681   #if ENABLED(PRINTCOUNTER)
// 15682     print_job_timer.tick();
// 15683   #endif
// 15684 
// 15685   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
// 15686     buzzer.tick();
// 15687   #endif
// 15688   #if 1
// 15689   display_temper_error();
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
// 15690   
// 15691   wifi_looping();
          CFI FunCall _Z12wifi_loopingv
        BL       _Z12wifi_loopingv
// 15692   
// 15693   if(wifi_link_state != WIFI_TRANS_FILE)
        LDR.W    R0,??DataTable192_10
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+16
        BEQ.N    ??idle_2
// 15694   {
// 15695 	  GUI_RefreshPage();
          CFI FunCall GUI_RefreshPage
        BL       GUI_RefreshPage
// 15696   }
// 15697   #if defined(TFT70)
// 15698   disp_pre_gcode(3,40);
// 15699   #elif defined(TFT35)
// 15700   //#if defined(MKS_ROBIN2)
// 15701   if(preview_no_display != 1)
??idle_2:
        LDR.W    R0,??DataTable193_1
        LDRB     R0,[R0, #+5]
        CMP      R0,#+1
        BEQ.N    ??idle_3
// 15702   {
// 15703 	  disp_pre_gcode(2,36);
        MOVS     R1,#+36
        MOVS     R0,#+2
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
// 15704   }
// 15705   //#endif
// 15706   #endif
// 15707   
// 15708   GUI_TOUCH_Exec(); 	  
??idle_3:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
// 15709   GUI_Exec(); 
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall GUI_Exec
        B.W      GUI_Exec
          CFI EndBlock cfiBlock93
// 15710 
// 15711 #endif
// 15712   #if ENABLED(I2C_POSITION_ENCODERS)
// 15713     if (planner.blocks_queued() &&
// 15714         ( (blockBufferIndexRef != planner.block_buffer_head) ||
// 15715           ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
// 15716       blockBufferIndexRef = planner.block_buffer_head;
// 15717       I2CPEM.update();
// 15718       lastUpdateMillis = millis();
// 15719     }
// 15720   #endif
// 15721 }
// 15722 
// 15723 extern "C" void kill_c(const char* lcd_msg);

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function kill_c
        THUMB
// 15724 void kill_c(const char* lcd_msg) {
kill_c:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15725   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable192_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15726   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15727 
// 15728   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15729   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15730 
// 15731   #if ENABLED(ULTRA_LCD)
// 15732     kill_screen(lcd_msg);
// 15733   #else
// 15734     UNUSED(lcd_msg);
// 15735   #endif
// 15736 
// 15737   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15738   cli(); // Stop interrupts
        cpsid i
// 15739 
// 15740   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15741   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15742 
// 15743   #if HAS_POWER_SWITCH
// 15744     SET_INPUT(PS_ON_PIN);
// 15745   #endif
// 15746 
// 15747   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 15748   while (1) {
??kill_c_0:
        B.N      ??kill_c_0
          CFI EndBlock cfiBlock94
// 15749     #if ENABLED(USE_WATCHDOG)
// 15750       watchdog_reset();
// 15751     #endif
// 15752   } // Wait for reset
// 15753 }
// 15754 #if 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function _Z17temper_error_killv
        THUMB
// 15755 void temper_error_kill()
// 15756 {
_Z17temper_error_killv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15757   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable192_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15758   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15759 
// 15760   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15761   disable_all_steppers();	
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15762 
// 15763   _delay_ms(600);
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15764 
// 15765   temper_error_flg = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable193_2
        STRB     R0,[R1, #+0]
// 15766 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock95

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184:
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
// 15767 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function _Z20display_temper_errorv
        THUMB
// 15768 void display_temper_error()
// 15769 {
_Z20display_temper_errorv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
// 15770     char buf_err[30]={0};
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 15771     
// 15772 	if(temper_error_flg == 1)
        LDR.W    R4,??DataTable193_2
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??display_temper_error_0
// 15773 	{
// 15774 		card.sdprinting = false;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable192_2
        STRB     R0,[R1, #+1888]
// 15775 		wait_for_heatup = false;
        LDR.W    R1,??DataTable192_3
        STRB     R0,[R1, #+4]
// 15776 
// 15777 		GUI_SetBkColor(gCfgItems.background_color);
        LDR.W    R5,??DataTable193
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 15778 		GUI_SetColor(0X0000ff);//	o®¨®¶?°¡?®¨?
        MOVS     R0,#+255
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 15779         sprintf(buf_err,"Err%d",temper_error_type);
        LDRB     R2,[R4, #+1]
        ADR.W    R1,`?<Constant "Err%d">`
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
// 15780 		GUI_DispStringAt(buf_err,380, TITLE_YPOS);
        MOVS     R2,#+5
        MOV      R1,#+380
        ADD      R0,SP,#+0
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 15781 		GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 15782 		GUI_SetColor(gCfgItems.title_color);			
        LDR      R0,[R5, #+8]
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 15783 	}
// 15784 }
??display_temper_error_0:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock96

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Err%d">`:
        DC8 "Err%d"
        DC8 0, 0
// 15785 
// 15786 #endif
// 15787 
// 15788 /**
// 15789  * Kill all activity and lock the machine.
// 15790  * After this the machine will need to be reset.
// 15791  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function _Z4killPKc
        THUMB
// 15792 void kill(const char* lcd_msg) {
_Z4killPKc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15793   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable192_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15794   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15795 
// 15796   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15797   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15798 
// 15799   #if ENABLED(ULTRA_LCD)
// 15800     kill_screen(lcd_msg);
// 15801   #else
// 15802     UNUSED(lcd_msg);
// 15803   #endif
// 15804 
// 15805   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15806  
// 15807 
// 15808   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15809    cli(); // Stop interrupts
        cpsid i
// 15810   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15811 
// 15812   #ifdef ACTION_ON_KILL
// 15813     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
// 15814   #endif
// 15815 
// 15816   #if HAS_POWER_SWITCH
// 15817     SET_INPUT(PS_ON_PIN);
// 15818   #endif
// 15819 
// 15820   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 15821   while (1) {
??kill_0:
        B.N      ??kill_0
          CFI EndBlock cfiBlock97
// 15822     #if ENABLED(USE_WATCHDOG)
// 15823       watchdog_reset();
// 15824     #endif
// 15825   } // Wait for reset
// 15826 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer halted. kill(...">`:
        DC8 "Printer halted. kill() called!\012"
// 15827 
// 15828 /**
// 15829  * Turn off heaters and stop the print in progress
// 15830  * After a stop the machine may be resumed with M999
// 15831  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock98 Using cfiCommon0
          CFI Function _Z4stopv
        THUMB
// 15832 void stop() {
_Z4stopv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15833   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15834 
// 15835   #if ENABLED(PROBING_FANS_OFF)
// 15836     if (fans_paused) fans_pause(false); // put things back the way they were
// 15837   #endif
// 15838 
// 15839   if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??stop_0
// 15840     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
        LDR.W    R4,??DataTable193_3
        LDR      R0,[R4, #+44]
        STR      R0,[R4, #+48]
// 15841     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable192_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15842     SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
        ADR.W    R0,`?<Constant "Printer stopped due t...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15843     LCD_MESSAGEPGM(MSG_STOPPED);
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "STOPPED. ">`
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
// 15844     safe_delay(350);       // allow enough time for messages to get out before stopping
        MOV      R0,#+350
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 15845     Running = false;
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
// 15846   }
// 15847 }
??stop_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock98

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_1:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_2:
        DC32     0x447a0001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_3:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer stopped due t...">`:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "STOPPED. ">`:
        DC8 "STOPPED. "
        DC8 0, 0
// 15848 
// 15849 /**
// 15850  * Marlin entry-point: Set up before the program loop
// 15851  *  - Set up the kill pin, filament runout, power hold
// 15852  *  - Start the serial port
// 15853  *  - Print startup messages and diagnostics
// 15854  *  - Get EEPROM or default settings
// 15855  *  - Initialize managers for:
// 15856  *    ‚Ä¢ temperature
// 15857  *    ‚Ä¢ planner
// 15858  *    ‚Ä¢ watchdog
// 15859  *    ‚Ä¢ stepper
// 15860  *    ‚Ä¢ photo pin
// 15861  *    ‚Ä¢ servos
// 15862  *    ‚Ä¢ LCD controller
// 15863  *    ‚Ä¢ Digipot I2C
// 15864  *    ‚Ä¢ Z probe sled
// 15865  *    ‚Ä¢ status LEDs
// 15866  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function setup
        THUMB
// 15867 void setup() {
setup:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 15868 
// 15869   #if ENABLED(MAX7219_DEBUG)
// 15870     Max7219_init();
// 15871   #endif
// 15872 /*
// 15873   #if ENABLED(DISABLE_JTAG)
// 15874     // Disable JTAG on AT90USB chips to free up pins for IO
// 15875     MCUCR = 0x80;
// 15876     MCUCR = 0x80;
// 15877   #endif
// 15878   */
// 15879 
// 15880   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15881     setup_filrunoutpin();
          CFI FunCall _Z18setup_filrunoutpinv
        BL       _Z18setup_filrunoutpinv
// 15882   #endif
// 15883 
// 15884   setup_killpin();
          CFI FunCall _Z13setup_killpinv
        BL       _Z13setup_killpinv
// 15885 
// 15886   //setup_powerhold();
// 15887 
// 15888   #if HAS_STEPPER_RESET
// 15889     disableStepperDrivers();
// 15890   #endif
// 15891 
// 15892   //MYSERIAL.begin(BAUDRATE);
// 15893   //SERIAL_PROTOCOLLNPGM("start");
// 15894   //SERIAL_ECHO_START();
// 15895 
// 15896   #if ENABLED(HAVE_TMC2208)
// 15897     tmc2208_serial_begin();
// 15898   #endif
// 15899 
// 15900   // Check startup - does nothing if bootloader sets MCUSR to 0
// 15901   byte mcu = MCUSR;
// 15902   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
// 15903   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
// 15904   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
// 15905   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
// 15906   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
// 15907   //MCUSR = 0;
// 15908 
// 15909   SERIAL_ECHOPGM(MSG_MARLIN);
        ADR.W    R0,`?<Constant "MKS Robin Nano">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15910   SERIAL_CHAR(' ');
        LDR.W    R4,??DataTable192_6
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15911   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
        ADR.W    R0,`?<Constant "1.0.0\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15912   SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15913 
// 15914   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
// 15915     SERIAL_ECHO_START();
        LDR.W    R5,??DataTable193_4
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15916     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
        ADR.W    R0,`?<Constant " Last Updated: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15917     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
        ADR.W    R0,`?<Constant "2017-12-25 12:00">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15918     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
        ADR.W    R0,`?<Constant " | Author: (none, def...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15919     SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15920     SERIAL_ECHOLNPGM("Compiled: " __DATE__);
        ADR.W    R0,`?<Constant "Compiled: Feb 25 2020\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15921   #endif
// 15922 
// 15923   SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15924   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
          CFI FunCall _Z10freeMemoryv
        BL       _Z10freeMemoryv
        MOV      R1,R0
        ADR.W    R0,`?<Constant " Free Memory: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
// 15925   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
        MOV      R1,#+1344
        ADR.W    R0,`?<Constant "  PlannerBufferBytes: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15926 
// 15927   // Send "ok" after commands by default
// 15928   for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
        MOVS     R0,#+0
        MOVS     R2,#+1
        LDR.W    R4,??DataTable193_1
        B.N      ??setup_0
??setup_1:
        ADDS     R1,R1,R4
        STRB     R2,[R1, #+20]
        ADDS     R0,R0,#+1
??setup_0:
        SXTB     R0,R0
        MOV      R1,R0
        CMP      R1,#+4
        BLT.N    ??setup_1
// 15929 
// 15930   // Load data from EEPROM if available (or use defaults)
// 15931   // This also updates variables in the planner, elsewhere
// 15932   (void)settings.load();
          CFI FunCall _ZN14MarlinSettings4loadEv
        BL       _ZN14MarlinSettings4loadEv
// 15933 
// 15934   //#if HAS_M206_COMMAND
// 15935     // Initialize current position based on home_offset
// 15936     if(MACHINETPYE != DELTA)
        LDR.W    R0,??DataTable192_3
        LDR.W    R5,??DataTable192_1
        LDRSH    R1,[R5, #+88]
        CMP      R1,#+2
        BEQ.N    ??setup_2
// 15937     	COPY(current_position, home_offset);
        MOVS     R2,#+12
        ADD      R1,R4,#+44
        ADDS     R0,R0,#+8
          CFI FunCall memcpy
        BL       memcpy
        B.N      ??setup_3
// 15938 	else
// 15939   //#else
// 15940     	ZERO(current_position);
??setup_2:
        MOVS     R2,#+16
        MOVS     R1,#+0
        ADDS     R0,R0,#+8
          CFI FunCall memset
        BL       memset
// 15941   //#endif
// 15942 
// 15943   // Vital to init stepper/planner equivalent for current_position
// 15944   SYNC_PLAN_POSITION_KINEMATIC();
??setup_3:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 15945 
// 15946   thermalManager.init();    // Initialize temperature loop
        LDR.W    R0,??DataTable195
          CFI FunCall _ZN11Temperature4initEv
        BL       _ZN11Temperature4initEv
// 15947 
// 15948   #if ENABLED(USE_WATCHDOG)
// 15949     watchdog_init();
// 15950   #endif
// 15951   //tan add
// 15952   soft_endstop_min_init();
          CFI FunCall _Z21soft_endstop_min_initv
        BL       _Z21soft_endstop_min_initv
// 15953 
// 15954   stepper.init();    // Initialize stepper, this enables interrupts!
          CFI FunCall _ZN7Stepper4initEv
        BL       _ZN7Stepper4initEv
// 15955   servo_init();
          CFI FunCall _Z10servo_initv
        BL       _Z10servo_initv
// 15956 
// 15957   #if HAS_PHOTOGRAPH
// 15958     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
// 15959   #endif
// 15960 
// 15961   #if HAS_CASE_LIGHT
// 15962     case_light_on = CASE_LIGHT_DEFAULT_ON;
// 15963     case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
// 15964     update_case_light();
// 15965   #endif
// 15966 
// 15967   #if ENABLED(SPINDLE_LASER_ENABLE)
// 15968     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
// 15969     #if SPINDLE_DIR_CHANGE
// 15970       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
// 15971     #endif
// 15972     #if ENABLED(SPINDLE_LASER_PWM)
// 15973       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
// 15974       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
// 15975     #endif
// 15976   #endif
// 15977 
// 15978   #if HAS_BED_PROBE
// 15979     endstops.enable_z_probe(false);
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops14enable_z_probeEb
        BL       _ZN8Endstops14enable_z_probeEb
// 15980   #endif
// 15981 
// 15982   #if ENABLED(USE_CONTROLLER_FAN)
// 15983     SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
// 15984   #endif
// 15985 
// 15986   #if HAS_STEPPER_RESET
// 15987     enableStepperDrivers();
// 15988   #endif
// 15989 
// 15990   #if ENABLED(DIGIPOT_I2C)
// 15991     digipot_i2c_init();
// 15992   #endif
// 15993 
// 15994   #if ENABLED(DAC_STEPPER_CURRENT)
// 15995     dac_init();
// 15996   #endif
// 15997 
// 15998   #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
// 15999     OUT_WRITE(SOL1_PIN, LOW); // turn it off
// 16000   #endif
// 16001 
// 16002   #if HAS_HOME
// 16003     SET_INPUT_PULLUP(HOME_PIN);
// 16004   #endif
// 16005 
// 16006   #if PIN_EXISTS(STAT_LED_RED)
// 16007     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
// 16008   #endif
// 16009 
// 16010   #if PIN_EXISTS(STAT_LED_BLUE)
// 16011     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
// 16012   #endif
// 16013 
// 16014   #if HAS_COLOR_LEDS
// 16015     leds.setup();
// 16016   #endif
// 16017 
// 16018   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
// 16019     SET_OUTPUT(RGB_LED_R_PIN);
// 16020     SET_OUTPUT(RGB_LED_G_PIN);
// 16021     SET_OUTPUT(RGB_LED_B_PIN);
// 16022     #if ENABLED(RGBW_LED)
// 16023       SET_OUTPUT(RGB_LED_W_PIN);
// 16024     #endif
// 16025   #endif
// 16026 
// 16027   #if ENABLED(MK2_MULTIPLEXER)
// 16028     SET_OUTPUT(E_MUX0_PIN);
// 16029     SET_OUTPUT(E_MUX1_PIN);
// 16030     SET_OUTPUT(E_MUX2_PIN);
// 16031   #endif
// 16032 
// 16033   #if HAS_FANMUX
// 16034     fanmux_init();
// 16035   #endif
// 16036 
// 16037   lcd_init();
          CFI FunCall _Z8lcd_initv
        BL       _Z8lcd_initv
// 16038 
// 16039   #if ENABLED(SHOW_BOOTSCREEN)
// 16040     lcd_bootscreen();
// 16041   #endif
// 16042 
// 16043   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 16044     // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
// 16045     for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
// 16046       for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16047         mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
// 16048 
// 16049     // Remaining virtual tools are 100% filament 1
// 16050     #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
// 16051       for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
// 16052         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16053           mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
// 16054     #endif
// 16055 
// 16056     // Initialize mixing to tool 0 color
// 16057     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16058       mixing_factor[i] = mixing_virtual_tool_mix[0][i];
// 16059   #endif
// 16060   mksCfg.mkstouch=1;
        MOVS     R0,#+1
        STRB     R0,[R5, #+256]
// 16061   //#if ENABLED(BLTOUCH)
// 16062   if(MKSTOUCH == 1)
// 16063   {
// 16064     // Make sure any BLTouch error condition is cleared
// 16065     bltouch_command(BLTOUCH_RESET);
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 16066     set_bltouch_deployed(true);
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 16067     set_bltouch_deployed(false);
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 16068   }
// 16069   //#endif
// 16070 
// 16071   #if ENABLED(I2C_POSITION_ENCODERS)
// 16072     I2CPEM.init();
// 16073   #endif
// 16074 
// 16075   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 16076     i2c.onReceive(i2c_on_receive);
// 16077     i2c.onRequest(i2c_on_request);
// 16078   #endif
// 16079 
// 16080   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
// 16081     setup_endstop_interrupts();
// 16082   #endif
// 16083 
// 16084   #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 16085     move_extruder_servo(0);  // Initialize extruder servo
// 16086   #endif
// 16087 
// 16088   #if ENABLED(SWITCHING_NOZZLE)
// 16089     move_nozzle_servo(0);  // Initialize nozzle servo
// 16090   #endif
// 16091 
// 16092   #if ENABLED(PARKING_EXTRUDER)
// 16093     #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 16094       pe_activate_magnet(0);
// 16095       pe_activate_magnet(1);
// 16096     #else
// 16097       pe_deactivate_magnet(0);
// 16098       pe_deactivate_magnet(1);
// 16099     #endif
// 16100   #endif
// 16101   #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
// 16102     SET_OUTPUT(LCD_PINS_DC);
// 16103     OUT_WRITE(LCD_PINS_RS, LOW);
// 16104     delay(1000);
// 16105     WRITE(LCD_PINS_RS, HIGH);
// 16106   #endif
// 16107     display_hold=0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+11]
// 16108     display_hold_cnt=0;
        STR      R0,[R4, #+56]
// 16109 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock99

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_1:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_2:
        DC32     0x401921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_3:
        DC32     0xc01921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_4:
        DC32     0x40c90fdb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "MKS Robin Nano">`:
        DC8 "MKS Robin Nano"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "1.0.0\\n">`:
        DC8 "1.0.0\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Last Updated: ">`:
        DC8 " Last Updated: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "2017-12-25 12:00">`:
        DC8 "2017-12-25 12:00"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " | Author: (none, def...">`:
        DC8 " | Author: (none, default config)\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Compiled: Feb 25 2020\\n">`:
        DC8 "Compiled: Feb 25 2020\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Free Memory: ">`:
        DC8 " Free Memory: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "  PlannerBufferBytes: ">`:
        DC8 "  PlannerBufferBytes: "
        DC8 0
// 16110 
// 16111 /**
// 16112  * The main Marlin program loop
// 16113  *
// 16114  *  - Save or log commands to SD
// 16115  *  - Process available commands (if not saving)
// 16116  *  - Call heater manager
// 16117  *  - Call inactivity manager
// 16118  *  - Call endstop manager
// 16119  *  - Call LCD update
// 16120  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function loop
        THUMB
// 16121 void loop() {
loop:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 16122 #if 1
// 16123     //display_sd_error();
// 16124 
// 16125 	display_temper_error();
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
// 16126 	
// 16127 	PowerOff_Filament_Check();
          CFI FunCall _Z23PowerOff_Filament_Checkv
        BL       _Z23PowerOff_Filament_Checkv
// 16128 	
// 16129 	MYSERIAL.MoremenuCmd();
        LDR.W    R0,??DataTable192_6
          CFI FunCall _ZN10USARTClass11MoremenuCmdEv
        BL       _ZN10USARTClass11MoremenuCmdEv
// 16130 
// 16131 #endif
// 16132   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R4,??DataTable192_3
        LDRB     R0,[R4, #+2]
        CMP      R0,#+4
        BGE.N    ??loop_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 16133 
// 16134   #if 0//ENABLED(SDSUPPORT)
// 16135     card.checkautostart(false);
// 16136   #endif
// 16137   card.checkFilesys(gCfgItems.fileSysType);
??loop_0:
        LDR.W    R6,??DataTable192_2
        LDR.W    R0,??DataTable193
        LDRB     R1,[R0, #+186]
        MOV      R0,R6
          CFI FunCall _ZN10CardReader12checkFilesysEh
        BL       _ZN10CardReader12checkFilesysEh
// 16138 
// 16139   if (commands_in_queue) {
        LDR.W    R5,??DataTable193_1
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 16140 
// 16141     #if ENABLED(SDSUPPORT)
// 16142 
// 16143       if (card.saving) {
        LDRB     R0,[R6, #+1889]
        CMP      R0,#+0
        BEQ.N    ??loop_2
// 16144         char* command = command_queue[cmd_queue_index_r];
        LDRB     R0,[R5, #+7]
        ADD      R1,R0,R0, LSL #+1
        LDR.W    R0,??DataTable195_1
        ADD      R7,R0,R1, LSL #+5
// 16145         if (strstr_P(command, PSTR("M29"))) {
        ADR.N    R1,??DataTable190_2  ;; "M29"
        MOV      R0,R7
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??loop_3
// 16146           // M29 closes the file
// 16147           card.closefile();
        MOVS     R1,#+0
        MOV      R0,R6
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
// 16148           SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
        ADR.W    R0,`?<Constant "Done saving file.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 16149 
// 16150           #if ENABLED(SERIAL_STATS_DROPPED_RX)
// 16151             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
// 16152           #endif
// 16153 
// 16154           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
// 16155             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
// 16156           #endif
// 16157 
// 16158           ok_to_send();
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 16159         }
// 16160         else {
// 16161           // Write the string from the read buffer to SD
// 16162           card.write_command(command);
??loop_3:
        MOV      R1,R7
        MOV      R0,R6
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
// 16163           if (card.logging)
        LDRB     R0,[R6, #+1890]
        CMP      R0,#+0
        BEQ.N    ??loop_5
// 16164             process_next_command(); // The card is saving because it's logging
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
        B.N      ??loop_4
// 16165           else
// 16166             ok_to_send();
??loop_5:
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 16167         }
// 16168       }
// 16169       else
// 16170         process_next_command();
??loop_2:
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
// 16171 
// 16172     #else
// 16173 
// 16174       process_next_command();
// 16175 
// 16176     #endif // SDSUPPORT
// 16177 
// 16178     // The queue may be reset by a command handler or by code invoked by idle() within a handler
// 16179     if (commands_in_queue) {
??loop_4:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 16180       --commands_in_queue;
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+2]
// 16181       if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
        LDRB     R0,[R5, #+7]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+7]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??loop_1
        MOVS     R0,#+0
        STRB     R0,[R5, #+7]
// 16182     }
// 16183   }
// 16184   endstops.report_state();
??loop_1:
          CFI FunCall _ZN8Endstops12report_stateEv
        BL       _ZN8Endstops12report_stateEv
// 16185   idle();
          CFI FunCall _Z4idlev
        BL       _Z4idlev
// 16186   loop_start=1;
        MOVS     R0,#+1
        STRB     R0,[R5, #+6]
// 16187   
// 16188   mks_PrintStatePolling();
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_PrintStatePolling
        B.W      mks_PrintStatePolling
          CFI EndBlock cfiBlock100
// 16189 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189:
        DC32     0x3a83126f

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Done saving file.\\n">`:
        DC8 "Done saving file.\012"
        DC8 0
// 16190 #if 1
// 16191 uint16_t z_high_count;
// 16192 
// 16193 extern uint8_t poweroff_det_flg;
// 16194 extern uint32_t poweroff_det_cnt;
// 16195 extern uint8_t poweroff_det_low_flg;
// 16196 extern uint32_t poweroff_det_low_cnt;
// 16197 extern uint8_t poweroff_det_high_flg;
// 16198 extern uint32_t poweroff_det_high_cnt;
// 16199 
// 16200 extern uint8_t filament_det1_flg;
// 16201 extern uint32_t filament_det1_cnt;
// 16202 extern uint8_t filament_det1_low_flg;
// 16203 extern uint32_t filament_det1_low_cnt;
// 16204 extern uint8_t filament_det1_high_flg;
// 16205 extern uint32_t filament_det1_high_cnt;
// 16206 extern uint8_t filament_det1_check;
// 16207 
// 16208 extern uint8_t filament_det2_flg;
// 16209 extern uint32_t filament_det2_cnt;
// 16210 extern uint8_t filament_det2_low_flg;
// 16211 extern uint32_t filament_det2_low_cnt;
// 16212 extern uint8_t filament_det2_high_flg;
// 16213 extern uint32_t filament_det2_high_cnt;
// 16214 extern uint8_t filament_det2_check;
// 16215 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// 16216 uint32_t wifi_loop_cycle = 500;
wifi_loop_cycle:
        DATA
        DC32 500
// 16217 extern char wifi_check_time;
// 16218 uint8_t wifi_init_flg = 0;
// 16219 uint8_t wifi_init_state = 0;
// 16220 uint8_t wifi_refresh_flg = 0, cloud_refresh_flg = 0;
// 16221 uint8_t waiting_wifi_time = 0;
// 16222 
// 16223 uint8_t beep_flg = 0;
// 16224 uint32_t beep_cnt = 0;
// 16225 extern uint8_t print_finish_start_timer;
// 16226 extern uint32_t print_finish_timer_count;
// 16227 extern uint8_t print_finish_close_machine;
// 16228 
// 16229 #if 0
// 16230 uint8_t btn_flg = 0;
// 16231 uint32_t btn_beep_cnt = 0;
// 16232 #endif
// 16233 extern void mksBeeperAlarm(void);
// 16234 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function _Z6Beeperj
          CFI NoCalls
        THUMB
// 16235 void Beeper(uint32_t cnt)
// 16236 {
// 16237     beep_flg = 1;
_Z6Beeperj:
        LDR.W    R1,??DataTable193_1
        MOVS     R2,#+1
        STRB     R2,[R1, #+17]
// 16238     beep_cnt = cnt;
        STR      R0,[R1, #+60]
// 16239     BEEPER_OP = 1;
        MOV      R0,R2
        LDR.W    R1,??DataTable196  ;; 0x42220194
        STR      R0,[R1, #+0]
// 16240 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock101

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_1:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_2:
        DC8      "M29"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_3:
        DC32     0x4062c000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_4:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_5:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_6:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_7:
        DC32     0x42c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_8:
        DC32     0xc2c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_9:
        DC32     0x42600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_10:
        DC32     0xbf800000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_11:
        DC32     ??C2
// 16241 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function _Z20SysTick_Handler_Userv
        THUMB
// 16242 void SysTick_Handler_User()
// 16243 {
_Z20SysTick_Handler_Userv:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
// 16244 		TimeIncrease++;
        LDR.W    R4,??DataTable193_1
        LDR      R0,[R4, #+40]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+40]
// 16245 
// 16246 
// 16247 		if(filament_loading_time_flg == 1)
        MOV      R5,#+1000
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_0
// 16248 		{
// 16249 			filament_loading_time_cnt++;
        LDR      R0,[R4, #+32]
        ADDS     R6,R0,#+1
        STR      R6,[R4, #+32]
// 16250 			filament_rate = (uint32_t)(((filament_loading_time_cnt/(gCfgItems.filament_loading_time*1000.0))*100.0)+0.5);
        LDR.W    R0,??DataTable194
        LDR      R7,[R0, #+244]
        MOV      R0,R6
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R7
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable196_1  ;; 0x408f4000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable196_2  ;; 0x40590000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable196_3  ;; 0x3fe00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        LDR.W    R1,??DataTable196_4
        STR      R0,[R1, #+0]
// 16251 			if(filament_loading_time_cnt >= (gCfgItems.filament_loading_time*1000))
        MUL      R0,R5,R7
        CMP      R6,R0
        BCC.N    ??SysTick_Handler_User_0
// 16252 			{
// 16253 				filament_loading_time_cnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+32]
// 16254 				filament_loading_time_flg = 0;
        STRB     R0,[R4, #+0]
// 16255 				filament_loading_completed = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+1]
// 16256 			}
// 16257 		}
// 16258 		if(filament_unloading_time_flg == 1)
??SysTick_Handler_User_0:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_1
// 16259 		{
// 16260 			filament_unloading_time_cnt++;
        LDR      R0,[R4, #+36]
        ADDS     R6,R0,#+1
        STR      R6,[R4, #+36]
// 16261 			filament_rate = (uint32_t)(((filament_unloading_time_cnt/(gCfgItems.filament_unloading_time*1000.0))*100.0)+0.5);
        LDR.W    R0,??DataTable194
        ADDS     R0,R0,#+244
        LDR      R8,[R0, #+4]
        LDR.W    R7,??DataTable196_4
        MOV      R0,R6
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R8
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable196_1  ;; 0x408f4000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable196_2  ;; 0x40590000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable196_3  ;; 0x3fe00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R7, #+0]
// 16262 			if(filament_unloading_time_cnt >= (gCfgItems.filament_unloading_time*1000))
        MUL      R0,R5,R8
        CMP      R6,R0
        BCC.N    ??SysTick_Handler_User_1
// 16263 			{
// 16264 				filament_unloading_time_cnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+36]
// 16265 				filament_unloading_time_flg = 0;
        STRB     R0,[R4, #+2]
// 16266 				filament_unloading_completed = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+3]
// 16267 				filament_rate = 100;
        MOVS     R0,#+100
        STR      R0,[R7, #+0]
// 16268 			}
// 16269 		}	
// 16270 	
// 16271 		temperature_change_frequency_cnt++;
??SysTick_Handler_User_1:
        LDR      R0,[R4, #+28]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+28]
// 16272 		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
        CMP      R0,#+2000
        BCC.N    ??SysTick_Handler_User_2
        LDR.W    R0,??DataTable196_5
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BEQ.N    ??SysTick_Handler_User_2
// 16273 		{
// 16274 			temperature_change_frequency_cnt = 0;
        MOVS     R1,#+0
        STR      R1,[R4, #+28]
// 16275 			temperature_change_frequency = 1;
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
// 16276 		}
// 16277 		
// 16278 		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
??SysTick_Handler_User_2:
        LDR      R0,[R4, #+40]
        MOVW     R1,#+3000
        UDIV     R1,R0,R1
        MOVW     R2,#+3000
        MLS      R0,R2,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_3
// 16279 		{		
// 16280 			printing_rate_update_flag = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
// 16281 		}	
// 16282 
// 16283 		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
??SysTick_Handler_User_3:
        LDR      R0,[R4, #+40]
        MOV      R1,R5
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_4
// 16284 		{		
// 16285 			if(print_time.start == 1)
        LDR.W    R0,??DataTable196_6
        LDRSB    R1,[R0, #+7]
        CMP      R1,#+1
        BNE.N    ??SysTick_Handler_User_5
// 16286 			{
// 16287 				print_time.seconds++;
        LDRB     R1,[R0, #+5]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+5]
// 16288 			}
// 16289 			display_hold_cnt++;
??SysTick_Handler_User_5:
        LDR      R0,[R4, #+56]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+56]
// 16290 		}
// 16291 		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
??SysTick_Handler_User_4:
        LDR      R0,[R4, #+40]
        MOV      R1,R5
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_6
// 16292 		{
// 16293 			z_high_count=1;
        MOVS     R0,#+1
        STRH     R0,[R4, #+24]
// 16294 		}
// 16295 
// 16296 	if(poweroff_det_flg==1)
??SysTick_Handler_User_6:
        LDR.W    R0,??DataTable196_7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_7
// 16297 	{
// 16298 		poweroff_det_cnt++;
        LDR.W    R0,??DataTable196_8
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16299 	}
// 16300 		
// 16301 	if(filament_det1_flg==1)
??SysTick_Handler_User_7:
        LDR.W    R0,??DataTable196_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_8
// 16302 	{
// 16303 		filament_det1_cnt++;
        LDR.W    R0,??DataTable197
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16304 	}
// 16305 
// 16306 	if(filament_det1_low_flg==1)
??SysTick_Handler_User_8:
        LDR.W    R0,??DataTable197_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_9
// 16307 	{
// 16308 		filament_det1_low_cnt++;
        LDR.W    R0,??DataTable197_2
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16309 	}
// 16310 
// 16311 	if(filament_det1_high_flg==1)
??SysTick_Handler_User_9:
        LDR.W    R0,??DataTable197_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_10
// 16312 	{
// 16313 		filament_det1_high_cnt++;
        LDR.W    R0,??DataTable197_4
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16314 	}
// 16315 	if(filament_det2_flg==1)
??SysTick_Handler_User_10:
        LDR.W    R0,??DataTable198
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_11
// 16316 	{
// 16317 		filament_det2_cnt++;
        LDR.W    R0,??DataTable198_1
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16318 	}
// 16319 
// 16320 	if(filament_det2_low_flg==1)
??SysTick_Handler_User_11:
        LDR.W    R0,??DataTable198_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_12
// 16321 	{
// 16322 		filament_det2_low_cnt++;
        LDR.W    R0,??DataTable198_3
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16323 	}
// 16324 
// 16325 	if(filament_det2_high_flg==1)
??SysTick_Handler_User_12:
        LDR.W    R0,??DataTable198_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_13
// 16326 	{
// 16327 		filament_det2_high_cnt++;
        LDR.W    R0,??DataTable198_5
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16328 	}
// 16329 
// 16330 	if(poweroff_det_low_flg==1)
??SysTick_Handler_User_13:
        LDR.W    R0,??DataTable199
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_14
// 16331 	{
// 16332 		poweroff_det_low_cnt++;
        LDR.W    R0,??DataTable199_1
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16333 	}
// 16334 	
// 16335 	if(poweroff_det_high_flg==1)
??SysTick_Handler_User_14:
        LDR.W    R0,??DataTable199_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_15
// 16336 	{
// 16337 		poweroff_det_high_cnt++;
        LDR.W    R0,??DataTable199_3
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16338 	}		
// 16339 
// 16340 	if(!(TimeIncrease * TICK_CYCLE % 5000))	//5s
??SysTick_Handler_User_15:
        LDR      R0,[R4, #+40]
        MOVW     R1,#+5000
        UDIV     R1,R0,R1
        MOVW     R2,#+5000
        MLS      R0,R2,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_16
// 16341 	{
// 16342 		wifi_check_time = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable199_4
        STRB     R0,[R1, #+0]
// 16343 		waiting_wifi_time ++;
        LDRB     R0,[R4, #+16]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+16]
// 16344 		if((waiting_wifi_time == 8) || (gCfgItems.wifi_type == ESP_WIFI))//40s
        UXTB     R0,R0
        CMP      R0,#+8
        BEQ.N    ??SysTick_Handler_User_17
        LDR.W    R0,??DataTable194
        LDRB     R0,[R0, #+556]
        CMP      R0,#+2
        BNE.N    ??SysTick_Handler_User_18
// 16345 		{
// 16346 			if(wifi_init_flg == 0)
??SysTick_Handler_User_17:
        LDRB     R0,[R4, #+13]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_18
// 16347 			{
// 16348 				wifi_init_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+13]
// 16349 			}
// 16350 			
// 16351 		}
// 16352 		if(wifi_refresh_flg == 0)
??SysTick_Handler_User_18:
        LDRB     R0,[R4, #+14]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_19
// 16353 			wifi_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+14]
// 16354 		
// 16355 		if(cloud_refresh_flg == 0)
??SysTick_Handler_User_19:
        LDRB     R0,[R4, #+15]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_16
// 16356 			cloud_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+15]
// 16357 
// 16358 	}
// 16359 	
// 16360 
// 16361 	mksBeeperAlarm();
??SysTick_Handler_User_16:
          CFI FunCall _Z14mksBeeperAlarmv
        BL       _Z14mksBeeperAlarmv
// 16362 
// 16363     if(beep_flg == 1)
        LDRB     R0,[R4, #+17]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_20
// 16364     {
// 16365         beep_cnt--;
        LDR      R0,[R4, #+60]
        SUBS     R0,R0,#+1
        STR      R0,[R4, #+60]
// 16366         if(beep_cnt<=0)
        BNE.N    ??SysTick_Handler_User_20
// 16367         {
// 16368            beep_flg = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+17]
// 16369            BEEPER_OP = 0; 
        LDR.W    R1,??DataTable196  ;; 0x42220194
        STR      R0,[R1, #+0]
// 16370         }
// 16371     }    
// 16372 #if 0
// 16373     if(btn_flg == 1)
// 16374     {
// 16375         btn_beep_cnt--;
// 16376         if(btn_beep_cnt<=0)
// 16377         {
// 16378            btn_flg = 0;
// 16379            BEEPER_OP = 0; 
// 16380         }
// 16381     }
// 16382     #endif
// 16383 	if(print_finish_start_timer==TIMER_START)
??SysTick_Handler_User_20:
        LDRB     R0,[R4, #+18]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_21
// 16384 	{
// 16385 		print_finish_timer_count++;
        LDR      R0,[R4, #+64]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+64]
// 16386 		if(print_finish_timer_count>=gCfgItems.print_finish_count*1000)
        LDR.W    R1,??DataTable194
        LDRH     R1,[R1, #+672]
        MULS     R1,R5,R1
        CMP      R0,R1
        BCC.N    ??SysTick_Handler_User_21
// 16387 		{
// 16388 			print_finish_start_timer=TIMER_STOP;
        MOVS     R0,#+0
        STRB     R0,[R4, #+18]
// 16389 			print_finish_timer_count=0;
        STR      R0,[R4, #+64]
// 16390 			print_finish_close_machine=true;
        MOVS     R0,#+1
        STRB     R0,[R4, #+19]
// 16391 		}
// 16392 	}
// 16393 }
??SysTick_Handler_User_21:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock102

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191:
        DC32     0xc2600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191_1:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191_2:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191_3:
        DC32     gArrayGpioPin
// 16394 #endif
// 16395 
// 16396 #include "mks_reprint.cpp"

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// __absolute char *mks_pft_name
mks_pft_name:
        DATA
        DC32 `?<Constant "mks_pft.sys">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function mkstft_ui_load
        THUMB
// __interwork __softfp void mkstft_ui_load()
mkstft_ui_load:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable194
        MOVS     R2,#+4
        ADDS     R1,R4,#+4
        MOVW     R0,#+1694
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+8
        MOVW     R0,#+1698
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+12
        MOVW     R0,#+1702
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+16
        MOVW     R0,#+1706
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+24
        MOVW     R0,#+1710
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+20
        MOVW     R0,#+1714
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+36
        MOVW     R0,#+1718
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOVW     R0,#+1722
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOVW     R0,#+1726
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+48
        MOVW     R0,#+1730
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+60
        MOVW     R0,#+1734
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+64
        MOVW     R0,#+1738
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+52
        MOVW     R0,#+1742
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+56
        MOVW     R0,#+1746
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+84
        MOVW     R0,#+1750
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+88
        MOVW     R0,#+1754
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+447
        MOVW     R0,#+1758
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+184
        MOVW     R0,#+1759
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+212
        MOVW     R0,#+1794
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+228
        MOV      R0,#+1768
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+220
        MOVW     R0,#+1772
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+236
        MOV      R0,#+1776
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+232
        MOVW     R0,#+1780
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+224
        MOV      R0,#+1784
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+240
        MOVW     R0,#+1788
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+213
        MOVW     R0,#+1793
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+661
        MOVW     R0,#+1797
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+444
        MOVW     R0,#+1799
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+205
        MOV      R0,#+1800
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+445
        MOVW     R0,#+1801
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+446
        MOVW     R0,#+1802
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+458
        MOVW     R0,#+1803
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+252
        MOVW     R0,#+1804
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+253
        MOVW     R0,#+1805
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+254
        MOVW     R0,#+1806
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+256
        MOV      R0,#+1808
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+258
        MOVW     R0,#+1810
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+260
        MOVW     R0,#+1812
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+262
        MOVW     R0,#+1814
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+264
        MOV      R0,#+1816
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+266
        MOVW     R0,#+1818
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+268
        MOVW     R0,#+1820
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+270
        MOVW     R0,#+1822
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+272
        MOV      R0,#+1824
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+217
        MOVW     R0,#+1826
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+557
        MOVW     R0,#+1827
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+668
        MOVW     R0,#+1836
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+669
        MOVW     R0,#+1837
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+670
        MOVW     R0,#+1838
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+674
        MOVW     R0,#+1841
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+676
        MOVW     R0,#+1842
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+672
        MOVW     R0,#+1839
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock103

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192:
        DC32     filament_ran_out

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_1:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_2:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_3:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_4:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_5:
        DC32     _ZN11GCodeParser11command_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_6:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_7:
        DC32     disp_state_stack

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_8:
        DC32     button_disp_pause_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_9:
        DC32     0x422281b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_10:
        DC32     wifi_link_state

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function _Z17mkstft_ui_set_eprv
        THUMB
// __interwork __softfp void mkstft_ui_set_epr()
_Z17mkstft_ui_set_eprv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOVW     R4,#+1450
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R5,??DataTable200  ;; 0x76313030
        LDR      R0,[SP, #+0]
        CMP      R0,R5
        BEQ.W    ??mkstft_ui_set_epr_0
        LDR.W    R6,??DataTable194
        MOVS     R2,#+4
        ADDS     R1,R6,#+4
        MOVW     R0,#+1694
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+8
        MOVW     R0,#+1698
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+12
        MOVW     R0,#+1702
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+16
        MOVW     R0,#+1706
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+24
        MOVW     R0,#+1710
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+20
        MOVW     R0,#+1714
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+36
        MOVW     R0,#+1718
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+40
        MOVW     R0,#+1722
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+44
        MOVW     R0,#+1726
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+48
        MOVW     R0,#+1730
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+60
        MOVW     R0,#+1734
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+64
        MOVW     R0,#+1738
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+52
        MOVW     R0,#+1742
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+56
        MOVW     R0,#+1746
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+84
        MOVW     R0,#+1750
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+88
        MOVW     R0,#+1754
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+447
        MOVW     R0,#+1758
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+184
        MOVW     R0,#+1759
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+212
        MOVW     R0,#+1794
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+228
        MOV      R0,#+1768
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+220
        MOVW     R0,#+1772
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+236
        MOV      R0,#+1776
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+232
        MOVW     R0,#+1780
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+224
        MOV      R0,#+1784
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+240
        MOVW     R0,#+1788
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+213
        MOVW     R0,#+1793
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+661
        MOVW     R0,#+1797
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+444
        MOVW     R0,#+1799
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+205
        MOV      R0,#+1800
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+445
        MOVW     R0,#+1801
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+446
        MOVW     R0,#+1802
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+458
        MOVW     R0,#+1803
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+252
        MOVW     R0,#+1804
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+253
        MOVW     R0,#+1805
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+254
        MOVW     R0,#+1806
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+256
        MOV      R0,#+1808
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+258
        MOVW     R0,#+1810
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+260
        MOVW     R0,#+1812
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+262
        MOVW     R0,#+1814
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+264
        MOV      R0,#+1816
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+266
        MOVW     R0,#+1818
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+268
        MOVW     R0,#+1820
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+270
        MOVW     R0,#+1822
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+272
        MOV      R0,#+1824
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+217
        MOVW     R0,#+1826
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+557
        MOVW     R0,#+1827
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+668
        MOVW     R0,#+1836
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+669
        MOVW     R0,#+1837
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+670
        MOVW     R0,#+1838
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+674
        MOVW     R0,#+1841
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+676
        MOVW     R0,#+1842
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+672
        MOVW     R0,#+1839
          CFI FunCall epr_write_data
        BL       epr_write_data
        STR      R5,[SP, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
??mkstft_ui_set_epr_0:
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock104

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_1:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_2:
        DC32     temper_error_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_3:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_4:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock105 Using cfiCommon0
          CFI Function mkstft_ui_init
        THUMB
// __interwork __softfp void mkstft_ui_init()
mkstft_ui_init:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R4,??DataTable194
        LDR.W    R0,??DataTable205  ;; 0x494949
        STR      R0,[R4, #+4]
        ADDS     R1,R4,#+4
        MVN      R2,#-16777216
        STR      R2,[R1, #+4]
        STR      R0,[R1, #+8]
        STR      R2,[R1, #+12]
        STR      R0,[R1, #+32]
        STR      R2,[R1, #+36]
        STR      R0,[R1, #+40]
        STR      R2,[R1, #+44]
        STR      R0,[R1, #+48]
        STR      R2,[R1, #+52]
        STR      R0,[R1, #+56]
        STR      R2,[R1, #+60]
        MOV      R0,#+65280
        STR      R0,[R1, #+64]
        LDR.W    R0,??DataTable206_1  ;; 0xaaaaaa
        STR      R0,[R1, #+68]
        MOVS     R0,#+0
        STR      R0,[R1, #+72]
        STR      R0,[R1, #+76]
        MOV      R0,#+16711680
        STR      R0,[R1, #+80]
        STR      R2,[R1, #+84]
        MOVS     R0,#+0
        STR      R0,[R1, #+88]
        STR      R2,[R1, #+92]
        MOVS     R0,#+1
        STRB     R0,[R4, #+447]
        ADD      R5,R4,#+156
        MOVS     R0,#+3
        STRB     R0,[R5, #+28]
        MOVS     R0,#+1
        STRB     R0,[R5, #+30]
        MOVS     R0,#+10
        STRB     R0,[R5, #+3]
        MOVS     R0,#+0
        STRB     R0,[R4, #+156]
        MOV      R0,#+1065353216
        STR      R0,[R5, #+24]
        MOVW     R0,#+3000
        STRH     R0,[R5, #+18]
        MOVS     R1,#+1
        STRB     R1,[R5, #+16]
        MOVS     R1,#+5
        STRB     R1,[R5, #+15]
        STRB     R1,[R5, #+14]
        MOVS     R1,#+100
        STRH     R1,[R5, #+8]
        STRH     R1,[R5, #+10]
        MOVS     R1,#+0
        STRB     R1,[R4, #+252]
        ADD      R1,R4,#+252
        MOVS     R2,#+4
        STRB     R2,[R1, #+1]
        MOVS     R2,#+50
        STRH     R2,[R1, #+2]
        STRH     R2,[R1, #+4]
        MOVS     R2,#+180
        STRH     R2,[R1, #+6]
        MOVS     R2,#+50
        STRH     R2,[R1, #+8]
        MOVS     R2,#+180
        STRH     R2,[R1, #+10]
        STRH     R2,[R1, #+12]
        MOVS     R2,#+50
        STRH     R2,[R1, #+14]
        MOVS     R2,#+180
        STRH     R2,[R1, #+16]
        STR      R0,[R1, #+28]
        MOVW     R0,#+1500
        STR      R0,[R1, #+24]
        ADDW     R0,R4,#+415
        MOVS     R1,#+0
        STRB     R1,[R0, #+29]
        STRB     R1,[R4, #+205]
        STRB     R1,[R0, #+30]
        STRB     R1,[R0, #+31]
        MOV      R0,R1
        STRB     R0,[R4, #+458]
        ADDW     R6,R4,#+205
        STRB     R0,[R6, #+12]
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "0.000">`
        ADD      R0,R4,#+352
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R4, #+297]
        ADD      R0,R4,#+220
        MOVS     R1,#+200
        STR      R1,[R0, #+16]
        MOV      R1,#+1000
        STR      R1,[R4, #+220]
        MOVS     R2,#+100
        STR      R2,[R0, #+8]
        MOVS     R2,#+200
        STR      R2,[R0, #+20]
        STR      R1,[R0, #+4]
        MOVS     R1,#+100
        STR      R1,[R0, #+12]
        MOVS     R0,#+0
        STRB     R0,[R6, #+7]
        MOVS     R0,#+1
        STRB     R0,[R6, #+8]
        STRB     R0,[R4, #+555]
        LDR.W    R8,??DataTable207
        MOVS     R2,#+108
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        LDR.W    R6,??DataTable207_1
        MOVS     R2,#+162
        MOVS     R1,#+0
        MOV      R0,R6
          CFI FunCall memset
        BL       memset
        MOVS     R7,#+12
        MOV      R2,R7
        ADR.W    R1,`?<Constant "TP-LINK_MKS">`
        MOV      R0,R8
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+10
        ADR.W    R1,`?<Constant "makerbase">`
        ADD      R0,R8,#+32
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADR.W    R8,`?<Constant "192.168.3.100">`
        MOV      R9,#+14
        MOV      R2,R9
        MOV      R1,R8
        ADDS     R0,R6,#+1
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        ADR.W    R10,`?<Constant "255.255.255.0">`
        MOV      R2,R9
        MOV      R1,R10
        ADD      R0,R6,#+17
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        ADR.W    R11,`?<Constant "192.168.3.1">`
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+33
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+49
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R6, #+0]
        MOV      R2,R9
        MOV      R1,R8
        ADD      R0,R6,#+66
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R9
        MOV      R1,R10
        ADD      R0,R6,#+82
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+98
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+114
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+130
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R9
        ADR.W    R1,`?<Constant "192.168.3.255">`
        ADD      R0,R6,#+146
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R6, #+65]
        ADDW     R6,R4,#+555
        MOVS     R0,#+2
        STRB     R0,[R6, #+1]
        MOVS     R2,#+15
        ADR.W    R1,`?<Constant "baizhongyun.cn">`
        ADDW     R0,R4,#+558
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVW     R0,#+10086
        STR      R0,[R4, #+656]
        MOVS     R0,#+1
        STRB     R0,[R6, #+2]
        ADD      R0,R4,#+656
        MOVS     R1,#+23
        STRB     R1,[R0, #+4]
        MOVS     R1,#+0
        STRB     R1,[R0, #+5]
        STRB     R1,[R4, #+415]
        STRB     R1,[R4, #+328]
        STRB     R1,[R4, #+341]
        STRB     R1,[R0, #+13]
        MOVS     R1,#+1
        STRB     R1,[R0, #+14]
        MOVS     R1,#+0
        STRB     R1,[R0, #+18]
        STR      R1,[R0, #+20]
        MOVS     R1,#+180
        STRH     R1,[R0, #+16]
          CFI FunCall _Z17mkstft_ui_set_eprv
        BL       _Z17mkstft_ui_set_eprv
        MOVW     R0,#+3518
        STR      R0,[R5, #+32]
        MOVW     R1,#+389
        STR      R1,[R5, #+36]
        MOV      R2,#+284
        STR      R2,[R5, #+40]
        MOVW     R3,#+3770
        STR      R3,[R5, #+44]
        LDR.W    R4,??DataTable210
        LDRH     R4,[R4, #+0]
        MOVW     R6,#+37697
        CMP      R4,R6
        BNE.N    ??mkstft_ui_init_0
        MOV      R0,#+400
        STR      R0,[R5, #+32]
        MOVW     R0,#+3836
        STR      R0,[R5, #+36]
        MOVW     R0,#+3805
        STR      R0,[R5, #+40]
        MOVS     R0,#+212
        STR      R0,[R5, #+44]
        B.N      ??mkstft_ui_init_1
??mkstft_ui_init_0:
        MOVW     R6,#+35209
        CMP      R4,R6
        BNE.N    ??mkstft_ui_init_2
        STR      R1,[R5, #+32]
        STR      R0,[R5, #+36]
        STR      R2,[R5, #+40]
        STR      R3,[R5, #+44]
        B.N      ??mkstft_ui_init_1
??mkstft_ui_init_2:
        MOVW     R0,#+5381
        CMP      R4,R0
        BNE.N    ??mkstft_ui_init_3
        MOV      R0,#+304
        STR      R0,[R5, #+32]
        MOVW     R0,#+3875
        STR      R0,[R5, #+36]
        MOVW     R1,#+313
        STR      R1,[R5, #+40]
        STR      R0,[R5, #+44]
        B.N      ??mkstft_ui_init_1
??mkstft_ui_init_3:
        MOVW     R0,#+34130
        CMP      R4,R0
        BNE.N    ??mkstft_ui_init_4
        MOV      R0,#+352
        STR      R0,[R5, #+32]
        MOVW     R0,#+3924
        STR      R0,[R5, #+36]
        MOV      R0,#+3840
        STR      R0,[R5, #+40]
        MOVS     R0,#+201
        STR      R0,[R5, #+44]
        B.N      ??mkstft_ui_init_1
??mkstft_ui_init_4:
        MOVW     R0,#+38024
        CMP      R4,R0
        BNE.N    ??mkstft_ui_init_1
        MOVS     R0,#+201
        STR      R0,[R5, #+32]
        MOVW     R0,#+3919
        STR      R0,[R5, #+36]
        MOV      R0,#+3776
        STR      R0,[R5, #+40]
        MOVS     R0,#+164
        STR      R0,[R5, #+44]
??mkstft_ui_init_1:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable211
        STRB     R0,[R1, #+0]
        LDR.W    R1,??DataTable213
        STRB     R0,[R1, #+0]
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock105

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "0.000">`:
        DC8 "0.000"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "TP-LINK_MKS">`:
        DC8 "TP-LINK_MKS"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "makerbase">`:
        DC8 "makerbase"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.100">`:
        DC8 "192.168.3.100"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "255.255.255.0">`:
        DC8 "255.255.255.0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.1">`:
        DC8 "192.168.3.1"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.255">`:
        DC8 "192.168.3.255"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "baizhongyun.cn">`:
        DC8 "baizhongyun.cn"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock106 Using cfiCommon0
          CFI Function mks_initPrint
        THUMB
// __interwork __softfp void mks_initPrint()
mks_initPrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable212_1
        LDR.W    R0,??DataTable212_2
        LDR      R1,[R0, #+212]
        STR      R1,[R4, #+2016]
        ADDW     R1,R4,#+2016
        ADDS     R0,R0,#+212
        LDR      R2,[R0, #+4]
        STR      R2,[R1, #+4]
        LDR      R0,[R0, #+8]
        STR      R0,[R1, #+8]
        LDR.W    R0,??DataTable214  ;; 0x40a00000
        STR      R0,[R1, #+12]
        MOVS     R0,#+0
        STR      R0,[R1, #+16]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2076]
        ADDW     R5,R4,#+2076
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
        MOVS     R2,#+20
        MOV      R1,R0
        ADD      R0,R4,#+1896
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+100
        MOVS     R1,#+0
        ADDW     R0,R4,#+1916
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+0
        STRH     R0,[R5, #+52]
        STRH     R0,[R5, #+22]
        STRH     R0,[R5, #+26]
        STRB     R0,[R4, #+2788]
        STRB     R0,[R5, #+20]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock106

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195:
        DC32     thermalManager

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_1:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock107 Using cfiCommon0
          CFI Function _Z14mks_WriteToEprv
        THUMB
// __interwork __softfp void mks_WriteToEpr()
_Z14mks_WriteToEprv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.W    R4,??DataTable212_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R4, #+2080]
        ADDW     R5,R4,#+2080
        MOVS     R2,#+4
        MOV      R1,R5
        MOVW     R0,#+1201
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable213_1
        LDR      R0,[R6, #+0]
        STRH     R0,[R5, #+18]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2098
        MOVW     R0,#+1205
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R7,??DataTable212_2
        LDRB     R0,[R7, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_WriteToEpr_0
        LDR      R0,[R6, #+4]
        STRH     R0,[R5, #+20]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2100
        MOVW     R0,#+1207
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_0:
        LDRB     R0,[R7, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_WriteToEpr_1
        LDR.W    R0,??DataTable213_2
        LDRH     R0,[R0, #+0]
        STRH     R0,[R5, #+22]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2102
        MOVW     R0,#+1209
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_1:
        MOVS     R2,#+4
        ADDW     R1,R4,#+2036
        MOVW     R0,#+1211
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2040
        MOVW     R0,#+1215
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2044
        MOVW     R0,#+1219
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2048
        MOVW     R0,#+1223
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2052
        MOVW     R0,#+1227
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2056
        MOVW     R0,#+1231
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2060
        MOVW     R0,#+1235
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2064
        MOVW     R0,#+1239
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.N    R5,??DataTable196_6
        MOVS     R2,#+2
        ADDS     R1,R5,#+2
        MOV      R0,#+1264
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+2108
        MOVW     R0,#+1247
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2104
        MOVW     R0,#+1243
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        LDR.W    R1,??DataTable216
        MOVW     R0,#+1268
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock107

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196:
        DC32     0x42220194

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_1:
        DC32     0x408f4000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_2:
        DC32     0x40590000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_3:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_4:
        DC32     filament_rate

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_5:
        DC32     temperature_change_frequency

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_6:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_7:
        DC32     poweroff_det_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_8:
        DC32     poweroff_det_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196_9:
        DC32     filament_det1_flg

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock108 Using cfiCommon0
          CFI Function mks_ReadFromEpr
        THUMB
// __interwork __softfp void mks_ReadFromEpr()
mks_ReadFromEpr:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R5,??DataTable212_1
        MOVS     R2,#+100
        ADDW     R1,R5,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVW     R0,#+1201
        LDR.W    R4,??DataTable215_1
        LDRB     R1,[R4, #+415]
        CMP      R1,#+1
        BEQ.N    ??mks_ReadFromEpr_0
        MOVS     R2,#+4
        ADD      R1,R5,#+2080
          CFI FunCall epr_read_data
        BL       epr_read_data
        B.N      ??mks_ReadFromEpr_1
??mks_ReadFromEpr_0:
        MOVS     R2,#+4
        ADDW     R1,R5,#+2088
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2084
        MOVW     R0,#+1269
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_1:
        MOVS     R2,#+2
        ADDW     R1,R5,#+2098
        MOVW     R0,#+1205
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R6,??DataTable212_2
        LDRB     R0,[R6, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_ReadFromEpr_2
        MOVS     R2,#+2
        ADDW     R1,R5,#+2100
        MOVW     R0,#+1207
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_2:
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromEpr_3
        MOVS     R2,#+2
        ADDW     R1,R5,#+2102
        MOVW     R0,#+1209
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_3:
        MOVS     R2,#+4
        ADDW     R1,R5,#+2036
        MOVW     R0,#+1211
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2040
        MOVW     R0,#+1215
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2044
        MOVW     R0,#+1219
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2048
        MOVW     R0,#+1223
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2052
        MOVW     R0,#+1227
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2056
        MOVW     R0,#+1231
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2060
        MOVW     R0,#+1235
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2064
        MOVW     R0,#+1239
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R6,??DataTable216_1
        MOVS     R2,#+2
        ADDS     R1,R6,#+2
        MOV      R0,#+1264
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R5,#+2108
        MOVW     R0,#+1247
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2104
        MOVW     R0,#+1243
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R5,??DataTable217_1
        MOVS     R2,#+1
        ADDS     R1,R5,#+3
        MOVW     R0,#+1268
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRSB    R0,[R5, #+3]
        STRB     R0,[R4, #+156]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197:
        DC32     filament_det1_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197_1:
        DC32     filament_det1_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197_2:
        DC32     filament_det1_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197_3:
        DC32     filament_det1_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197_4:
        DC32     filament_det1_high_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock109 Using cfiCommon0
          CFI Function mks_resumePrint
        THUMB
// __interwork __softfp void mks_resumePrint()
mks_resumePrint:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable212_1
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+170
        BNE.N    ??mks_resumePrint_0
        MOVS     R0,#+167
        STRB     R0,[R4, #+2076]
        LDR      R0,[R4, #+2028]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        ADDW     R0,R4,#+2028
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOVS     R1,#+0
        ADDW     R0,R4,#+1916
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
??mks_resumePrint_0:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+171
        BNE.N    ??mks_resumePrint_1
        MOVS     R0,#+172
        STRB     R0,[R4, #+2076]
??mks_resumePrint_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock109

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198:
        DC32     filament_det2_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_1:
        DC32     filament_det2_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_2:
        DC32     filament_det2_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_3:
        DC32     filament_det2_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_4:
        DC32     filament_det2_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_5:
        DC32     filament_det2_high_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock110 Using cfiCommon0
          CFI Function mks_pausePrint
        THUMB
// __interwork __softfp void mks_pausePrint()
mks_pausePrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.W    R4,??DataTable212_1
        ADDW     R5,R4,#+2016
        LDR.W    R0,??DataTable217_1
        LDR      R1,[R0, #+8]
        STR      R1,[R5, #+20]
        LDR      R1,[R0, #+12]
        STR      R1,[R5, #+24]
        LDR      R1,[R0, #+16]
        STR      R1,[R5, #+28]
        LDR      R1,[R0, #+20]
        STR      R1,[R5, #+32]
        LDR      R1,[R0, #+24]
        STR      R1,[R5, #+36]
        LDR      R1,[R0, #+28]
        STR      R1,[R5, #+40]
        LDR      R1,[R0, #+32]
        STR      R1,[R5, #+44]
        LDR      R1,[R0, #+36]
        STR      R1,[R5, #+48]
        LDR      R1,[R0, #+108]
        STRB     R1,[R4, #+2108]
        LDR      R0,[R0, #+92]
        STR      R0,[R5, #+88]
        MOV      R0,#-1073741824
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R0,[R5, #+8]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR      R1,[R5, #+4]
        LDR      R0,[R4, #+2016]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14mks_WriteToEprv
        B.N      _Z14mks_WriteToEprv
          CFI EndBlock cfiBlock110

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199:
        DC32     poweroff_det_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_1:
        DC32     poweroff_det_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_2:
        DC32     poweroff_det_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_3:
        DC32     poweroff_det_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_4:
        DC32     wifi_check_time

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
filament_loading_time_flg:
        DS8 1
filament_loading_completed:
        DS8 1
filament_unloading_time_flg:
        DS8 1
filament_unloading_completed:
        DS8 1
printing_rate_update_flag:
        DS8 1
preview_no_display:
        DS8 1
loop_start:
        DS8 1
        DS8 1
        DS8 1
sd_read_error_flg:
        DS8 1
sd_read_cnt:
        DS8 1
display_hold:
        DS8 1
display_hold_release:
        DS8 1
wifi_init_flg:
        DS8 1
wifi_refresh_flg:
        DS8 1
cloud_refresh_flg:
        DS8 1
waiting_wifi_time:
        DS8 1
beep_flg:
        DS8 1
// __absolute uint8_t print_finish_start_timer
print_finish_start_timer:
        DS8 1
// __absolute uint8_t print_finish_close_machine
print_finish_close_machine:
        DS8 1
        DS8 4
z_high_count:
        DS8 2
        DS8 2
        DS8 4
filament_loading_time_cnt:
        DS8 4
filament_unloading_time_cnt:
        DS8 4
TimeIncrease:
        DS8 4
home_offset:
        DS8 12
display_hold_cnt:
        DS8 4
beep_cnt:
        DS8 4
// __absolute uint32_t print_finish_timer_count
print_finish_timer_count:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
filament_heat_completed_load:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
filament_heat_completed_unload:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
g26_debug_flag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
card:
        DS8 1896
// __absolute DATA_REPRINT_ITMES mksReprint
mksReprint:
        DS8 896
print_job_timer:
        DS8 16

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
command_queue:
        DS8 384

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
injected_commands_P:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
saved_feedrate_percentage:
        DS8 2
        DS8 2
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
z_endstop_adj:
        DS8 4
delta_endstop_adj:
        DS8 12

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
hotend_offset:
        DS8 24

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
z_values:
        DS8 576

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
home_dir_P:
        DS8 4
base_min_pos_P:
        DS8 12
base_max_pos_P:
        DS8 12
base_home_pos_P:
        DS8 12
max_length_P:
        DS8 12
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
filament_ran_out:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE18serial_line_buffer
_ZZ19get_serial_commandsvE18serial_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_serial_commandsvE19serial_comment_mode
_ZZ19get_serial_commandsvE19serial_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE14last_wait_time
_ZZ19get_serial_commandsvE14last_wait_time:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE14stop_buffering
_ZZ19get_sdcard_commandsvE14stop_buffering:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE15sd_comment_mode
_ZZ19get_sdcard_commandsvE15sd_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvE16wifi_line_buffer
_ZZ17get_wifi_commandsvE16wifi_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ17get_wifi_commandsvE17wifi_comment_mode
_ZZ17get_wifi_commandsvE17wifi_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
_ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
// __absolute unsigned char prepare_kinematic_move_to(float const (&)[4]){9}::_ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
_ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
_ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
??C2:
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
button_disp_pause_state:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
wifi_init_state:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
// __absolute uint8_t continue_print_error_flg
continue_print_error_flg:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t1
t1:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t2
t2:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute char t12[10]
t12:
        DS8 12

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock111 Using cfiCommon0
          CFI Function mks_PrintStatePolling
        THUMB
// __interwork __softfp void mks_PrintStatePolling()
mks_PrintStatePolling:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.W    R4,??DataTable212_1
        ADDW     R6,R4,#+2024
        ADDW     R5,R4,#+2076
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+169
        BNE.N    ??mks_PrintStatePolling_0
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        CMP      R0,#+101
        BCC.N    ??mks_PrintStatePolling_1
        LDR      R0,[R6, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+8]
??mks_PrintStatePolling_1:
        LDR      R0,[R6, #+8]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_2
        MOVS     R0,#+170
        STRB     R0,[R4, #+2076]
        LDR.W    R0,??DataTable215_1
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_3
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_3:
        MOVS     R0,#+0
        STR      R0,[R6, #+8]
          CFI FunCall mks_pausePrint
        BL       mks_pausePrint
        B.N      ??mks_PrintStatePolling_2
??mks_PrintStatePolling_0:
        MOVS     R0,#+0
        STR      R0,[R6, #+8]
??mks_PrintStatePolling_2:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+170
        BNE.N    ??mks_PrintStatePolling_4
        LDR.W    R8,??DataTable217_3  ;; 0x38d1b718
        LDR.W    R7,??DataTable217_1
        LDR      R0,[R6, #+12]
        LDR      R1,[R7, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_5
        LDR      R0,[R7, #+8]
        STR      R0,[R6, #+12]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2036
        MOVW     R0,#+1211
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_5:
        LDR      R0,[R6, #+16]
        LDR      R1,[R7, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_6
        LDR      R0,[R7, #+12]
        STR      R0,[R6, #+16]
        MOVS     R2,#+4
        ADD      R1,R4,#+2040
        MOVW     R0,#+1215
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_6:
        LDR      R0,[R6, #+20]
        LDR      R1,[R7, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_4
        LDR      R0,[R7, #+16]
        STR      R0,[R6, #+20]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2044
        MOVW     R0,#+1219
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_4:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+168
        BNE.N    ??mks_PrintStatePolling_7
        LDR.W    R0,??DataTable217_4
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_PrintStatePolling_7
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        LDR      R0,[R6, #+4]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R6, #+32]
        LDR      R0,[R6, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+173
        BNE.N    ??mks_PrintStatePolling_8
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        B.N      ??mks_PrintStatePolling_9
??mks_PrintStatePolling_8:
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADDW     R0,R4,#+2792
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??mks_PrintStatePolling_7:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_10
        LDRB     R0,[R4, #+1888]
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_11
        LDRH     R0,[R5, #+52]
        ADDS     R0,R0,#+1
        STRH     R0,[R5, #+52]
        B.N      ??mks_PrintStatePolling_12
??mks_PrintStatePolling_11:
        MOVS     R0,#+0
        STRH     R0,[R5, #+52]
??mks_PrintStatePolling_12:
        LDRH     R0,[R5, #+52]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_10
        MOVS     R0,#+0
        STRH     R0,[R5, #+52]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2076]
        LDR.W    R8,??DataTable215_1
        LDRB     R0,[R8, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_13
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall mks_clearFile
        BL       mks_clearFile
??mks_PrintStatePolling_13:
        LDRB     R0,[R8, #+217]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_10
        LDR.W    R0,??DataTable217_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_10
        MOVS     R0,#+1
        LDR.W    R1,??DataTable219
        STRB     R0,[R1, #+18]
??mks_PrintStatePolling_10:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+173
        BNE.N    ??mks_PrintStatePolling_14
        MOVS     R0,#+166
        STRB     R0,[R4, #+2076]
        LDR.W    R8,??DataTable215_1
        LDRB     R0,[R8, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_15
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_15:
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        LDR.W    R7,??DataTable217_1
        LDR      R0,[R7, #+32]
        STR      R0,[R6, #+36]
        LDR      R0,[R4, #+2024]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR.W    R0,??DataTable218
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        ADDW     R0,R4,#+2792
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        MOVS     R0,#+0
        LDR.W    R1,??DataTable220  ;; 0x40000440
        B.N      ??mks_PrintStatePolling_16
??mks_PrintStatePolling_17:
        MOVS     R0,#+0
        STR      R0,[R7, #+108]
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??mks_PrintStatePolling_16:
        CMP      R0,#+0
        BEQ.N    ??mks_PrintStatePolling_17
        MOVS     R0,#+0
        STRB     R0,[R7, #+4]
        LDRB     R0,[R8, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_14
          CFI FunCall mks_clearFile
        BL       mks_clearFile
??mks_PrintStatePolling_14:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+172
        BNE.N    ??mks_PrintStatePolling_18
        LDR.W    R0,??DataTable212_2
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_19
        CMP      R0,#+2
        BEQ.N    ??mks_PrintStatePolling_20
        CMP      R0,#+4
        BEQ.N    ??mks_PrintStatePolling_19
        CMP      R0,#+8
        BNE.N    ??mks_PrintStatePolling_18
??mks_PrintStatePolling_19:
        LDRSB    R0,[R4, #+2788]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_21
          CFI FunCall mks_contiuePrintPause
        BL       mks_contiuePrintPause
        B.N      ??mks_PrintStatePolling_18
??mks_PrintStatePolling_21:
        CMP      R0,#+2
        BNE.N    ??mks_PrintStatePolling_18
          CFI FunCall mks_contiuePrintPwdwn
        BL       mks_contiuePrintPwdwn
        B.N      ??mks_PrintStatePolling_18
??mks_PrintStatePolling_20:
          CFI FunCall mks_contiuePrintDelta
        BL       mks_contiuePrintDelta
??mks_PrintStatePolling_18:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_22
        LDRB     R0,[R4, #+1888]
        LDRB     R1,[R5, #+20]
        TST      R0,R1
        BEQ.N    ??mks_PrintStatePolling_22
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        CMP      R0,#+101
        BCC.N    ??mks_PrintStatePolling_23
          CFI FunCall mks_WriteToFile
        BL       mks_WriteToFile
??mks_PrintStatePolling_23:
        MOVS     R0,#+0
        STRB     R0,[R5, #+20]
??mks_PrintStatePolling_22:
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+166
        BNE.N    ??mks_PrintStatePolling_9
        LDR.W    R0,??DataTable219
        LDRB     R1,[R0, #+19]
        CMP      R1,#+1
        BNE.N    ??mks_PrintStatePolling_9
        MOVS     R1,#+0
        STRB     R1,[R0, #+19]
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z21Close_machine_displayv
        B.W      _Z21Close_machine_displayv
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_PrintStatePolling_9:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200:
        DC32     0x76313030

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock112 Using cfiCommon0
          CFI Function _Z18mks_setTemperaturev
        THUMB
// __interwork __softfp void mks_setTemperature()
_Z18mks_setTemperaturev:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+24
          CFI CFA R13+56
        LDR.W    R4,??DataTable212_1
        ADDW     R5,R4,#+2098
        LDR.W    R6,??DataTable212_2
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_0
        LDRH     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_0
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R7,R4,#+2130
        MOVS     R2,#+7
        ADR.W    R1,`?<Constant "M140 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+4]
        ADR.N    R1,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
??mks_setTemperature_0:
        LDRH     R0,[R4, #+2098]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_1
        ADDW     R7,R4,#+2130
        ADDW     R8,R4,#+2130
        MOV      R9,#+10
        ADR.W    R10,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
        LDRB     R0,[R6, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_setTemperature_2
        MOVS     R2,#+96
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        MOV      R2,R9
        ADR.W    R1,`?<Constant "M104 T1 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        MOV      R1,R10
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
??mks_setTemperature_2:
        MOVS     R2,#+96
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        MOV      R2,R9
        ADR.W    R1,`?<Constant "M109 T0 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R4, #+2098]
        MOV      R1,R10
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
??mks_setTemperature_1:
        LDRB     R0,[R6, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_setTemperature_3
        LDRH     R0,[R5, #+2]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_3
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R7,R4,#+2130
        MOVS     R2,#+10
        ADR.W    R1,`?<Constant "M109 T1 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        ADR.N    R1,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
??mks_setTemperature_3:
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_4
        LDRH     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_4
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R7,R4,#+2130
        MOVS     R2,#+7
        ADR.W    R1,`?<Constant "M190 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+4]
        ADR.N    R1,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
??mks_setTemperature_4:
        ADD      SP,SP,#+24
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock112

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M140 S">`:
        DC8 "M140 S"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M104 T1 S">`:
        DC8 "M104 T1 S"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M109 T0 S">`:
        DC8 "M109 T0 S"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M109 T1 S">`:
        DC8 "M109 T1 S"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M190 S">`:
        DC8 "M190 S"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function mks_setPositionZ
        THUMB
// __interwork __softfp void mks_setPositionZ()
mks_setPositionZ:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        LDR.W    R4,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R5,R4,#+2130
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R4, #+2044]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        MOVS     R0,#+0
        LDR.W    R1,??DataTable217_1
        STR      R0,[R1, #+76]
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock113

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function _Z18mks_ResetPositionZf
        THUMB
// __interwork __softfp void mks_ResetPositionZ(float)
_Z18mks_ResetPositionZf:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        LDR.W    R5,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R5,R5,#+2130
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        MOVS     R0,#+0
        LDR.W    R1,??DataTable217_1
        STR      R0,[R1, #+76]
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock114

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G92 Z">`:
        DC8 "G92 Z"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function _Z15mks_setFeedratev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setFeedrate()
_Z15mks_setFeedratev:
        LDR.W    R0,??DataTable212_1
        LDR      R0,[R0, #+2104]
        LDR.W    R1,??DataTable217_1
        STR      R0,[R1, #+92]
        BX       LR               ;; return
          CFI EndBlock cfiBlock115

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function mks_preExtrude
        THUMB
// __interwork __softfp void mks_preExtrude(float)
mks_preExtrude:
        PUSH     {R4-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOV      R9,R0
        LDR.W    R4,??DataTable221_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+5]
        LDR.W    R5,??DataTable212_1
        ADDW     R8,R5,#+2130
        MOVS     R2,#+96
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        ADDW     R6,R5,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 E">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R7,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
        MOVS     R2,#+96
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 E">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R5, #+2064]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        ADD      SP,SP,#+20
          CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
          CFI EndBlock cfiBlock116

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable205:
        DC32     0x494949

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 E">`:
        DC8 "G1 E"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G92 E">`:
        DC8 "G92 E"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function mks_moveXY
        THUMB
// __interwork __softfp void mks_moveXY(float, float)
mks_moveXY:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R4,R1
        LDR.N    R6,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R6,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R6,R6,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 X">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R7,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable212  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock117

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable206:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable206_1:
        DC32     0xaaaaaa

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function mks_home_moveXY
        THUMB
// __interwork __softfp void mks_home_moveXY(float, float, float)
mks_home_moveXY:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+28
          CFI CFA R13+48
        MOV      R6,R0
        MOV      R4,R1
        MOV      R5,R2
        LDR.N    R7,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R7,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R7,R7,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 X">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+4
          CFI FunCall memset
        BL       memset
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f">`
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable212  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+4
          CFI FunCall memset
        BL       memset
        MOV      R0,R5
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+0]
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f F%d">`
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+28
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock118

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207:
        DC32     wifiPara

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207_1:
        DC32     ipPara

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "%.3f F%d">`:
        DC8 "%.3f F%d"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function mks_home_moveZ
        THUMB
// __interwork __softfp void mks_home_moveZ(float)
mks_home_moveZ:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        LDR.N    R5,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R5,R5,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable208:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function mks_moveZ
        THUMB
// __interwork __softfp void mks_moveZ(float)
mks_moveZ:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+24
          CFI CFA R13+40
        MOV      R4,R0
        LDR.N    R5,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R6,R5,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R5, #+2060]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable215  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock120

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function _Z18mks_moveZ_relativef
        THUMB
// __interwork __softfp void mks_moveZ_relative(float)
_Z18mks_moveZ_relativef:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+24
          CFI CFA R13+40
        MOV      R5,R0
        LDR.W    R4,??DataTable221_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+5]
        LDR.N    R6,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R6,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R6,R6,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable215  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock121

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210:
        DC32     DeviceCode

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function _Z7mks_G28Pc
        THUMB
// __interwork __softfp void mks_G28(char *)
_Z7mks_G28Pc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R5,R5,#+2130
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
        LDR.N    R4,??DataTable212_2
        LDRB     R0,[R4, #+64]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??mks_G28_0
        CMP      R0,#+16
        BEQ.N    ??mks_G28_0
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+2
        BEQ.N    ??mks_G28_0
        LDRB     R0,[R4, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??mks_G28_0
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??mks_G28_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+1
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17set_z_fade_heightfb
        B.W      _Z17set_z_fade_heightfb
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_G28_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock122

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable211:
        DC32     BMP_PIC_X

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function _Z18mks_leveling_moveZf
        THUMB
// __interwork __softfp void mks_leveling_moveZ(float)
_Z18mks_leveling_moveZf:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.N    R5,??DataTable212_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R6,R5,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall memset
        BL       memset
        LDR.W    R0,??DataTable225_1
        LDR      R1,[R0, #+8]
        LDR.W    R0,??DataTable226_1  ;; 0x42700000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        LDR      R0,[R5, #+2060]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f F%.3f">`
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable212:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable212_1:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable212_2:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z">`:
        DC8 "G1 Z"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function _Z19mks_leveling_moveXYff
        THUMB
// __interwork __softfp void mks_leveling_moveXY(float, float)
_Z19mks_leveling_moveXYff:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R5,R0
        MOV      R4,R1
        LDR.W    R6,??DataTable225_2
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R6,#+2130
          CFI FunCall memset
        BL       memset
        ADDW     R6,R6,#+2130
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 X">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall memset
        BL       memset
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f">`
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable217  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall memset
        BL       memset
        LDR.W    R0,??DataTable228
        LDR      R0,[R0, #+36]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f F%.3f">`
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock124

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable213:
        DC32     BMP_PIC_Y

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable213_1:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable213_2:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 X">`:
        DC8 "G1 X"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "%.3f">`:
        DC8 "%.3f"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "%.3f F%.3f">`:
        DC8 "%.3f F%.3f"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function mks_manual_leveling
        THUMB
// __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
mks_manual_leveling:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R0,??DataTable225_3
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_manual_leveling_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        ADR.N    R0,??DataTable217_2  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
??mks_manual_leveling_0:
        LDR.N    R0,??DataTable217_1
        LDR      R0,[R0, #+16]
        LDR.W    R1,??DataTable225_2
        STR      R0,[R1, #+2060]
        LDR.W    R0,??DataTable229  ;; 0x41200000
          CFI FunCall _Z18mks_leveling_moveZf
        BL       _Z18mks_leveling_moveZf
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R5,R1
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _Z19mks_leveling_moveXYff
        BL       _Z19mks_leveling_moveXYff
        ADR.W    R0,`?<Constant "G1 Z0">`
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        B.W      _Z27enqueue_and_echo_commands_PPKc
          CFI EndBlock cfiBlock125

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable214:
        DC32     0x40a00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z0">`:
        DC8 "G1 Z0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function mks_contiuePrintPause
        THUMB
// __interwork __softfp void mks_contiuePrintPause()
mks_contiuePrintPause:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable225_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        ADR.W    R0,`?<Constant "G28 X0 Y0">`
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPause_0
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        POP      {R4,PC}
??mks_contiuePrintPause_0:
        LDR      R0,[R4, #+2028]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        ADDW     R0,R4,#+2028
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
        LDRB     R0,[R4, #+2108]
        LDR.N    R1,??DataTable217_1
        STR      R0,[R1, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable220  ;; 0x40000440
        STR      R0,[R1, #+0]
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPause_1
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        POP      {R4,PC}
??mks_contiuePrintPause_1:
        MOVS     R0,#+167
        STRB     R0,[R4, #+2076]
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock126

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable215:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable215_1:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function mks_contiuePrintPwdwn
        THUMB
// __interwork __softfp void mks_contiuePrintPwdwn()
mks_contiuePrintPwdwn:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable225_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
        MOVS     R2,#+0
        MOV      R1,#+256
        LDR.W    R0,??DataTable228_1  ;; 0x40010c00
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R2,#+0
        MOVS     R1,#+8
        LDR.W    R0,??DataTable228_2  ;; 0x40010800
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        LDR      R0,[R4, #+2024]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        ADR.W    R0,`?<Constant "G28 X0 Y0">`
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPwdwn_0
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        POP      {R0,R4,R5,PC}
??mks_contiuePrintPwdwn_0:
        ADDW     R5,R4,#+2024
        LDR.W    R0,??DataTable228
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??mks_contiuePrintPwdwn_1
        LDR      R0,[R5, #+20]
        LDR      R1,[R4, #+2024]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall _Z18mks_ResetPositionZf
        BL       _Z18mks_ResetPositionZf
??mks_contiuePrintPwdwn_1:
        MOVW     R0,#+3000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        LDR      R0,[R5, #+4]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+32]
        LDR      R0,[R5, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
        LDRB     R0,[R4, #+2108]
        LDR.N    R1,??DataTable217_1
        STR      R0,[R1, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable220  ;; 0x40000440
        STR      R0,[R1, #+0]
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPwdwn_2
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        POP      {R0,R4,R5,PC}
??mks_contiuePrintPwdwn_2:
        MOVS     R0,#+167
        STRB     R0,[R4, #+2076]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R4, #+2096]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock127

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable216:
        DC32     mks_heating_busy+0x3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable216_1:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G28 X0 Y0">`:
        DC8 "G28 X0 Y0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock128 Using cfiCommon0
          CFI Function mks_contiuePrintDelta
        THUMB
// __interwork __softfp void mks_contiuePrintDelta()
mks_contiuePrintDelta:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable225_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        ADR.N    R0,??DataTable217_2  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDR      R0,[R4, #+2024]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        ADDW     R5,R4,#+2024
        LDR      R0,[R5, #+4]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+32]
        LDR      R0,[R5, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
        LDRB     R0,[R4, #+2108]
        LDR.N    R1,??DataTable217_1
        STR      R0,[R1, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable220  ;; 0x40000440
        STR      R0,[R1, #+0]
        MOVS     R0,#+167
        STRB     R0,[R4, #+2076]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R4, #+2096]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock128

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217_1:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217_2:
        DC8      "G28"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217_3:
        DC32     0x38d1b718

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217_4:
        DC32     pause_resum

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217_5:
        DC32     IsChooseAutoShutdown

        SECTION `.data`:DATA:REORDER:NOROOT(0)
// static __absolute uint8_t first_resu
first_resu:
        DATA
        DC8 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock129 Using cfiCommon0
          CFI Function mks_getPositionXYZE
        THUMB
// __interwork __softfp void mks_getPositionXYZE()
mks_getPositionXYZE:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+24
          CFI CFA R13+56
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
        LDR.W    R0,??DataTable230
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_getPositionXYZE_0
        LDR.W    R4,??DataTable225_2
        ADDW     R5,R4,#+2044
        LDR      R1,[R5, #+36]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
          CFI FunCall _Z19get_sdcard_commandsv
        BL       _Z19get_sdcard_commandsv
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        STRB     R0,[R4, #+2096]
        LDR.W    R6,??DataTable226_2
        MOV      R2,R0
        B.N      ??mks_getPositionXYZE_1
??mks_getPositionXYZE_2:
        ADD      R1,R6,R0, LSL #+2
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+24]
        ADDS     R0,R0,#+1
??mks_getPositionXYZE_1:
        CMP      R0,#+4
        BLT.N    ??mks_getPositionXYZE_2
        MOV      R7,R2
        B.N      ??mks_getPositionXYZE_3
??mks_getPositionXYZE_4:
        ADD      R2,R4,R3, LSL #+2
        LDR      R0,[R2, #+2052]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_5
        LDR.W    R6,??DataTable226_2
        ADD      R6,R6,R3, LSL #+2
        LDR      R0,[R6, #+24]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_getPositionXYZE_5
        LDR      R0,[R6, #+24]
        STR      R0,[R2, #+2052]
??mks_getPositionXYZE_5:
        ADDS     R3,R3,#+1
??mks_getPositionXYZE_6:
        CMP      R3,#+4
        BLT.N    ??mks_getPositionXYZE_4
        ADDS     R7,R7,#+1
??mks_getPositionXYZE_3:
        CMP      R7,#+4
        BGE.N    ??mks_getPositionXYZE_7
        CMP      R7,#+0
        BNE.N    ??mks_getPositionXYZE_8
        LDR.W    R0,??DataTable230_1
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_getPositionXYZE_8
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        MOVS     R1,#+90
        LDR.W    R0,??DataTable230_2
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        ADD      R3,SP,#+4
        BEQ.N    ??mks_getPositionXYZE_9
??mks_getPositionXYZE_10:
        LDRSB    R1,[R0], #+1
        CMP      R1,#+0
        BEQ.N    ??mks_getPositionXYZE_11
        LDRSB    R1,[SP, #+0]
        ADDS     R2,R1,#+1
        STRB     R2,[SP, #+0]
        LDRB     R2,[R0, #+0]
        STRB     R2,[R1, R3]
        LDRSB    R1,[SP, #+0]
        CMP      R1,#+21
        BLT.N    ??mks_getPositionXYZE_10
??mks_getPositionXYZE_11:
        ADD      R0,SP,#+4
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??DataTable226_2
        STR      R0,[R1, #+32]
        B.N      ??mks_getPositionXYZE_9
??mks_getPositionXYZE_8:
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable230_2
        ADD      R0,R1,R0, LSL #+5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
??mks_getPositionXYZE_9:
        MOVS     R3,#+0
        LDR.W    R1,??DataTable230_3  ;; 0x38d1b718
        B.N      ??mks_getPositionXYZE_6
??mks_getPositionXYZE_7:
        LDR      R0,[R5, #+16]
        STR      R0,[R4, #+2044]
        LDR      R0,[R5, #+20]
        STR      R0,[R5, #+4]
        B.N      ??mks_getPositionXYZE_12
??mks_getPositionXYZE_0:
        MOVS     R0,#+0
        LDR.W    R6,??DataTable226_2
        MOV      R2,R0
        B.N      ??mks_getPositionXYZE_13
??mks_getPositionXYZE_14:
        ADD      R1,R6,R0, LSL #+2
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+24]
        ADDS     R0,R0,#+1
??mks_getPositionXYZE_13:
        CMP      R0,#+4
        BLT.N    ??mks_getPositionXYZE_14
        LDR.W    R4,??DataTable225_2
        ADDW     R5,R4,#+2044
        LDR      R1,[R5, #+40]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        B.N      ??mks_getPositionXYZE_15
??mks_getPositionXYZE_16:
        LDR      R0,[R5, #+16]
        STR      R0,[R4, #+2044]
        LDR      R0,[R5, #+20]
        STR      R0,[R5, #+4]
??mks_getPositionXYZE_15:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        LDR      R1,[R5, #+44]
        CMP      R0,R1
        BCS.N    ??mks_getPositionXYZE_17
        MOVS     R0,#+0
        STRB     R0,[R6, #+2]
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
          CFI FunCall _Z19get_sdcard_commandsv
        BL       _Z19get_sdcard_commandsv
        MOVS     R7,#+0
        B.N      ??mks_getPositionXYZE_18
??mks_getPositionXYZE_19:
        ADDS     R7,R7,#+1
??mks_getPositionXYZE_18:
        CMP      R7,#+4
        BGE.N    ??mks_getPositionXYZE_16
        CMP      R7,#+0
        BNE.N    ??mks_getPositionXYZE_20
        LDR.W    R0,??DataTable230_1
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_getPositionXYZE_20
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        MOVS     R1,#+90
        LDR.W    R0,??DataTable230_2
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        ADD      R3,SP,#+4
        BEQ.N    ??mks_getPositionXYZE_21
??mks_getPositionXYZE_22:
        LDRSB    R1,[R0], #+1
        CMP      R1,#+0
        BEQ.N    ??mks_getPositionXYZE_23
        LDRSB    R1,[SP, #+0]
        ADDS     R2,R1,#+1
        STRB     R2,[SP, #+0]
        LDRB     R2,[R0, #+0]
        STRB     R2,[R1, R3]
        LDRSB    R1,[SP, #+0]
        CMP      R1,#+21
        BLT.N    ??mks_getPositionXYZE_22
??mks_getPositionXYZE_23:
        ADD      R0,SP,#+4
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+32]
        B.N      ??mks_getPositionXYZE_21
??mks_getPositionXYZE_20:
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable230_2
        ADD      R0,R1,R0, LSL #+5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
??mks_getPositionXYZE_21:
        MOV      R8,#+0
        B.N      ??mks_getPositionXYZE_24
??mks_getPositionXYZE_25:
        MOVS     R0,#+0
??mks_getPositionXYZE_26:
          CFI FunCall abs
        BL       abs
        CMP      R0,#+0
        BEQ.N    ??mks_getPositionXYZE_27
        LDR      R0,[R10, #+24]
        STR      R0,[R9, #+2052]
??mks_getPositionXYZE_27:
        ADD      R8,R8,#+1
??mks_getPositionXYZE_24:
        CMP      R8,#+4
        BGE.N    ??mks_getPositionXYZE_19
        ADD      R9,R4,R8, LSL #+2
        LDR.W    R1,??DataTable230_3  ;; 0x38d1b718
        LDR      R0,[R9, #+2052]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_28
        ADD      R10,R6,R8, LSL #+2
        LDR      R0,[R10, #+24]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_getPositionXYZE_28
        LDR      R0,[R10, #+24]
        STR      R0,[R9, #+2052]
??mks_getPositionXYZE_28:
        CMP      R8,#+2
        BEQ.N    ??mks_getPositionXYZE_27
        ADD      R10,R6,R8, LSL #+2
        LDR      R0,[R10, #+24]
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_getPositionXYZE_25
        MOVS     R0,#+1
        B.N      ??mks_getPositionXYZE_26
??mks_getPositionXYZE_17:
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        STRB     R0,[R4, #+2096]
??mks_getPositionXYZE_12:
        MOVS     R0,#+0
        LDR.W    R6,??DataTable226_2
        MOV      R2,R0
        B.N      ??mks_getPositionXYZE_29
??mks_getPositionXYZE_30:
        ADD      R1,R6,R0, LSL #+2
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+24]
        ADDS     R0,R0,#+1
??mks_getPositionXYZE_29:
        CMP      R0,#+4
        BLT.N    ??mks_getPositionXYZE_30
        MOV      R4,R2
        B.N      ??mks_getPositionXYZE_31
??mks_getPositionXYZE_32:
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADD      R0,R4,R4, LSL #+1
        LDR.W    R3,??DataTable230_2
        ADD      R0,R3,R0, LSL #+5
          CFI FunCall memset
        BL       memset
        ADDS     R4,R4,#+1
??mks_getPositionXYZE_31:
        CMP      R4,#+4
        BLT.N    ??mks_getPositionXYZE_32
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
        ADD      SP,SP,#+24
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock129

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable218:
        DC32     `?<Constant "G28 X0 Y0">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock130 Using cfiCommon0
          CFI Function mks_clearDir
        THUMB
// __interwork __softfp void mks_clearDir()
mks_clearDir:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+32
          CFI CFA R13+40
        LDR.W    R4,??DataTable230_4
        B.N      ??mks_clearDir_0
??mks_clearDir_1:
        ADDS     R1,R0,#+1
        ADD      R0,SP,#+0
          CFI FunCall strcpy
        BL       strcpy
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcpy
        BL       strcpy
??mks_clearDir_0:
        ADR.N    R1,??DataTable221  ;; "/"
        MOV      R0,R4
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??mks_clearDir_1
        ADD      SP,SP,#+32
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock130

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable219:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock131 Using cfiCommon0
          CFI Function mks_contiuePrint_UI
        THUMB
// __interwork __softfp void mks_contiuePrint_UI()
mks_contiuePrint_UI:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "Resume print?">`
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.W    R4,??DataTable225_2
        ADDW     R5,R4,#+1916
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R1,R5
        LDR.W    R0,??DataTable230_5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10isFileOpenEv
        BL       _ZN10CardReader10isFileOpenEv
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_0
        MOV      R0,#+1200
          CFI FunCall _Z6Beeperj
        BL       _Z6Beeperj
        MOVS     R0,#+2
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_dialog
        B.W      draw_dialog
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_0:
        ADDW     R6,R4,#+2076
        LDR      R0,[R6, #+4]
        CMP      R0,#+101
        BCS.N    ??mks_contiuePrint_UI_1
        LDR      R0,[R6, #+12]
        CMP      R0,#+101
        BCC.N    ??mks_contiuePrint_UI_2
??mks_contiuePrint_UI_1:
        MOVS     R2,#+100
        ADDW     R1,R4,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        LDRSB    R0,[R4, #+2788]
        CMP      R0,#+2
        BNE.N    ??mks_contiuePrint_UI_3
          CFI FunCall mks_getPositionXYZE
        BL       mks_getPositionXYZE
??mks_contiuePrint_UI_3:
        LDR.W    R5,??DataTable230
        LDRB     R0,[R5, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_contiuePrint_UI_4
        LDR      R1,[R6, #+4]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        B.N      ??mks_contiuePrint_UI_5
??mks_contiuePrint_UI_4:
        LDR      R1,[R6, #+12]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??mks_contiuePrint_UI_5:
        LDR.W    R0,??DataTable226_2
        LDR      R1,[R4, #+2036]
        STR      R1,[R0, #+8]
        ADDW     R1,R4,#+2036
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+12]
        LDR      R1,[R1, #+8]
        STR      R1,[R0, #+16]
        LDRB     R0,[R5, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_contiuePrint_UI_6
          CFI FunCall mks_clearDir
        BL       mks_clearDir
??mks_contiuePrint_UI_6:
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable230_6
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable230_7
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCS.N    ??mks_contiuePrint_UI_7
        LDRSB    R0,[R5, #+186]
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_6
??mks_contiuePrint_UI_7:
        LDR.W    R4,??DataTable230_8
        MOVS     R2,#+1
        MOV      R1,R4
        MOV      R0,#+1792
          CFI FunCall AT24CXX_Read
        BL       AT24CXX_Read
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??mks_contiuePrint_UI_8
        MOVS     R0,#+1
        LDR.W    R1,??DataTable230_9
        STRB     R0,[R1, #+0]
        B.N      ??mks_contiuePrint_UI_9
??mks_contiuePrint_UI_8:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable230_10
        STRB     R0,[R1, #+0]
??mks_contiuePrint_UI_9:
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_printing
        B.W      draw_printing
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_2:
        MOVS     R0,#+0
        STRB     R0,[R4, #+2788]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2076]
        LDR.W    R0,??DataTable230
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_contiuePrint_UI_10
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_contiuePrint_UI_10:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable230_11
        STRB     R0,[R1, #+0]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock131

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable220:
        DC32     0x40000440

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resume print?">`:
        DC8 "Resume print?"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock132 Using cfiCommon0
          CFI Function mks_rePrintCheck
        THUMB
// __interwork __softfp void mks_rePrintCheck()
mks_rePrintCheck:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable230_12
        ADDW     R5,R4,#+2076
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+170
        BNE.N    ??mks_rePrintCheck_0
        MOVS     R0,#+171
        STRB     R0,[R4, #+2076]
          CFI FunCall mks_ReadFromEpr
        BL       mks_ReadFromEpr
        MOVS     R0,#+1
        STRB     R0,[R4, #+2788]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_0:
        LDR.W    R1,??DataTable230
        CMP      R0,#+167
        BNE.N    ??mks_rePrintCheck_2
        LDRB     R0,[R1, #+415]
        CMP      R0,#+1
        BNE.N    ??mks_rePrintCheck_3
        MOVS     R0,#+171
        STRB     R0,[R4, #+2076]
          CFI FunCall _Z22mks_ReadFromEpr_pwroffv
        BL       _Z22mks_ReadFromEpr_pwroffv
        MOVS     R0,#+2
        STRB     R0,[R4, #+2788]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_3:
        MOVS     R0,#+171
        STRB     R0,[R4, #+2076]
        MOVS     R2,#+100
        ADDW     R1,R4,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
          CFI FunCall mks_ReadFromFile
        BL       mks_ReadFromFile
        MOVS     R0,#+2
        STRB     R0,[R4, #+2788]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_2:
        MOVS     R0,#+166
        STRB     R0,[R4, #+2076]
        LDRB     R0,[R1, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_rePrintCheck_4
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_rePrintCheck_4:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable230_11
        STRB     R0,[R1, #+0]
??mks_rePrintCheck_1:
        LDR.W    R0,??DataTable230_11
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_rePrintCheck_5
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
??mks_rePrintCheck_6:
        LDR.W    R0,??DataTable230_13
        LDRB     R0,[R0, #+19]
        CMP      R0,#+1
        BEQ.N    ??mks_rePrintCheck_5
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable230_6
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable230_7
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCC.N    ??mks_rePrintCheck_6
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_ready_print
        B.W      draw_ready_print
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_rePrintCheck_5:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock132

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable221:
        DC8      "/",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable221_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock133 Using cfiCommon0
          CFI Function mks_WriteToFile
        THUMB
// __interwork __softfp void mks_WriteToFile()
mks_WriteToFile:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+56
          CFI CFA R13+80
        ADD      R0,SP,#+20
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        LDR.W    R7,??DataTable225_2
        LDRB     R0,[R7, #+1891]
        CMP      R0,#+0
        BEQ.N    ??mks_WriteToFile_0
        LDR.W    R1,??DataTable230_14
        ADD      R0,SP,#+20
          CFI FunCall strcat
        BL       strcat
??mks_WriteToFile_0:
        LDR.W    R0,??DataTable230_15
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+20
          CFI FunCall strcat
        BL       strcat
        ADDW     R4,R7,#+2228
        MOVS     R2,#+3
        ADD      R1,SP,#+20
        MOV      R0,R4
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.W    ??mks_WriteToFile_1
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+7
        ADR.W    R1,`?<Constant "start\\n">`
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R5,??DataTable223  ;; 0x25, 0x64, 0x00, 0x00
        LDR      R2,[R7, #+2080]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADR.N    R6,??DataTable223_1  ;; "\n"
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R8,??DataTable230_16
        LDR      R2,[R8, #+0]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R2,[R8, #+4]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R0,??DataTable230_17
        LDRSH    R2,[R0, #+0]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        ADDW     R3,R7,#+2120
        ADDW     R2,R7,#+2116
        ADD      R1,R7,#+2112
        ADDW     R0,R7,#+2792
          CFI FunCall _ZN9Stopwatch7getTimeEPmS0_S0_
        BL       _ZN9Stopwatch7getTimeEPmS0_S0_
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDW     R7,R7,#+2080
        STR      R0,[R7, #+44]
        LDR      R1,[R7, #+40]
        LDR      R2,[R7, #+36]
        CMP      R1,R2
        BCS.N    ??mks_WriteToFile_2
        STR      R0,[R7, #+40]
??mks_WriteToFile_2:
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R2,[R7, #+32]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R7,??DataTable230_18
        LDRH     R2,[R7, #+2]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDRB     R2,[R7, #+4]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDRSB    R2,[R7, #+5]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R7,??DataTable226_2
        LDR      R2,[R7, #+108]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R7, #+92]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable225  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDRB     R2,[R7, #+3]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+4
        ADR.N    R1,??DataTable226  ;; "end"
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R0,R4
          CFI FunCall f_close
        BL       f_close
??mks_WriteToFile_1:
        ADD      SP,SP,#+56
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock133

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "start\\n">`:
        DC8 "start\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function _Z21mks_WriteToEpr_pwroffv
        THUMB
// __interwork __softfp void mks_WriteToEpr_pwroff()
_Z21mks_WriteToEpr_pwroffv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??DataTable225_2
        MOVS     R2,#+1
        ADDW     R1,R4,#+2076
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2084
        MOVW     R0,#+1269
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R4, #+2080]
        ADDW     R5,R4,#+2080
        MOVS     R2,#+4
        MOV      R1,R5
        MOVW     R0,#+1201
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable230_16
        LDR      R0,[R6, #+0]
        STRH     R0,[R5, #+18]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2098
        MOVW     R0,#+1205
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R7,??DataTable228
        LDRB     R0,[R7, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_WriteToEpr_pwroff_0
        LDR      R0,[R6, #+4]
        STRH     R0,[R5, #+20]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2100
        MOVW     R0,#+1207
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_pwroff_0:
        LDRB     R0,[R7, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_WriteToEpr_pwroff_1
        LDR.W    R0,??DataTable230_17
        LDRH     R0,[R0, #+0]
        STRH     R0,[R5, #+22]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2102
        MOVW     R0,#+1209
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_pwroff_1:
        LDR.W    R6,??DataTable230_18
        MOVS     R2,#+2
        ADDS     R1,R6,#+2
        MOV      R0,#+1264
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.N    R6,??DataTable226_2
        LDR      R0,[R6, #+108]
        STRB     R0,[R5, #+28]
        MOVS     R2,#+1
        ADDW     R1,R4,#+2108
        MOVW     R0,#+1247
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR      R0,[R6, #+92]
        STR      R0,[R5, #+24]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2104
        MOVW     R0,#+1243
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+3
        MOVW     R0,#+1268
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock134

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable223:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable223_1:
        DC8      "\n",0x0,0x0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function _Z22mks_ReadFromEpr_pwroffv
        THUMB
// __interwork __softfp void mks_ReadFromEpr_pwroff()
_Z22mks_ReadFromEpr_pwroffv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??DataTable225_2
        MOVS     R2,#+100
        ADDW     R1,R4,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2088
        MOVW     R0,#+1201
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2084
        MOVW     R0,#+1269
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADDW     R1,R4,#+2098
        MOVW     R0,#+1205
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.N    R5,??DataTable228
        LDRB     R0,[R5, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_ReadFromEpr_pwroff_0
        MOVS     R2,#+2
        ADDW     R1,R4,#+2100
        MOVW     R0,#+1207
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_pwroff_0:
        LDRB     R0,[R5, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromEpr_pwroff_1
        MOVS     R2,#+2
        ADDW     R1,R4,#+2102
        MOVW     R0,#+1209
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_pwroff_1:
        LDR.W    R5,??DataTable230_18
        MOVS     R2,#+2
        ADDS     R1,R5,#+2
        MOV      R0,#+1264
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+2108
        MOVW     R0,#+1247
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2104
        MOVW     R0,#+1243
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.N    R4,??DataTable226_2
        MOVS     R2,#+1
        ADDS     R1,R4,#+3
        MOVW     R0,#+1268
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRSB    R0,[R4, #+3]
        LDR.N    R1,??DataTable230
        STRB     R0,[R1, #+156]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock135

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function _Z7pft_getv
        THUMB
// __interwork __softfp int16_t pft_get()
_Z7pft_getv:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        LDR.N    R4,??DataTable230_12
        ADD      R3,SP,#+4
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        ADDW     R0,R4,#+2228
          CFI FunCall f_read
        BL       f_read
        CMP      R0,#+0
        BEQ.N    ??pft_get_0
        MOVS     R0,#+255
        STRB     R0,[SP, #+0]
        B.N      ??pft_get_1
??pft_get_0:
        LDR      R0,[R4, #+2092]
        LDR      R1,[SP, #+4]
        ADDS     R0,R1,R0
        STR      R0,[R4, #+2092]
??pft_get_1:
        LDRB     R0,[SP, #+0]
        POP      {R1,R2,R4,PC}    ;; return
          CFI EndBlock cfiBlock136

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable225:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable225_1:
        DC32     _ZN7Planner17max_feedrate_mm_sE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable225_2:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable225_3:
        DC32     leveling_first_time

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function _Z16mks_get_commandsv
        THUMB
// __interwork __softfp bool mks_get_commands()
_Z16mks_get_commandsv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+24
          CFI CFA R13+48
        MOVS     R5,#+0
        MOV      R8,R5
        MOV      R4,R5
        LDR.N    R7,??DataTable230_12
        B.N      ??mks_get_commands_1
??mks_get_commands_2:
        ADR.N    R1,??DataTable226  ;; "end"
        ADD      R0,SP,#+0
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??mks_get_commands_3
        MOVS     R4,#+1
??mks_get_commands_3:
        MOV      R8,#+0
        MOVS     R2,#+20
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADDS     R5,R5,#+1
??mks_get_commands_1:
        ADDW     R6,R7,#+2080
        LDR      R0,[R6, #+12]
        LDR      R1,[R7, #+2784]
        CMP      R0,R1
        BCS.N    ??mks_get_commands_4
          CFI FunCall _Z7pft_getv
        BL       _Z7pft_getv
        CMN      R0,#+1
        BEQ.N    ??mks_get_commands_4
        MOV      R1,R8
        SXTB     R0,R0
        CMP      R0,#+10
        BNE.N    ??mks_get_commands_5
        MOVS     R0,#+0
        ADD      R2,SP,#+0
        ADDS     R1,R1,R2
        STRB     R0,[R1, #-1]
        SXTB     R5,R5
        MOV      R0,R5
        SUBS     R0,R0,#+1
        CMP      R0,#+11
        BHI.N    ??mks_get_commands_3
        TBB      [PC, R0]
        DATA
??mks_get_commands_0:
        DC8      0x8,0xE,0x13,0x18
        DC8      0x1D,0x22,0x28,0x2E
        DC8      0x34,0x39,0x40,0x6
        THUMB
??mks_get_commands_6:
        B.N      ??mks_get_commands_2
??mks_get_commands_7:
        B.N      ??mks_get_commands_3
??mks_get_commands_8:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STR      R0,[R7, #+2080]
        B.N      ??mks_get_commands_3
??mks_get_commands_9:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRH     R0,[R6, #+18]
        B.N      ??mks_get_commands_3
??mks_get_commands_10:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRH     R0,[R6, #+20]
        B.N      ??mks_get_commands_3
??mks_get_commands_11:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRH     R0,[R6, #+22]
        B.N      ??mks_get_commands_3
??mks_get_commands_12:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STR      R0,[R6, #+32]
        B.N      ??mks_get_commands_3
??mks_get_commands_13:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        LDR.N    R1,??DataTable230_18
        STRH     R0,[R1, #+2]
        B.N      ??mks_get_commands_3
??mks_get_commands_14:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        LDR.N    R1,??DataTable230_18
        STRB     R0,[R1, #+4]
        B.N      ??mks_get_commands_3
??mks_get_commands_15:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        LDR.N    R1,??DataTable230_18
        STRB     R0,[R1, #+5]
        B.N      ??mks_get_commands_3
??mks_get_commands_16:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRB     R0,[R6, #+28]
        B.N      ??mks_get_commands_3
??mks_get_commands_17:
        ADD      R0,SP,#+0
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+24]
        B.N      ??mks_get_commands_3
??mks_get_commands_18:
        LDR.N    R6,??DataTable230
        ADD      R0,SP,#+0
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        STRB     R0,[R6, #+156]
        LDRB     R0,[R6, #+156]
        LDR.N    R1,??DataTable226_2
        STRB     R0,[R1, #+3]
        B.N      ??mks_get_commands_3
??mks_get_commands_5:
        ADD      R2,SP,#+0
        STRB     R0,[R1, R2]
        ADD      R8,R8,#+1
        UXTH     R8,R8
        CMP      R8,#+20
        BLT.N    ??mks_get_commands_1
??mks_get_commands_4:
        MOV      R0,R4
        ADD      SP,SP,#+24
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock137

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226:
        DC8      "end"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_1:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_2:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function mks_ReadFromFile
        THUMB
// __interwork __softfp bool mks_ReadFromFile()
mks_ReadFromFile:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOVS     R4,#+0
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        LDR.N    R5,??DataTable230_12
        LDRB     R0,[R5, #+1891]
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromFile_0
        LDR.N    R1,??DataTable230_14
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
??mks_ReadFromFile_0:
        LDR.N    R0,??DataTable230_15
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADDW     R6,R5,#+2228
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.N    ??mks_ReadFromFile_1
        MOV      R0,R4
        STR      R0,[R5, #+2092]
        LDR      R0,[R5, #+2752]
        STR      R0,[R5, #+2784]
          CFI FunCall _Z16mks_get_commandsv
        BL       _Z16mks_get_commandsv
        MOV      R4,R0
        MOV      R0,R6
          CFI FunCall f_close
        BL       f_close
??mks_ReadFromFile_1:
        MOV      R0,R4
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock138

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function mks_clearFile
        THUMB
// __interwork __softfp void mks_clearFile()
mks_clearFile:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+56
          CFI CFA R13+64
        ADD      R0,SP,#+32
        ADR.W    R1,`?<Constant "clear">`
        MOVS     R2,#+20
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        LDR.N    R4,??DataTable230_12
        LDRB     R0,[R4, #+1891]
        CMP      R0,#+0
        BEQ.N    ??mks_clearFile_0
        LDR.N    R1,??DataTable230_14
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
??mks_clearFile_0:
        LDR.N    R0,??DataTable230_15
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADDW     R4,R4,#+2228
        MOVS     R2,#+10
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.N    ??mks_clearFile_1
        ADD      R1,SP,#+32
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R0,R4
          CFI FunCall f_close
        BL       f_close
??mks_clearFile_1:
        ADD      SP,SP,#+56
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock139

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable228:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable228_1:
        DC32     0x40010c00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable228_2:
        DC32     0x40010800

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function mks_saveFileName
        THUMB
// __interwork __softfp void mks_saveFileName(char *)
mks_saveFileName:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable230_12
        MOVS     R2,#+100
        MOVS     R1,#+0
        ADDW     R0,R5,#+1916
          CFI FunCall memset
        BL       memset
        MOV      R1,R4
        ADDW     R0,R5,#+1916
          CFI FunCall strcpy
        BL       strcpy
        MOVS     R2,#+100
        ADDW     R1,R5,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDRB     R0,[R5, #+2076]
        CMP      R0,#+166
        BNE.N    ??mks_saveFileName_0
        LDR.N    R0,??DataTable230
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_saveFileName_0
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_clearFile
        B.N      mks_clearFile
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_saveFileName_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock140

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable229:
        DC32     0x41200000

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function EXTI9_5_IRQHandler
        THUMB
// __interwork __softfp void EXTI9_5_IRQHandler()
EXTI9_5_IRQHandler:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+0
        LDR.N    R1,??DataTable230_19  ;; 0x422281b4
        STR      R0,[R1, #+0]
        LDR.N    R0,??DataTable230_20  ;; 0x40010414
        LDR      R1,[R0, #+0]
        LSLS     R1,R1,#+26
        BPL.N    ??EXTI9_5_IRQHandler_0
        MOVS     R1,#+32
        STR      R1,[R0, #+0]
        LDR.N    R0,??DataTable230_12
        LDRB     R0,[R0, #+2076]
        CMP      R0,#+166
        BEQ.N    ??EXTI9_5_IRQHandler_1
        CMP      R0,#+171
        BEQ.N    ??EXTI9_5_IRQHandler_1
        CMP      R0,#+169
        BEQ.N    ??EXTI9_5_IRQHandler_1
        CMP      R0,#+170
        BNE.N    ??EXTI9_5_IRQHandler_2
??EXTI9_5_IRQHandler_1:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable230_21  ;; 0x422381a8
        STR      R0,[R1, #+0]
        POP      {R0,PC}
??EXTI9_5_IRQHandler_2:
        LDR.N    R0,??DataTable230
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BNE.N    ??EXTI9_5_IRQHandler_0
        MOVS     R0,#+0
        LDR.N    R1,??DataTable230_22  ;; 0x42210180
        STR      R0,[R1, #+0]
          CFI FunCall _Z21mks_WriteToEpr_pwroffv
        BL       _Z21mks_WriteToEpr_pwroffv
        MOV      R0,#+1000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        LDR.N    R1,??DataTable230_21  ;; 0x422381a8
        STR      R0,[R1, #+0]
??EXTI9_5_IRQHandler_3:
        B.N      ??EXTI9_5_IRQHandler_3
??EXTI9_5_IRQHandler_0:
        cpsie i
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock141

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_1:
        DC32     first_resu

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_2:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_3:
        DC32     0x38d1b718

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_4:
        DC32     card+0x77C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_5:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_6:
        DC32     logo_tick2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_7:
        DC32     logo_tick1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_8:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_9:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_10:
        DC32     default_preview_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_11:
        DC32     continue_print_error_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_12:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_13:
        DC32     mksTmp

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_14:
        DC32     SD_Path

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_15:
        DC32     mks_pft_name

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_16:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_17:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_18:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_19:
        DC32     0x422281b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_20:
        DC32     0x40010414

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_21:
        DC32     0x422381a8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable230_22:
        DC32     0x42210180

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "clear">`:
        DC8 "clear"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strchrPci
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function _Z6strchrPci
          CFI FunCall __iar_Strchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
_Z6strchrPci:
        B.W      __iar_Strchr
          CFI EndBlock cfiBlock142

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z7strrchrPci
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function _Z7strrchrPci
          CFI FunCall __iar_Strrchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strrchr(char *, int)
_Z7strrchrPci:
        B.W      __iar_Strrchr
          CFI EndBlock cfiBlock143

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strstrPcPKc
          CFI Block cfiBlock144 Using cfiCommon0
          CFI Function _Z6strstrPcPKc
          CFI FunCall __iar_Strstr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
_Z6strstrPcPKc:
        B.W      __iar_Strstr
          CFI EndBlock cfiBlock144

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17serial_echopair_PPKcb
          CFI Block cfiBlock145 Using cfiCommon0
          CFI Function _Z17serial_echopair_PPKcb
          CFI FunCall _Z17serial_echopair_PPKci
        THUMB
// __interwork __softfp void serial_echopair_P(char const *, bool)
_Z17serial_echopair_PPKcb:
        B.W      _Z17serial_echopair_PPKci
          CFI EndBlock cfiBlock145

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14serialprintPGMPKc
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function _Z14serialprintPGMPKc
        THUMB
// __interwork __softfp void serialprintPGM(char const *)
_Z14serialprintPGMPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        B.N      ??serialprintPGM_0
??serialprintPGM_1:
        UXTB     R1,R1
        LDR.N    R0,??serialprintPGM_2
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??serialprintPGM_0:
        LDRSB    R1,[R4], #+1
        MOVS     R0,R1
        BNE.N    ??serialprintPGM_1
        POP      {R4,PC}          ;; return
        DATA
??serialprintPGM_2:
        DC32     Serial3
          CFI EndBlock cfiBlock146

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsRunningv
          CFI Block cfiBlock147 Using cfiCommon0
          CFI Function _Z9IsRunningv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsRunning()
_Z9IsRunningv:
        LDR.N    R0,??IsRunning_0
        LDRB     R0,[R0, #+4]
        BX       LR               ;; return
        Nop      
        DATA
??IsRunning_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock147

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsStoppedv
          CFI Block cfiBlock148 Using cfiCommon0
          CFI Function _Z9IsStoppedv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsStopped()
_Z9IsStoppedv:
        LDR.N    R0,??IsStopped_0
        LDRB     R0,[R0, #+4]
        EOR      R0,R0,#0x1
        BX       LR               ;; return
        Nop      
        DATA
??IsStopped_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock148

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19refresh_cmd_timeoutv
          CFI Block cfiBlock149 Using cfiCommon0
          CFI Function _Z19refresh_cmd_timeoutv
        THUMB
// __interwork __softfp void refresh_cmd_timeout()
_Z19refresh_cmd_timeoutv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R1,??refresh_cmd_timeout_0
        STR      R0,[R1, #+92]
        POP      {R0,PC}          ;; return
        DATA
??refresh_cmd_timeout_0:
        DC32     axis_homed
          CFI EndBlock cfiBlock149

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_current_from_destinationv
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function _Z28set_current_from_destinationv
        THUMB
// __interwork __softfp void set_current_from_destination()
_Z28set_current_from_destinationv:
        LDR.N    R0,??set_current_from_destination_0
        MOVS     R2,#+16
        ADD      R1,R0,#+24
        ADDS     R0,R0,#+8
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_current_from_destination_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock150

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_destination_from_currentv
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function _Z28set_destination_from_currentv
        THUMB
// __interwork __softfp void set_destination_from_current()
_Z28set_destination_from_currentv:
        LDR.N    R0,??set_destination_from_current_0
        MOVS     R2,#+16
        ADD      R1,R0,#+8
        ADDS     R0,R0,#+24
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_destination_from_current_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock151

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z34position_is_reachable_IS_KINEMATICRKfS0_
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function _Z34position_is_reachable_IS_KINEMATICRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_IS_KINEMATIC(float const &, float const &)
_Z34position_is_reachable_IS_KINEMATICRKfS0_:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R5,R0
        MOV      R4,R1
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0
        LDRSH    R1,[R0, #+88]
        LSLS     R2,R1,#+30
        BPL.N    ??position_is_reachable_IS_KINEMATIC_1
        LDR      R8,[R0, #+84]
        MOV      R9,#+2
        MOV      R6,#+1065353216
        MOV      R7,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_2
??position_is_reachable_IS_KINEMATIC_3:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_2:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_4
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??position_is_reachable_IS_KINEMATIC_4:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_3
        LDR      R8,[R5, #+0]
        MOV      R9,#+2
        MOV      R5,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_5
??position_is_reachable_IS_KINEMATIC_6:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_5:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_7
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_IS_KINEMATIC_7:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_6
        LDR      R4,[R4, #+0]
        MOV      R8,#+2
        B.N      ??position_is_reachable_IS_KINEMATIC_8
??position_is_reachable_IS_KINEMATIC_9:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??position_is_reachable_IS_KINEMATIC_8:
        LSLS     R0,R8,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_10
        MOV      R0,R6
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_10:
        LSRS     R8,R8,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_9
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??position_is_reachable_IS_KINEMATIC_11
        MOVS     R0,#+1
        B.N      ??position_is_reachable_IS_KINEMATIC_12
??position_is_reachable_IS_KINEMATIC_11:
        MOVS     R0,#+0
        B.N      ??position_is_reachable_IS_KINEMATIC_12
??position_is_reachable_IS_KINEMATIC_1:
        MOV      R0,#+768
        TST      R1,R0
        BEQ.N    ??position_is_reachable_IS_KINEMATIC_12
        LDR.W    R8,??position_is_reachable_IS_KINEMATIC_0+0x4  ;; 0x43960000
        MOV      R9,#+2
        MOV      R6,#+1065353216
        MOV      R7,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_13
??position_is_reachable_IS_KINEMATIC_14:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_13:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_15
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??position_is_reachable_IS_KINEMATIC_15:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_14
        LDR      R1,[R5, #+0]
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0x8  ;; 0xc2c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        MOV      R9,#+2
        MOV      R5,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_16
??position_is_reachable_IS_KINEMATIC_17:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_16:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_18
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_IS_KINEMATIC_18:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_17
        LDR      R1,[R4, #+0]
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0xC  ;; 0x42600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        MOV      R8,#+2
        B.N      ??position_is_reachable_IS_KINEMATIC_19
??position_is_reachable_IS_KINEMATIC_20:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??position_is_reachable_IS_KINEMATIC_19:
        LSLS     R0,R8,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_21
        MOV      R0,R6
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_21:
        LSRS     R8,R8,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_20
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??position_is_reachable_IS_KINEMATIC_22
        MOVS     R0,#+1
        B.N      ??position_is_reachable_IS_KINEMATIC_12
??position_is_reachable_IS_KINEMATIC_22:
        MOVS     R0,#+0
??position_is_reachable_IS_KINEMATIC_12:
        POP      {R1,R4-R9,PC}    ;; return
        Nop      
        DATA
??position_is_reachable_IS_KINEMATIC_0:
        DC32     mksCfg
        DC32     0x43960000
        DC32     0xc2c80000
        DC32     0x42600000
          CFI EndBlock cfiBlock152

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
          CFI Block cfiBlock153 Using cfiCommon0
          CFI Function _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
_Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??position_is_reachable_by_probe_IS_KINEMATIC_0
        LDR.N    R6,??position_is_reachable_by_probe_IS_KINEMATIC_1
        LDR      R0,[R4, #+0]
        LDR      R1,[R6, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+0]
        LDR      R1,[R6, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        POP      {R1,R2,R4-R6,PC}
??position_is_reachable_by_probe_IS_KINEMATIC_0:
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
        Nop      
        DATA
??position_is_reachable_by_probe_IS_KINEMATIC_1:
        DC32     mksCfg
          CFI EndBlock cfiBlock153

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z34position_is_reachable_IS_CARTESIANRKfS0_
          CFI Block cfiBlock154 Using cfiCommon0
          CFI Function _Z34position_is_reachable_IS_CARTESIANRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_IS_CARTESIAN(float const &, float const &)
_Z34position_is_reachable_IS_CARTESIANRKfS0_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R11,R1
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R8,??position_is_reachable_IS_CARTESIAN_0  ;; 0xd2f1a9fc
        LDR.W    R9,??position_is_reachable_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
        LDR.W    R10,??position_is_reachable_IS_CARTESIAN_0+0x8
        LDR      R0,[R10, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        MOV      R6,R8
        LDR.N    R7,??position_is_reachable_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
        LDR      R0,[R10, #+20]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        LDR      R0,[R11, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R10, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        LDR      R0,[R10, #+24]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        MOVS     R0,#+1
        B.N      ??position_is_reachable_IS_CARTESIAN_2
??position_is_reachable_IS_CARTESIAN_1:
        MOVS     R0,#+0
??position_is_reachable_IS_CARTESIAN_2:
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??position_is_reachable_IS_CARTESIAN_0:
        DC32     0xd2f1a9fc
        DC32     0xbf50624d
        DC32     mksCfg
        DC32     0x3f50624d
          CFI EndBlock cfiBlock154

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
          CFI Block cfiBlock155 Using cfiCommon0
          CFI Function _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
_Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R11,R1
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R8,??position_is_reachable_by_probe_IS_CARTESIAN_0  ;; 0xd2f1a9fc
        LDR.W    R9,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
        LDR.W    R10,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x8
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        MOV      R6,R8
        LDR.N    R7,??position_is_reachable_by_probe_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
        LDR      R0,[R10, #+4]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        LDR      R0,[R11, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R10, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        LDR      R0,[R10, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        MOVS     R0,#+1
        B.N      ??position_is_reachable_by_probe_IS_CARTESIAN_2
??position_is_reachable_by_probe_IS_CARTESIAN_1:
        MOVS     R0,#+0
??position_is_reachable_by_probe_IS_CARTESIAN_2:
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??position_is_reachable_by_probe_IS_CARTESIAN_0:
        DC32     0xd2f1a9fc
        DC32     0xbf50624d
        DC32     mksTmp
        DC32     0x3f50624d
          CFI EndBlock cfiBlock155

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10lcd_updatev
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function _Z10lcd_updatev
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_update()
_Z10lcd_updatev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock156

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z8lcd_initv
          CFI Block cfiBlock157 Using cfiCommon0
          CFI Function _Z8lcd_initv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_init()
_Z8lcd_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock157

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_hasstatusv
          CFI Block cfiBlock158 Using cfiCommon0
          CFI Function _Z13lcd_hasstatusv
          CFI NoCalls
        THUMB
// __interwork __softfp bool lcd_hasstatus()
_Z13lcd_hasstatusv:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock158

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_setstatusPKcb
          CFI Block cfiBlock159 Using cfiCommon0
          CFI Function _Z13lcd_setstatusPKcb
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatus(char const *, bool)
_Z13lcd_setstatusPKcb:
        BX       LR               ;; return
          CFI EndBlock cfiBlock159

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z16lcd_setstatusPGMPKca
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function _Z16lcd_setstatusPGMPKca
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatusPGM(char const *, int8_t)
_Z16lcd_setstatusPGMPKca:
        BX       LR               ;; return
          CFI EndBlock cfiBlock160

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_setalertstatusPGMPKc
          CFI Block cfiBlock161 Using cfiCommon0
          CFI Function _Z21lcd_setalertstatusPGMPKc
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setalertstatusPGM(char const *)
_Z21lcd_setalertstatusPGMPKc:
        BX       LR               ;; return
          CFI EndBlock cfiBlock161

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_reset_alert_levelv
          CFI Block cfiBlock162 Using cfiCommon0
          CFI Function _Z21lcd_reset_alert_levelv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_reset_alert_level()
_Z21lcd_reset_alert_levelv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock162

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11lcd_refreshv
          CFI Block cfiBlock163 Using cfiCommon0
          CFI Function _Z11lcd_refreshv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_refresh()
_Z11lcd_refreshv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock163

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner16refresh_e_factorEh
          CFI Block cfiBlock164 Using cfiCommon0
          CFI Function _ZN7Planner16refresh_e_factorEh
        THUMB
// __interwork __softfp void Planner::refresh_e_factor(uint8_t)
_ZN7Planner16refresh_e_factorEh:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R6,R0
        LDR.N    R0,??refresh_e_factor_0
        LDRSH    R0,[R0, R6, LSL #+1]
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
        LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        LDR.N    R0,??refresh_e_factor_0+0xC
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??refresh_e_factor_0+0x10
        STR      R0,[R1, R6, LSL #+2]
        POP      {R4-R6,PC}       ;; return
        DATA
??refresh_e_factor_0:
        DC32     _ZN7Planner15flow_percentageE
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     _ZN7Planner21volumetric_multiplierE
        DC32     _ZN7Planner8e_factorE
          CFI EndBlock cfiBlock164

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17set_filament_sizeEhRKf
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function _ZN7Planner17set_filament_sizeEhRKf
        THUMB
// __interwork __softfp void Planner::set_filament_size(uint8_t, float const &)
_ZN7Planner17set_filament_sizeEhRKf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R2,??set_filament_size_0
        LDR      R1,[R1, #+0]
        STR      R1,[R2, R0, LSL #+2]
        MOVS     R3,#+0
        MOV      R1,R3
        B.N      ??set_filament_size_1
??set_filament_size_2:
        LDR      R0,[R2, R3, LSL #+2]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??set_filament_size_3
        LDR.N    R0,??set_filament_size_0+0x4  ;; 0x40400000
        STR      R0,[R2, R3, LSL #+2]
??set_filament_size_3:
        ADDS     R3,R3,#+1
??set_filament_size_1:
        CMP      R3,#+2
        BCC.N    ??set_filament_size_2
        POP      {R0,PC}          ;; return
        DATA
??set_filament_size_0:
        DC32     _ZN7Planner13filament_sizeE
        DC32     0x40400000
          CFI EndBlock cfiBlock165

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17force_fade_recalcEv
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function _ZN7Planner17force_fade_recalcEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Planner::force_fade_recalc()
_ZN7Planner17force_fade_recalcEv:
        LDR.N    R0,??force_fade_recalc_0  ;; 0xc479fff0
        LDR.N    R1,??force_fade_recalc_0+0x4
        STR      R0,[R1, #+0]
        BX       LR               ;; return
        DATA
??force_fade_recalc_0:
        DC32     0xc479fff0
        DC32     _ZN7Planner11last_fade_zE
          CFI EndBlock cfiBlock166

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17set_z_fade_heightERKf
          CFI Block cfiBlock167 Using cfiCommon0
          CFI Function _ZN7Planner17set_z_fade_heightERKf
        THUMB
// __interwork __softfp void Planner::set_z_fade_height(float const &)
_ZN7Planner17set_z_fade_heightERKf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR      R0,[R0, #+0]
        LDR.N    R2,??set_z_fade_height_6
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??set_z_fade_height_7
        STR      R0,[R2, #+0]
        B.N      ??set_z_fade_height_8
??set_z_fade_height_7:
        MOV      R0,R1
        STR      R0,[R2, #+0]
??set_z_fade_height_8:
        LDR      R2,[R2, #+0]
        MOV      R0,R2
        LDR.N    R1,??set_z_fade_height_6+0x4  ;; 0xb58637bd
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??set_z_fade_height_9
        LDR.N    R1,??set_z_fade_height_6+0x8  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??set_z_fade_height_9
        MOVS     R0,#+0
        LDR.N    R1,??set_z_fade_height_6+0xC
        STR      R0,[R1, #+0]
        B.N      ??set_z_fade_height_10
??set_z_fade_height_9:
        MOV      R0,#+1065353216
        MOV      R1,R2
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.N    R1,??set_z_fade_height_6+0xC
        STR      R0,[R1, #+0]
??set_z_fade_height_10:
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner17force_fade_recalcEv
        B.W      _ZN7Planner17force_fade_recalcEv
        DATA
??set_z_fade_height_6:
        DC32     _ZN7Planner13z_fade_heightE
        DC32     0xb58637bd
        DC32     0x358637be
        DC32     _ZN7Planner21inverse_z_fade_heightE
          CFI EndBlock cfiBlock167

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner20leveling_active_at_zERKf
          CFI Block cfiBlock168 Using cfiCommon0
          CFI Function _ZN7Planner20leveling_active_at_zERKf
        THUMB
// __interwork __softfp bool Planner::leveling_active_at_z(float const &)
_ZN7Planner20leveling_active_at_zERKf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOV      R2,R0
        LDR.N    R0,??leveling_active_at_z_0
        LDR      R3,[R0, #+0]
        MOV      R0,R3
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??leveling_active_at_z_1
        LDR      R0,[R2, #+0]
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??leveling_active_at_z_2
??leveling_active_at_z_1:
        MOVS     R0,#+1
        POP      {R1,PC}
??leveling_active_at_z_2:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        DATA
??leveling_active_at_z_0:
        DC32     _ZN7Planner13z_fade_heightE
          CFI EndBlock cfiBlock168

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner14apply_levelingERA3_f
          CFI Block cfiBlock169 Using cfiCommon0
          CFI Function _ZN7Planner14apply_levelingERA3_f
        THUMB
// __interwork __softfp void Planner::apply_leveling(float (&)[3])
_ZN7Planner14apply_levelingERA3_f:
        ADD      R2,R0,#+8
        ADDS     R1,R0,#+4
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        B.W      _ZN7Planner14apply_levelingERfS0_S0_
          CFI EndBlock cfiBlock169

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner11buffer_lineEfffRKfS1_h
          CFI Block cfiBlock170 Using cfiCommon0
          CFI Function _ZN7Planner11buffer_lineEfffRKfS1_h
        THUMB
// __interwork __softfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
_ZN7Planner11buffer_lineEfffRKfS1_h:
        PUSH     {R0-R2,R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R4,R3
        LDR      R5,[SP, #+32]
        LDR.N    R0,??buffer_line_0
        LDRB     R1,[R0, #+64]
        MOVS     R2,#+46
        TST      R1,R2
        BEQ.N    ??buffer_line_1
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BNE.N    ??buffer_line_1
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??buffer_line_1:
        LDR      R0,[SP, #+36]
        STR      R0,[SP, #+4]
        STR      R5,[SP, #+0]
        MOV      R3,R4
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        DATA
??buffer_line_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock170

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
          CFI Block cfiBlock171 Using cfiCommon0
          CFI Function _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        THUMB
// __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
_ZN7Planner21buffer_line_kinematicERA4_KfRS0_h:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        LDR      R0,[R4, #+0]
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+8
        LDR      R1,[R4, #+4]
        STR      R1,[R0, #+4]
        LDR      R1,[R4, #+8]
        STR      R1,[R0, #+8]
        LDR.N    R7,??buffer_line_kinematic_0
        LDRB     R0,[R7, #+64]
        MOVS     R1,#+46
        TST      R0,R1
        BEQ.N    ??buffer_line_kinematic_1
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14apply_levelingERA3_f
        BL       _ZN7Planner14apply_levelingERA3_f
??buffer_line_kinematic_1:
        ADD      R0,R7,#+64
        LDRSH    R0,[R0, #+24]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??buffer_line_kinematic_2
        CMP      R0,#+256
        ADD      R0,SP,#+8
        BNE.N    ??buffer_line_kinematic_3
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??buffer_line_kinematic_4
??buffer_line_kinematic_3:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??buffer_line_kinematic_4:
        LDR.N    R1,??buffer_line_kinematic_0+0x4
        LDRB     R0,[R1, #+328]
        CMP      R0,#+1
        BNE.N    ??buffer_line_kinematic_5
        LDR      R0,[R4, #+8]
        LDR      R1,[R1, #+664]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??buffer_line_kinematic_5
        LDR      R1,[R4, #+12]
        LDR.N    R0,??buffer_line_kinematic_0+0x8
        ADD      R0,R0,R6, LSL #+2
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall lroundf
        BL       lroundf
        LDR.N    R1,??buffer_line_kinematic_0+0xC
        STR      R0,[R1, #+12]
        B.N      ??buffer_line_kinematic_6
??buffer_line_kinematic_5:
        LDR.N    R0,??buffer_line_kinematic_0+0x10
        STR      R6,[SP, #+4]
        STR      R5,[SP, #+0]
        ADD      R3,R4,#+12
        ADD      R2,R0,#+88
        ADD      R1,R0,#+84
        ADDS     R0,R0,#+80
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        B.N      ??buffer_line_kinematic_6
??buffer_line_kinematic_2:
        STR      R6,[SP, #+4]
        STR      R5,[SP, #+0]
        ADD      R3,R4,#+12
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
??buffer_line_kinematic_6:
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        Nop      
        DATA
??buffer_line_kinematic_0:
        DC32     mksCfg
        DC32     gCfgItems
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     _ZN7Planner8positionE
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock171

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner15set_position_mmEfffRKf
          CFI Block cfiBlock172 Using cfiCommon0
          CFI Function _ZN7Planner15set_position_mmEfffRKf
        THUMB
// __interwork __softfp void Planner::set_position_mm(float, float, float, float const &)
_ZN7Planner15set_position_mmEfffRKf:
        PUSH     {R0-R2,R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+20
        SUB      SP,SP,#+4
          CFI CFA R13+24
        MOV      R4,R3
        LDR.N    R0,??set_position_mm_0
        LDRB     R1,[R0, #+64]
        MOVS     R2,#+46
        TST      R1,R2
        BEQ.N    ??set_position_mm_1
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BNE.N    ??set_position_mm_1
        ADD      R2,SP,#+12
        ADD      R1,SP,#+8
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??set_position_mm_1:
        MOV      R3,R4
        ADD      R2,SP,#+12
        ADD      R1,SP,#+8
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        POP      {R0-R4,PC}       ;; return
        Nop      
        DATA
??set_position_mm_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock172

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner17set_e_position_mmERKf
          CFI Block cfiBlock173 Using cfiCommon0
          CFI Function _ZN7Planner17set_e_position_mmERKf
        THUMB
// __interwork __softfp void Planner::set_e_position_mm(float const &)
_ZN7Planner17set_e_position_mmERKf:
        MOV      R1,R0
        MOVS     R0,#+3
          CFI FunCall _ZN7Planner15set_position_mmE8AxisEnumRKf
        B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf
          CFI EndBlock cfiBlock173

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner13blocks_queuedEv
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function _ZN7Planner13blocks_queuedEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool Planner::blocks_queued()
_ZN7Planner13blocks_queuedEv:
        LDR.N    R0,??blocks_queued_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??blocks_queued_0+0x4
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??blocks_queued_1
        MOVS     R0,#+1
        BX       LR
??blocks_queued_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??blocks_queued_0:
        DC32     _ZN7Planner17block_buffer_headE
        DC32     _ZN7Planner17block_buffer_tailE
          CFI EndBlock cfiBlock174

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Stepper25get_axis_position_degreesE8AxisEnum
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function _ZN7Stepper25get_axis_position_degreesE8AxisEnum
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        THUMB
// __interwork __softfp float Stepper::get_axis_position_degrees(AxisEnum)
_ZN7Stepper25get_axis_position_degreesE8AxisEnum:
        B.W      _ZN7Stepper20get_axis_position_mmE8AxisEnum
          CFI EndBlock cfiBlock175

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Stepper17set_homing_flag_zEb
          CFI Block cfiBlock176 Using cfiCommon0
          CFI Function _ZN7Stepper17set_homing_flag_zEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Stepper::set_homing_flag_z(bool)
_ZN7Stepper17set_homing_flag_zEb:
        LDR.N    R1,??set_homing_flag_z_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??set_homing_flag_z_0:
        DC32     _ZN7Stepper17performing_homingE
          CFI EndBlock cfiBlock176

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Stepper10set_z_lockEb
          CFI Block cfiBlock177 Using cfiCommon0
          CFI Function _ZN7Stepper10set_z_lockEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Stepper::set_z_lock(bool)
_ZN7Stepper10set_z_lockEb:
        LDR.N    R1,??set_z_lock_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??set_z_lock_0:
        DC32     _ZN7Stepper14locked_z_motorE
          CFI EndBlock cfiBlock177

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Stepper11set_z2_lockEb
          CFI Block cfiBlock178 Using cfiCommon0
          CFI Function _ZN7Stepper11set_z2_lockEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Stepper::set_z2_lock(bool)
_ZN7Stepper11set_z2_lockEb:
        LDR.N    R1,??set_z2_lock_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??set_z2_lock_0:
        DC32     _ZN7Stepper15locked_z2_motorE
          CFI EndBlock cfiBlock178

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops15enable_globallyEb
          CFI Block cfiBlock179 Using cfiCommon0
          CFI Function _ZN8Endstops15enable_globallyEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_globally(bool)
_ZN8Endstops15enable_globallyEb:
        LDR.N    R1,??enable_globally_0
        STRB     R0,[R1, #+0]
        LDR.N    R1,??enable_globally_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_globally_0:
        DC32     _ZN8Endstops7enabledE
        DC32     _ZN8Endstops16enabled_globallyE
          CFI EndBlock cfiBlock179

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops6enableEb
          CFI Block cfiBlock180 Using cfiCommon0
          CFI Function _ZN8Endstops6enableEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable(bool)
_ZN8Endstops6enableEb:
        LDR.N    R1,??enable_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_0:
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock180

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops10not_homingEv
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function _ZN8Endstops10not_homingEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::not_homing()
_ZN8Endstops10not_homingEv:
        LDR.N    R0,??not_homing_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??not_homing_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??not_homing_0:
        DC32     _ZN8Endstops16enabled_globallyE
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock181

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14hit_on_purposeEv
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function _ZN8Endstops14hit_on_purposeEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::hit_on_purpose()
_ZN8Endstops14hit_on_purposeEv:
        MOVS     R0,#+0
        LDR.N    R1,??hit_on_purpose_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        DATA
??hit_on_purpose_0:
        DC32     _ZN8Endstops16endstop_hit_bitsE
          CFI EndBlock cfiBlock182

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14enable_z_probeEb
          CFI Block cfiBlock183 Using cfiCommon0
          CFI Function _ZN8Endstops14enable_z_probeEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_z_probe(bool)
_ZN8Endstops14enable_z_probeEb:
        LDR.N    R1,??enable_z_probe_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_z_probe_0:
        DC32     _ZN8Endstops15z_probe_enabledE
          CFI EndBlock cfiBlock183

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature16tooColdToExtrudeEh
          CFI Block cfiBlock184 Using cfiCommon0
          CFI Function _ZN11Temperature16tooColdToExtrudeEh
        THUMB
// __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
_ZN11Temperature16tooColdToExtrudeEh:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??tooColdToExtrude_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??tooColdToExtrude_1
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}
??tooColdToExtrude_1:
        LDR.N    R0,??tooColdToExtrude_0+0x4
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R5,R1
        MOV      R0,R4
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??tooColdToExtrude_2
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}
??tooColdToExtrude_2:
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
        DATA
??tooColdToExtrude_0:
        DC32     _ZN11Temperature18allow_cold_extrudeE
        DC32     _ZN11Temperature16extrude_min_tempE
          CFI EndBlock cfiBlock184

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature9degHotendEh
          CFI Block cfiBlock185 Using cfiCommon0
          CFI Function _ZN11Temperature9degHotendEh
          CFI NoCalls
        THUMB
// __interwork __softfp float Temperature::degHotend(uint8_t)
_ZN11Temperature9degHotendEh:
        LDR.N    R1,??degHotend_0
        LDR      R0,[R1, R0, LSL #+2]
        BX       LR               ;; return
        DATA
??degHotend_0:
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock185

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature6degBedEv
          CFI Block cfiBlock186 Using cfiCommon0
          CFI Function _ZN11Temperature6degBedEv
          CFI NoCalls
        THUMB
// __interwork __softfp float Temperature::degBed()
_ZN11Temperature6degBedEv:
        LDR.N    R0,??degBed_0
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??degBed_0:
        DC32     _ZN11Temperature23current_temperature_bedE
          CFI EndBlock cfiBlock186

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15degTargetHotendEh
          CFI Block cfiBlock187 Using cfiCommon0
          CFI Function _ZN11Temperature15degTargetHotendEh
        THUMB
// __interwork __softfp float Temperature::degTargetHotend(uint8_t)
_ZN11Temperature15degTargetHotendEh:
        LDR.N    R1,??degTargetHotend_0
        LDR      R0,[R1, R0, LSL #+2]
          CFI FunCall __aeabi_i2f
        B.W      __aeabi_i2f
        Nop      
        DATA
??degTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock187

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12degTargetBedEv
          CFI Block cfiBlock188 Using cfiCommon0
          CFI Function _ZN11Temperature12degTargetBedEv
        THUMB
// __interwork __softfp float Temperature::degTargetBed()
_ZN11Temperature12degTargetBedEv:
        LDR.N    R0,??degTargetBed_0
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        B.W      __aeabi_i2f
        Nop      
        DATA
??degTargetBed_0:
        DC32     _ZN11Temperature22target_temperature_bedE
          CFI EndBlock cfiBlock188

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15setTargetHotendEfh
          CFI Block cfiBlock189 Using cfiCommon0
          CFI Function _ZN11Temperature15setTargetHotendEfh
        THUMB
// __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
_ZN11Temperature15setTargetHotendEfh:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDR.N    R1,??setTargetHotend_0
        STR      R0,[R1, R4, LSL #+2]
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        B.W      _ZN11Temperature21start_watching_heaterEh
        DATA
??setTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock189

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12setTargetBedEf
          CFI Block cfiBlock190 Using cfiCommon0
          CFI Function _ZN11Temperature12setTargetBedEf
        THUMB
// __interwork __softfp void Temperature::setTargetBed(float)
_ZN11Temperature12setTargetBedEf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??setTargetBed_0
        LDRSH    R5,[R0, #+50]
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??setTargetBed_1
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
??setTargetBed_1:
        LDR.N    R0,??setTargetBed_0+0x4
        STRH     R5,[R0, #+0]
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature18start_watching_bedEv
        B.W      _ZN11Temperature18start_watching_bedEv
        DATA
??setTargetBed_0:
        DC32     mksCfg
        DC32     _ZN11Temperature22target_temperature_bedE
          CFI EndBlock cfiBlock190

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15isCoolingHotendEh
          CFI Block cfiBlock191 Using cfiCommon0
          CFI Function _ZN11Temperature15isCoolingHotendEh
        THUMB
// __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
_ZN11Temperature15isCoolingHotendEh:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        LDR.N    R0,??isCoolingHotend_0
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R1,??isCoolingHotend_0+0x4
        LDR      R1,[R1, R4, LSL #+2]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??isCoolingHotend_1
        MOVS     R0,#+1
        POP      {R4,PC}
??isCoolingHotend_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??isCoolingHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock191

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12isCoolingBedEv
          CFI Block cfiBlock192 Using cfiCommon0
          CFI Function _ZN11Temperature12isCoolingBedEv
        THUMB
// __interwork __softfp bool Temperature::isCoolingBed()
_ZN11Temperature12isCoolingBedEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??isCoolingBed_0
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R1,??isCoolingBed_0+0x4
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??isCoolingBed_1
        MOVS     R0,#+1
        POP      {R1,PC}
??isCoolingBed_1:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        Nop      
        DATA
??isCoolingBed_0:
        DC32     _ZN11Temperature22target_temperature_bedE
        DC32     _ZN11Temperature23current_temperature_bedE
          CFI EndBlock cfiBlock192

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11Temperature9updatePIDEv
          CFI Block cfiBlock193 Using cfiCommon0
          CFI Function _ZN11Temperature9updatePIDEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Temperature::updatePID()
_ZN11Temperature9updatePIDEv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock193

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature24set_auto_report_intervalEh
          CFI Block cfiBlock194 Using cfiCommon0
          CFI Function _ZN11Temperature24set_auto_report_intervalEh
        THUMB
// __interwork __softfp void Temperature::set_auto_report_interval(uint8_t)
_ZN11Temperature24set_auto_report_intervalEh:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
        CMP      R4,#+61
        BLT.N    ??set_auto_report_interval_0
        MOVS     R4,#+60
??set_auto_report_interval_0:
        LDR.N    R0,??set_auto_report_interval_1
        STRB     R4,[R0, #+0]
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R1,#+1000
        MLA      R0,R1,R4,R0
        LDR.N    R1,??set_auto_report_interval_1+0x4
        STR      R0,[R1, #+0]
        POP      {R4,PC}          ;; return
        DATA
??set_auto_report_interval_1:
        DC32     _ZN11Temperature25auto_report_temp_intervalE
        DC32     _ZN11Temperature19next_temp_report_msE
          CFI EndBlock cfiBlock194

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader10isFileOpenEv
          CFI Block cfiBlock195 Using cfiCommon0
          CFI Function _ZN10CardReader10isFileOpenEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::isFileOpen()
_ZN10CardReader10isFileOpenEv:
        LDR      R0,[R0, #+512]
        CMP      R0,#+0
        BEQ.N    ??isFileOpen_0
        MOVS     R0,#+1
        BX       LR
??isFileOpen_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock195

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3eofEv
          CFI Block cfiBlock196 Using cfiCommon0
          CFI Function _ZN10CardReader3eofEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::eof()
_ZN10CardReader3eofEv:
        LDR      R1,[R0, #+1120]
        LDR      R0,[R0, #+1116]
        CMP      R1,R0
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock196

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3getEv
          CFI Block cfiBlock197 Using cfiCommon0
          CFI Function _ZN10CardReader3getEv
        THUMB
// __interwork __softfp int16_t CardReader::get()
_ZN10CardReader3getEv:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R4,R0
        ADD      R3,SP,#+4
        MOVS     R2,#+1
        ADD      R1,SP,#+0
          CFI FunCall f_read
        BL       f_read
        CMP      R0,#+0
        BEQ.N    ??get_0
        MOV      R0,#-1
        STRB     R0,[SP, #+0]
        B.N      ??get_1
??get_0:
        LDR      R0,[R4, #+1120]
        LDR      R1,[SP, #+4]
        ADDS     R0,R1,R0
        STR      R0,[R4, #+1120]
??get_1:
        LDRSB    R0,[SP, #+0]
        POP      {R1,R2,R4,PC}    ;; return
          CFI EndBlock cfiBlock197

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader8setIndexEl
          CFI Block cfiBlock198 Using cfiCommon0
          CFI Function _ZN10CardReader8setIndexEl
        THUMB
// __interwork __softfp void CardReader::setIndex(long)
_ZN10CardReader8setIndexEl:
        STR      R1,[R0, #+1120]
          CFI FunCall f_lseek
        B.W      f_lseek
          CFI EndBlock cfiBlock198

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10duration_tC1ERKj
          CFI Block cfiBlock199 Using cfiCommon0
          CFI Function _ZN10duration_tC1ERKj
          CFI NoCalls
        THUMB
// __code __interwork __softfp duration_t::duration_t(uint32_t const &)
_ZN10duration_tC1ERKj:
        LDR      R1,[R1, #+0]
        STR      R1,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock199

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4yearEv
          CFI Block cfiBlock200 Using cfiCommon0
          CFI Function _ZNK10duration_t4yearEv
        THUMB
// __interwork __softfp uint8_t duration_t::year() const
_ZNK10duration_t4yearEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R0,R0,R1
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock200

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t3dayEv
          CFI Block cfiBlock201 Using cfiCommon0
          CFI Function _ZNK10duration_t3dayEv
        THUMB
// __interwork __softfp uint16_t duration_t::day() const
_ZNK10duration_t3dayEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R0,R0,R1
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock201

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4hourEv
          CFI Block cfiBlock202 Using cfiCommon0
          CFI Function _ZNK10duration_t4hourEv
        THUMB
// __interwork __softfp uint32_t duration_t::hour() const
_ZNK10duration_t4hourEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock202

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6minuteEv
          CFI Block cfiBlock203 Using cfiCommon0
          CFI Function _ZNK10duration_t6minuteEv
        THUMB
// __interwork __softfp uint32_t duration_t::minute() const
_ZNK10duration_t6minuteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock203

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6secondEv
          CFI Block cfiBlock204 Using cfiCommon0
          CFI Function _ZNK10duration_t6secondEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t duration_t::second() const
_ZNK10duration_t6secondEv:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock204

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZNK10duration_t8toStringEPc
          CFI Block cfiBlock205 Using cfiCommon0
          CFI Function _ZNK10duration_t8toStringEPc
        THUMB
// __interwork __softfp void duration_t::toString(char *) const
_ZNK10duration_t8toStringEPc:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R7,R0
        MOV      R4,R1
          CFI FunCall _ZNK10duration_t4yearEv
        BL       _ZNK10duration_t4yearEv
        MOV      R5,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R1,R0,R1
        MOVW     R2,#+365
        MLS      R6,R2,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R1,R0,R1
        ADD      R2,R1,R1, LSL #+1
        SUB      R8,R0,R2, LSL #+3
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOV      R9,#+60
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R10,R9,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R2,R9,R1,R0
        CMP      R5,#+0
        BEQ.N    ??toString_0
        STR      R2,[SP, #+8]
        STR      R10,[SP, #+4]
        STR      R8,[SP, #+0]
        MOV      R3,R6
        MOV      R2,R5
        LDR.N    R1,??toString_1
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_0:
        CMP      R6,#+0
        BEQ.N    ??toString_3
        STR      R2,[SP, #+4]
        STR      R10,[SP, #+0]
        MOV      R3,R8
        MOV      R2,R6
        LDR.N    R1,??toString_1+0x4
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_3:
        CMP      R8,#+0
        BEQ.N    ??toString_4
        STR      R2,[SP, #+0]
        MOV      R3,R10
        MOV      R2,R8
        LDR.N    R1,??toString_1+0x8
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_4:
        CMP      R10,#+0
        BEQ.N    ??toString_5
        MOV      R3,R2
        MOV      R2,R10
        LDR.N    R1,??toString_1+0xC
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_5:
        LDR.N    R1,??toString_1+0x10
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_2:
        POP      {R0-R10,PC}      ;; return
        Nop      
        DATA
??toString_1:
        DC32     _ZZNK10duration_t8toStringEPcEs
        DC32     _ZZNK10duration_t8toStringEPcEs_0
        DC32     _ZZNK10duration_t8toStringEPcEs_1
        DC32     _ZZNK10duration_t8toStringEPcEs_2
        DC32     _ZZNK10duration_t8toStringEPcEs_3
          CFI EndBlock cfiBlock205

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser4seenEc
          CFI Block cfiBlock206 Using cfiCommon0
          CFI Function _ZN11GCodeParser4seenEc
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::seen(char)
_ZN11GCodeParser4seenEc:
        SUB      R1,R0,#+65
        UXTB     R1,R1
        CMP      R1,#+26
        BCC.N    ??seen_0
        MOVS     R0,#+0
        BX       LR
??seen_0:
        ASRS     R0,R1,#+3
        LDR.N    R2,??seen_1
        LDRB     R0,[R0, R2]
        AND      R2,R1,#0x7
        LSRS     R0,R0,R2
        ANDS     R0,R0,#0x1
        BEQ.N    ??seen_2
        LDR.N    R2,??seen_1+0x4
        LDRB     R1,[R1, R2]
        LDR.N    R2,??seen_1+0x8
        CMP      R1,#+0
        BEQ.N    ??seen_3
        LDR.N    R3,??seen_1+0xC
        LDR      R3,[R3, #+0]
        ADDS     R1,R1,R3
        STR      R1,[R2, #+0]
        BX       LR
??seen_3:
        MOVS     R1,#+0
        STR      R1,[R2, #+0]
??seen_2:
        BX       LR               ;; return
        Nop      
        DATA
??seen_1:
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
          CFI EndBlock cfiBlock206

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser9has_valueEv
          CFI Block cfiBlock207 Using cfiCommon0
          CFI Function _ZN11GCodeParser9has_valueEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::has_value()
_ZN11GCodeParser9has_valueEv:
        LDR.N    R0,??has_value_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??has_value_1
        MOVS     R0,#+1
        BX       LR
??has_value_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??has_value_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock207

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7seenvalEc
          CFI Block cfiBlock208 Using cfiCommon0
          CFI Function _ZN11GCodeParser7seenvalEc
        THUMB
// __interwork __softfp bool GCodeParser::seenval(char)
_ZN11GCodeParser7seenvalEc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??seenval_0
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser9has_valueEv
        B.W      _ZN11GCodeParser9has_valueEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??seenval_0:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock208

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_floatEv
          CFI Block cfiBlock209 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_float()
_ZN11GCodeParser11value_floatEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R2,??value_float_0
        LDR      R0,[R2, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_float_1
        MOV      R4,R0
        B.N      ??value_float_2
??value_float_3:
        ADDS     R4,R4,#+1
??value_float_2:
        LDRSB    R5,[R4, #+0]
        CMP      R5,#+0
        BEQ.N    ??value_float_4
        CMP      R5,#+32
        BNE.N    ??value_float_5
??value_float_4:
        MOVS     R1,#+0
          CFI FunCall strtod
        BL       strtod
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_d2f
        B.W      __aeabi_d2f
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??value_float_5:
        CMP      R5,#+69
        BEQ.N    ??value_float_6
        CMP      R5,#+101
        BNE.N    ??value_float_3
??value_float_6:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        MOV      R1,R0
        LDR      R0,[R2, #+0]
          CFI FunCall strtod
        BL       strtod
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STRB     R5,[R4, #+0]
        POP      {R1,R4,R5,PC}
??value_float_1:
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
        Nop      
        DATA
??value_float_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock209

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser10value_longEv
          CFI Block cfiBlock210 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_longEv
        THUMB
// __interwork __softfp int32_t GCodeParser::value_long()
_ZN11GCodeParser10value_longEv:
        LDR.N    R0,??value_long_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_long_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtol
        B.W      strtol
??value_long_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_long_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock210

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_ulongEv
          CFI Block cfiBlock211 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp uint32_t GCodeParser::value_ulong()
_ZN11GCodeParser11value_ulongEv:
        LDR.N    R0,??value_ulong_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_ulong_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtoul
        B.W      strtoul
??value_ulong_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_ulong_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock211

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_millisEv
          CFI Block cfiBlock212 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_millisEv
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis()
_ZN11GCodeParser12value_millisEv:
        B.W      _ZN11GCodeParser11value_ulongEv
          CFI EndBlock cfiBlock212

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser25value_millis_from_secondsEv
          CFI Block cfiBlock213 Using cfiCommon0
          CFI Function _ZN11GCodeParser25value_millis_from_secondsEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis_from_seconds()
_ZN11GCodeParser25value_millis_from_secondsEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??value_millis_from_seconds_0  ;; 0x447a0000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_f2uiz
        B.W      __aeabi_f2uiz
        DATA
??value_millis_from_seconds_0:
        DC32     0x447a0000
          CFI EndBlock cfiBlock213

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9value_intEv
          CFI Block cfiBlock214 Using cfiCommon0
          CFI Function _ZN11GCodeParser9value_intEv
        THUMB
// __interwork __softfp int16_t GCodeParser::value_int()
_ZN11GCodeParser9value_intEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        SXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock214

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_ushortEv
          CFI Block cfiBlock215 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_ushortEv
        THUMB
// __interwork __softfp uint16_t GCodeParser::value_ushort()
_ZN11GCodeParser12value_ushortEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock215

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_byteEv
          CFI Block cfiBlock216 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_byteEv
        THUMB
// __interwork __softfp uint8_t GCodeParser::value_byte()
_ZN11GCodeParser10value_byteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+0
        BPL.N    ??value_byte_0
        MOVS     R0,#+0
        B.N      ??value_byte_1
??value_byte_0:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+255
        BLE.N    ??value_byte_2
        MOVS     R0,#+255
        B.N      ??value_byte_1
??value_byte_2:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
??value_byte_1:
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock216

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_boolEv
          CFI Block cfiBlock217 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_boolEv
        THUMB
// __interwork __softfp bool GCodeParser::value_bool()
_ZN11GCodeParser10value_boolEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser9has_valueEv
        BL       _ZN11GCodeParser9has_valueEv
        CMP      R0,#+0
        BEQ.N    ??value_bool_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        POP      {R1,PC}
??value_bool_0:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock217

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser18value_linear_unitsEv
          CFI Block cfiBlock218 Using cfiCommon0
          CFI Function _ZN11GCodeParser18value_linear_unitsEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_linear_units()
_ZN11GCodeParser18value_linear_unitsEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock218

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI Block cfiBlock219 Using cfiCommon0
          CFI Function _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_axis_units(AxisEnum)
_ZN11GCodeParser16value_axis_unitsE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock219

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI Block cfiBlock220 Using cfiCommon0
          CFI Function _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_per_axis_unit(AxisEnum)
_ZN11GCodeParser19value_per_axis_unitE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock220

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser13value_celsiusEv
          CFI Block cfiBlock221 Using cfiCommon0
          CFI Function _ZN11GCodeParser13value_celsiusEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_celsius()
_ZN11GCodeParser13value_celsiusEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock221

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser14value_feedrateEv
          CFI Block cfiBlock222 Using cfiCommon0
          CFI Function _ZN11GCodeParser14value_feedrateEv
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        THUMB
// __interwork __softfp float GCodeParser::value_feedrate()
_ZN11GCodeParser14value_feedrateEv:
        B.W      _ZN11GCodeParser18value_linear_unitsEv
          CFI EndBlock cfiBlock222

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7boolvalEc
          CFI Block cfiBlock223 Using cfiCommon0
          CFI Function _ZN11GCodeParser7boolvalEc
        THUMB
// __interwork __softfp bool GCodeParser::boolval(char)
_ZN11GCodeParser7boolvalEc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??boolval_0
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        B.W      _ZN11GCodeParser10value_boolEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??boolval_0:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser4seenEc
        B.W      _ZN11GCodeParser4seenEc
          CFI EndBlock cfiBlock223

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7bytevalEch
          CFI Block cfiBlock224 Using cfiCommon0
          CFI Function _ZN11GCodeParser7bytevalEch
        THUMB
// __interwork __softfp uint8_t GCodeParser::byteval(char, uint8_t)
_ZN11GCodeParser7bytevalEch:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??byteval_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
??byteval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock224

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser6intvalEcs
          CFI Block cfiBlock225 Using cfiCommon0
          CFI Function _ZN11GCodeParser6intvalEcs
        THUMB
// __interwork __softfp int16_t GCodeParser::intval(char, int16_t)
_ZN11GCodeParser6intvalEcs:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??intval_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
??intval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock225

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9ushortvalEct
          CFI Block cfiBlock226 Using cfiCommon0
          CFI Function _ZN11GCodeParser9ushortvalEct
        THUMB
// __interwork __softfp uint16_t GCodeParser::ushortval(char, uint16_t)
_ZN11GCodeParser9ushortvalEct:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??ushortval_0
          CFI FunCall _ZN11GCodeParser12value_ushortEv
        BL       _ZN11GCodeParser12value_ushortEv
        MOV      R4,R0
??ushortval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock226

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9linearvalEcf
          CFI Block cfiBlock227 Using cfiCommon0
          CFI Function _ZN11GCodeParser9linearvalEcf
        THUMB
// __interwork __softfp float GCodeParser::linearval(char, float)
_ZN11GCodeParser9linearvalEcf:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??linearval_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R4,R0
??linearval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock227

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10celsiusvalEcf
          CFI Block cfiBlock228 Using cfiCommon0
          CFI Function _ZN11GCodeParser10celsiusvalEcf
        THUMB
// __interwork __softfp float GCodeParser::celsiusval(char, float)
_ZN11GCodeParser10celsiusvalEcf:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??celsiusval_0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R4,R0
??celsiusval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock228

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21incremental_LSF_resetP15linear_fit_data
          CFI Block cfiBlock229 Using cfiCommon0
          CFI Function _Z21incremental_LSF_resetP15linear_fit_data
        THUMB
// __interwork __softfp void incremental_LSF_reset(linear_fit_data *)
_Z21incremental_LSF_resetP15linear_fit_data:
        MOVS     R2,#+60
        MOVS     R1,#+0
          CFI FunCall memset
        B.W      memset
          CFI EndBlock cfiBlock229

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
          CFI Block cfiBlock230 Using cfiCommon0
          CFI Function _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        THUMB
// __interwork __softfp void incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
_Z15incremental_LSFP15linear_fit_dataRKfS2_S2_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R7,R1
        MOV      R6,R2
        MOV      R8,R3
        LDR      R1,[R5, #+0]
        LDR      R0,[R7, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+0]
        LDR      R1,[R5, #+4]
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+4]
        LDR      R1,[R5, #+8]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+8]
        LDR      R11,[R7, #+0]
        MOV      R9,#+2
        MOV      R4,#+1065353216
        MOV      R10,R4
        B.N      ??incremental_LSF_0
??incremental_LSF_1:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??incremental_LSF_0:
        LSLS     R0,R9,#+31
        BPL.N    ??incremental_LSF_2
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_2:
        LSRS     R9,R9,#+1
        BNE.N    ??incremental_LSF_1
        LDR      R0,[R5, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+12]
        LDR      R11,[R6, #+0]
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??incremental_LSF_3
??incremental_LSF_4:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??incremental_LSF_3:
        LSLS     R0,R9,#+31
        BPL.N    ??incremental_LSF_5
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_5:
        LSRS     R9,R9,#+1
        BNE.N    ??incremental_LSF_4
        LDR      R0,[R5, #+16]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+16]
        LDR      R10,[R8, #+0]
        MOV      R9,#+2
        B.N      ??incremental_LSF_6
??incremental_LSF_7:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_6:
        LSLS     R0,R9,#+31
        BPL.N    ??incremental_LSF_8
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??incremental_LSF_8:
        LSRS     R9,R9,#+1
        BNE.N    ??incremental_LSF_7
        LDR      R0,[R5, #+20]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+20]
        LDR      R1,[R7, #+0]
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+24]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+24]
        LDR      R1,[R7, #+0]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+28]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+28]
        LDR      R1,[R6, #+0]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+32]
        LDR      R0,[R5, #+36]
        LDR      R1,[R7, #+0]
        BIC      R1,R1,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??incremental_LSF_9
        LDR      R0,[R7, #+0]
        BIC      R0,R0,#0x80000000
??incremental_LSF_9:
        STR      R0,[R5, #+36]
        LDR      R0,[R5, #+40]
        LDR      R1,[R6, #+0]
        BIC      R1,R1,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??incremental_LSF_10
        LDR      R0,[R6, #+0]
        BIC      R0,R0,#0x80000000
??incremental_LSF_10:
        STR      R0,[R5, #+40]
        LDR      R1,[R5, #+56]
        MOV      R0,#+1065353216
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+56]
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock230

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling18mesh_index_to_xposEh
          CFI Block cfiBlock231 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling18mesh_index_to_xposEh
        THUMB
// __interwork __softfp float unified_bed_leveling::mesh_index_to_xpos(uint8_t)
_ZN20unified_bed_leveling18mesh_index_to_xposEh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        LDR.N    R7,??mesh_index_to_xpos_0
        LDRB     R6,[R7, #+96]
        ADD      R0,R7,#+8
        LDRH     R1,[R0, #+80]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??mesh_index_to_xpos_1
        CMP      R5,R6
        BCS.N    ??mesh_index_to_xpos_2
        LDR.N    R0,??mesh_index_to_xpos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_xpos_3
??mesh_index_to_xpos_2:
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        LDR.N    R4,??mesh_index_to_xpos_0+0x8
        LDR      R0,[R4, #+0]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        LDR      R0,[R4, #+4]
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_xpos_1:
        CMP      R5,R6
        BCS.N    ??mesh_index_to_xpos_4
        LDR.N    R0,??mesh_index_to_xpos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_xpos_3
??mesh_index_to_xpos_4:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        ADD      R0,R7,#+96
        LDR      R11,[R0, #+12]
        LDR      R0,[R7, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mesh_index_to_xpos_5
        STR      R4,[SP, #+0]
        B.N      ??mesh_index_to_xpos_6
??mesh_index_to_xpos_5:
        STR      R7,[SP, #+0]
??mesh_index_to_xpos_6:
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_xpos_7
        MOV      R9,R1
??mesh_index_to_xpos_7:
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_xpos_8
        MOV      R4,R7
??mesh_index_to_xpos_8:
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+0]
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_xpos_3:
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??mesh_index_to_xpos_0:
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling19_mesh_index_to_xposE
        DC32     mksTmp
          CFI EndBlock cfiBlock231

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling18mesh_index_to_yposEh
          CFI Block cfiBlock232 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling18mesh_index_to_yposEh
        THUMB
// __interwork __softfp float unified_bed_leveling::mesh_index_to_ypos(uint8_t)
_ZN20unified_bed_leveling18mesh_index_to_yposEh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        LDR.N    R7,??mesh_index_to_ypos_0
        LDRB     R6,[R7, #+97]
        ADD      R0,R7,#+12
        LDRH     R1,[R0, #+76]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??mesh_index_to_ypos_1
        CMP      R5,R6
        BCS.N    ??mesh_index_to_ypos_2
        LDR.N    R0,??mesh_index_to_ypos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_ypos_3
??mesh_index_to_ypos_2:
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        LDR.N    R4,??mesh_index_to_ypos_0+0x8
        LDR      R0,[R4, #+8]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        LDR      R0,[R4, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_ypos_1:
        CMP      R5,R6
        BCS.N    ??mesh_index_to_ypos_4
        LDR.N    R0,??mesh_index_to_ypos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_ypos_3
??mesh_index_to_ypos_4:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R11,[R7, #+112]
        LDR      R0,[R7, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mesh_index_to_ypos_5
        STR      R4,[SP, #+0]
        B.N      ??mesh_index_to_ypos_6
??mesh_index_to_ypos_5:
        STR      R7,[SP, #+0]
??mesh_index_to_ypos_6:
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_ypos_7
        MOV      R9,R1
??mesh_index_to_ypos_7:
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_ypos_8
        MOV      R4,R7
??mesh_index_to_ypos_8:
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+0]
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_ypos_3:
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??mesh_index_to_ypos_0:
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling19_mesh_index_to_yposE
        DC32     mksTmp
          CFI EndBlock cfiBlock232

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling13mesh_is_validEv
          CFI Block cfiBlock233 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling13mesh_is_validEv
        THUMB
// __interwork __softfp bool unified_bed_leveling::mesh_is_valid()
_ZN20unified_bed_leveling13mesh_is_validEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R2,??mesh_is_valid_0
        LDR      R3,[R2, #+4]
        LDR      R4,[R2, #+0]
        MOV      R0,R4
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R3
        LDR      R1,[R2, #+8]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        LDR      R3,[R2, #+52]
        LDR      R5,[R2, #+48]
        MOV      R0,R5
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R3
        LDR      R1,[R2, #+56]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        LDR      R3,[R2, #+100]
        LDR      R6,[R2, #+96]
        MOV      R0,R6
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R3
        LDR      R1,[R2, #+104]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R6
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??mesh_is_valid_2
??mesh_is_valid_1:
        MOV      R0,R4
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??mesh_is_valid_2
        MOVS     R0,#+1
        POP      {R4-R6,PC}
??mesh_is_valid_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
        DATA
??mesh_is_valid_0:
        DC32     _ZN20unified_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock233

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13gcode_G29_UBLv
          CFI Block cfiBlock234 Using cfiCommon0
          CFI Function _Z13gcode_G29_UBLv
          CFI FunCall _ZN20unified_bed_leveling13gcode_G29_UBLEv
        THUMB
// __interwork __softfp void gcode_G29_UBL()
_Z13gcode_G29_UBLv:
        B.W      _ZN20unified_bed_leveling13gcode_G29_UBLEv
          CFI EndBlock cfiBlock234

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling5set_zEaaRKf
          CFI Block cfiBlock235 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling5set_zEaaRKf
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
_ZN17mesh_bed_leveling5set_zEaaRKf:
        ADD      R3,R0,R0, LSL #+1
        LDR.N    R0,??set_z_0
        ADD      R0,R0,R3, LSL #+4
        LDR      R2,[R2, #+0]
        STR      R2,[R0, R1, LSL #+2]
        BX       LR               ;; return
        Nop      
        DATA
??set_z_0:
        DC32     _ZN17mesh_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock235

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling6zigzagEaRaS0_
          CFI Block cfiBlock236 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling6zigzagEaRaS0_
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
_ZN17mesh_bed_leveling6zigzagEaRaS0_:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R3,??zigzag_0
        LDRB     R4,[R3, #+96]
        SDIV     R5,R0,R4
        MLS      R4,R4,R5,R0
        STRB     R4,[R1, #+0]
        LDRB     R4,[R3, #+96]
        SDIV     R0,R0,R4
        STRB     R0,[R2, #+0]
        LDRB     R0,[R2, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??zigzag_1
        LDRSB    R0,[R3, #+96]
        SUBS     R0,R0,#+1
        LDRB     R2,[R1, #+0]
        SUBS     R0,R0,R2
        STRB     R0,[R1, #+0]
??zigzag_1:
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??zigzag_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock236

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
          CFI Block cfiBlock237 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
_ZN17mesh_bed_leveling12set_zigzag_zEaRKf:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R1
        ADD      R2,SP,#+0
        ADD      R1,SP,#+1
          CFI FunCall _ZN17mesh_bed_leveling6zigzagEaRaS0_
        BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
        MOV      R2,R4
        LDRSB    R1,[SP, #+0]
        LDRSB    R0,[SP, #+1]
          CFI FunCall _ZN17mesh_bed_leveling5set_zEaaRKf
        BL       _ZN17mesh_bed_leveling5set_zEaaRKf
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock237

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_xERKf
          CFI Block cfiBlock238 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
_ZN17mesh_bed_leveling12cell_index_xERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
        LDR.N    R6,??cell_index_x_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        ADD      R0,R6,#+8
        LDRH     R1,[R0, #+80]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??cell_index_x_1
        LDR.W    R8,??cell_index_x_0+0x4
        LDR      R0,[R8, #+0]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R8, #+4]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??cell_index_x_2
??cell_index_x_1:
        LDR      R9,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        ADD      R0,R6,#+96
        LDR      R10,[R0, #+12]
        LDR      R0,[R6, #+8]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??cell_index_x_3
        STR      R8,[SP, #+0]
        B.N      ??cell_index_x_4
??cell_index_x_3:
        STR      R5,[SP, #+0]
??cell_index_x_4:
        MOV      R0,#+1073741824
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_x_5
        MOV      R7,R1
??cell_index_x_5:
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_x_6
        MOV      R8,R5
??cell_index_x_6:
        LDR      R0,[R4, #+0]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??cell_index_x_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BPL.N    ??cell_index_x_7
        MOVS     R0,#+0
        B.N      ??cell_index_x_8
??cell_index_x_7:
        LDRB     R2,[R6, #+96]
        SUBS     R3,R2,#+2
        CMP      R3,R1
        BGE.N    ??cell_index_x_8
        SUBS     R0,R2,#+2
??cell_index_x_8:
        SXTB     R0,R0
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??cell_index_x_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3ff00000
          CFI EndBlock cfiBlock238

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_yERKf
          CFI Block cfiBlock239 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
_ZN17mesh_bed_leveling12cell_index_yERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
        LDR.N    R6,??cell_index_y_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        ADD      R0,R6,#+12
        LDRH     R1,[R0, #+76]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??cell_index_y_1
        LDR.W    R8,??cell_index_y_0+0x4
        LDR      R0,[R8, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R8, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??cell_index_y_2
??cell_index_y_1:
        LDR      R9,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R10,[R6, #+112]
        LDR      R0,[R6, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??cell_index_y_3
        STR      R8,[SP, #+0]
        B.N      ??cell_index_y_4
??cell_index_y_3:
        STR      R5,[SP, #+0]
??cell_index_y_4:
        MOV      R0,#+1073741824
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_y_5
        MOV      R7,R1
??cell_index_y_5:
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_y_6
        MOV      R8,R5
??cell_index_y_6:
        LDR      R0,[R4, #+0]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??cell_index_y_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BPL.N    ??cell_index_y_7
        MOVS     R0,#+0
        B.N      ??cell_index_y_8
??cell_index_y_7:
        LDRB     R2,[R6, #+97]
        SUBS     R3,R2,#+2
        CMP      R3,R1
        BGE.N    ??cell_index_y_8
        SUBS     R0,R2,#+2
??cell_index_y_8:
        SXTB     R0,R0
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??cell_index_y_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3ff00000
          CFI EndBlock cfiBlock239

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_xERKf
          CFI Block cfiBlock240 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_x(float const &)
_ZN17mesh_bed_leveling13probe_index_xERKf:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R7,R0
        LDR.N    R6,??probe_index_x_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R9,R0
        ADD      R0,R6,#+8
        LDRH     R1,[R0, #+80]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??probe_index_x_1
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR.N    R4,??probe_index_x_0+0x4
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R4, #+4]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0x8  ;; 0x3fe00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??probe_index_x_2
??probe_index_x_1:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        ADD      R0,R6,#+96
        LDR      R11,[R0, #+12]
        LDR      R0,[R6, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_x_3
        STR      R4,[SP, #+8]
        B.N      ??probe_index_x_4
??probe_index_x_3:
        STR      R5,[SP, #+8]
??probe_index_x_4:
        MOV      R0,#+1073741824
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R2,R0
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_x_5
        MOV      R8,R10
        B.N      ??probe_index_x_6
??probe_index_x_5:
        MOV      R8,R2
??probe_index_x_6:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_x_7
        MOV      R9,R4
        B.N      ??probe_index_x_8
??probe_index_x_7:
        MOV      R9,R5
??probe_index_x_8:
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_x_9
        MOV      R10,R2
??probe_index_x_9:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_x_10
        MOV      R4,R5
??probe_index_x_10:
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR      R0,[R7, #+0]
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_x_0+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDRD     R2,R3,[SP, #+0]
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??probe_index_x_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BMI.N    ??probe_index_x_11
        LDRB     R2,[R6, #+96]
        SUBS     R2,R2,#+1
        CMP      R2,R1
        BGE.N    ??probe_index_x_12
??probe_index_x_11:
        MOV      R0,#-1
??probe_index_x_12:
        POP      {R1-R11,PC}      ;; return
        Nop      
        DATA
??probe_index_x_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock240

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_yERKf
          CFI Block cfiBlock241 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_y(float const &)
_ZN17mesh_bed_leveling13probe_index_yERKf:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R7,R0
        LDR.N    R6,??probe_index_y_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R9,R0
        ADD      R0,R6,#+12
        LDRSH    R1,[R0, #+76]
        MOVW     R2,#+770
        CMP      R1,R2
        BNE.N    ??probe_index_y_1
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR.N    R4,??probe_index_y_0+0x4
        LDR      R0,[R4, #+8]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R4, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0x8  ;; 0x3fe00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??probe_index_y_2
??probe_index_y_1:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R11,[R6, #+112]
        LDR      R0,[R6, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_y_3
        STR      R4,[SP, #+8]
        B.N      ??probe_index_y_4
??probe_index_y_3:
        STR      R5,[SP, #+8]
??probe_index_y_4:
        MOV      R0,#+1073741824
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R2,R0
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_y_5
        MOV      R8,R10
        B.N      ??probe_index_y_6
??probe_index_y_5:
        MOV      R8,R2
??probe_index_y_6:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_y_7
        MOV      R9,R4
        B.N      ??probe_index_y_8
??probe_index_y_7:
        MOV      R9,R5
??probe_index_y_8:
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_y_9
        MOV      R10,R2
??probe_index_y_9:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_y_10
        MOV      R4,R5
??probe_index_y_10:
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR      R0,[R7, #+0]
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_y_0+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDRD     R2,R3,[SP, #+0]
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??probe_index_y_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BMI.N    ??probe_index_y_11
        LDRB     R2,[R6, #+97]
        SUBS     R2,R2,#+1
        CMP      R2,R1
        BGE.N    ??probe_index_y_12
??probe_index_y_11:
        MOV      R0,#-1
??probe_index_y_12:
        POP      {R1-R11,PC}      ;; return
        Nop      
        DATA
??probe_index_y_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock241

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z20sync_plan_position_ev
          CFI Block cfiBlock242 Using cfiCommon0
          CFI Function _Z20sync_plan_position_ev
        THUMB
_Z20sync_plan_position_ev:
        LDR.N    R0,??sync_plan_position_e_0
          CFI FunCall _ZN7Planner17set_e_position_mmERKf
        B.W      _ZN7Planner17set_e_position_mmERKf
        Nop      
        DATA
??sync_plan_position_e_0:
        DC32     mks_heating_busy+0x14
          CFI EndBlock cfiBlock242

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28sync_plan_position_kinematicv
          CFI Block cfiBlock243 Using cfiCommon0
          CFI Function _Z28sync_plan_position_kinematicv
        THUMB
_Z28sync_plan_position_kinematicv:
        LDR.N    R0,??sync_plan_position_kinematic_0
          CFI FunCall _ZN7Planner25set_position_mm_kinematicERA4_Kf
        B.W      _ZN7Planner25set_position_mm_kinematicERA4_Kf
        Nop      
        DATA
??sync_plan_position_kinematic_0:
        DC32     mks_heating_busy+0x8
          CFI EndBlock cfiBlock243

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_commit_commandb
          CFI Block cfiBlock244 Using cfiCommon0
          CFI Function _Z15_commit_commandb
          CFI NoCalls
        THUMB
_Z15_commit_commandb:
        LDR.N    R1,??_commit_command_0
        LDRB     R2,[R1, #+8]
        ADDS     R3,R2,R1
        STRB     R0,[R3, #+20]
        ADDS     R0,R2,#+1
        STRB     R0,[R1, #+8]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??_commit_command_1
        MOVS     R0,#+0
        STRB     R0,[R1, #+8]
??_commit_command_1:
        LDR.N    R0,??_commit_command_0+0x4
        LDRB     R1,[R0, #+2]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+2]
        BX       LR               ;; return
        DATA
??_commit_command_0:
        DC32     filament_loading_time_flg
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock244

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_enqueuecommandPKcb
          CFI Block cfiBlock245 Using cfiCommon0
          CFI Function _Z15_enqueuecommandPKcb
        THUMB
_Z15_enqueuecommandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+59
        BEQ.N    ??_enqueuecommand_0
        LDR.N    R1,??_enqueuecommand_1
        LDRB     R1,[R1, #+2]
        CMP      R1,#+4
        BLT.N    ??_enqueuecommand_2
??_enqueuecommand_0:
        MOVS     R0,#+0
        POP      {R4,PC}
??_enqueuecommand_2:
        MOV      R1,R0
        LDR.N    R0,??_enqueuecommand_1+0x4
        LDRB     R0,[R0, #+8]
        ADD      R2,R0,R0, LSL #+1
        LDR.N    R0,??_enqueuecommand_1+0x8
        ADD      R0,R0,R2, LSL #+5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
        MOVS     R0,#+1
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??_enqueuecommand_1:
        DC32     mks_heating_busy
        DC32     filament_loading_time_flg
        DC32     command_queue
          CFI EndBlock cfiBlock245

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_serial_commandsv
          CFI Block cfiBlock246 Using cfiCommon0
          CFI Function _Z19get_serial_commandsv
        THUMB
_Z19get_serial_commandsv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
        LDR.N    R4,??get_serial_commands_0
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x4
          CFI FunCall _ZN10USARTClass9availableEv
        BL       _ZN10USARTClass9availableEv
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x8
        LDR      R1,[R0, #+0]
        SUBS     R1,R6,R1
        SUBS     R1,R1,#+1000
        BMI.W    ??get_serial_commands_1
        LDR.N    R5,??get_serial_commands_0+0xC
        LDRB     R1,[R5, #+8]
        CMP      R1,#+6
        BGE.N    ??get_serial_commands_2
        ADDS     R1,R1,#+1
        STRB     R1,[R5, #+8]
??get_serial_commands_2:
        STR      R6,[R0, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_3:
        ADDS     R7,R7,#+1
??get_serial_commands_4:
        LDRSB    R0,[R7, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_serial_commands_3
        CMP      R0,#+78
        BNE.N    ??get_serial_commands_5
        MOV      R9,R7
        B.N      ??get_serial_commands_6
??get_serial_commands_5:
        MOV      R9,#+0
??get_serial_commands_6:
        CMP      R9,#+0
        BEQ.N    ??get_serial_commands_7
        LDR.N    R1,??get_serial_commands_0+0x10
        MOV      R0,R7
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_8
        MOV      R8,#+1
        B.N      ??get_serial_commands_9
??get_serial_commands_8:
        MOV      R8,#+0
??get_serial_commands_9:
        CMP      R8,#+0
        BEQ.N    ??get_serial_commands_10
        MOVS     R1,#+78
        ADDS     R0,R7,#+4
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_10
        MOV      R9,R0
??get_serial_commands_10:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,R9,#+1
          CFI FunCall strtol
        BL       strtol
        STR      R0,[R5, #+40]
        LDR      R1,[R5, #+44]
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BEQ.N    ??get_serial_commands_11
        CMP      R8,#+0
        BNE.N    ??get_serial_commands_11
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x14
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_11:
        MOVS     R1,#+42
        MOV      R0,R7
          CFI FunCall _Z7strrchrPci
        BL       _Z7strrchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_12
        MOV      R8,#+0
        SUBS     R1,R0,R7
        B.N      ??get_serial_commands_13
??get_serial_commands_14:
        SUBS     R1,R1,#+1
        UXTB     R1,R1
        LDRSB    R2,[R1, R7]
        EOR      R8,R2,R8
??get_serial_commands_13:
        UXTB     R1,R1
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_14
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        UXTB     R8,R8
        CMP      R0,R8
        BEQ.N    ??get_serial_commands_15
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x18
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_15:
        LDR      R0,[R5, #+40]
        STR      R0,[R5, #+44]
??get_serial_commands_7:
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R1,#+71
        MOV      R0,R7
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_serial_commands_16
        LDR.N    R0,??get_serial_commands_0+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_serial_commands_0+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??get_serial_commands_16:
        LDR.N    R1,??get_serial_commands_0+0x24
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_17
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
??get_serial_commands_17:
        LDR.N    R1,??get_serial_commands_0+0x28
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_18
        LDR.N    R0,??get_serial_commands_0+0x2C
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_serial_commands_18:
        LDR.N    R1,??get_serial_commands_0+0x30
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_19
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_serial_commands_19:
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_serial_commands_1:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+4
        BGE.N    ??get_serial_commands_20
        LDR.N    R6,??get_serial_commands_0+0x4
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_20
        SXTB     R0,R0
        LDR.N    R5,??get_serial_commands_0+0xC
        MOVS     R1,#+0
        STRH     R1,[R5, #+8]
        CMP      R0,#+10
        BEQ.N    ??get_serial_commands_21
        CMP      R0,#+13
        BNE.N    ??get_serial_commands_22
??get_serial_commands_21:
        MOV      R0,R1
        LDR.N    R1,??get_serial_commands_0+0x34
        STRB     R0,[R1, #+0]
        LDR      R1,[R5, #+52]
        CMP      R1,#+0
        BEQ.N    ??get_serial_commands_1
        LDR.N    R6,??get_serial_commands_0+0x38
        STRB     R0,[R1, R6]
        STR      R0,[R5, #+52]
        MOV      R7,R6
        B.N      ??get_serial_commands_4
??get_serial_commands_12:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x3C
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_22:
        LDR      R1,[R5, #+52]
        CMP      R1,#+95
        BGE.N    ??get_serial_commands_1
        CMP      R0,#+92
        BNE.N    ??get_serial_commands_23
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_1
        LDR.N    R1,??get_serial_commands_0+0x34
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_1
        LDR      R1,[R5, #+52]
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R5, #+52]
        B.N      ??get_serial_commands_1
??get_serial_commands_23:
        LDR.N    R2,??get_serial_commands_0+0x34
        CMP      R0,#+59
        BNE.N    ??get_serial_commands_24
        MOVS     R3,#+1
        STRB     R3,[R2, #+0]
??get_serial_commands_24:
        LDRB     R2,[R2, #+0]
        CMP      R2,#+0
        BNE.N    ??get_serial_commands_1
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R5, #+52]
        B.N      ??get_serial_commands_1
??get_serial_commands_20:
        POP      {R0,R4-R9,PC}    ;; return
        Nop      
        DATA
??get_serial_commands_0:
        DC32     mks_heating_busy
        DC32     Serial3
        DC32     _ZZ19get_serial_commandsvE14last_wait_time
        DC32     axis_relative_modes
        DC32     _ZZ19get_serial_commandsvEs
        DC32     _ZZ19get_serial_commandsvEs_0
        DC32     _ZZ19get_serial_commandsvEs_1
        DC32     _ZZ19get_serial_commandsvEs_3
        DC32     _ZZ19get_serial_commandsvEs_4
        DC32     _ZZ19get_serial_commandsvEs_5
        DC32     _ZZ19get_serial_commandsvEs_6
        DC32     _ZZ19get_serial_commandsvEs_7
        DC32     _ZZ19get_serial_commandsvEs_8
        DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
        DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
        DC32     _ZZ19get_serial_commandsvEs_2
          CFI EndBlock cfiBlock246

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_sdcard_commandsv
          CFI Block cfiBlock247 Using cfiCommon0
          CFI Function _Z19get_sdcard_commandsv
        THUMB
_Z19get_sdcard_commandsv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.N    R4,??get_sdcard_commands_0
        LDRB     R0,[R4, #+1888]
        CMP      R0,#+0
        BEQ.W    ??get_sdcard_commands_1
        LDR.N    R5,??get_sdcard_commands_0+0x4
        LDRB     R0,[R5, #+2]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_2
        MOVS     R0,#+0
        LDR.N    R1,??get_sdcard_commands_0+0x8
        STRB     R0,[R1, #+0]
??get_sdcard_commands_2:
        MOVS     R6,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R9,R0
        LDR.N    R7,??get_sdcard_commands_0+0x8
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_4:
        CMN      R10,#+1
        BNE.N    ??get_sdcard_commands_5
        LDR.N    R0,??get_sdcard_commands_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_sdcard_commands_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall SD_Init
        BL       SD_Init
        MOV      R0,R4
          CFI FunCall _ZN10CardReader6initsdEv
        BL       _ZN10CardReader6initsdEv
        LDR.N    R1,??get_sdcard_commands_0+0x14
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10reopenfileEPc
        BL       _ZN10CardReader10reopenfileEPc
        CMP      R0,#+0
        BEQ.N    ??get_sdcard_commands_6
        LDR      R1,[R4, #+1120]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??get_sdcard_commands_6:
        LDR.W    R10,??get_sdcard_commands_0+0x18
        MOVS     R2,#+96
        MOVS     R1,#+0
        LDRB     R0,[R10, #+8]
        ADD      R3,R0,R0, LSL #+1
        LDR.N    R0,??get_sdcard_commands_0+0x1C
        ADD      R0,R0,R3, LSL #+5
          CFI FunCall memset
        BL       memset
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
        LDR.N    R0,??get_sdcard_commands_0+0x20
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+16
        BEQ.N    ??get_sdcard_commands_7
          CFI FunCall GUI_RefreshPage
        BL       GUI_RefreshPage
??get_sdcard_commands_7:
        LDRB     R0,[R10, #+5]
        CMP      R0,#+1
        BEQ.N    ??get_sdcard_commands_8
        MOVS     R1,#+36
        MOVS     R0,#+2
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
??get_sdcard_commands_8:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        MOVS     R0,#+1
        STRB     R0,[R10, #+9]
        LDRB     R0,[R10, #+10]
        ADDS     R0,R0,#+1
        STRB     R0,[R10, #+10]
??get_sdcard_commands_5:
        CMP      R8,#+35
        BNE.N    ??get_sdcard_commands_9
        MOVS     R0,#+1
        STRB     R0,[R7, #+0]
??get_sdcard_commands_9:
        MOVS     R0,#+0
        LDR.N    R1,??get_sdcard_commands_0+0x24
        STRB     R0,[R1, #+0]
        UXTH     R6,R6
        CMP      R6,#+0
        BEQ.N    ??get_sdcard_commands_3
        LDR.N    R0,??get_sdcard_commands_0+0x18
        LDRB     R0,[R0, #+8]
        ADD      R1,R0,R0, LSL #+1
        LDR.N    R0,??get_sdcard_commands_0+0x1C
        ADD      R0,R0,R1, LSL #+5
        MOVS     R1,#+0
        STRB     R1,[R6, R0]
        MOV      R6,R1
        MOV      R0,R1
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
??get_sdcard_commands_3:
        LDRB     R0,[R5, #+2]
        CMP      R0,#+4
        BGE.N    ??get_sdcard_commands_1
        LDRB     R0,[R7, #+0]
        ORRS     R0,R0,R9
        BNE.N    ??get_sdcard_commands_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader3getEv
        BL       _ZN10CardReader3getEv
        MOV      R10,R0
        MOV      R8,R10
        SXTB     R8,R8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R9,R0
        CMP      R9,#+0
        BNE.N    ??get_sdcard_commands_10
        CMN      R10,#+1
        BEQ.N    ??get_sdcard_commands_10
        CMP      R8,#+10
        BEQ.N    ??get_sdcard_commands_10
        CMP      R8,#+13
        BEQ.N    ??get_sdcard_commands_10
        CMP      R8,#+35
        BEQ.N    ??get_sdcard_commands_11
        CMP      R8,#+58
        BNE.N    ??get_sdcard_commands_12
??get_sdcard_commands_11:
        LDR.N    R0,??get_sdcard_commands_0+0x24
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_12
??get_sdcard_commands_10:
        CMP      R9,#+0
        BEQ.W    ??get_sdcard_commands_4
        LDR.N    R0,??get_sdcard_commands_0+0x28
        MOVS     R1,#+0
        STRB     R1,[R0, #+328]
        STR      R1,[R0, #+664]
        STRB     R1,[R0, #+341]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        LDRB     R0,[R4, #+1888]
        CMP      R0,#+0
        BEQ.N    ??get_sdcard_commands_13
        MOVS     R6,#+0
        B.N      ??get_sdcard_commands_5
??get_sdcard_commands_13:
        LDR.N    R0,??get_sdcard_commands_0+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14checkautostartEb
        BL       _ZN10CardReader14checkautostartEb
        B.N      ??get_sdcard_commands_5
??get_sdcard_commands_12:
        UXTH     R6,R6
        MOV      R0,R6
        CMP      R0,#+95
        BGE.N    ??get_sdcard_commands_3
        LDR.N    R1,??get_sdcard_commands_0+0x24
        CMP      R8,#+59
        BNE.N    ??get_sdcard_commands_14
        MOVS     R2,#+1
        STRB     R2,[R1, #+0]
??get_sdcard_commands_14:
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_sdcard_commands_3
        LDR.N    R1,??get_sdcard_commands_0+0x18
        LDRB     R1,[R1, #+8]
        ADD      R2,R1,R1, LSL #+1
        LDR.N    R1,??get_sdcard_commands_0+0x1C
        ADD      R1,R1,R2, LSL #+5
        STRB     R8,[R0, R1]
        ADDS     R6,R6,#+1
        CMP      R8,#+90
        BNE.N    ??get_sdcard_commands_3
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        SUBS     R0,R0,#+3
        STR      R0,[R4, #+2080]
        ADDW     R0,R4,#+2080
        LDR      R1,[R4, #+2080]
        STR      R1,[R0, #+4]
        LDR.N    R1,??get_sdcard_commands_0+0x28
        LDRB     R1,[R1, #+415]
        CMP      R1,#+1
        BEQ.N    ??get_sdcard_commands_3
        MOVS     R1,#+1
        STRB     R1,[R0, #+16]
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_1:
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??get_sdcard_commands_0:
        DC32     card
        DC32     mks_heating_busy
        DC32     _ZZ19get_sdcard_commandsvE14stop_buffering
        DC32     errormagic
        DC32     _ZZ19get_sdcard_commandsvEs_0
        DC32     curFileName
        DC32     filament_loading_time_flg
        DC32     command_queue
        DC32     wifi_link_state
        DC32     _ZZ19get_sdcard_commandsvE15sd_comment_mode
        DC32     gCfgItems
        DC32     _ZZ19get_sdcard_commandsvEs
          CFI EndBlock cfiBlock247

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z17get_wifi_commandsv
          CFI Block cfiBlock248 Using cfiCommon0
          CFI Function _Z17get_wifi_commandsv
        THUMB
_Z17get_wifi_commandsv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??get_wifi_commands_0
        LDRB     R0,[R4, #+8]
        CMP      R0,#+6
        BLT.N    ??get_wifi_commands_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+9]
        LDR.N    R5,??get_wifi_commands_0+0x4
        B.N      ??get_wifi_commands_2
??get_wifi_commands_3:
        ADDS     R7,R7,#+1
??get_wifi_commands_4:
        LDRSB    R0,[R7, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_wifi_commands_3
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R1,#+71
        MOV      R0,R7
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_wifi_commands_5
        LDR.N    R0,??get_wifi_commands_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_wifi_commands_0+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??get_wifi_commands_5:
        LDR.N    R1,??get_wifi_commands_0+0x10
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_6
        MOVS     R0,#+0
        STRB     R0,[R5, #+4]
??get_wifi_commands_6:
        LDR.N    R1,??get_wifi_commands_0+0x14
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_7
        LDR.N    R0,??get_wifi_commands_0+0x18
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_wifi_commands_7:
        LDR.N    R1,??get_wifi_commands_0+0x1C
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_8
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_wifi_commands_8:
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_wifi_commands_2:
        LDRB     R0,[R5, #+2]
        CMP      R0,#+4
        BGE.N    ??get_wifi_commands_9
        LDR.N    R1,??get_wifi_commands_0+0x20
        LDR      R2,[R1, #+96]
        LDR      R0,[R1, #+100]
        CMP      R2,R0
        BEQ.N    ??get_wifi_commands_9
        LDRSB    R0,[R2, R1]
        ADDS     R2,R2,#+1
        MOVS     R3,#+96
        UDIV     R3,R2,R3
        ADD      R6,R3,R3, LSL #+1
        SUB      R2,R2,R6, LSL #+5
        STR      R2,[R1, #+96]
        CMP      R0,#+10
        BEQ.N    ??get_wifi_commands_10
        CMP      R0,#+13
        BNE.N    ??get_wifi_commands_11
??get_wifi_commands_10:
        MOVS     R0,#+0
        LDR.N    R1,??get_wifi_commands_0+0x24
        STRB     R0,[R1, #+0]
        LDR      R1,[R4, #+56]
        CMP      R1,#+0
        BEQ.N    ??get_wifi_commands_2
        LDR.N    R6,??get_wifi_commands_0+0x28
        STRB     R0,[R1, R6]
        STR      R0,[R4, #+56]
        MOV      R7,R6
        B.N      ??get_wifi_commands_4
??get_wifi_commands_11:
        LDR      R1,[R4, #+56]
        CMP      R1,#+95
        BGE.N    ??get_wifi_commands_2
        LDR.N    R2,??get_wifi_commands_0+0x24
        CMP      R0,#+59
        BNE.N    ??get_wifi_commands_12
        MOVS     R3,#+1
        STRB     R3,[R2, #+0]
??get_wifi_commands_12:
        LDRB     R2,[R2, #+0]
        CMP      R2,#+0
        BNE.N    ??get_wifi_commands_2
        LDR.N    R2,??get_wifi_commands_0+0x28
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R4, #+56]
        B.N      ??get_wifi_commands_2
??get_wifi_commands_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+9]
??get_wifi_commands_9:
        POP      {R0,R4-R7,PC}    ;; return
        Nop      
        DATA
??get_wifi_commands_0:
        DC32     axis_relative_modes
        DC32     mks_heating_busy
        DC32     _ZZ17get_wifi_commandsvEs
        DC32     _ZZ17get_wifi_commandsvEs_0
        DC32     _ZZ17get_wifi_commandsvEs_1
        DC32     _ZZ17get_wifi_commandsvEs_2
        DC32     _ZZ17get_wifi_commandsvEs_3
        DC32     _ZZ17get_wifi_commandsvEs_4
        DC32     espGcodeFifo
        DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
        DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
          CFI EndBlock cfiBlock248

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z24get_homing_bump_feedrate8AxisEnum
          CFI Block cfiBlock249 Using cfiCommon0
          CFI Function _Z24get_homing_bump_feedrate8AxisEnum
        THUMB
_Z24get_homing_bump_feedrate8AxisEnum:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        ADD      R0,SP,#+0
        LDR.N    R1,??get_homing_bump_feedrate_0
        LDRSH    R1,[R1, #+88]
        CMP      R1,#+2
        BNE.N    ??get_homing_bump_feedrate_1
        MOVS     R1,#+10
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        STR      R1,[R0, #+8]
        B.N      ??get_homing_bump_feedrate_2
??get_homing_bump_feedrate_1:
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        MOVS     R1,#+4
        STR      R1,[R0, #+8]
??get_homing_bump_feedrate_2:
        LDRB     R5,[R0, R4, LSL #+2]
        CMP      R5,#+0
        BNE.N    ??get_homing_bump_feedrate_3
        MOVS     R5,#+10
        LDR.N    R0,??get_homing_bump_feedrate_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_homing_bump_feedrate_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??get_homing_bump_feedrate_3:
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        LDR.N    R0,??get_homing_bump_feedrate_0+0xC
        ADD      R0,R0,R4, LSL #+2
        LDR      R0,[R0, #+40]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        DATA
??get_homing_bump_feedrate_0:
        DC32     mksCfg
        DC32     echomagic
        DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock249

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z31buffer_line_to_current_positionv
          CFI Block cfiBlock250 Using cfiCommon0
          CFI Function _Z31buffer_line_to_current_positionv
        THUMB
_Z31buffer_line_to_current_positionv:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+12
          CFI CFA R13+16
        LDR.N    R0,??buffer_line_to_current_position_0
        LDRB     R1,[R0, #+3]
        STR      R1,[SP, #+4]
        ADD      R1,R0,#+92
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+20
        LDR      R2,[R0, #+16]
        LDR      R1,[R0, #+12]
        LDR      R0,[R0, #+8]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0-R2,PC}       ;; return
        DATA
??buffer_line_to_current_position_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock250

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z26buffer_line_to_destinationf
          CFI Block cfiBlock251 Using cfiCommon0
          CFI Function _Z26buffer_line_to_destinationf
        THUMB
_Z26buffer_line_to_destinationf:
        PUSH     {R0,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        LDR.N    R0,??buffer_line_to_destination_0
        LDRB     R1,[R0, #+3]
        STR      R1,[SP, #+4]
        ADD      R1,SP,#+8
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+36
        LDR      R2,[R0, #+32]
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0-R2,PC}       ;; return
        Nop      
        DATA
??buffer_line_to_destination_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock251

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14do_probe_raisef
          CFI Block cfiBlock252 Using cfiCommon0
          CFI Function _Z14do_probe_raisef
        THUMB
_Z14do_probe_raisef:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        STR      R0,[SP, #+0]
        LDR.N    R4,??do_probe_raise_0
        LDR      R2,[R4, #+112]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_probe_raise_1
        LDR      R0,[SP, #+0]
        MOV      R1,R2
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
??do_probe_raise_1:
        LDR      R0,[R4, #+16]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_probe_raise_2
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??do_probe_raise_2:
        POP      {R0,R1,R4,PC}    ;; return
        DATA
??do_probe_raise_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock252

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11gcode_G0_G1v
          CFI Block cfiBlock253 Using cfiCommon0
          CFI Function _Z11gcode_G0_G1v
        THUMB
_Z11gcode_G0_G1v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock253

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17gcode_G0_G1_SCARAb
          CFI Block cfiBlock254 Using cfiCommon0
          CFI Function _Z17gcode_G0_G1_SCARAb
        THUMB
_Z17gcode_G0_G1_SCARAb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_SCARA_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        CMP      R4,#+0
        BEQ.N    ??gcode_G0_G1_SCARA_1
        MOVS     R0,#+0
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.W      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_SCARA_1:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_SCARA_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock254

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z11gcode_G2_G3b
          CFI Block cfiBlock255 Using cfiCommon0
          CFI Function _Z11gcode_G2_G3b
        THUMB
_Z11gcode_G2_G3b:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+32
          CFI CFA R13+72
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        ADD      R0,SP,#+16
        MOVS     R1,#+0
        MOV      R2,R1
        STM      R0!,{R1,R2}
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R4,R0
        LDR.N    R0,??gcode_G2_G3_2
        LDR      R1,[R0, #+8]
        STR      R1,[SP, #+4]
        LDR      R1,[R0, #+12]
        STR      R1,[SP, #+0]
        LDR      R1,[R0, #+24]
        STR      R1,[SP, #+12]
        LDR      R0,[R0, #+28]
        STR      R0,[SP, #+8]
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??gcode_G2_G3_3
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_4
        LDR      R0,[SP, #+8]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??gcode_G2_G3_3
??gcode_G2_G3_4:
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G2_G3_5
        MOVS     R0,#+1
        B.N      ??gcode_G2_G3_6
??gcode_G2_G3_5:
        MOV      R0,R1
??gcode_G2_G3_6:
        MOV      R7,#+1065353216
        LDRB     R1,[SP, #+32]
        TEQ      R0,R1
        BEQ.N    ??gcode_G2_G3_7
        LDR.N    R6,??gcode_G2_G3_2+0x4  ;; 0xbf800000
        B.N      ??gcode_G2_G3_8
??gcode_G2_G3_7:
        MOV      R6,R7
??gcode_G2_G3_8:
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
        LDR      R0,[SP, #+8]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
        LDR      R8,[SP, #+28]
        MOV      R9,#+2
        MOV      R5,R7
        B.N      ??gcode_G2_G3_9
??gcode_G2_G3_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??gcode_G2_G3_9:
        LSLS     R0,R9,#+31
        BPL.N    ??gcode_G2_G3_11
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??gcode_G2_G3_11:
        LSRS     R9,R9,#+1
        BNE.N    ??gcode_G2_G3_10
        LDR      R8,[SP, #+24]
        MOV      R9,#+2
        MOV      R10,R7
        B.N      ??gcode_G2_G3_12
??gcode_G2_G3_13:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??gcode_G2_G3_12:
        LSLS     R0,R9,#+31
        BPL.N    ??gcode_G2_G3_14
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??gcode_G2_G3_14:
        LSRS     R9,R9,#+1
        BNE.N    ??gcode_G2_G3_13
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R10,R0
        MOVS     R5,#+2
        B.N      ??gcode_G2_G3_15
??gcode_G2_G3_16:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??gcode_G2_G3_15:
        LSLS     R0,R5,#+31
        BPL.N    ??gcode_G2_G3_17
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??gcode_G2_G3_17:
        LSRS     R5,R5,#+1
        BNE.N    ??gcode_G2_G3_16
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??gcode_G2_G3_2+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        MOV      R11,#+2
        MOVS     R4,#+0
        LDR.N    R5,??gcode_G2_G3_2+0xC  ;; 0x3ff00000
        B.N      ??gcode_G2_G3_18
??gcode_G2_G3_19:
        MOV      R0,R8
        MOV      R1,R9
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
??gcode_G2_G3_18:
        LSLS     R0,R11,#+31
        BPL.N    ??gcode_G2_G3_20
        MOV      R2,R8
        MOV      R3,R9
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
??gcode_G2_G3_20:
        LSRS     R11,R11,#+1
        BNE.N    ??gcode_G2_G3_19
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall sqrt
        BL       sqrt
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        MOV      R5,#+1056964608
        LDR      R1,[SP, #+4]
        LDR      R0,[SP, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
        LDR      R0,[SP, #+24]
        MOV      R1,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+16]
        LDR      R1,[SP, #+0]
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+28]
        MOV      R1,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+20]
        B.N      ??gcode_G2_G3_3
??gcode_G2_G3_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_21
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+16]
??gcode_G2_G3_21:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+20]
??gcode_G2_G3_3:
        LDR      R0,[SP, #+16]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_22
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_G2_G3_23
??gcode_G2_G3_22:
        LDRB     R2,[SP, #+32]
        ADD      R1,SP,#+16
        LDR.N    R0,??gcode_G2_G3_2+0x10
          CFI FunCall _Z8plan_arcRA4_KfRA2_S_b
        BL       _Z8plan_arcRA4_KfRA2_S_b
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        B.N      ??gcode_G2_G3_0
??gcode_G2_G3_23:
        LDR.N    R0,??gcode_G2_G3_2+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_G2_G3_2+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G2_G3_0:
        ADD      SP,SP,#+36
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??gcode_G2_G3_2:
        DC32     mks_heating_busy
        DC32     0xbf800000
        DC32     0x3fe00000
        DC32     0x3ff00000
        DC32     mks_heating_busy+0x18
        DC32     errormagic
        DC32     _ZZ11gcode_G2_G3bEs
          CFI EndBlock cfiBlock255

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z8gcode_G4v
          CFI Block cfiBlock256 Using cfiCommon0
          CFI Function _Z8gcode_G4v
        THUMB
_Z8gcode_G4v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_0
          CFI FunCall _ZN11GCodeParser12value_millisEv
        BL       _ZN11GCodeParser12value_millisEv
        MOV      R4,R0
??gcode_G4_0:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_1
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        MOV      R4,R0
??gcode_G4_1:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z13lcd_hasstatusv
        BL       _Z13lcd_hasstatusv
        CMP      R0,#+0
        BNE.N    ??gcode_G4_2
        MOVS     R1,#+0
        LDR.N    R0,??gcode_G4_3
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_G4_2:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z5dwellm
        B.W      _Z5dwellm
        Nop      
        DATA
??gcode_G4_3:
        DC32     _ZZ8gcode_G4vEs
          CFI EndBlock cfiBlock256

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10home_deltav
          CFI Block cfiBlock257 Using cfiCommon0
          CFI Function _Z10home_deltav
        THUMB
_Z10home_deltav:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??home_delta_0
        MOVS     R2,#+16
        MOVS     R1,#+0
        ADD      R0,R4,#+8
          CFI FunCall memset
        BL       memset
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
        LDR      R0,[R4, #+120]
        LDR.N    R1,??home_delta_0+0x4  ;; 0x41200000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
        STR      R0,[R4, #+12]
        STR      R0,[R4, #+8]
        LDR      R0,[R4, #+40]
        STR      R0,[R4, #+92]
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.N    R0,??home_delta_0+0x8
        LDRSB    R0,[R0, #+0]
        MOVS     R1,#+112
        TST      R0,R1
        BNE.N    ??home_delta_1
        MOVS     R1,#+0
        LDR.N    R0,??home_delta_0+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        LDR.N    R0,??home_delta_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??home_delta_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+0
        POP      {R4,PC}
??home_delta_1:
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
        MOVS     R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R4,#+0
        B.N      ??home_delta_2
??home_delta_3:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
        ADDS     R4,R4,#+1
??home_delta_2:
        CMP      R4,#+3
        BLT.N    ??home_delta_3
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        MOVS     R0,#+1
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??home_delta_0:
        DC32     mks_heating_busy
        DC32     0x41200000
        DC32     _ZN8Endstops16endstop_hit_bitsE
        DC32     _ZZ10home_deltavEs
        DC32     errormagic
        DC32     _ZZ10home_deltavEs_0
          CFI EndBlock cfiBlock257

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G28b
          CFI Block cfiBlock258 Using cfiCommon0
          CFI Function _Z9gcode_G28b
        THUMB
_Z9gcode_G28b:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R8,R0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.N    R5,??gcode_G28_0
        ADDW     R0,R5,#+63
        STR      R0,[SP, #+0]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+16
        BNE.N    ??gcode_G28_1
        LDR.N    R1,??gcode_G28_0+0x4
        LDRB     R4,[R1, #+0]
??gcode_G28_1:
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??gcode_G28_2
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G28_2:
        LDR.N    R6,??gcode_G28_0+0x8
        LDRB     R0,[R6, #+3]
        STRB     R0,[SP, #+8]
        MOVS     R2,#+1
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall _Z11tool_changehfb
        BL       _Z11tool_changehfb
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops6enableEb
        BL       _ZN8Endstops6enableEb
        LDRSH    R0,[R5, #+88]
        CMP      R0,#+2
        BNE.N    ??gcode_G28_3
          CFI FunCall _Z10home_deltav
        BL       _Z10home_deltav
        B.N      ??gcode_G28_4
??gcode_G28_3:
        CMP      R8,#+0
        BNE.N    ??gcode_G28_5
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R11,R0
        B.N      ??gcode_G28_6
??gcode_G28_5:
        MOV      R11,#+1
??gcode_G28_6:
        CMP      R8,#+0
        BNE.N    ??gcode_G28_7
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R7,R0
        B.N      ??gcode_G28_8
??gcode_G28_7:
        MOVS     R7,#+1
??gcode_G28_8:
        CMP      R8,#+0
        BNE.N    ??gcode_G28_9
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R8,R0
        B.N      ??gcode_G28_10
??gcode_G28_9:
        MOV      R8,#+1
??gcode_G28_10:
        AND      R9,R7,R11
        ORR      R0,R7,R11
        ORR      R0,R8,R0
        EOR      R0,R0,#0x1
        AND      R1,R8,R9
        ORR      R10,R1,R0
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+1
        BLT.N    ??gcode_G28_11
        ORRS     R0,R8,R10
        BEQ.N    ??gcode_G28_11
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_11:
        ORR      R11,R11,R10
        ORRS     R0,R7,R11
        BEQ.N    ??gcode_G28_12
        LDR.N    R0,??gcode_G28_0+0xC
        LDRB     R0,[R0, #+2076]
        CMP      R0,#+171
        BNE.N    ??gcode_G28_13
        CMP      R0,#+172
        BEQ.N    ??gcode_G28_12
??gcode_G28_13:
        LDR.N    R1,??gcode_G28_0+0x10  ;; 0x40a00000
        STR      R1,[R6, #+32]
        LDR      R0,[R6, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G28_12
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,R6,#+32
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??gcode_G28_12:
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G28_14
        ORRS     R0,R9,R10
        BEQ.N    ??gcode_G28_14
          CFI FunCall _Z13quick_home_xyv
        BL       _Z13quick_home_xyv
??gcode_G28_14:
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G28_15
        ORRS     R0,R7,R10
        BEQ.N    ??gcode_G28_15
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_15:
        CMP      R11,#+0
        BEQ.N    ??gcode_G28_16
        MOVS     R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_16:
        LDRB     R0,[R5, #+63]
        CMP      R0,#+0
        BNE.N    ??gcode_G28_17
        ORRS     R0,R7,R10
        BEQ.N    ??gcode_G28_17
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_17:
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+0
        BPL.N    ??gcode_G28_18
        ORRS     R0,R8,R10
        BEQ.N    ??gcode_G28_18
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_18:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G28_4:
          CFI FunCall _ZN8Endstops10not_homingEv
        BL       _ZN8Endstops10not_homingEv
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+16
        BNE.N    ??gcode_G28_19
        MOV      R0,R4
        UXTB     R0,R0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G28_19:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
        MOVS     R2,#+1
        MOVS     R1,#+0
        LDRB     R0,[SP, #+8]
          CFI FunCall _Z11tool_changehfb
        BL       _Z11tool_changehfb
          CFI FunCall _Z11lcd_refreshv
        BL       _Z11lcd_refreshv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        POP      {R0-R2,R4-R11,PC}  ;; return
        DATA
??gcode_G28_0:
        DC32     mksCfg
        DC32     _ZN7Planner15leveling_activeE
        DC32     mks_heating_busy
        DC32     card
        DC32     0x40a00000
          CFI EndBlock cfiBlock258

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_manual_goto_xyRKfS0_
          CFI Block cfiBlock259 Using cfiCommon0
          CFI Function _Z15_manual_goto_xyRKfS0_
        THUMB
_Z15_manual_goto_xyRKfS0_:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R5,R1
        LDR.N    R6,??_manual_goto_xy_0
        LDR.N    R2,??_manual_goto_xy_0+0x4
        LDR      R0,[R2, #+104]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??_manual_goto_xy_1
        LDR      R0,[R6, #+16]
        STR      R0,[SP, #+8]
        MOV      R0,R1
        STR      R0,[SP, #+4]
        ADD      R3,SP,#+4
        ADDS     R2,R2,#+104
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
        B.N      ??_manual_goto_xy_2
??_manual_goto_xy_1:
        MOV      R0,R1
        STR      R0,[SP, #+0]
        ADD      R2,SP,#+0
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z22do_blocking_move_to_xyRKfS0_S0_
        BL       _Z22do_blocking_move_to_xyRKfS0_S0_
??_manual_goto_xy_2:
        LDR      R0,[R4, #+0]
        STR      R0,[R6, #+8]
        LDR      R0,[R5, #+0]
        STR      R0,[R6, #+12]
        MOVS     R0,#+0
        LDR.N    R1,??_manual_goto_xy_0+0x8
        STRB     R0,[R1, #+9]
        POP      {R0-R6,PC}       ;; return
        Nop      
        DATA
??_manual_goto_xy_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     axis_homed
          CFI EndBlock cfiBlock259

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z27gcode_G29_MESH_BED_LEVELINGv
          CFI Block cfiBlock260 Using cfiCommon0
          CFI Function _Z27gcode_G29_MESH_BED_LEVELINGv
        THUMB
_Z27gcode_G29_MESH_BED_LEVELINGv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOVS     R1,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        MOV      R4,R0
        SXTB     R4,R4
        CMP      R4,#+6
        BCC.N    ??gcode_G29_MESH_BED_LEVELING_1
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_1:
        MOV      R0,R4
        CMP      R0,#+5
        BHI.W    ??gcode_G29_MESH_BED_LEVELING_4
        TBB      [PC, R0]
        DATA
??gcode_G29_MESH_BED_LEVELING_0:
        DC8      0x3,0x1C,0x2B,0x7F
        DC8      0xD0,0xE1
          CFI FunCall _Z17leveling_is_validv
        THUMB
??gcode_G29_MESH_BED_LEVELING_5:
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_6
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_7
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x8
        B.N      ??gcode_G29_MESH_BED_LEVELING_8
??gcode_G29_MESH_BED_LEVELING_7:
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0xC
??gcode_G29_MESH_BED_LEVELING_8:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x10
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_6:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_9:
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        STR      R0,[R1, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x20
        LDRB     R0,[R0, #+9]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x24
        B.N      ??gcode_G29_MESH_BED_LEVELING_11
??gcode_G29_MESH_BED_LEVELING_10:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x28
??gcode_G29_MESH_BED_LEVELING_11:
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        BL       _Z27enqueue_and_echo_commands_PPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_12:
        LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BPL.N    ??gcode_G29_MESH_BED_LEVELING_13
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_13:
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x30
        LDR.N    R7,??gcode_G29_MESH_BED_LEVELING_2+0x20
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_14
        LDRB     R0,[R7, #+8]
        STRB     R0,[R6, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_15
??gcode_G29_MESH_BED_LEVELING_14:
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x34
        SUBS     R0,R0,#+1
        SXTB     R0,R0
          CFI FunCall _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        BL       _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        LDRB     R0,[R6, #+0]
        STRB     R0,[R7, #+8]
??gcode_G29_MESH_BED_LEVELING_15:
        LDR      R0,[R5, #+0]
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
        ADD      R8,R6,#+96
        LDRB     R1,[R6, #+96]
        LDRB     R2,[R8, #+1]
        MULS     R1,R2,R1
        CMP      R0,R1
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_16
        ADD      R2,SP,#+0
        ADD      R1,SP,#+1
        SXTB     R0,R0
          CFI FunCall _ZN17mesh_bed_leveling6zigzagEaRaS0_
        BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
        LDRSB    R0,[SP, #+0]
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x3C
        ADD      R1,R1,R0, LSL #+2
        LDRSB    R0,[SP, #+1]
        LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x40
        ADD      R0,R2,R0, LSL #+2
          CFI FunCall _Z15_manual_goto_xyRKfS0_
        BL       _Z15_manual_goto_xyRKfS0_
        MOVS     R0,#+0
        STRB     R0,[R7, #+8]
        LDR      R0,[R5, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_16:
        LDR      R0,[R6, #+16]
        LDR      R1,[R8, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x44
        STR      R0,[R1, #+16]
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOV      R0,#-1
        STR      R0,[R5, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x48
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x4C
        STRB     R0,[R1, #+0]
          CFI FunCall _Z13home_all_axesv
        BL       _Z13home_all_axesv
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MOVS     R0,#+0
        STRB     R0,[R7, #+9]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_17:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_18
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+1]
        LDRSB    R0,[SP, #+1]
        CMP      R0,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_19
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
        LDRB     R1,[R6, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R0
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_20
??gcode_G29_MESH_BED_LEVELING_19:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x50
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_20:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_21
        MOVS     R1,#+89
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z16echo_not_enteredv
        BL       _Z16echo_not_enteredv
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_18:
        MOVS     R1,#+88
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z16echo_not_enteredv
        BL       _Z16echo_not_enteredv
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_21:
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+0]
        LDRSB    R0,[SP, #+0]
        CMP      R0,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_22
        ADD      R1,R6,#+96
        LDRB     R1,[R1, #+1]
        SUBS     R1,R1,#+1
        CMP      R1,R0
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_23
??gcode_G29_MESH_BED_LEVELING_22:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_23:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDRSB    R1,[SP, #+0]
        LDRSB    R2,[SP, #+1]
        ADD      R3,R2,R2, LSL #+1
        LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x58
        ADD      R2,R2,R3, LSL #+4
        STR      R0,[R2, R1, LSL #+2]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_25:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x5C
        STR      R0,[R1, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_24:
        MOVS     R1,#+90
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z16echo_not_enteredv
        BL       _Z16echo_not_enteredv
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_26:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
??gcode_G29_MESH_BED_LEVELING_4:
        CMP      R4,#+1
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_27
        CMP      R4,#+2
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_28
??gcode_G29_MESH_BED_LEVELING_27:
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
        ADD      R8,R6,#+96
        LDRB     R0,[R6, #+96]
        LDRB     R1,[R8, #+1]
        MULS     R1,R1,R0
        LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        LDR      R0,[R5, #+0]
        CMP      R0,R1
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_29
        MOV      R1,R0
??gcode_G29_MESH_BED_LEVELING_29:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x60
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDRB     R0,[R6, #+96]
        LDRB     R1,[R8, #+1]
        MULS     R1,R1,R0
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x64
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_MESH_BED_LEVELING_28:
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_G29_MESH_BED_LEVELING_3:
        POP      {R0,R1,R4-R8,PC}  ;; return
        DATA
??gcode_G29_MESH_BED_LEVELING_2:
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        DC32     _ZN7Planner15leveling_activeE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        DC32     Serial3
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        DC32     axis_homed
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        DC32     mks_heating_busy+0x10
        DC32     mksCfg
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
        DC32     mks_heating_busy
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
        DC32     _ZN17mesh_bed_leveling8has_meshE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
        DC32     _ZN17mesh_bed_leveling8z_valuesE
        DC32     _ZN17mesh_bed_leveling8z_offsetE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
          CFI EndBlock cfiBlock260

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G29v
          CFI Block cfiBlock261 Using cfiCommon0
          CFI Function _Z9gcode_G29v
        THUMB
_Z9gcode_G29v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+812
          CFI CFA R13+848
        MOVS     R2,#+1
        MOV      R1,R2
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BNE.W    ??gcode_G29_0
        MOVS     R0,#+0
        STR      R0,[SP, #+56]
        STR      R0,[SP, #+52]
        STR      R0,[SP, #+36]
        MOV      R6,R0
        STR      R0,[SP, #+20]
        STR      R0,[SP, #+8]
        STR      R0,[SP, #+72]
        STR      R0,[SP, #+28]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+96]
        STR      R0,[SP, #+48]
        LDR.W    R1,??gcode_G29_1+0x4
        STR      R1,[SP, #+32]
        LDRB     R1,[R1, #+1]
        STR      R1,[SP, #+16]
        MOV      R2,R6
        STRB     R2,[SP, #+12]
        MULS     R0,R1,R0
        LDR.W    R1,??gcode_G29_1
        LDRB     R1,[R1, #+64]
        MOVS     R2,#+6
        TST      R1,R2
        BNE.N    ??gcode_G29_2
        STR      R0,[SP, #+68]
??gcode_G29_2:
        ADD      R0,R0,R0, LSL #+1
        ADDS     R0,R0,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        STR      R0,[SP, #+44]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_3
        MOV      R0,R6
        LDR.W    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+4]
        LDR.W    R0,??gcode_G29_1+0xC
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_3:
        MOV      R0,R6
        B.N      ??gcode_G29_4
??gcode_G29_5:
        MOV      R1,R6
        LDR      R2,[SP, #+44]
        STR      R1,[R2, R0, LSL #+2]
        ADDS     R0,R0,#+1
??gcode_G29_4:
        LDR.W    R1,??gcode_G29_1
        LDRB     R1,[R1, #+96]
        LDR      R2,[SP, #+32]
        LDRB     R2,[R2, #+1]
        MULS     R1,R2,R1
        ADD      R2,R1,R1, LSL #+1
        ADDS     R2,R2,#+1
        CMP      R0,R2
        BLT.N    ??gcode_G29_5
        ADDS     R0,R1,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        STR      R0,[SP, #+64]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_6
        MOV      R0,R6
        LDR.W    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+4]
        LDR.W    R0,??gcode_G29_1+0x10
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_6:
        MOV      R0,R6
        B.N      ??gcode_G29_7
??gcode_G29_8:
        MOV      R1,R6
        LDR      R2,[SP, #+64]
        STR      R1,[R2, R0, LSL #+2]
        ADDS     R0,R0,#+1
??gcode_G29_7:
        LDR.W    R1,??gcode_G29_1
        LDRB     R1,[R1, #+96]
        LDR      R2,[SP, #+32]
        LDRB     R2,[R2, #+1]
        MULS     R1,R2,R1
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BLT.N    ??gcode_G29_8
        MOV      R3,R6
        LDR      R0,[SP, #+32]
        LDR      R2,[R0, #+64]
        LDR      R1,[R0, #+60]
        ADD      R0,SP,#+88
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        MOV      R3,R6
        LDR      R0,[SP, #+32]
        LDR      R2,[R0, #+72]
        LDR      R1,[R0, #+68]
        ADD      R0,SP,#+100
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        MOV      R3,R6
        LDR      R0,[SP, #+32]
        LDR      R2,[R0, #+80]
        LDR      R1,[R0, #+76]
        ADD      R0,SP,#+112
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDR.W    R0,??gcode_G29_1
        LDRB     R4,[R0, #+64]
        ANDS     R5,R4,#0x4
        BEQ.N    ??gcode_G29_9
        ADD      R0,SP,#+172
          CFI FunCall _Z21incremental_LSF_resetP15linear_fit_data
        BL       _Z21incremental_LSF_resetP15linear_fit_data
??gcode_G29_9:
        CMP      R5,#+0
        BEQ.N    ??gcode_G29_10
        MOV      R6,#-1
??gcode_G29_10:
        LDR.W    R0,??gcode_G29_1+0x14
        LDRB     R9,[R0, #+0]
        CMP      R4,#+8
        BNE.W    ??gcode_G29_11
        MOVS     R0,#+87
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_11
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BNE.N    ??gcode_G29_12
        LDR.W    R0,??gcode_G29_1+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_1+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_12:
        LDR.W    R4,??gcode_G29_1+0x20
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_13
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        B.N      ??gcode_G29_14
??gcode_G29_13:
        LDR      R5,[R4, #+16]
??gcode_G29_14:
        MOV      R0,R5
        LDR.W    R1,??gcode_G29_1+0x24  ;; 0xc1200000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_15
        LDR.W    R1,??gcode_G29_1+0x28  ;; 0x41200001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_16
??gcode_G29_15:
        LDR.W    R0,??gcode_G29_1+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_1+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_16:
        MVN      R6,#-2147483648
        MOV      R1,R6
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR      R1,[R4, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R1,R6
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR      R1,[R4, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        MOVS     R1,#+255
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        MOV      R7,R0
        SXTB     R7,R7
        MOVS     R1,#+255
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        MOV      R4,R0
        SXTB     R4,R4
        MOV      R0,R8
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_17
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_17
        LDR.W    R4,??gcode_G29_1+0x8
        LDR      R0,[R4, #+24]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R7,R0
        SXTB     R7,R7
        LDR      R0,[R4, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R4,R0
        SXTB     R4,R4
        CMP      R7,#+0
        BPL.N    ??gcode_G29_18
        MOVS     R7,#+0
        B.N      ??gcode_G29_19
??gcode_G29_18:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+96]
        SUBS     R1,R0,#+1
        CMP      R1,R7
        BGE.N    ??gcode_G29_19
        SUBS     R7,R0,#+1
??gcode_G29_19:
        SXTB     R7,R7
        CMP      R4,#+0
        BPL.N    ??gcode_G29_20
        MOVS     R4,#+0
        B.N      ??gcode_G29_21
??gcode_G29_20:
        LDR      R0,[SP, #+32]
        LDRB     R0,[R0, #+1]
        SUBS     R1,R0,#+1
        CMP      R1,R4
        BGE.N    ??gcode_G29_21
        SUBS     R4,R0,#+1
??gcode_G29_21:
        SXTB     R4,R4
??gcode_G29_17:
        CMP      R7,#+0
        BMI.W    ??gcode_G29_0
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+96]
        SUBS     R0,R0,#+1
        CMP      R0,R7
        BLT.W    ??gcode_G29_0
        CMP      R4,#+0
        BMI.W    ??gcode_G29_0
        LDR      R0,[SP, #+32]
        LDRB     R0,[R0, #+1]
        CMP      R0,R4
        BLT.W    ??gcode_G29_0
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??gcode_G29_1+0x30
        ADD      R0,R1,R0, LSL #+4
        STR      R5,[R0, R4, LSL #+2]
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        CMP      R9,#+0
        BEQ.W    ??gcode_G29_0
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        B.W      ??gcode_G29_0
??gcode_G29_11:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_22
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        B.W      ??gcode_G29_0
??gcode_G29_22:
        MOVS     R1,#+0
        MOVS     R0,#+86
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        STR      R0,[SP, #+40]
        CMP      R0,#+5
        BCC.N    ??gcode_G29_23
        LDR.W    R0,??gcode_G29_1+0x34
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_23:
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        STR      R0,[SP, #+60]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        LSLS     R1,R0,#+29
        BPL.N    ??gcode_G29_24
        LDR      R0,[SP, #+40]
        CMP      R0,#+3
        BGE.N    ??gcode_G29_25
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        STRB     R0,[SP, #+12]
        B.N      ??gcode_G29_26
??gcode_G29_25:
        MOVS     R0,#+1
        STRB     R0,[SP, #+12]
??gcode_G29_26:
        LDR.W    R0,??gcode_G29_1
        LDRB     R1,[R0, #+96]
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        UXTB     R0,R0
        STR      R0,[SP, #+48]
        LDR      R0,[SP, #+32]
        LDRB     R1,[R0, #+1]
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        UXTB     R0,R0
        STR      R0,[SP, #+16]
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_27
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        UXTB     R0,R0
        STR      R0,[SP, #+16]
        ADD      R0,SP,#+16
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+48]
??gcode_G29_27:
        LDR      R0,[SP, #+48]
        CMP      R0,#+2
        BLT.N    ??gcode_G29_28
        LDR      R0,[SP, #+16]
        CMP      R0,#+2
        BGE.N    ??gcode_G29_29
??gcode_G29_28:
        LDR.W    R0,??gcode_G29_1+0x38
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_29:
        LDR      R0,[SP, #+48]
        LDR      R1,[SP, #+16]
        MULS     R0,R1,R0
        STR      R0,[SP, #+68]
        MOV      R8,#+0
        B.N      ??gcode_G29_30
??gcode_G29_24:
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G29_30
        MOVS     R1,#+0
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        STR      R0,[SP, #+84]
??gcode_G29_30:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+12
        TST      R0,R1
        BEQ.W    ??gcode_G29_31
        LDR.W    R4,??gcode_G29_1+0x20
        LDR      R0,[SP, #+32]
        LDR      R1,[R0, #+20]
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR.W    R1,??gcode_G29_1+0x3C  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, #+116]
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_32
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+20]
        B.N      ??gcode_G29_33
??gcode_G29_32:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+40]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+20]
??gcode_G29_33:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_34
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
        B.N      ??gcode_G29_35
??gcode_G29_34:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+44]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
??gcode_G29_35:
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_36
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+8]
        B.N      ??gcode_G29_37
??gcode_G29_36:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+48]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+8]
??gcode_G29_37:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_38
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
        B.N      ??gcode_G29_39
??gcode_G29_38:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+52]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
??gcode_G29_39:
        LDR.W    R7,??gcode_G29_1+0x40
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R7, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_40
        SUB      R0,R5,#+10
        LDR      R1,[SP, #+20]
        CMP      R0,R1
        BGE.N    ??gcode_G29_41
??gcode_G29_40:
        MOVS     R0,#+1
        STRB     R0,[SP, #+0]
        B.N      ??gcode_G29_42
??gcode_G29_41:
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
??gcode_G29_42:
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_43
        LDR      R0,[SP, #+20]
        ADDS     R0,R0,#+10
        CMP      R5,R0
        BGE.N    ??gcode_G29_44
??gcode_G29_43:
        MOV      R10,#+1
        B.N      ??gcode_G29_45
??gcode_G29_44:
        MOV      R10,#+0
??gcode_G29_45:
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R7, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_46
        SUB      R0,R4,#+10
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BGE.N    ??gcode_G29_47
??gcode_G29_46:
        MOV      R11,#+1
        B.N      ??gcode_G29_48
??gcode_G29_47:
        MOV      R11,#+0
??gcode_G29_48:
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+12]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_49
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,#+10
        CMP      R4,R0
        BGE.N    ??gcode_G29_50
??gcode_G29_49:
        MOVS     R7,#+1
        B.N      ??gcode_G29_51
??gcode_G29_50:
        MOVS     R7,#+0
??gcode_G29_51:
        LDRB     R0,[SP, #+0]
        ORR      R0,R10,R0
        ORR      R0,R11,R0
        ORRS     R0,R7,R0
        BEQ.N    ??gcode_G29_52
        LDRB     R0,[SP, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_53
        LDR.W    R0,??gcode_G29_1+0x44
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_53:
        CMP      R10,#+0
        BEQ.N    ??gcode_G29_54
        LDR.W    R0,??gcode_G29_1+0x48
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_54:
        CMP      R11,#+0
        BEQ.N    ??gcode_G29_55
        LDR.W    R0,??gcode_G29_1+0x4C
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_55:
        CMP      R7,#+0
        BEQ.W    ??gcode_G29_0
        LDR.W    R0,??gcode_G29_1+0x50
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
        B.N      ??gcode_G29_0
??gcode_G29_52:
        LDR      R0,[SP, #+20]
        SUBS     R0,R5,R0
        LDR      R1,[SP, #+48]
        SUBS     R1,R1,#+1
        SDIV     R0,R0,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+72]
        LDR      R0,[SP, #+8]
        SUBS     R0,R4,R0
        LDR      R1,[SP, #+16]
        SUBS     R1,R1,#+1
        SDIV     R0,R0,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+28]
??gcode_G29_31:
        LDR      R0,[SP, #+40]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_56
        LDR.W    R0,??gcode_G29_1+0x54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_57
        LDR.W    R0,??gcode_G29_1+0x58
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G29_57:
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_1+0x5C
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_56:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_58
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        B.N      ??gcode_G29_0
??gcode_G29_58:
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_59
        LDR.W    R4,??gcode_G29_1+0x8
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_60
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_60
        LDR      R0,[SP, #+20]
        LDR      R1,[R4, #+24]
        CMP      R0,R1
        BNE.N    ??gcode_G29_60
        LDR      R0,[SP, #+8]
        LDR      R1,[R4, #+28]
        CMP      R0,R1
        BEQ.N    ??gcode_G29_59
??gcode_G29_60:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+16]
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+20]
        LDR      R0,[SP, #+20]
        STR      R0,[R4, #+24]
        LDR      R0,[SP, #+8]
        STR      R0,[R4, #+28]
        MOV      R9,#+0
??gcode_G29_59:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+2
        BNE.N    ??gcode_G29_61
        ADD      R4,SP,#+88
        MOVS     R0,#+0
        STR      R0,[R4, #+32]
        STR      R0,[R4, #+20]
        STR      R0,[R4, #+8]
??gcode_G29_61:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        STRB     R0,[SP, #+5]
        MOVS     R0,#+0
        STR      R0,[SP, #+36]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+12
        TST      R0,R1
        BEQ.W    ??gcode_G29_62
        LDR      R0,[SP, #+16]
        AND      R0,R0,#0x1
        STRB     R0,[SP, #+4]
        MOVS     R0,#+0
        STR      R0,[SP, #+24]
        B.N      ??gcode_G29_63
??gcode_G29_64:
        LDR      R0,[SP, #+48]
        SUBS     R7,R0,#+1
        MOV      R0,#-1
        STR      R0,[SP, #+80]
        STR      R0,[SP, #+76]
??gcode_G29_65:
        LDRB     R0,[SP, #+4]
        EOR      R0,R0,#0x1
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[SP, #+4]
        SXTB     R7,R7
        B.N      ??gcode_G29_66
??gcode_G29_67:
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G29_68
        LDR      R4,[SP, #+24]
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??gcode_G29_1+0x30
        ADD      R5,R1,R0, LSL #+4
        LDR      R1,[SP, #+36]
        LDR      R0,[SP, #+84]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, R4, LSL #+2]
??gcode_G29_68:
        MOV      R9,#+0
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??gcode_G29_69:
        LDR      R0,[SP, #+76]
        ADDS     R7,R0,R7
        SXTB     R7,R7
??gcode_G29_66:
        LDR      R0,[SP, #+80]
        CMP      R7,R0
        BEQ.W    ??gcode_G29_70
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R4,R0
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R11,R0
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R4,R0
        ADD      R0,SP,#+24
        LDRB     R0,[R0, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R10,R0
        MOV      R0,R11
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R4,R1
        BCS.N    ??gcode_G29_71
        MOV      R5,R1
        B.N      ??gcode_G29_72
??gcode_G29_71:
        LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
??gcode_G29_72:
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+56]
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_73
        MOV      R5,R1
        B.N      ??gcode_G29_74
??gcode_G29_73:
        LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
??gcode_G29_74:
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+52]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        LSLS     R0,R0,#+29
        BPL.N    ??gcode_G29_75
        ADDS     R6,R6,#+1
        LDR      R0,[SP, #+24]
        ADD      R1,R7,R7, LSL #+1
        ADD      R2,SP,#+232
        ADD      R1,R2,R1, LSL #+4
        STR      R6,[R1, R0, LSL #+2]
??gcode_G29_75:
        LDR.W    R0,??gcode_G29_1
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??gcode_G29_76
        ADD      R1,SP,#+52
        ADD      R0,SP,#+56
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_69
??gcode_G29_76:
          CFI FunCall rand
        BL       rand
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        LDR      R3,[SP, #+40]
        UXTB     R3,R3
        LDRB     R2,[SP, #+5]
        ADD      R1,SP,#+52
        ADD      R0,SP,#+56
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??gcode_G29_77
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G29_70:
        LDR      R0,[SP, #+24]
        ADDS     R0,R0,#+1
        UXTB     R0,R0
        STR      R0,[SP, #+24]
??gcode_G29_63:
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+16]
        CMP      R0,R1
        BGE.W    ??gcode_G29_78
        LDR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.W    ??gcode_G29_78
        LDRB     R0,[SP, #+4]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_64
        MOVS     R7,#+0
        ADD      R0,SP,#+48
        LDRSB    R0,[R0, #+0]
        STR      R0,[SP, #+80]
        MOVS     R0,#+1
        STR      R0,[SP, #+76]
        B.N      ??gcode_G29_65
??gcode_G29_77:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        LSLS     R1,R0,#+29
        BPL.W    ??gcode_G29_67
        LDR      R1,[SP, #+36]
        MOV      R0,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[SP, #+36]
        LDR      R1,[SP, #+64]
        STR      R0,[R1, R6, LSL #+2]
        LDR      R0,[SP, #+56]
        LDR      R1,[SP, #+44]
        STR      R0,[R1, R6, LSL #+2]
        LDR      R0,[SP, #+44]
        ADD      R0,R0,R6, LSL #+2
        LDR      R1,[SP, #+52]
        LDR      R2,[SP, #+68]
        STR      R1,[R0, R2, LSL #+2]
        MOV      R1,#+1065353216
        LDR      R2,[SP, #+68]
        STR      R1,[R0, R2, LSL #+3]
        ADD      R3,SP,#+36
        ADD      R2,SP,#+52
        ADD      R1,SP,#+56
        ADD      R0,SP,#+172
          CFI FunCall _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        BL       _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        B.N      ??gcode_G29_68
??gcode_G29_62:
        LSLS     R0,R0,#+30
        BPL.W    ??gcode_G29_78
        MOVS     R4,#+0
        B.N      ??gcode_G29_79
??gcode_G29_80:
        LDR      R0,[SP, #+36]
        STR      R0,[R5, #+8]
        ADDS     R4,R4,#+1
        UXTB     R4,R4
??gcode_G29_79:
        CMP      R4,#+3
        BGE.N    ??gcode_G29_81
        ADD      R0,R4,R4, LSL #+1
        LSLS     R0,R0,#+2
        ADD      R1,SP,#+88
        LDR      R1,[R0, R1]
        STR      R1,[SP, #+56]
        ADD      R1,SP,#+88
        ADDS     R5,R0,R1
        LDR      R0,[R5, #+4]
        STR      R0,[SP, #+52]
          CFI FunCall rand
        BL       rand
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        LDR      R3,[SP, #+40]
        UXTB     R3,R3
        LDRB     R2,[SP, #+5]
        ADD      R1,SP,#+52
        ADD      R0,SP,#+56
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??gcode_G29_80
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G29_81:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_78
        LDR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_78
        ADD      R4,SP,#+88
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+856
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+848
        ADD      R1,SP,#+112
        ADD      R0,SP,#+136
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+856
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+848
        ADD      R1,SP,#+88
        ADD      R0,SP,#+72
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,SP,#+136
        MOV      R2,SP
        LDM      R0!,{R1,R3}
        STM      R2!,{R1,R3}
        LDR      R3,[R0, #0]
        STR      R3,[R2, #+0]
        ADD      R0,SP,#+72
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_35crossES_S_
        BL       _ZN8vector_35crossES_S_
        ADD      R0,SP,#+124
        ADD      R1,SP,#+20
        LDM      R1!,{R2-R4}
        STM      R0!,{R2-R4}
        ADD      R1,SP,#+124
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_310get_normalEv
        BL       _ZN8vector_310get_normalEv
        ADD      R0,SP,#+0
        ADD      R1,SP,#+20
        LDM      R1!,{R2-R4}
        STM      R0!,{R2-R4}
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_82
        LDR.W    R5,??gcode_G29_1+0x64  ;; 0xbf800000
        MOV      R1,R2
        MOV      R0,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+0]
        LDR      R1,[SP, #+4]
        MOV      R0,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+4]
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+8]
??gcode_G29_82:
        ADD      R0,SP,#+0
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+136
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.W    R0,??gcode_G29_1+0x68
        ADD      R1,SP,#+136
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R9,#+0
??gcode_G29_78:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_83
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MVN      R0,#-2147483648
        STR      R0,[SP, #+36]
??gcode_G29_83:
        LDR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.W    ??gcode_G29_84
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_85
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_86
          CFI FunCall _Z30extrapolate_unprobed_bed_levelv
        BL       _Z30extrapolate_unprobed_bed_levelv
??gcode_G29_86:
          CFI FunCall _Z28print_bilinear_leveling_gridv
        BL       _Z28print_bilinear_leveling_gridv
          CFI FunCall _Z17refresh_bed_levelv
        BL       _Z17refresh_bed_levelv
        B.N      ??gcode_G29_87
??gcode_G29_85:
        CMP      R0,#+4
        BNE.W    ??gcode_G29_87
        ADD      R0,SP,#+172
          CFI FunCall _Z22finish_incremental_LSFP15linear_fit_data
        BL       _Z22finish_incremental_LSFP15linear_fit_data
        LDR      R7,[SP, #+216]
        MOV      R11,R7
        EOR      R11,R11,#0x80000000
        LDR      R6,[SP, #+220]
        MOV      R5,R6
        EOR      R5,R5,#0x80000000
        LDR      R10,[SP, #+224]
        EOR      R10,R10,#0x80000000
        LDR      R0,[SP, #+68]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR      R0,[SP, #+40]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_88
        LDR.W    R0,??gcode_G29_1+0x6C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R4,??gcode_G29_1+0x5C
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        LDR.W    R0,??gcode_G29_1+0x70
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        LDR.W    R0,??gcode_G29_1+0x74
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR      R0,[SP, #+40]
        CMP      R0,#+3
        BLT.N    ??gcode_G29_88
        LDR.N    R0,??gcode_G29_1+0x78
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_88:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_89
        MOV      R3,#+1065353216
        MOV      R2,R6
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        ADD      R0,SP,#+0
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+124
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.N    R0,??gcode_G29_1+0x68
        ADD      R1,SP,#+124
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
??gcode_G29_89:
        LDRB     R0,[SP, #+12]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_87
        LDR.N    R0,??gcode_G29_1+0x7C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R7,??gcode_G29_1+0x80  ;; 0x4479c000
        LDR      R0,[SP, #+16]
        SUB      R11,R0,#+1
        SXTB     R11,R11
        MOV      R10,R11
        B.N      ??gcode_G29_90
??gcode_G29_91:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_1+0x5C
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        SUB      R10,R10,#+1
        SXTB     R10,R10
??gcode_G29_90:
        CMP      R10,#+0
        BMI.N    ??gcode_G29_92
        MOVS     R5,#+0
        B.N      ??gcode_G29_93
??gcode_G29_94:
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_95:
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADDS     R5,R5,#+1
??gcode_G29_93:
        UXTB     R5,R5
        MOV      R0,R5
        LDR      R1,[SP, #+48]
        CMP      R0,R1
        BGE.N    ??gcode_G29_91
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,SP,#+232
        ADD      R0,R0,R1, LSL #+4
        LDR      R4,[R0, R10, LSL #+2]
        LDR      R0,[SP, #+64]
        LDR      R0,[R0, R4, LSL #+2]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR      R0,[SP, #+44]
        LDR      R0,[R0, R4, LSL #+2]
        STR      R0,[SP, #+80]
        LDR      R0,[SP, #+68]
        LDR      R1,[SP, #+44]
        ADD      R1,R1,R4, LSL #+2
        LDR      R0,[R1, R0, LSL #+2]
        STR      R0,[SP, #+76]
        MOVS     R0,#+0
        STR      R0,[SP, #+72]
        ADD      R0,SP,#+72
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+76
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+80
        STR      R0,[SP, #+20]
        LDR.N    R1,??gcode_G29_1+0x68
        SUB      SP,SP,#+16
          CFI CFA R13+864
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+848
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[SP, #+64]
        LDR      R0,[R0, R4, LSL #+2]
        LDR      R1,[SP, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_96
        MOV      R7,R0
??gcode_G29_96:
        LDR.N    R4,??gcode_G29_1+0x5C
        MOV      R0,R6
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_94
        LDR.N    R0,??gcode_G29_1+0x84
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_95
??gcode_G29_92:
        LDR.N    R4,??gcode_G29_1+0x5C
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR      R0,[SP, #+40]
        CMP      R0,#+4
        BLT.N    ??gcode_G29_87
        LDR.N    R0,??gcode_G29_1+0x88
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R8,R11
        B.N      ??gcode_G29_97
??gcode_G29_98:
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        SUB      R8,R8,#+1
        SXTB     R8,R8
??gcode_G29_97:
        CMP      R8,#+0
        BMI.N    ??gcode_G29_99
        MOVS     R5,#+0
        B.N      ??gcode_G29_100
??gcode_G29_101:
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_102:
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADDS     R5,R5,#+1
??gcode_G29_100:
        UXTB     R5,R5
        MOV      R0,R5
        LDR      R1,[SP, #+48]
        CMP      R0,R1
        BGE.N    ??gcode_G29_98
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,SP,#+232
        ADD      R0,R0,R1, LSL #+4
        LDR      R6,[R0, R8, LSL #+2]
        LDR      R0,[SP, #+44]
        LDR      R0,[R0, R6, LSL #+2]
        STR      R0,[SP, #+80]
        LDR      R0,[SP, #+68]
        LDR      R1,[SP, #+44]
        ADD      R1,R1,R6, LSL #+2
        LDR      R0,[R1, R0, LSL #+2]
        STR      R0,[SP, #+76]
        MOVS     R0,#+0
        STR      R0,[SP, #+72]
        ADD      R0,SP,#+72
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+76
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+80
        STR      R0,[SP, #+20]
        LDR.N    R1,??gcode_G29_1+0x68
        SUB      SP,SP,#+16
          CFI CFA R13+864
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+848
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[SP, #+64]
        LDR      R0,[R0, R6, LSL #+2]
        LDR      R1,[SP, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_101
        LDR.N    R0,??gcode_G29_1+0x84
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_102
??gcode_G29_99:
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_87:
        LDR.N    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??gcode_G29_103
        LDR      R0,[SP, #+40]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_104
        LDR.N    R1,??gcode_G29_1+0x8C
        LDR.N    R0,??gcode_G29_1+0x68
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
??gcode_G29_104:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_105
        LDR.N    R4,??gcode_G29_1+0x20
        MOVS     R2,#+12
        ADD      R1,R4,#+8
        ADD      R0,SP,#+0
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_1+0x14
        STRB     R0,[R1, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        MOVS     R0,#+0
        LDR.N    R1,??gcode_G29_1+0x14
        STRB     R0,[R1, #+0]
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+12]
        LDR      R1,[SP, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R5,??gcode_G29_1+0x90  ;; 0xb58637bd
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_106
        LDR.N    R6,??gcode_G29_1+0x94  ;; 0x358637be
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_106
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+16]
        LDR      R1,[SP, #+52]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_106
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_106
        LDR      R0,[R4, #+16]
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
??gcode_G29_106:
        MOVS     R2,#+12
        ADD      R1,SP,#+0
        ADD      R0,R4,#+8
          CFI FunCall memcpy
        BL       memcpy
        B.N      ??gcode_G29_105
??gcode_G29_103:
        CMP      R0,#+8
        BNE.N    ??gcode_G29_105
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_105
        LDR.N    R4,??gcode_G29_1+0x20
        ADD      R0,R4,#+8
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        MOV      R1,R0
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+16]
??gcode_G29_105:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_107
        LDR.N    R0,??gcode_G29_1+0x14
        STRB     R9,[R0, #+0]
        B.N      ??gcode_G29_84
??gcode_G29_107:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_1+0x14
        STRB     R0,[R1, #+0]
??gcode_G29_84:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+6]
        LDR.N    R0,??gcode_G29_1+0x14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_108
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G29_108:
        LDR      R0,[SP, #+64]
          CFI FunCall free
        BL       free
        LDR      R0,[SP, #+44]
          CFI FunCall free
        BL       free
??gcode_G29_0:
        ADD      SP,SP,#+812
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??gcode_G29_1:
        DC32     mksCfg
        DC32     mksCfg+0x60
        DC32     axis_relative_modes
        DC32     _ZZ9gcode_G29vEs
        DC32     _ZZ9gcode_G29vEs_0
        DC32     _ZN7Planner15leveling_activeE
        DC32     errormagic
        DC32     _ZZ9gcode_G29vEs_1
        DC32     mks_heating_busy
        DC32     0xc1200000
        DC32     0x41200001
        DC32     _ZZ9gcode_G29vEs_2
        DC32     z_values
        DC32     _ZZ9gcode_G29vEs_3
        DC32     _ZZ9gcode_G29vEs_4
        DC32     0x42700000
        DC32     mksTmp
        DC32     _ZZ9gcode_G29vEs_5
        DC32     _ZZ9gcode_G29vEs_6
        DC32     _ZZ9gcode_G29vEs_7
        DC32     _ZZ9gcode_G29vEs_8
        DC32     _ZZ9gcode_G29vEs_9
        DC32     _ZZ9gcode_G29vEs__10_
        DC32     Serial3
        DC32     0x3fe00000
        DC32     0xbf800000
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     _ZZ9gcode_G29vEs__11_
        DC32     _ZZ9gcode_G29vEs__12_
        DC32     _ZZ9gcode_G29vEs__13_
        DC32     _ZZ9gcode_G29vEs__14_
        DC32     _ZZ9gcode_G29vEs__15_
        DC32     0x4479c000
        DC32     _ZZ9gcode_G29vEs__16_
        DC32     _ZZ9gcode_G29vEs__17_
        DC32     _ZZ9gcode_G29vEs__18_
        DC32     0xb58637bd
        DC32     0x358637be
          CFI EndBlock cfiBlock261

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G30v
          CFI Block cfiBlock262 Using cfiCommon0
          CFI Function _Z9gcode_G30v
        THUMB
_Z9gcode_G30v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
        LDR.N    R4,??gcode_G30_0
        ADD      R5,R4,#+64
        LDR.N    R6,??gcode_G30_0+0x4
        LDR      R1,[R6, #+8]
        LDR      R0,[R5, #+44]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        STR      R0,[SP, #+8]
        LDR      R1,[R6, #+12]
        LDR      R0,[R5, #+48]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        STR      R0,[SP, #+4]
        LDRH     R0,[R5, #+24]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??gcode_G30_1
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_2
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_2
??gcode_G30_1:
        LDRB     R0,[R4, #+64]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??gcode_G30_3
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G30_3:
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOVS     R1,#+1
        STR      R1,[SP, #+0]
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
        MOV      R6,R0
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G30_4
        LDR.N    R4,??gcode_G30_0+0x8  ;; 0x88e368f1
        LDR.N    R5,??gcode_G30_0+0xC  ;; 0x3ee4f8b5
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x10
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x14
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G30_0+0x1C
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G30_4:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_G30_2:
        POP      {R0-R6,PC}       ;; return
        DATA
??gcode_G30_0:
        DC32     mksCfg
        DC32     mks_heating_busy
        DC32     0x88e368f1
        DC32     0x3ee4f8b5
        DC32     _ZZ9gcode_G30vEs
        DC32     _ZZ9gcode_G30vEs_0
        DC32     _ZZ9gcode_G30vEs_1
        DC32     Serial3
          CFI EndBlock cfiBlock262

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G42v
          CFI Block cfiBlock263 Using cfiCommon0
          CFI Function _Z9gcode_G42v
        THUMB
_Z9gcode_G42v:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.W    ??gcode_G42_0
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        MOVS     R4,R0
        BEQ.N    ??gcode_G42_1
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R5,R0
        SXTB     R5,R5
        B.N      ??gcode_G42_2
??gcode_G42_1:
        MOVS     R5,#+0
??gcode_G42_2:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        MOVS     R6,R0
        BEQ.N    ??gcode_G42_3
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R7,R0
        SXTB     R7,R7
        B.N      ??gcode_G42_4
??gcode_G42_3:
        MOVS     R7,#+0
??gcode_G42_4:
        LDR.W    R8,??gcode_G42_5
        CMP      R4,#+0
        BEQ.N    ??gcode_G42_6
        CMP      R5,#+0
        BMI.N    ??gcode_G42_7
        LDRB     R0,[R8, #+96]
        SUBS     R0,R0,#+1
        CMP      R0,R5
        BLT.N    ??gcode_G42_7
??gcode_G42_6:
        CMP      R6,#+0
        BEQ.N    ??gcode_G42_8
        CMP      R7,#+0
        BMI.N    ??gcode_G42_7
        ADD      R0,R8,#+96
        LDRB     R0,[R0, #+1]
        SUBS     R0,R0,#+1
        CMP      R0,R7
        BGE.N    ??gcode_G42_8
??gcode_G42_7:
        LDR.N    R0,??gcode_G42_5+0x4
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_8:
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
        LDR.W    R9,??gcode_G42_5+0x8
        CMP      R4,#+0
        BEQ.N    ??gcode_G42_9
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G42_10
        LDR.N    R0,??gcode_G42_5+0xC
        LDR      R1,[R0, #+24]
        LDR      R0,[R0, #+16]
        MLA      R0,R0,R5,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R9, #+24]
??gcode_G42_10:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_G42_11
        MOV      R0,R5
        UXTB     R0,R0
          CFI FunCall _ZN20unified_bed_leveling18mesh_index_to_xposEh
        BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
        STR      R0,[R9, #+24]
??gcode_G42_11:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+26
        BPL.N    ??gcode_G42_9
        LDR.N    R0,??gcode_G42_5+0x10
        LDR      R0,[R0, R5, LSL #+2]
        STR      R0,[R9, #+24]
??gcode_G42_9:
        CMP      R6,#+0
        BEQ.N    ??gcode_G42_12
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G42_13
        LDR.N    R0,??gcode_G42_5+0xC
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+20]
        MLA      R0,R0,R7,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R9, #+28]
??gcode_G42_13:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_G42_14
        MOV      R0,R7
        UXTB     R0,R0
          CFI FunCall _ZN20unified_bed_leveling18mesh_index_to_yposEh
        BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
        STR      R0,[R9, #+28]
??gcode_G42_14:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+26
        BPL.N    ??gcode_G42_12
        LDR.N    R0,??gcode_G42_5+0x14
        LDR      R0,[R0, R7, LSL #+2]
        STR      R0,[R9, #+28]
??gcode_G42_12:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G42_15
        CMP      R4,#+0
        BEQ.N    ??gcode_G42_16
        LDR      R0,[R9, #+24]
        ADD      R1,R8,#+96
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+24]
??gcode_G42_16:
        CMP      R6,#+0
        BEQ.N    ??gcode_G42_15
        LDR      R0,[R9, #+28]
        ADD      R1,R8,#+96
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+28]
??gcode_G42_15:
        MOVS     R1,#+0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_G42_17
        LDR.N    R1,??gcode_G42_5+0x18  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R9, #+92]
??gcode_G42_17:
        LDRH     R0,[R8, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G42_18
        MOVS     R0,#+0
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.W      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_18:
        POP      {R0,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_0:
        POP      {R0,R4-R9,PC}    ;; return
        DATA
??gcode_G42_5:
        DC32     mksCfg
        DC32     _ZZ9gcode_G42vEs
        DC32     mks_heating_busy
        DC32     axis_relative_modes
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
        DC32     0x42700000
          CFI EndBlock cfiBlock263

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G92v
          CFI Block cfiBlock264 Using cfiCommon0
          CFI Function _Z9gcode_G92v
        THUMB
_Z9gcode_G92v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOVS     R5,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R4,R0
        BNE.N    ??gcode_G92_0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_G92_0:
        MOV      R6,R5
        B.N      ??gcode_G92_1
??gcode_G92_2:
        LDR      R8,[R7, #+8]
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        STR      R0,[R7, #+8]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_3
        MOVS     R5,#+1
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R7, #+96]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+96]
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??gcode_G92_3:
        ADDS     R6,R6,#+1
??gcode_G92_1:
        CMP      R6,#+4
        BGE.N    ??gcode_G92_4
        LDR.N    R0,??gcode_G92_5
        LDRSB    R0,[R6, R0]
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G92_3
        LDR.N    R0,??gcode_G92_5+0x4
        ADD      R7,R0,R6, LSL #+2
        LDR.N    R0,??gcode_G92_5+0x8
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G92_2
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        STR      R0,[R7, #+8]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_3
        MOVS     R5,#+1
        B.N      ??gcode_G92_3
??gcode_G92_4:
        CMP      R5,#+0
        BEQ.N    ??gcode_G92_6
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??gcode_G92_7
??gcode_G92_6:
        CMP      R4,#+0
        BEQ.N    ??gcode_G92_7
          CFI FunCall _Z20sync_plan_position_ev
        BL       _Z20sync_plan_position_ev
??gcode_G92_7:
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
        DATA
??gcode_G92_5:
        DC32     axis_codes
        DC32     mks_heating_busy
        DC32     mksCfg
          CFI EndBlock cfiBlock264

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M17v
          CFI Block cfiBlock265 Using cfiCommon0
          CFI Function _Z9gcode_M17v
        THUMB
_Z9gcode_M17v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M17_0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19enable_all_steppersv
        B.W      _Z19enable_all_steppersv
        Nop      
        DATA
??gcode_M17_0:
        DC32     _ZZ9gcode_M17vEs
          CFI EndBlock cfiBlock265

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M20v
          CFI Block cfiBlock266 Using cfiCommon0
          CFI Function _Z9gcode_M20v
        THUMB
_Z9gcode_M20v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M20_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M20_0+0x4
          CFI FunCall _ZN10CardReader2lsEv
        BL       _ZN10CardReader2lsEv
        LDR.N    R0,??gcode_M20_0+0x8
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        DATA
??gcode_M20_0:
        DC32     _ZZ9gcode_M20vEs
        DC32     card
        DC32     _ZZ9gcode_M20vEs_0
          CFI EndBlock cfiBlock266

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M22v
          CFI Block cfiBlock267 Using cfiCommon0
          CFI Function _Z9gcode_M22v
        THUMB
_Z9gcode_M22v:
        LDR.N    R0,??gcode_M22_0
          CFI FunCall _ZN10CardReader7releaseEv
        B.W      _ZN10CardReader7releaseEv
        Nop      
        DATA
??gcode_M22_0:
        DC32     card
          CFI EndBlock cfiBlock267

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M23v
          CFI Block cfiBlock268 Using cfiCommon0
          CFI Function _Z9gcode_M23v
        THUMB
_Z9gcode_M23v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M23_0
        LDR      R1,[R0, #+0]
        B.N      ??gcode_M23_1
??gcode_M23_2:
        CMP      R2,#+32
        BNE.N    ??gcode_M23_3
        MOVS     R2,#+0
        STRB     R2,[R1, #+0]
??gcode_M23_3:
        ADDS     R1,R1,#+1
??gcode_M23_1:
        LDRSB    R2,[R1, #+0]
        CMP      R2,#+0
        BNE.N    ??gcode_M23_2
        LDR.N    R4,??gcode_M23_0+0x4
        MOVS     R3,#+1
        MOV      R2,R3
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        ADDW     R1,R4,#+1916
        LDR.N    R0,??gcode_M23_0+0x8
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall strcpy
        B.W      strcpy
        Nop      
        DATA
??gcode_M23_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
        DC32     curFileName
          CFI EndBlock cfiBlock268

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M24v
          CFI Block cfiBlock269 Using cfiCommon0
          CFI Function _Z9gcode_M24v
        THUMB
_Z9gcode_M24v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
          CFI FunCall mks_resumePrint
        BL       mks_resumePrint
        LDR.N    R4,??gcode_M24_0
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+171
        BEQ.N    ??gcode_M24_1
        CMP      R0,#+172
        BEQ.N    ??gcode_M24_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADDW     R0,R4,#+2792
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M24_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M24_0:
        DC32     card
          CFI EndBlock cfiBlock269

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M25v
          CFI Block cfiBlock270 Using cfiCommon0
          CFI Function _Z9gcode_M25v
        THUMB
_Z9gcode_M25v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M25_0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
        ADDW     R0,R4,#+2792
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        MOVS     R0,#+169
        STRB     R0,[R4, #+2076]
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M25_0:
        DC32     card
          CFI EndBlock cfiBlock270

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M998v
          CFI Block cfiBlock271 Using cfiCommon0
          CFI Function _Z10gcode_M998v
        THUMB
_Z10gcode_M998v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M998_0
        LDRB     R0,[R4, #+2076]
        CMP      R0,#+172
        BEQ.N    ??gcode_M998_1
        MOVS     R0,#+166
        STRB     R0,[R4, #+2076]
        LDR.N    R0,??gcode_M998_0+0x4
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??gcode_M998_2
        MOVS     R2,#+1
        ADDW     R1,R4,#+2076
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??gcode_M998_2:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader11stopSDPrintEv
        BL       _ZN10CardReader11stopSDPrintEv
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        ADDW     R0,R4,#+2792
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        MOVS     R0,#+0
        B.N      ??gcode_M998_3
??gcode_M998_4:
        MOVS     R0,#+0
        STR      R0,[R1, #+108]
        LDR.N    R1,??gcode_M998_0+0x8  ;; 0x40000440
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??gcode_M998_3:
        LDR.N    R1,??gcode_M998_0+0xC
        CMP      R0,#+0
        BEQ.N    ??gcode_M998_4
        MOVS     R0,#+0
        STRB     R0,[R1, #+4]
??gcode_M998_1:
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M998_0:
        DC32     card
        DC32     gCfgItems
        DC32     0x40000440
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock271

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M26v
          CFI Block cfiBlock272 Using cfiCommon0
          CFI Function _Z9gcode_M26v
        THUMB
_Z9gcode_M26v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M26_0
        LDRB     R0,[R4, #+1891]
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8setIndexEl
        B.W      _ZN10CardReader8setIndexEl
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M26_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M26_0:
        DC32     card
          CFI EndBlock cfiBlock272

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M27v
          CFI Block cfiBlock273 Using cfiCommon0
          CFI Function _Z9gcode_M27v
        THUMB
_Z9gcode_M27v:
        LDR.N    R0,??gcode_M27_0
          CFI FunCall _ZN10CardReader9getStatusEv
        B.W      _ZN10CardReader9getStatusEv
        Nop      
        DATA
??gcode_M27_0:
        DC32     card
          CFI EndBlock cfiBlock273

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M28v
          CFI Block cfiBlock274 Using cfiCommon0
          CFI Function _Z9gcode_M28v
        THUMB
_Z9gcode_M28v:
        MOVS     R3,#+1
        MOVS     R2,#+0
        LDR.N    R0,??gcode_M28_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M28_0+0x4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        B.W      _ZN10CardReader8openFileEPcbb
        Nop      
        DATA
??gcode_M28_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock274

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z9gcode_M29v
          CFI Block cfiBlock275 Using cfiCommon0
          CFI Function _Z9gcode_M29v
          CFI NoCalls
        THUMB
_Z9gcode_M29v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock275

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M30v
          CFI Block cfiBlock276 Using cfiCommon0
          CFI Function _Z9gcode_M30v
        THUMB
_Z9gcode_M30v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M30_0
        LDRB     R0,[R4, #+1891]
        CMP      R0,#+0
        BEQ.N    ??gcode_M30_1
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        LDR.N    R0,??gcode_M30_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader10removeFileEPc
        B.W      _ZN10CardReader10removeFileEPc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M30_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M30_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock276

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M31v
          CFI Block cfiBlock277 Using cfiCommon0
          CFI Function _Z9gcode_M31v
        THUMB
_Z9gcode_M31v:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+36
          CFI CFA R13+40
        LDR.N    R0,??gcode_M31_0
          CFI FunCall _ZN9Stopwatch8durationEv
        BL       _ZN9Stopwatch8durationEv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _ZN10duration_tC1ERKj
        BL       _ZN10duration_tC1ERKj
        ADD      R1,SP,#+8
          CFI FunCall _ZNK10duration_t8toStringEPc
        BL       _ZNK10duration_t8toStringEPc
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.N    R0,??gcode_M31_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      R1,SP,#+8
        LDR.N    R0,??gcode_M31_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M31_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADD      SP,SP,#+36
          CFI CFA R13+4
        POP      {PC}             ;; return
        DATA
??gcode_M31_0:
        DC32     card+0xAE8
        DC32     echomagic
        DC32     _ZZ9gcode_M31vEs
        DC32     Serial3
          CFI EndBlock cfiBlock277

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M32v
          CFI Block cfiBlock278 Using cfiCommon0
          CFI Function _Z9gcode_M32v
        THUMB
_Z9gcode_M32v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M32_0
        LDRB     R0,[R4, #+1888]
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_1
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_M32_1:
        ADDW     R0,R4,#+1888
        LDRB     R1,[R0, #+3]
        LDRB     R0,[R0, #+4]
        ORRS     R0,R0,R1
        BEQ.N    ??gcode_M32_2
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R5,R0
        MOV      R3,R5
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M32_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_3
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??gcode_M32_3:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        CMP      R5,#+0
        BNE.N    ??gcode_M32_2
        ADDW     R0,R4,#+2792
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M32_2:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M32_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock278

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M928v
          CFI Block cfiBlock279 Using cfiCommon0
          CFI Function _Z10gcode_M928v
        THUMB
_Z10gcode_M928v:
        LDR.N    R0,??gcode_M928_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M928_0+0x4
          CFI FunCall _ZN10CardReader11openLogFileEPc
        B.W      _ZN10CardReader11openLogFileEPc
        Nop      
        DATA
??gcode_M928_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock279

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M42v
          CFI Block cfiBlock280 Using cfiCommon0
          CFI Function _Z9gcode_M42v
        THUMB
_Z9gcode_M42v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOVS     R5,R0
        BMI.N    ??gcode_M42_0
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_1
        LDR.N    R0,??gcode_M42_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M42_2+0x4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M42_1:
        CMP      R5,#+0
        MOV      R2,R4
        SXTB     R2,R2
        BMI.N    ??gcode_M42_3
        LDR.N    R0,??gcode_M42_2+0x8
        LDRH     R1,[R0, R5, LSL #+1]
        LDR.N    R0,??gcode_M42_2+0xC
        LDR      R0,[R0, R5, LSL #+2]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        B.N      ??gcode_M42_4
??gcode_M42_3:
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
??gcode_M42_4:
        CMP      R5,#+17
        BNE.N    ??gcode_M42_0
        LDR.N    R0,??gcode_M42_2+0x10
        STR      R4,[R0, #+108]
??gcode_M42_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M42_2:
        DC32     errormagic
        DC32     _ZZ9gcode_M42vEs
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock280

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M49v
          CFI Block cfiBlock281 Using cfiCommon0
          CFI Function _Z9gcode_M49v
        THUMB
_Z9gcode_M49v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M49_0
        LDRB     R0,[R4, #+0]
        EOR      R0,R0,#0x1
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[R4, #+0]
        LDR.N    R0,??gcode_M49_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M49_1
        LDR.N    R0,??gcode_M49_0+0x8
        B.N      ??gcode_M49_2
??gcode_M49_1:
        LDR.N    R0,??gcode_M49_0+0xC
??gcode_M49_2:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M49_0:
        DC32     g26_debug_flag
        DC32     _ZZ9gcode_M49vEs
        DC32     _ZZ9gcode_M49vEs_0
        DC32     _ZZ9gcode_M49vEs_1
          CFI EndBlock cfiBlock281

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M75v
          CFI Block cfiBlock282 Using cfiCommon0
          CFI Function _Z9gcode_M75v
        THUMB
_Z9gcode_M75v:
        LDR.N    R0,??gcode_M75_0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
        Nop      
        DATA
??gcode_M75_0:
        DC32     card+0xAE8
          CFI EndBlock cfiBlock282

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M76v
          CFI Block cfiBlock283 Using cfiCommon0
          CFI Function _Z9gcode_M76v
        THUMB
_Z9gcode_M76v:
        LDR.N    R0,??gcode_M76_0
          CFI FunCall _ZN9Stopwatch5pauseEv
        B.W      _ZN9Stopwatch5pauseEv
        Nop      
        DATA
??gcode_M76_0:
        DC32     card+0xAE8
          CFI EndBlock cfiBlock283

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M77v
          CFI Block cfiBlock284 Using cfiCommon0
          CFI Function _Z9gcode_M77v
        THUMB
_Z9gcode_M77v:
        LDR.N    R0,??gcode_M77_0
          CFI FunCall _ZN9Stopwatch4stopEv
        B.W      _ZN9Stopwatch4stopEv
        Nop      
        DATA
??gcode_M77_0:
        DC32     card+0xAE8
          CFI EndBlock cfiBlock284

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M104v
          CFI Block cfiBlock285 Using cfiCommon0
          CFI Function _Z10gcode_M104v
        THUMB
_Z10gcode_M104v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+104
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M104_1
        LDR.N    R4,??gcode_M104_2
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.N    ??gcode_M104_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M104_3
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDRB     R1,[R4, #+5]
        MOV      R5,R1
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R5,R0
        LDR.N    R0,??gcode_M104_2+0x4
        LDR      R1,[R0, #+44]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M104_4
        LDR.N    R0,??gcode_M104_2+0x8
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_4:
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R5,R0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M104_3
        LDRB     R0,[R4, #+5]
        CMP      R0,#+4
        BHI.N    ??gcode_M104_3
        TBB      [PC, R0]
        DATA
??gcode_M104_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M104_5:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x10
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_6:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_3:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        B.W      _ZN7Planner18autotemp_M104_M109Ev
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M104_1:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M104_2:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     card+0xAE8
        DC32     _ZZ10gcode_M104vEs
        DC32     _ZZ10gcode_M104vEs_0
        DC32     _ZZ10gcode_M104vEs_1
        DC32     _ZZ10gcode_M104vEs_2
        DC32     _ZZ10gcode_M104vEs_3
        DC32     _ZZ10gcode_M104vEs_4
          CFI EndBlock cfiBlock285

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M105v
          CFI Block cfiBlock286 Using cfiCommon0
          CFI Function _Z10gcode_M105v
        THUMB
_Z10gcode_M105v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+105
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M105_0
        LDR.N    R0,??gcode_M105_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M105_1+0x4
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M105_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M105_1:
        DC32     _ZZ10gcode_M105vEs
        DC32     Serial3
          CFI EndBlock cfiBlock286

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M155v
          CFI Block cfiBlock287 Using cfiCommon0
          CFI Function _Z10gcode_M155v
        THUMB
_Z10gcode_M155v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M155_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R1,R0
        LDR.N    R0,??gcode_M155_1
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature24set_auto_report_intervalEh
        B.W      _ZN11Temperature24set_auto_report_intervalEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M155_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M155_1:
        DC32     thermalManager
          CFI EndBlock cfiBlock287

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M106v
          CFI Block cfiBlock288 Using cfiCommon0
          CFI Function _Z10gcode_M106v
        THUMB
_Z10gcode_M106v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+0
        BNE.N    ??gcode_M106_0
        MOVS     R1,#+255
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        MOVS     R1,#+255
        CMP      R0,#+255
        BGT.N    ??gcode_M106_1
        MOV      R1,R0
??gcode_M106_1:
        LDR.N    R2,??gcode_M106_2
        STR      R1,[R2, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.N    R1,??gcode_M106_2+0x4  ;; 0x40000440
        STR      R0,[R1, #+0]
??gcode_M106_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M106_2:
        DC32     mks_heating_busy
        DC32     0x40000440
          CFI EndBlock cfiBlock288

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M107v
          CFI Block cfiBlock289 Using cfiCommon0
          CFI Function _Z10gcode_M107v
        THUMB
_Z10gcode_M107v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        CMP      R0,#+0
        BNE.N    ??gcode_M107_0
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M107_1
        STR      R0,[R1, #+108]
        LDR.N    R1,??gcode_M107_1+0x4  ;; 0x40000440
        STR      R0,[R1, #+0]
??gcode_M107_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M107_1:
        DC32     mks_heating_busy
        DC32     0x40000440
          CFI EndBlock cfiBlock289

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M108v
          CFI Block cfiBlock290 Using cfiCommon0
          CFI Function _Z10gcode_M108v
          CFI NoCalls
        THUMB
_Z10gcode_M108v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M108_0
        STRB     R0,[R1, #+4]
        BX       LR               ;; return
        DATA
??gcode_M108_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock290

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M112v
          CFI Block cfiBlock291 Using cfiCommon0
          CFI Function _Z10gcode_M112v
        THUMB
_Z10gcode_M112v:
        LDR.N    R0,??gcode_M112_0
          CFI FunCall _Z4killPKc
        B.W      _Z4killPKc
        Nop      
        DATA
??gcode_M112_0:
        DC32     _ZZ10gcode_M112vEs
          CFI EndBlock cfiBlock291

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M410v
          CFI Block cfiBlock292 Using cfiCommon0
          CFI Function _Z10gcode_M410v
          CFI FunCall _Z17quickstop_stepperv
        THUMB
_Z10gcode_M410v:
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock292

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M109v
          CFI Block cfiBlock293 Using cfiCommon0
          CFI Function _Z10gcode_M109v
        THUMB
_Z10gcode_M109v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
        MOVS     R0,#+109
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??gcode_M109_1
        LDR.N    R4,??gcode_M109_2
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M109_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        STR      R0,[SP, #+4]
        CMP      R0,#+0
        BNE.N    ??gcode_M109_3
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_M109_1
??gcode_M109_3:
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDRB     R1,[R4, #+5]
        MOV      R5,R1
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R5,R0
        LDR.N    R6,??gcode_M109_2+0x4
        LDR.N    R0,??gcode_M109_2+0x8
        LDR      R1,[R0, #+44]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        MOV      R0,R6
        BHI.N    ??gcode_M109_4
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_5
??gcode_M109_4:
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M109_5:
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R5,R0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M109_6
        LDRB     R0,[R4, #+5]
        CMP      R0,#+4
        BHI.N    ??gcode_M109_6
        TBB      [PC, R0]
        DATA
??gcode_M109_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M109_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x10
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_10:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_11:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M109_6:
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        BL       _ZN7Planner18autotemp_M104_M109Ev
        MOVS     R5,#+0
        LDR.W    R8,??gcode_M109_2+0x24  ;; 0xbf800000
        LDR.N    R6,??gcode_M109_2+0x28  ;; 0x461c3c00
        MOV      R7,R5
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
        MOV      R0,R5
        STR      R0,[SP, #+0]
        MOV      R9,R0
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        BL       _ZN11Temperature21start_watching_heaterEh
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
??gcode_M109_12:
        LDRB     R10,[R4, #+5]
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M109_13
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15isCoolingHotendEh
        BL       _ZN11Temperature15isCoolingHotendEh
        MOV      R7,R0
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOV      R8,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R7
        UXTB     R0,R0
        TST      R0,R1
        BNE.N    ??gcode_M109_14
??gcode_M109_13:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        SUBS     R0,R10,R0
        BMI.N    ??gcode_M109_15
        ADD      R0,R10,#+1000
        STR      R0,[SP, #+0]
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        LDR.N    R0,??gcode_M109_2+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R11,??gcode_M109_2+0x30
        CMP      R5,#+0
        BEQ.N    ??gcode_M109_16
        MOVS     R2,#+10
        RSB      R0,R10,#+4000
        ADDS     R0,R5,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M109_17
??gcode_M109_16:
        MOVS     R1,#+63
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_17:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_15:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R11,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CMP      R5,#+0
        BNE.N    ??gcode_M109_18
        MOV      R1,#+1082130432
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M109_19
        MOV      R5,R10
        B.N      ??gcode_M109_19
??gcode_M109_18:
        LDR.N    R1,??gcode_M109_2+0x34  ;; 0x40800001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M109_19
        MOV      R5,R10
??gcode_M109_19:
        CMP      R7,#+0
        BEQ.N    ??gcode_M109_20
        CMP      R9,#+0
        BEQ.N    ??gcode_M109_21
        SUBS     R0,R10,R9
        BMI.N    ??gcode_M109_20
??gcode_M109_21:
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M109_14
        ADD      R9,R10,#+59904
        ADD      R9,R9,#+96
        MOV      R6,R11
??gcode_M109_20:
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_14
        CMP      R5,#+0
        BEQ.N    ??gcode_M109_12
        SUB      R0,R10,R5
        SUBS     R0,R0,#+4000
        BMI.N    ??gcode_M109_12
??gcode_M109_14:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x38
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        B.W      _Z16lcd_setstatusPGMPKca
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M109_1:
        POP      {R0-R2,R4-R11,PC}  ;; return
        DATA
??gcode_M109_2:
        DC32     mks_heating_busy
        DC32     card+0xAE8
        DC32     mksCfg
        DC32     _ZZ10gcode_M109vEs
        DC32     _ZZ10gcode_M109vEs_0
        DC32     _ZZ10gcode_M109vEs_1
        DC32     _ZZ10gcode_M109vEs_2
        DC32     _ZZ10gcode_M109vEs_3
        DC32     _ZZ10gcode_M109vEs_4
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     _ZZ10gcode_M109vEs_5
        DC32     Serial3
        DC32     0x40800001
        DC32     _ZZ10gcode_M109vEs_6
          CFI EndBlock cfiBlock293

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M190v
          CFI Block cfiBlock294 Using cfiCommon0
          CFI Function _Z10gcode_M190v
        THUMB
_Z10gcode_M190v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
        LDR.N    R4,??gcode_M190_0
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M190_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M190_0+0x4
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        STR      R0,[SP, #+4]
        CMP      R0,#+0
        BNE.N    ??gcode_M190_2
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_M190_1
??gcode_M190_2:
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall _ZN11Temperature12setTargetBedEf
        BL       _ZN11Temperature12setTargetBedEf
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        LDR.N    R1,??gcode_M190_0+0x8  ;; 0x40a00001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M190_3
        LDR.N    R0,??gcode_M190_0+0xC
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M190_3:
        MOVS     R5,#+0
        LDR.W    R8,??gcode_M190_0+0x10  ;; 0xbf800000
        LDR.N    R6,??gcode_M190_0+0x14  ;; 0x461c3c00
        MOV      R7,R5
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
        MOV      R0,R5
        STR      R0,[SP, #+0]
        MOV      R9,R0
        LDRB     R0,[R4, #+3]
        STRB     R0,[R4, #+5]
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
??gcode_M190_4:
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M190_5
          CFI FunCall _ZN11Temperature12isCoolingBedEv
        BL       _ZN11Temperature12isCoolingBedEv
        MOV      R7,R0
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOV      R8,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R7
        UXTB     R0,R0
        TST      R0,R1
        BNE.N    ??gcode_M190_6
??gcode_M190_5:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        SUBS     R0,R10,R0
        BMI.N    ??gcode_M190_7
        ADD      R0,R10,#+1000
        STR      R0,[SP, #+0]
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        LDR.N    R0,??gcode_M190_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R11,??gcode_M190_0+0x1C
        CMP      R5,#+0
        BEQ.N    ??gcode_M190_8
        MOVS     R2,#+10
        RSB      R0,R10,#+4000
        ADDS     R0,R5,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M190_9
??gcode_M190_8:
        MOVS     R1,#+63
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M190_9:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M190_7:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
          CFI FunCall _ZN11Temperature6degBedEv
        BL       _ZN11Temperature6degBedEv
        MOV      R11,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CMP      R5,#+0
        BNE.N    ??gcode_M190_10
        MOV      R1,#+1073741824
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M190_11
        MOV      R5,R10
        B.N      ??gcode_M190_11
??gcode_M190_10:
        LDR.N    R1,??gcode_M190_0+0x20  ;; 0x40800001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M190_11
        MOV      R5,R10
??gcode_M190_11:
        CMP      R7,#+0
        BEQ.N    ??gcode_M190_12
        CMP      R9,#+0
        BEQ.N    ??gcode_M190_13
        SUBS     R0,R10,R9
        BMI.N    ??gcode_M190_12
??gcode_M190_13:
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M190_6
        ADD      R9,R10,#+59904
        ADD      R9,R9,#+96
        MOV      R6,R11
??gcode_M190_12:
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_6
        CMP      R5,#+0
        BEQ.N    ??gcode_M190_4
        SUB      R0,R10,R5
        SUBS     R0,R0,#+4000
        BMI.N    ??gcode_M190_4
??gcode_M190_6:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M190_0+0x24
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        B.W      _Z16lcd_setstatusPGMPKca
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M190_1:
        POP      {R0-R2,R4-R11,PC}  ;; return
        Nop      
        DATA
??gcode_M190_0:
        DC32     mks_heating_busy
        DC32     _ZZ10gcode_M190vEs
        DC32     0x40a00001
        DC32     card+0xAE8
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     _ZZ10gcode_M190vEs_0
        DC32     Serial3
        DC32     0x40800001
        DC32     _ZZ10gcode_M190vEs_1
          CFI EndBlock cfiBlock294

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M110v
          CFI Block cfiBlock295 Using cfiCommon0
          CFI Function _Z10gcode_M110v
        THUMB
_Z10gcode_M110v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+78
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M110_0
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        LDR.N    R1,??gcode_M110_1
        STR      R0,[R1, #+44]
??gcode_M110_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M110_1:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock295

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M111v
          CFI Block cfiBlock296 Using cfiCommon0
          CFI Function _Z10gcode_M111v
        THUMB
_Z10gcode_M111v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M111_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_1
        MOVS     R1,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        STRB     R0,[R4, #+1]
??gcode_M111_1:
        LDR.N    R0,??gcode_M111_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M111_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+1]
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_2
        MOVS     R6,#+0
        MOV      R5,R6
??gcode_M111_3:
        CMP      R5,#+5
        BCS.N    ??gcode_M111_4
        LDRB     R0,[R4, #+1]
        MOVS     R1,#+1
        LSLS     R1,R1,R5
        TST      R0,R1
        BEQ.N    ??gcode_M111_5
        MOV      R0,R6
        ADDS     R6,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_6
        MOVS     R1,#+44
        LDR.N    R0,??gcode_M111_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M111_6:
        LDR.N    R0,??gcode_M111_0+0x10
        ADD      R0,R0,R5, LSL #+2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_5:
        ADDS     R5,R5,#+1
        B.N      ??gcode_M111_3
??gcode_M111_2:
        LDR.N    R0,??gcode_M111_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_4:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M111_0+0xC
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M111_0:
        DC32     mks_heating_busy
        DC32     echomagic
        DC32     _ZZ10gcode_M111vEs_4
        DC32     Serial3
        DC32     _ZZ10gcode_M111vE13debug_strings
        DC32     _ZZ10gcode_M111vEs_5
          CFI EndBlock cfiBlock296

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M113v
          CFI Block cfiBlock297 Using cfiCommon0
          CFI Function _Z10gcode_M113v
        THUMB
_Z10gcode_M113v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M113_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M113_1
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        STRB     R0,[R4, #+7]
        CMP      R0,#+61
        BLT.N    ??gcode_M113_2
        MOVS     R0,#+60
        STRB     R0,[R4, #+7]
        POP      {R4,PC}
??gcode_M113_1:
        LDR.N    R0,??gcode_M113_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R1,[R4, #+7]
        LDR.N    R0,??gcode_M113_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcm
        BL       _Z17serial_echopair_PPKcm
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M113_0+0xC
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M113_2:
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M113_0:
        DC32     axis_relative_modes
        DC32     echomagic
        DC32     _ZZ10gcode_M113vEs
        DC32     Serial3
          CFI EndBlock cfiBlock297

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M140v
          CFI Block cfiBlock298 Using cfiCommon0
          CFI Function _Z10gcode_M140v
        THUMB
_Z10gcode_M140v:
        LDR.N    R0,??gcode_M140_0
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M140_1
        BX       LR
??gcode_M140_1:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M140_2
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12setTargetBedEf
        B.W      _ZN11Temperature12setTargetBedEf
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M140_2:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M140_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock298

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M81v
          CFI Block cfiBlock299 Using cfiCommon0
          CFI Function _Z9gcode_M81v
        THUMB
_Z9gcode_M81v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        BL       _ZN7Stepper18finish_and_disableEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M81_0
        B.N      ??gcode_M81_1
??gcode_M81_2:
        MOVS     R0,#+0
        STR      R0,[R1, #+108]
        MOVS     R0,#+1
??gcode_M81_1:
        CMP      R0,#+0
        BEQ.N    ??gcode_M81_2
        MOV      R0,#+1000
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10safe_delaym
        B.W      _Z10safe_delaym
        Nop      
        DATA
??gcode_M81_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock299

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M82v
          CFI Block cfiBlock300 Using cfiCommon0
          CFI Function _Z9gcode_M82v
          CFI NoCalls
        THUMB
_Z9gcode_M82v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M82_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M82_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock300

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M83v
          CFI Block cfiBlock301 Using cfiCommon0
          CFI Function _Z9gcode_M83v
          CFI NoCalls
        THUMB
_Z9gcode_M83v:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M83_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M83_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock301

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z13gcode_M18_M84v
          CFI Block cfiBlock302 Using cfiCommon0
          CFI Function _Z13gcode_M18_M84v
        THUMB
_Z13gcode_M18_M84v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M18_M84_1
        STR      R0,[R1, #+100]
        POP      {R4-R6,PC}
??gcode_M18_M84_0:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M18_M84_3
??gcode_M18_M84_2:
        MOVS     R0,#+0
??gcode_M18_M84_3:
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        B.W      _ZN7Stepper18finish_and_disableEv
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M18_M84_4:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_5
        LDR.N    R0,??gcode_M18_M84_1+0x4
        LDRB     R0,[R0, #+260]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDR.N    R0,??gcode_M18_M84_1+0x8
        LDRH     R1,[R0, #+4]
        LDR.N    R0,??gcode_M18_M84_1+0xC
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1
        STRB     R0,[R1, #+4]
??gcode_M18_M84_5:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_6
        LDR.N    R0,??gcode_M18_M84_1+0x10
        LDRB     R0,[R0, #+1]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDR.N    R0,??gcode_M18_M84_1+0x8
        LDRH     R1,[R0, #+14]
        LDR.N    R0,??gcode_M18_M84_1+0xC
        LDR      R0,[R0, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1
        STRB     R0,[R1, #+5]
??gcode_M18_M84_6:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_7
        LDR.N    R4,??gcode_M18_M84_1+0x10
        LDRB     R0,[R4, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.N    R5,??gcode_M18_M84_1+0xC
        LDR.N    R6,??gcode_M18_M84_1+0x8
        SXTB     R2,R2
        LDRH     R1,[R6, #+24]
        LDR      R0,[R5, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R4, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+40]
        LDR      R0,[R5, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1
        STRB     R0,[R1, #+6]
??gcode_M18_M84_7:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_8
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.W      _Z18disable_e_steppersv
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M18_M84_8:
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??gcode_M18_M84_1:
        DC32     axis_homed
        DC32     mksCfg
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     mksCfg+0x104
          CFI EndBlock cfiBlock302

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M85v
          CFI Block cfiBlock303 Using cfiCommon0
          CFI Function _Z9gcode_M85v
        THUMB
_Z9gcode_M85v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M85_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M85_1
        STR      R0,[R1, #+96]
??gcode_M85_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M85_1:
        DC32     axis_homed
          CFI EndBlock cfiBlock303

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M92v
          CFI Block cfiBlock304 Using cfiCommon0
          CFI Function _Z9gcode_M92v
        THUMB
_Z9gcode_M92v:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOVS     R0,#+92
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M92_0
        MOVS     R4,#+0
        B.N      ??gcode_M92_1
??gcode_M92_2:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        STR      R0,[R7, R4, LSL #+2]
??gcode_M92_3:
        ADDS     R4,R4,#+1
??gcode_M92_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M92_4
        LDR.N    R0,??gcode_M92_5
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M92_3
        LDR.N    R7,??gcode_M92_5+0x4
        CMP      R4,#+3
        BNE.N    ??gcode_M92_2
        LDR.N    R6,??gcode_M92_5+0x8
        LDRSB    R0,[R6, #+5]
        ADDS     R0,R0,#+3
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        MOV      R5,R0
        LDRB     R6,[R6, #+5]
        ADD      R7,R7,R6, LSL #+2
        LDR.N    R1,??gcode_M92_5+0xC  ;; 0x41a00000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M92_6
        LDR      R0,[R7, #+12]
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR.W    R9,??gcode_M92_5+0x10
        LDR      R0,[R9, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R9, #+12]
        LDR.N    R0,??gcode_M92_5+0x14
        ADD      R9,R0,R6, LSL #+2
        LDR      R0,[R9, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R9, #+12]
        LDR.N    R0,??gcode_M92_5+0x18
        ADD      R6,R0,R6, LSL #+2
        LDR      R0,[R6, #+12]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        STR      R0,[R6, #+12]
??gcode_M92_6:
        STR      R5,[R7, #+12]
        B.N      ??gcode_M92_3
??gcode_M92_4:
        POP      {R0,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19refresh_positioningEv
        B.W      _ZN7Planner19refresh_positioningEv
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M92_0:
        POP      {R0,R4-R9,PC}    ;; return
        DATA
??gcode_M92_5:
        DC32     axis_codes
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     mks_heating_busy
        DC32     0x41a00000
        DC32     _ZN7Planner8max_jerkE
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     _ZN7Planner29max_acceleration_steps_per_s2E
          CFI EndBlock cfiBlock304

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M114v
          CFI Block cfiBlock305 Using cfiCommon0
          CFI Function _Z10gcode_M114v
        THUMB
_Z10gcode_M114v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
          CFI EndBlock cfiBlock305

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M115v
          CFI Block cfiBlock306 Using cfiCommon0
          CFI Function _Z10gcode_M115v
        THUMB
_Z10gcode_M115v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M115_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x4
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x8
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0xC
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x10
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x14
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x18
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x1C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x20
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x24
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x28
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x2C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x30
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x34
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x38
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z8cap_linePKcb
        B.W      _Z8cap_linePKcb
        DATA
??gcode_M115_0:
        DC32     _ZZ10gcode_M115vEs
        DC32     _ZZ10gcode_M115vEs_0
        DC32     _ZZ10gcode_M115vEs_1
        DC32     _ZZ10gcode_M115vEs_2
        DC32     _ZZ10gcode_M115vEs_3
        DC32     _ZZ10gcode_M115vEs_4
        DC32     _ZZ10gcode_M115vEs_5
        DC32     _ZZ10gcode_M115vEs_6
        DC32     _ZZ10gcode_M115vEs_7
        DC32     _ZZ10gcode_M115vEs_8
        DC32     _ZZ10gcode_M115vEs_9
        DC32     _ZZ10gcode_M115vEs__10_
        DC32     _ZZ10gcode_M115vEs__11_
        DC32     _ZZ10gcode_M115vEs__12_
        DC32     _ZZ10gcode_M115vEs__13_
          CFI EndBlock cfiBlock306

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M117v
          CFI Block cfiBlock307 Using cfiCommon0
          CFI Function _Z10gcode_M117v
        THUMB
_Z10gcode_M117v:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M117_0
        LDR      R0,[R0, #+0]
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
        Nop      
        DATA
??gcode_M117_0:
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock307

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M118v
          CFI Block cfiBlock308 Using cfiCommon0
          CFI Function _Z10gcode_M118v
        THUMB
_Z10gcode_M118v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_0
        LDR.N    R0,??gcode_M118_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_0:
        MOVS     R0,#+65
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_2
        LDR.N    R0,??gcode_M118_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_2:
        LDR.N    R4,??gcode_M118_1+0x8
        LDR.N    R0,??gcode_M118_1+0xC
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M118_1:
        DC32     echomagic
        DC32     _ZZ10gcode_M118vEs
        DC32     Serial3
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock308

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M119v
          CFI Block cfiBlock309 Using cfiCommon0
          CFI Function _Z10gcode_M119v
          CFI FunCall _ZN8Endstops4M119Ev
        THUMB
_Z10gcode_M119v:
        B.W      _ZN8Endstops4M119Ev
          CFI EndBlock cfiBlock309

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M120v
          CFI Block cfiBlock310 Using cfiCommon0
          CFI Function _Z10gcode_M120v
        THUMB
_Z10gcode_M120v:
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock310

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M121v
          CFI Block cfiBlock311 Using cfiCommon0
          CFI Function _Z10gcode_M121v
        THUMB
_Z10gcode_M121v:
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock311

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M200v
          CFI Block cfiBlock312 Using cfiCommon0
          CFI Function _Z10gcode_M200v
        THUMB
_Z10gcode_M200v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOVS     R0,#+200
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M200_0
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
        LDR.N    R4,??gcode_M200_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M200_3
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
        B.N      ??gcode_M200_4
??gcode_M200_3:
        MOV      R0,R1
        STRB     R0,[R4, #+0]
??gcode_M200_4:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        LDR.N    R0,??gcode_M200_2+0x4
        LDRB     R0,[R0, #+5]
          CFI FunCall _ZN7Planner17set_filament_sizeEhRKf
        BL       _ZN7Planner17set_filament_sizeEhRKf
??gcode_M200_1:
          CFI FunCall _ZN7Planner32calculate_volumetric_multipliersEv
        BL       _ZN7Planner32calculate_volumetric_multipliersEv
??gcode_M200_0:
        POP      {R0,R1,R4,PC}    ;; return
        DATA
??gcode_M200_2:
        DC32     _ZN11GCodeParser18volumetric_enabledE
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock312

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M201v
          CFI Block cfiBlock313 Using cfiCommon0
          CFI Function _Z10gcode_M201v
        THUMB
_Z10gcode_M201v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+201
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M201_0
        MOVS     R4,#+0
        B.N      ??gcode_M201_1
??gcode_M201_2:
        MOVS     R0,#+0
??gcode_M201_3:
        ADDS     R5,R0,R4
        UXTB     R5,R5
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        LDR.N    R1,??gcode_M201_4
        STR      R0,[R1, R5, LSL #+2]
??gcode_M201_5:
        ADDS     R4,R4,#+1
??gcode_M201_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M201_6
        LDR.N    R0,??gcode_M201_4+0x4
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M201_5
        CMP      R4,#+3
        BNE.N    ??gcode_M201_2
        LDR.N    R0,??gcode_M201_4+0x8
        LDRB     R0,[R0, #+5]
        B.N      ??gcode_M201_3
??gcode_M201_6:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner24reset_acceleration_ratesEv
        B.W      _ZN7Planner24reset_acceleration_ratesEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M201_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M201_4:
        DC32     _ZN7Planner26max_acceleration_mm_per_s2E
        DC32     axis_codes
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock313

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M203v
          CFI Block cfiBlock314 Using cfiCommon0
          CFI Function _Z10gcode_M203v
        THUMB
_Z10gcode_M203v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+203
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M203_0
        MOVS     R4,#+0
        B.N      ??gcode_M203_1
??gcode_M203_2:
        MOVS     R0,#+0
??gcode_M203_3:
        ADDS     R5,R0,R4
        UXTB     R5,R5
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDR.N    R1,??gcode_M203_4
        STR      R0,[R1, R5, LSL #+2]
??gcode_M203_5:
        ADDS     R4,R4,#+1
??gcode_M203_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M203_0
        LDR.N    R0,??gcode_M203_4+0x4
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M203_5
        CMP      R4,#+3
        BNE.N    ??gcode_M203_2
        LDR.N    R0,??gcode_M203_4+0x8
        LDRB     R0,[R0, #+5]
        B.N      ??gcode_M203_3
??gcode_M203_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M203_4:
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     axis_codes
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock314

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M204v
          CFI Block cfiBlock315 Using cfiCommon0
          CFI Function _Z10gcode_M204v
        THUMB
_Z10gcode_M204v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M204_1+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_0:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x10
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_2:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1+0x14
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_3:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x1C
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M204_4:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M204_1:
        DC32     _ZN7Planner12accelerationE
        DC32     _ZN7Planner19travel_accelerationE
        DC32     _ZZ10gcode_M204vEs
        DC32     Serial3
        DC32     _ZZ10gcode_M204vEs_0
        DC32     _ZN7Planner20retract_accelerationE
        DC32     _ZZ10gcode_M204vEs_1
        DC32     _ZZ10gcode_M204vEs_2
          CFI EndBlock cfiBlock315

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M205v
          CFI Block cfiBlock316 Using cfiCommon0
          CFI Function _Z10gcode_M205v
        THUMB
_Z10gcode_M205v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1
        STR      R0,[R1, #+0]
??gcode_M205_0:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0x4
        STR      R0,[R1, #+0]
??gcode_M205_2:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_3
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        BL       _ZN11GCodeParser11value_ulongEv
        LDR.N    R1,??gcode_M205_1+0x8
        STR      R0,[R1, #+0]
??gcode_M205_3:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+0]
??gcode_M205_4:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_5
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+4]
??gcode_M205_5:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_6
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+8]
??gcode_M205_6:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_7
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+12]
??gcode_M205_7:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M205_1:
        DC32     _ZN7Planner17min_feedrate_mm_sE
        DC32     _ZN7Planner24min_travel_feedrate_mm_sE
        DC32     _ZN7Planner19min_segment_time_usE
        DC32     _ZN7Planner8max_jerkE
          CFI EndBlock cfiBlock316

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M206v
          CFI Block cfiBlock317 Using cfiCommon0
          CFI Function _Z10gcode_M206v
        THUMB
_Z10gcode_M206v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M206_0
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M206_1
        MOVS     R5,#+0
        B.N      ??gcode_M206_2
??gcode_M206_3:
        LDR.N    R0,??gcode_M206_0+0x4
        LDRSB    R0,[R5, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R1,R0
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_4:
        ADDS     R5,R5,#+1
??gcode_M206_2:
        CMP      R5,#+3
        BLT.N    ??gcode_M206_3
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        BNE.N    ??gcode_M206_5
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_6
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R1,R0
        MOVS     R0,#+0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_6:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_5
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R1,R0
        MOVS     R0,#+1
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_5:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M206_1:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M206_0:
        DC32     mksCfg
        DC32     axis_codes
          CFI EndBlock cfiBlock317

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M665v
          CFI Block cfiBlock318 Using cfiCommon0
          CFI Function _Z10gcode_M665v
        THUMB
_Z10gcode_M665v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+72
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M665_1
        STR      R0,[R1, #+120]
??gcode_M665_0:
        LDR.N    R4,??gcode_M665_1+0x4
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[R4, #+108]
??gcode_M665_2:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[R4, #+104]
??gcode_M665_3:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+116]
??gcode_M665_4:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_5
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+112]
??gcode_M665_5:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_6
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+48]
??gcode_M665_6:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_7
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+52]
??gcode_M665_7:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_8
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+56]
??gcode_M665_8:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z21recalc_delta_settingsv
        B.W      _Z21recalc_delta_settingsv
        Nop      
        DATA
??gcode_M665_1:
        DC32     mks_heating_busy
        DC32     axis_homed
          CFI EndBlock cfiBlock318

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M666v
          CFI Block cfiBlock319 Using cfiCommon0
          CFI Function _Z10gcode_M666v
        THUMB
_Z10gcode_M666v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        B.N      ??gcode_M666_0
??gcode_M666_1:
        LDR.N    R0,??gcode_M666_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M666_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R5,R0
        LDR.N    R0,??gcode_M666_2+0x4
        LDRSB    R0,[R0, #+7]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BHI.N    ??gcode_M666_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M666_2+0x8
        ADD      R1,R1,R4, LSL #+2
        STR      R0,[R1, #+4]
??gcode_M666_3:
        ADDS     R4,R4,#+1
??gcode_M666_0:
        CMP      R4,#+3
        BLT.N    ??gcode_M666_1
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M666_2:
        DC32     axis_codes
        DC32     mksCfg
        DC32     z_endstop_adj
          CFI EndBlock cfiBlock319

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15gcode_M666_dualv
          CFI Block cfiBlock320 Using cfiCommon0
          CFI Function _Z15gcode_M666_dualv
        THUMB
_Z15gcode_M666_dualv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M666_dual_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M666_dual_0+0x4
        LDRB     R0,[R0, #+258]
        CMP      R0,#+1
        BNE.N    ??gcode_M666_dual_1
        LDR.N    R4,??gcode_M666_dual_0+0x8
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M666_dual_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[R4, #+0]
??gcode_M666_dual_2:
        LDR      R1,[R4, #+0]
        LDR.N    R0,??gcode_M666_dual_0+0xC
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
??gcode_M666_dual_1:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M666_dual_0+0x10
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        DATA
??gcode_M666_dual_0:
        DC32     _ZZ15gcode_M666_dualvEs
        DC32     mksCfg
        DC32     z_endstop_adj
        DC32     _ZZ15gcode_M666_dualvEs_0
        DC32     Serial3
          CFI EndBlock cfiBlock320

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M211v
          CFI Block cfiBlock321 Using cfiCommon0
          CFI Function _Z10gcode_M211v
        THUMB
_Z10gcode_M211v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.N    R0,??gcode_M211_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M211_0+0x4
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_1
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        STRB     R0,[R4, #+8]
??gcode_M211_1:
        LDR.N    R0,??gcode_M211_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+8]
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_2
        LDR.N    R0,??gcode_M211_0+0xC
        B.N      ??gcode_M211_3
??gcode_M211_2:
        LDR.N    R0,??gcode_M211_0+0x10
??gcode_M211_3:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M211_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??gcode_M211_0+0x18
        LDR.N    R6,??gcode_M211_0+0x1C
        LDR      R1,[R6, #+68]
        LDR      R0,[R6, #+56]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R7,??gcode_M211_0+0x20
        LDR      R1,[R6, #+72]
        LDR      R0,[R6, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.W    R8,??gcode_M211_0+0x24
        LDR      R1,[R6, #+76]
        LDR      R0,[R6, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M211_0+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R1,[R4, #+36]
        LDR      R0,[R6, #+56]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R4, #+40]
        LDR      R0,[R6, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R4, #+44]
        LDR      R0,[R6, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M211_0+0x2C
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        DATA
??gcode_M211_0:
        DC32     echomagic
        DC32     axis_homed
        DC32     _ZZ10gcode_M211vEs
        DC32     _ZZ10gcode_M211vEs_0
        DC32     _ZZ10gcode_M211vEs_1
        DC32     _ZZ10gcode_M211vEs_2
        DC32     _ZZ10gcode_M211vEs_3
        DC32     mks_heating_busy
        DC32     _ZZ10gcode_M211vEs_4
        DC32     _ZZ10gcode_M211vEs_5
        DC32     _ZZ10gcode_M211vEs_6
        DC32     Serial3
          CFI EndBlock cfiBlock321

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M218v
          CFI Block cfiBlock322 Using cfiCommon0
          CFI Function _Z10gcode_M218v
        THUMB
_Z10gcode_M218v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOVS     R0,#+218
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M218_0
        LDR.N    R4,??gcode_M218_1
        LDRB     R0,[R4, #+5]
        CMP      R0,#+0
        BEQ.N    ??gcode_M218_0
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M218_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDRB     R1,[R4, #+5]
        LDR.N    R2,??gcode_M218_1+0x4
        STR      R0,[R2, R1, LSL #+2]
??gcode_M218_2:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M218_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDRB     R1,[R4, #+5]
        LDR.N    R2,??gcode_M218_1+0x4
        ADD      R1,R2,R1, LSL #+2
        STR      R0,[R1, #+8]
??gcode_M218_3:
        LDR.N    R0,??gcode_M218_1+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M218_1+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M218_1+0x10
        LDR.N    R6,??gcode_M218_1+0x4
        B.N      ??gcode_M218_4
??gcode_M218_5:
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R6, R4, LSL #+2]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+44
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        ADD      R0,R6,R4, LSL #+2
        LDR      R0,[R0, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADDS     R4,R4,#+1
        SXTB     R4,R4
??gcode_M218_4:
        LDR.N    R0,??gcode_M218_1+0x14
        LDRB     R0,[R0, #+247]
        CMP      R4,R0
        BLT.N    ??gcode_M218_5
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M218_0:
        POP      {R0,R1,R4-R6,PC}  ;; return
        Nop      
        DATA
??gcode_M218_1:
        DC32     mks_heating_busy
        DC32     hotend_offset
        DC32     echomagic
        DC32     _ZZ10gcode_M218vEs
        DC32     Serial3
        DC32     mksCfg
          CFI EndBlock cfiBlock322

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M220v
          CFI Block cfiBlock323 Using cfiCommon0
          CFI Function _Z10gcode_M220v
        THUMB
_Z10gcode_M220v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M220_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M220_1
        STRH     R0,[R1, #+6]
??gcode_M220_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M220_1:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock323

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M221v
          CFI Block cfiBlock324 Using cfiCommon0
          CFI Function _Z10gcode_M221v
        THUMB
_Z10gcode_M221v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+221
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M221_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M221_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M221_1
        LDRB     R1,[R1, #+5]
        LDR.N    R2,??gcode_M221_1+0x4
        STRH     R0,[R2, R1, LSL #+1]
        MOV      R0,R1
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner16refresh_e_factorEh
        B.W      _ZN7Planner16refresh_e_factorEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M221_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M221_1:
        DC32     mks_heating_busy
        DC32     _ZN7Planner15flow_percentageE
          CFI EndBlock cfiBlock324

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M226v
          CFI Block cfiBlock325 Using cfiCommon0
          CFI Function _Z10gcode_M226v
        THUMB
_Z10gcode_M226v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M226_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        ADDS     R0,R5,#+1
        CMP      R0,#+3
        BCS.N    ??gcode_M226_0
        CMP      R4,#+0
        BMI.N    ??gcode_M226_0
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BNE.N    ??gcode_M226_0
        MOVS     R6,#+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        CMP      R5,#+1
        BEQ.N    ??gcode_M226_1
        CMP      R5,#-1
        BEQ.N    ??gcode_M226_2
        B.N      ??gcode_M226_3
??gcode_M226_1:
        MOVS     R6,#+1
        B.N      ??gcode_M226_3
??gcode_M226_2:
        CMP      R4,#+0
        BPL.N    ??gcode_M226_3
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        MOV      R6,R0
        B.N      ??gcode_M226_3
??gcode_M226_5:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??gcode_M226_3:
        CMP      R4,#+0
        BMI.N    ??gcode_M226_6
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        B.N      ??gcode_M226_7
??gcode_M226_6:
        MOV      R0,R6
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
??gcode_M226_7:
        CMP      R0,#+0
        BNE.N    ??gcode_M226_5
??gcode_M226_0:
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M226_4:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock325

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M280v
          CFI Block cfiBlock326 Using cfiCommon0
          CFI Function _Z10gcode_M280v
        THUMB
_Z10gcode_M280v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M280_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOVS     R4,R0
        BNE.N    ??gcode_M280_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M280_2
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        CMP      R0,#+10
        BEQ.N    ??gcode_M280_3
        CMP      R0,#+60
        BEQ.N    ??gcode_M280_4
        CMP      R0,#+90
        BEQ.N    ??gcode_M280_5
        CMP      R0,#+120
        BEQ.N    ??gcode_M280_6
        B.N      ??gcode_M280_7
??gcode_M280_3:
        MOV      R0,#+350
        B.N      ??gcode_M280_8
??gcode_M280_5:
        MOVW     R0,#+750
        B.N      ??gcode_M280_8
??gcode_M280_6:
        MOV      R0,#+900
        B.N      ??gcode_M280_8
??gcode_M280_4:
        MOV      R0,#+600
        B.N      ??gcode_M280_8
??gcode_M280_7:
        MOVW     R0,#+1100
??gcode_M280_8:
        LDR.N    R1,??gcode_M280_9  ;; 0x40012c34
        STR      R0,[R1, #+0]
        POP      {R4,PC}
??gcode_M280_2:
        LDR.N    R0,??gcode_M280_9+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M280_9+0x8
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M280_9+0xC
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M280_1:
        LDR.N    R0,??gcode_M280_9+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R1,R4
        LDR.N    R0,??gcode_M280_9+0x14
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M280_9+0xC
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M280_0:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M280_9:
        DC32     0x40012c34
        DC32     echomagic
        DC32     _ZZ10gcode_M280vEs
        DC32     _ZZ10gcode_M280vEs_0
        DC32     errormagic
        DC32     _ZZ10gcode_M280vEs_1
          CFI EndBlock cfiBlock326

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M301v
          CFI Block cfiBlock327 Using cfiCommon0
          CFI Function _Z10gcode_M301v
        THUMB
_Z10gcode_M301v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+2
        BGE.N    ??gcode_M301_0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_1
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??gcode_M301_2
        STR      R0,[R1, #+0]
??gcode_M301_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M301_2+0xC
        STR      R0,[R1, #+0]
??gcode_M301_3:
        LDR.N    R4,??gcode_M301_2+0x10
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M301_4:
          CFI FunCall _ZN11Temperature9updatePIDEv
        BL       _ZN11Temperature9updatePIDEv
        LDR.N    R0,??gcode_M301_2+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M301_2
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M301_2+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M301_2+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M301_2+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M301_2+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_2+0x24
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M301_0:
        LDR.N    R0,??gcode_M301_2+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M301_2+0x24
        LDR.N    R1,??gcode_M301_2+0x2C
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M301_2:
        DC32     _ZN11Temperature2KpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature2KiE
        DC32     _ZN11Temperature2KdE
        DC32     echomagic
        DC32     _ZZ10gcode_M301vEs
        DC32     _ZZ10gcode_M301vEs_0
        DC32     _ZZ10gcode_M301vEs_1
        DC32     Serial3
        DC32     errormagic
        DC32     _ZZ10gcode_M301vEs_2
          CFI EndBlock cfiBlock327

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M304v
          CFI Block cfiBlock328 Using cfiCommon0
          CFI Function _Z10gcode_M304v
        THUMB
_Z10gcode_M304v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_0
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??gcode_M304_1
        STR      R0,[R1, #+0]
??gcode_M304_0:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_2
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M304_1+0xC
        STR      R0,[R1, #+0]
??gcode_M304_2:
        LDR.N    R4,??gcode_M304_1+0x10
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M304_3:
        LDR.N    R0,??gcode_M304_1+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M304_1
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M304_1+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M304_1+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M304_1+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M304_1+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M304_1+0x24
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M304_1:
        DC32     _ZN11Temperature5bedKpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature5bedKiE
        DC32     _ZN11Temperature5bedKdE
        DC32     echomagic
        DC32     _ZZ10gcode_M304vEs
        DC32     _ZZ10gcode_M304vEs_0
        DC32     _ZZ10gcode_M304vEs_1
        DC32     Serial3
          CFI EndBlock cfiBlock328

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M302v
          CFI Block cfiBlock329 Using cfiCommon0
          CFI Function _Z10gcode_M302v
        THUMB
_Z10gcode_M302v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R4,R0
        BEQ.N    ??gcode_M302_0
        LDR.N    R5,??gcode_M302_1
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRH     R0,[R5, #+0]
        LDRSH    R0,[R5, #+0]
        SUBS     R1,R0,#+1
        SBCS     R1,R1,R1
        LSRS     R1,R1,#+31
        LDR.N    R0,??gcode_M302_1+0x4
        STRB     R1,[R0, #+0]
??gcode_M302_0:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_2
        LDR.N    R4,??gcode_M302_1+0x4
        LDR.N    R0,??gcode_M302_1
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_3
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        STRB     R0,[R4, #+0]
        POP      {R0,R4,R5,PC}
??gcode_M302_3:
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
        POP      {R0,R4,R5,PC}
??gcode_M302_2:
        CMP      R4,#+0
        BNE.N    ??gcode_M302_4
        LDR.N    R0,??gcode_M302_1+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M302_1+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_5
        LDR.N    R1,??gcode_M302_1+0xC
        B.N      ??gcode_M302_6
??gcode_M302_5:
        LDR.N    R1,??gcode_M302_1+0x10
??gcode_M302_6:
        LDR.N    R0,??gcode_M302_1+0x14
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.N    R0,??gcode_M302_1
        LDRSH    R1,[R0, #+0]
        LDR.N    R0,??gcode_M302_1+0x18
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M302_1+0x1C
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M302_4:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M302_1:
        DC32     _ZN11Temperature16extrude_min_tempE
        DC32     _ZN11Temperature18allow_cold_extrudeE
        DC32     echomagic
        DC32     _ZZ10gcode_M302vEs_0
        DC32     _ZZ10gcode_M302vEs_1
        DC32     _ZZ10gcode_M302vEs
        DC32     _ZZ10gcode_M302vEs_2
        DC32     _ZZ10gcode_M302vEs_3
          CFI EndBlock cfiBlock329

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M303v
          CFI Block cfiBlock330 Using cfiCommon0
          CFI Function _Z10gcode_M303v
        THUMB
_Z10gcode_M303v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R0,??gcode_M303_0
        LDRB     R1,[R0, #+52]
        CMP      R1,#+0
        BNE.N    ??gcode_M303_1
        LDRB     R0,[R0, #+53]
        CMP      R0,#+0
        BEQ.N    ??gcode_M303_2
??gcode_M303_1:
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R4,R0
        MOVS     R1,#+5
        MOVS     R0,#+67
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        MOVS     R0,#+85
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R6,R0
        CMP      R4,#+0
        BPL.N    ??gcode_M303_3
        MOVS     R0,#+70
        B.N      ??gcode_M303_4
??gcode_M303_3:
        MOVS     R0,#+150
??gcode_M303_4:
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser10celsiusvalEcf
        BL       _ZN11GCodeParser10celsiusvalEcf
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        CMP      R4,#+2
        BCS.N    ??gcode_M303_5
        LDR.N    R1,??gcode_M303_0+0x4
        STRB     R4,[R1, #+5]
??gcode_M303_5:
        MOV      R2,R5
        SXTB     R2,R2
        MOV      R1,R4
        SXTB     R1,R1
        MOV      R4,R1
        MOV      R5,R2
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R3,R6
        MOV      R2,R5
        MOV      R1,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12PID_autotuneEfaab
        B.W      _ZN11Temperature12PID_autotuneEfaab
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M303_2:
        LDR.N    R0,??gcode_M303_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M303_0+0xC
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M303_0:
        DC32     mksCfg
        DC32     mks_heating_busy
        DC32     errormagic
        DC32     _ZZ10gcode_M303vEs
          CFI EndBlock cfiBlock330

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M360v
          CFI Block cfiBlock331 Using cfiCommon0
          CFI Function _Z10gcode_M360v
        THUMB
_Z10gcode_M360v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M360_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+120
        MOVS     R0,#+0
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M360_0:
        DC32     _ZZ10gcode_M360vEs
          CFI EndBlock cfiBlock331

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M361v
          CFI Block cfiBlock332 Using cfiCommon0
          CFI Function _Z10gcode_M361v
        THUMB
_Z10gcode_M361v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M361_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+130
        MOVS     R0,#+90
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M361_0:
        DC32     _ZZ10gcode_M361vEs
          CFI EndBlock cfiBlock332

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M362v
          CFI Block cfiBlock333 Using cfiCommon0
          CFI Function _Z10gcode_M362v
        THUMB
_Z10gcode_M362v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M362_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+180
        MOVS     R0,#+60
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M362_0:
        DC32     _ZZ10gcode_M362vEs
          CFI EndBlock cfiBlock333

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M363v
          CFI Block cfiBlock334 Using cfiCommon0
          CFI Function _Z10gcode_M363v
        THUMB
_Z10gcode_M363v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M363_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+90
        MOVS     R0,#+50
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M363_0:
        DC32     _ZZ10gcode_M363vEs
          CFI EndBlock cfiBlock334

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M364v
          CFI Block cfiBlock335 Using cfiCommon0
          CFI Function _Z10gcode_M364v
        THUMB
_Z10gcode_M364v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M364_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+135
        MOVS     R0,#+45
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M364_0:
        DC32     _ZZ10gcode_M364vEs
          CFI EndBlock cfiBlock335

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M400v
          CFI Block cfiBlock336 Using cfiCommon0
          CFI Function _Z10gcode_M400v
          CFI FunCall _ZN7Stepper11synchronizeEv
        THUMB
_Z10gcode_M400v:
        B.W      _ZN7Stepper11synchronizeEv
          CFI EndBlock cfiBlock336

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M401v
          CFI Block cfiBlock337 Using cfiCommon0
          CFI Function _Z10gcode_M401v
        THUMB
_Z10gcode_M401v:
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI EndBlock cfiBlock337

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M402v
          CFI Block cfiBlock338 Using cfiCommon0
          CFI Function _Z10gcode_M402v
        THUMB
_Z10gcode_M402v:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI EndBlock cfiBlock338

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M420v
          CFI Block cfiBlock339 Using cfiCommon0
          CFI Function _Z10gcode_M420v
        THUMB
_Z10gcode_M420v:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        LDR.N    R4,??gcode_M420_0
        LDR      R0,[R4, #+8]
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+12]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+16]
        STR      R0,[SP, #+12]
        LDR.N    R6,??gcode_M420_0+0x4
        LDRB     R0,[R6, #+64]
        CMP      R0,#+16
        BNE.N    ??gcode_M420_1
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_2
          CFI FunCall _ZN11GCodeParser9has_valueEv
        BL       _ZN11GCodeParser9has_valueEv
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_3
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R5,R0
        B.N      ??gcode_M420_4
??gcode_M420_3:
        LDR.N    R0,??gcode_M420_0+0x8
        LDRSB    R5,[R0, #+0]
??gcode_M420_4:
          CFI FunCall _ZN14MarlinSettings15calc_num_meshesEv
        BL       _ZN14MarlinSettings15calc_num_meshesEv
        SXTH     R0,R0
        CMP      R0,#+0
        BNE.N    ??gcode_M420_5
        LDR.N    R0,??gcode_M420_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M420_6
??gcode_M420_5:
        SUBS     R7,R0,#+1
        SXTB     R5,R5
        MOVS     R0,R5
        BMI.N    ??gcode_M420_7
        CMP      R7,R0
        BGE.N    ??gcode_M420_8
??gcode_M420_7:
        LDR.N    R0,??gcode_M420_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R1,R7
        LDR.N    R0,??gcode_M420_0+0x14
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x18
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??gcode_M420_6
??gcode_M420_8:
        MOVS     R1,#+0
          CFI FunCall _ZN14MarlinSettings9load_meshEaPv
        BL       _ZN14MarlinSettings9load_meshEaPv
        LDR.N    R0,??gcode_M420_0+0x8
        STRB     R5,[R0, #+0]
??gcode_M420_2:
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M420_9
        MOVS     R0,#+86
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_1
??gcode_M420_9:
        MOVS     R0,#+0
          CFI FunCall _ZN20unified_bed_leveling11display_mapEi
        BL       _ZN20unified_bed_leveling11display_mapEi
        ADD      R0,R4,#+132
          CFI FunCall _ZN20unified_bed_leveling13mesh_is_validEv
        BL       _ZN20unified_bed_leveling13mesh_is_validEv
        MOV      R1,R0
        LDR.N    R0,??gcode_M420_0+0x1C
          CFI FunCall _Z17serial_echopair_PPKcb
        BL       _Z17serial_echopair_PPKcb
        LDR.N    R5,??gcode_M420_0+0x18
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R0,??gcode_M420_0+0x8
        LDRSB    R1,[R0, #+0]
        LDR.N    R0,??gcode_M420_0+0x20
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M420_1:
        MOVS     R0,#+86
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_10
        LDRB     R5,[R6, #+64]
        MOVS     R0,#+6
        TST      R5,R0
        BEQ.N    ??gcode_M420_11
        LDR.N    R1,??gcode_M420_0+0x24
        LDR.N    R0,??gcode_M420_0+0x28
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
        B.N      ??gcode_M420_10
??gcode_M420_11:
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_10
        CMP      R5,#+8
        BNE.N    ??gcode_M420_12
          CFI FunCall _Z28print_bilinear_leveling_gridv
        BL       _Z28print_bilinear_leveling_gridv
        B.N      ??gcode_M420_10
??gcode_M420_12:
        CMP      R5,#+32
        BNE.N    ??gcode_M420_10
        LDR.N    R0,??gcode_M420_0+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
??gcode_M420_10:
        LDRSH    R0,[R6, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M420_13
        LDRB     R0,[R6, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_M420_13
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_13
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+0
          CFI FunCall _Z17set_z_fade_heightfb
        BL       _Z17set_z_fade_heightfb
??gcode_M420_13:
        MOVS     R5,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_14
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        MOV      R5,R0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_M420_14:
        LDR.N    R0,??gcode_M420_0+0x30
        LDRB     R6,[R0, #+0]
        EOR      R0,R6,#0x1
        MOV      R1,R5
        TST      R1,R0
        BEQ.N    ??gcode_M420_15
        LDR.N    R0,??gcode_M420_0+0x34
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x38
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M420_15:
        LDR.N    R7,??gcode_M420_0+0x3C
        MOV      R0,R7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R6,#+0
        BEQ.N    ??gcode_M420_16
        LDR.N    R1,??gcode_M420_0+0x40
        B.N      ??gcode_M420_17
??gcode_M420_16:
        LDR.N    R1,??gcode_M420_0+0x44
??gcode_M420_17:
        LDR.N    R0,??gcode_M420_0+0x48
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.N    R5,??gcode_M420_0+0x18
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOV      R0,R7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x4C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x50
        LDR      R0,[R0, #+0]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_M420_18
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??gcode_M420_19
??gcode_M420_18:
        LDR.N    R0,??gcode_M420_0+0x54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M420_19:
        MOVS     R2,#+12
        ADD      R1,R4,#+8
        ADD      R0,SP,#+4
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_6
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_M420_6:
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        Nop      
        DATA
??gcode_M420_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling12storage_slotE
        DC32     _ZZ10gcode_M420vEs
        DC32     _ZZ10gcode_M420vEs_0
        DC32     _ZZ10gcode_M420vEs_1
        DC32     Serial3
        DC32     _ZZ10gcode_M420vEs_2
        DC32     _ZZ10gcode_M420vEs_3
        DC32     _ZZ10gcode_M420vEs_4
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     _ZZ10gcode_M420vEs_5
        DC32     _ZN7Planner15leveling_activeE
        DC32     errormagic
        DC32     _ZZ10gcode_M420vEs_6
        DC32     echomagic
        DC32     _ZZ10gcode_M420vEs_8
        DC32     _ZZ10gcode_M420vEs_9
        DC32     _ZZ10gcode_M420vEs_7
        DC32     _ZZ10gcode_M420vEs__10_
        DC32     _ZN7Planner13z_fade_heightE
        DC32     _ZZ10gcode_M420vEs__11_
          CFI EndBlock cfiBlock339

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28gcode_M421_MESH_BED_LEVELINGv
          CFI Block cfiBlock340 Using cfiCommon0
          CFI Function _Z28gcode_M421_MESH_BED_LEVELINGv
        THUMB
_Z28gcode_M421_MESH_BED_LEVELINGv:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R4,R0
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R5,R0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R6,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_1
??gcode_M421_MESH_BED_LEVELING_0:
        CMP      R4,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_xERKf
        BL       _ZN17mesh_bed_leveling13probe_index_xERKf
        MOV      R6,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_1
??gcode_M421_MESH_BED_LEVELING_2:
        MOV      R6,#-1
??gcode_M421_MESH_BED_LEVELING_1:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R7,R0
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R8,R0
        CMP      R8,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_3
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R9,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_4
??gcode_M421_MESH_BED_LEVELING_3:
        CMP      R7,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_5
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_yERKf
        BL       _ZN17mesh_bed_leveling13probe_index_yERKf
        MOV      R9,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_4
??gcode_M421_MESH_BED_LEVELING_5:
        MOV      R9,#-1
??gcode_M421_MESH_BED_LEVELING_4:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R11,R0
        CMP      R11,#+0
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_6
        MOVS     R0,#+81
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R10,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_7
??gcode_M421_MESH_BED_LEVELING_6:
        MOV      R10,#+0
??gcode_M421_MESH_BED_LEVELING_7:
        AND      R0,R8,R5
        AND      R1,R7,R4
        ADDS     R0,R1,R0
        CMP      R0,#+1
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_8
        ORRS     R0,R10,R11
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_9
??gcode_M421_MESH_BED_LEVELING_8:
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M421_MESH_BED_LEVELING_11
??gcode_M421_MESH_BED_LEVELING_9:
        SXTB     R6,R6
        MOVS     R4,R6
        BMI.N    ??gcode_M421_MESH_BED_LEVELING_12
        SXTB     R9,R9
        MOV      R5,R9
        CMP      R5,#+0
        BPL.N    ??gcode_M421_MESH_BED_LEVELING_13
??gcode_M421_MESH_BED_LEVELING_12:
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M421_MESH_BED_LEVELING_11
??gcode_M421_MESH_BED_LEVELING_13:
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        CMP      R10,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_14
        ADD      R1,R4,R4, LSL #+1
        LDR.N    R2,??gcode_M421_MESH_BED_LEVELING_10+0xC
        ADD      R1,R2,R1, LSL #+4
        LDR      R1,[R1, R5, LSL #+2]
        B.N      ??gcode_M421_MESH_BED_LEVELING_15
??gcode_M421_MESH_BED_LEVELING_14:
        MOVS     R1,#+0
??gcode_M421_MESH_BED_LEVELING_15:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+0]
        ADD      R2,SP,#+0
        MOV      R1,R9
        MOV      R0,R6
          CFI FunCall _ZN17mesh_bed_leveling5set_zEaaRKf
        BL       _ZN17mesh_bed_leveling5set_zEaaRKf
??gcode_M421_MESH_BED_LEVELING_11:
        POP      {R0,R4-R11,PC}   ;; return
        DATA
??gcode_M421_MESH_BED_LEVELING_10:
        DC32     errormagic
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        DC32     _ZN17mesh_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock340

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
          CFI Block cfiBlock341 Using cfiCommon0
          CFI Function _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        THUMB
_Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R1,#-1
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R6,R0
        SXTB     R6,R6
        MOV      R1,#-1
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R4,R0
        SXTB     R4,R4
        MOV      R7,R6
        MVNS     R7,R7
        MOV      R8,R4
        MVN      R8,R8
        LSR      R8,R8,#+31
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R9,R0
        CMP      R9,#+0
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0
        MOVS     R0,#+81
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R5,R0
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0:
        MOVS     R5,#+0
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1:
        AND      R0,R8,R7, LSR #+31
        ORR      R1,R5,R9
        TST      R0,R1
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x4
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2:
        CMP      R6,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x8
        LDRB     R1,[R0, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R6
        BLT.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
        CMP      R4,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
        LDRB     R0,[R0, #+97]
        SUBS     R0,R0,#+1
        CMP      R0,R4
        BGE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0xC
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5:
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        ADD      R1,R6,R6, LSL #+1
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x10
        ADD      R6,R2,R1, LSL #+4
        CMP      R5,#+0
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6
        LDR      R1,[R6, R4, LSL #+2]
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6:
        MOVS     R1,#+0
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, R4, LSL #+2]
        POP      {R0,R4-R9,PC}    ;; return
        DATA
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3:
        DC32     errormagic
        DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
        DC32     mksCfg
        DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
        DC32     z_values
          CFI EndBlock cfiBlock341

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
          CFI Block cfiBlock342 Using cfiCommon0
          CFI Function _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        THUMB
_Z32gcode_M421_AUTO_BED_LEVELING_UBLv:
        PUSH     {R0-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+48
        MOV      R1,#-1
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R10,R0
        SXTB     R10,R10
        MOV      R1,#-1
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        SXTB     R5,R5
        MOV      R6,R10
        MVNS     R6,R6
        MOV      R7,R5
        MVNS     R7,R7
        LSRS     R7,R7,#+31
        MOVS     R0,#+67
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R8,R0
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R9,R0
        CMP      R9,#+0
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_0
        MOVS     R0,#+81
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R4,R0
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_1
??gcode_M421_AUTO_BED_LEVELING_UBL_0:
        MOVS     R4,#+0
??gcode_M421_AUTO_BED_LEVELING_UBL_1:
        CMP      R8,#+0
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_2
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3
        MOVS     R1,#+0
        STR      R1,[SP, #+4]
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+12
        ADD      R2,R0,#+8
        MOVS     R1,#+1
        ADD      R0,SP,#+8
          CFI FunCall _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        BL       _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        LDRSB    R10,[SP, #+8]
        LDRSB    R5,[SP, #+9]
??gcode_M421_AUTO_BED_LEVELING_UBL_2:
        AND      R0,R7,R6, LSR #+31
        ADD      R0,R0,R8
        CMP      R0,#+1
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_4
        ORRS     R0,R4,R9
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_5
??gcode_M421_AUTO_BED_LEVELING_UBL_4:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x8
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M421_AUTO_BED_LEVELING_UBL_5:
        CMP      R10,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0xC
        LDRB     R1,[R0, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R10
        BLT.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
        CMP      R5,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
        LDRB     R0,[R0, #+97]
        SUBS     R0,R0,#+1
        CMP      R0,R5
        BGE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_7
??gcode_M421_AUTO_BED_LEVELING_UBL_6:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x10
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M421_AUTO_BED_LEVELING_UBL_7:
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        ADD      R1,R10,R10, LSL #+1
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x14
        ADD      R6,R2,R1, LSL #+4
        CMP      R4,#+0
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_8
        LDR      R1,[R6, R5, LSL #+2]
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_9
??gcode_M421_AUTO_BED_LEVELING_UBL_8:
        MOVS     R1,#+0
??gcode_M421_AUTO_BED_LEVELING_UBL_9:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, R5, LSL #+2]
        POP      {R0-R10,PC}      ;; return
        Nop      
        DATA
??gcode_M421_AUTO_BED_LEVELING_UBL_3:
        DC32     mks_heating_busy
        DC32     errormagic
        DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
        DC32     mksCfg
        DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
        DC32     _ZN20unified_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock342

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M428v
          CFI Block cfiBlock343 Using cfiCommon0
          CFI Function _Z10gcode_M428v
        THUMB
_Z10gcode_M428v:
        LDR.N    R0,??gcode_M428_0
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??gcode_M428_1
        BX       LR
??gcode_M428_1:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
        MOVS     R2,#+1
        MOV      R1,R2
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BNE.N    ??gcode_M428_2
        MOVS     R4,#+0
        ADD      R6,SP,#+0
        LDR.N    R7,??gcode_M428_0+0x4  ;; 0xc1a00000
        B.N      ??gcode_M428_3
??gcode_M428_4:
        ADDS     R4,R4,#+1
        UXTB     R4,R4
??gcode_M428_3:
        CMP      R4,#+3
        BGE.N    ??gcode_M428_5
        LDR.N    R0,??gcode_M428_0+0x8
        ADD      R0,R0,R4, LSL #+2
        LDR      R5,[R0, #+8]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R6, R4, LSL #+2]
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M428_6
        LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M428_7
??gcode_M428_6:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        CMP      R0,#+1
        BLT.N    ??gcode_M428_7
        EOR      R5,R5,#0x80000000
        STR      R5,[R6, R4, LSL #+2]
??gcode_M428_7:
        LDR      R0,[R6, R4, LSL #+2]
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M428_8
        LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M428_4
??gcode_M428_8:
        LDR.N    R0,??gcode_M428_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_0+0x18
          CFI FunCall _Z21lcd_setalertstatusPGMPKc
        BL       _Z21lcd_setalertstatusPGMPKc
        POP      {R0-R2,R4-R7,PC}
??gcode_M428_5:
        MOVS     R4,#+0
        B.N      ??gcode_M428_9
??gcode_M428_10:
        ADD      R0,SP,#+0
        LDR      R1,[R0, R4, LSL #+2]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
        ADDS     R4,R4,#+1
??gcode_M428_9:
        CMP      R4,#+3
        BLT.N    ??gcode_M428_10
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M428_0+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M428_2:
        POP      {R0-R2,R4-R7,PC}  ;; return
        DATA
??gcode_M428_0:
        DC32     mksCfg
        DC32     0xc1a00000
        DC32     mks_heating_busy
        DC32     0x41a00001
        DC32     errormagic
        DC32     _ZZ10gcode_M428vEs
        DC32     _ZZ10gcode_M428vEs_0
        DC32     _ZZ10gcode_M428vEs_1
          CFI EndBlock cfiBlock343

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M500v
          CFI Block cfiBlock344 Using cfiCommon0
          CFI Function _Z10gcode_M500v
          CFI FunCall _ZN14MarlinSettings4saveEv
        THUMB
_Z10gcode_M500v:
        B.W      _ZN14MarlinSettings4saveEv
          CFI EndBlock cfiBlock344

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M501v
          CFI Block cfiBlock345 Using cfiCommon0
          CFI Function _Z10gcode_M501v
          CFI FunCall _ZN14MarlinSettings4loadEv
        THUMB
_Z10gcode_M501v:
        B.W      _ZN14MarlinSettings4loadEv
          CFI EndBlock cfiBlock345

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M502v
          CFI Block cfiBlock346 Using cfiCommon0
          CFI Function _Z10gcode_M502v
          CFI FunCall _ZN14MarlinSettings5resetEv
        THUMB
_Z10gcode_M502v:
        B.W      _ZN14MarlinSettings5resetEv
          CFI EndBlock cfiBlock346

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M503v
          CFI Block cfiBlock347 Using cfiCommon0
          CFI Function _Z10gcode_M503v
        THUMB
_Z10gcode_M503v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M503_0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M503_1
??gcode_M503_0:
        MOVS     R0,#+0
??gcode_M503_1:
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN14MarlinSettings6reportEb
        B.W      _ZN14MarlinSettings6reportEb
          CFI EndBlock cfiBlock347

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M851v
          CFI Block cfiBlock348 Using cfiCommon0
          CFI Function _Z10gcode_M851v
        THUMB
_Z10gcode_M851v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M851_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M851_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M851_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M851_0+0x8  ;; 0xc1a00000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M851_2
        LDR.N    R1,??gcode_M851_0+0xC  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M851_3
??gcode_M851_2:
        LDR.N    R0,??gcode_M851_0+0x10
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M851_3:
        LDR.N    R1,??gcode_M851_0+0x14
        STR      R0,[R1, #+112]
??gcode_M851_1:
        LDR.N    R0,??gcode_M851_0+0x14
        LDR      R1,[R0, #+112]
        LDR.N    R0,??gcode_M851_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M851_0+0x1C
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        DATA
??gcode_M851_0:
        DC32     echomagic
        DC32     _ZZ10gcode_M851vEs
        DC32     0xc1a00000
        DC32     0x41a00001
        DC32     _ZZ10gcode_M851vEs_0
        DC32     mks_heating_busy
        DC32     _ZZ10gcode_M851vEs_1
        DC32     Serial3
          CFI EndBlock cfiBlock348

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M907v
          CFI Block cfiBlock349 Using cfiCommon0
          CFI Function _Z10gcode_M907v
          CFI NoCalls
        THUMB
_Z10gcode_M907v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock349

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M355v
          CFI Block cfiBlock350 Using cfiCommon0
          CFI Function _Z10gcode_M355v
        THUMB
_Z10gcode_M355v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M355_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M355_0+0x4
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M355_0:
        DC32     errormagic
        DC32     _ZZ10gcode_M355vEs
          CFI EndBlock cfiBlock350

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M999v
          CFI Block cfiBlock351 Using cfiCommon0
          CFI Function _Z10gcode_M999v
        THUMB
_Z10gcode_M999v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M999_0
        STRB     R0,[R1, #+4]
          CFI FunCall _Z21lcd_reset_alert_levelv
        BL       _Z21lcd_reset_alert_levelv
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BNE.N    ??gcode_M999_1
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z24FlushSerialRequestResendv
        B.W      _Z24FlushSerialRequestResendv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M999_1:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M999_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock351

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z22invalid_extruder_errorh
          CFI Block cfiBlock352 Using cfiCommon0
          CFI Function _Z22invalid_extruder_errorh
        THUMB
_Z22invalid_extruder_errorh:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??invalid_extruder_error_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??invalid_extruder_error_0+0x4
        MOVS     R1,#+84
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEhi
        BL       _ZN5Print5printEhi
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R1,??invalid_extruder_error_0+0x8
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??invalid_extruder_error_0:
        DC32     echomagic
        DC32     Serial3
        DC32     _ZZ22invalid_extruder_errorhEs
          CFI EndBlock cfiBlock352

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z7gcode_Th
          CFI Block cfiBlock353 Using cfiCommon0
          CFI Function _Z7gcode_Th
        THUMB
_Z7gcode_Th:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??gcode_T_0
        LDRB     R0,[R0, #+3]
        CMP      R4,R0
        BEQ.N    ??gcode_T_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R5,R0
        B.N      ??gcode_T_2
??gcode_T_1:
        MOVS     R5,#+1
??gcode_T_2:
        MOVS     R1,#+0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR.N    R1,??gcode_T_0+0x4  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R0
        MOV      R2,R5
        MOV      R0,R4
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z11tool_changehfb
        B.W      _Z11tool_changehfb
        DATA
??gcode_T_0:
        DC32     mks_heating_busy
        DC32     0x42700000
          CFI EndBlock cfiBlock353

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z25prepare_kinematic_move_toRA4_Kf
          CFI Block cfiBlock354 Using cfiCommon0
          CFI Function _Z25prepare_kinematic_move_toRA4_Kf
        THUMB
_Z25prepare_kinematic_move_toRA4_Kf:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+48
          CFI CFA R13+88
        LDR.W    R4,??prepare_kinematic_move_to_0
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??prepare_kinematic_move_to_0+0x4  ;; 0x47ae147b
        LDR.W    R3,??prepare_kinematic_move_to_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+0]
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+4]
        LDR      R1,[R4, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_kinematic_move_to_1
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??prepare_kinematic_move_to_2
??prepare_kinematic_move_to_1:
        LDR.W    R0,??prepare_kinematic_move_to_0+0xC
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        LDR      R0,[SP, #+48]
        BEQ.N    ??prepare_kinematic_move_to_3
        ADDS     R1,R0,#+4
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BNE.N    ??prepare_kinematic_move_to_4
        B.N      ??prepare_kinematic_move_to_5
??prepare_kinematic_move_to_3:
        ADDS     R1,R0,#+4
          CFI FunCall _Z34position_is_reachable_IS_CARTESIANRKfS0_
        BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.N    ??prepare_kinematic_move_to_5
??prepare_kinematic_move_to_4:
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+8]
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+12]
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        MOV      R6,R9
        MOV      R8,#+2
        MOV      R5,#+1065353216
        B.N      ??prepare_kinematic_move_to_6
??prepare_kinematic_move_to_7:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??prepare_kinematic_move_to_6:
        LSLS     R0,R8,#+31
        BPL.N    ??prepare_kinematic_move_to_8
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??prepare_kinematic_move_to_8:
        LSRS     R8,R8,#+1
        BNE.N    ??prepare_kinematic_move_to_7
        MOV      R8,R7
        MOV      R10,#+2
        MOV      R6,#+1065353216
        B.N      ??prepare_kinematic_move_to_9
??prepare_kinematic_move_to_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_9:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_11
        MOV      R0,R6
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??prepare_kinematic_move_to_11:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_10
        LDR      R11,[SP, #+4]
        MOV      R8,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_12
??prepare_kinematic_move_to_13:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_12:
        LSLS     R0,R8,#+31
        BPL.N    ??prepare_kinematic_move_to_14
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_14:
        LSRS     R8,R8,#+1
        BNE.N    ??prepare_kinematic_move_to_13
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
        LDR.N    R1,??prepare_kinematic_move_to_0+0x10  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_15
        LDR      R0,[SP, #+0]
        BIC      R8,R0,#0x80000000
??prepare_kinematic_move_to_15:
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_16
??prepare_kinematic_move_to_5:
        MOVS     R0,#+1
        B.N      ??prepare_kinematic_move_to_17
??prepare_kinematic_move_to_16:
        LDR.N    R5,??prepare_kinematic_move_to_0+0x14
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[R5, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
        LDR.N    R0,??prepare_kinematic_move_to_0+0xC
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??prepare_kinematic_move_to_18
        MOV      R0,#+1082130432
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        UXTH     R6,R6
        MOV      R0,R6
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_18
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
??prepare_kinematic_move_to_18:
        UXTH     R6,R6
        CMP      R6,#+0
        BNE.N    ??prepare_kinematic_move_to_19
        MOVS     R6,#+1
??prepare_kinematic_move_to_19:
        MOV      R0,R6
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,#+1065353216
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+28]
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+32]
        LDR      R0,[SP, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+36]
        LDR      R0,[SP, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+40]
        MOVS     R2,#+16
        ADD      R1,R4,#+8
        ADD      R0,SP,#+12
          CFI FunCall memcpy
        BL       memcpy
        B.N      ??prepare_kinematic_move_to_20
??prepare_kinematic_move_to_21:
        LDRB     R0,[R4, #+3]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+24
        LDR      R2,[R4, #+88]
        LDR      R1,[R4, #+84]
        LDR      R0,[R4, #+80]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
??prepare_kinematic_move_to_20:
        SUBS     R6,R6,#+1
        UXTH     R6,R6
        CMP      R6,#+0
        BEQ.W    ??prepare_kinematic_move_to_2
        LDR.N    R7,??prepare_kinematic_move_to_0+0x18
        LDR.N    R0,??prepare_kinematic_move_to_0+0x1C
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BNE.N    ??prepare_kinematic_move_to_22
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDS     R0,R0,#+200
        STR      R0,[R7, #+0]
??prepare_kinematic_move_to_22:
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR      R1,[R7, #+0]
        SUBS     R0,R0,R1
        BMI.N    ??prepare_kinematic_move_to_23
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDS     R0,R0,#+200
        STR      R0,[R7, #+0]
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??prepare_kinematic_move_to_23:
        MOV      R8,#+0
        ADD      R7,SP,#+12
        B.N      ??prepare_kinematic_move_to_24
??prepare_kinematic_move_to_25:
        LDR      R0,[R7, R8, LSL #+2]
        ADD      R1,SP,#+28
        LDR      R1,[R1, R8, LSL #+2]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, R8, LSL #+2]
        ADD      R8,R8,#+1
??prepare_kinematic_move_to_24:
        CMP      R8,#+4
        BLT.N    ??prepare_kinematic_move_to_25
        LDR.N    R0,??prepare_kinematic_move_to_0+0xC
        LDRB     R0,[R0, #+88]
        LSLS     R0,R0,#+30
        BPL.W    ??prepare_kinematic_move_to_26
        LDR      R0,[R5, #+12]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R9,#+2
        MOV      R8,#+1065353216
        B.N      ??prepare_kinematic_move_to_27
??prepare_kinematic_move_to_28:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??prepare_kinematic_move_to_27:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_29
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_29:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_28
        ADD      R7,SP,#+12
        LDR      R0,[R5, #+16]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_30
??prepare_kinematic_move_to_31:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_30:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_32
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_32:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_31
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+80]
        LDR      R0,[R5, #+20]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??prepare_kinematic_move_to_33
??prepare_kinematic_move_to_34:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_33:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_35
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_35:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_34
        LDR      R0,[R5, #+24]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_36
??prepare_kinematic_move_to_37:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_36:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_38
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_38:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_37
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+84]
        LDR      R0,[R5, #+28]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??prepare_kinematic_move_to_39
??prepare_kinematic_move_to_40:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_39:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_41
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_41:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_40
        LDR      R0,[R5, #+32]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_42
??prepare_kinematic_move_to_43:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_42:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_44
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_44:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_43
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+88]
        B.N      ??prepare_kinematic_move_to_45
??prepare_kinematic_move_to_26:
        ADD      R0,SP,#+12
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??prepare_kinematic_move_to_45:
        ADD      R0,SP,#+12
          CFI FunCall _Z12ADJUST_DELTAPKf
        BL       _Z12ADJUST_DELTAPKf
        LDR.N    R2,??prepare_kinematic_move_to_0+0x20
        LDRB     R0,[R2, #+328]
        CMP      R0,#+1
        BNE.W    ??prepare_kinematic_move_to_21
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+8]
        LDR      R1,[R2, #+664]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.W    ??prepare_kinematic_move_to_21
        ADD      R4,R2,#+328
        MOVS     R0,#+1
        STRB     R0,[R4, #+12]
        LDR      R1,[SP, #+24]
        LDR.N    R0,??prepare_kinematic_move_to_0+0x24
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall lroundf
        BL       lroundf
        STR      R0,[R4, #+8]
        MOVS     R0,#+0
        B.N      ??prepare_kinematic_move_to_17
??prepare_kinematic_move_to_2:
        LDRB     R2,[R4, #+3]
        ADD      R1,SP,#+8
        LDR      R0,[SP, #+48]
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        MOVS     R0,#+0
??prepare_kinematic_move_to_17:
        ADD      SP,SP,#+52
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??prepare_kinematic_move_to_0:
        DC32     mks_heating_busy
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     mksCfg
        DC32     0x358637be
        DC32     axis_homed
        DC32     _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        DC32     _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        DC32     gCfgItems
        DC32     _ZN7Planner17axis_steps_per_mmE
          CFI EndBlock cfiBlock354

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37prepare_move_to_destination_cartesianv
          CFI Block cfiBlock355 Using cfiCommon0
          CFI Function _Z37prepare_move_to_destination_cartesianv
        THUMB
_Z37prepare_move_to_destination_cartesianv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        LDR.N    R4,??prepare_move_to_destination_cartesian_0
        LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_cartesian_1
        ADD      R0,R4,#+32
          CFI FunCall _ZN7Planner20leveling_active_at_zERKf
        BL       _ZN7Planner20leveling_active_at_zERKf
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_cartesian_1
        LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x8
        LDRB     R2,[R0, #+64]
        CMP      R2,#+16
        BNE.N    ??prepare_move_to_destination_cartesian_2
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        LDRB     R1,[R4, #+3]
        ADD      R0,SP,#+0
          CFI FunCall _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        BL       _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
??prepare_move_to_destination_cartesian_2:
        LDR      R0,[R4, #+8]
        LDR      R1,[R4, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_move_to_destination_cartesian_3
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_cartesian_1
??prepare_move_to_destination_cartesian_3:
        CMP      R2,#+32
        BNE.N    ??prepare_move_to_destination_cartesian_4
        MOVS     R2,#+255
        MOV      R1,R2
        MOV      R5,R1
        MOV      R6,R2
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R2,R6
        MOV      R1,R5
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
        B.N      ??prepare_move_to_destination_cartesian_5
??prepare_move_to_destination_cartesian_4:
        CMP      R2,#+8
        BNE.N    ??prepare_move_to_destination_cartesian_5
        MOVW     R1,#+65535
        MOV      R2,R1
        MOV      R5,R2
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R2,R5
        MOV      R1,R5
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
??prepare_move_to_destination_cartesian_5:
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
??prepare_move_to_destination_cartesian_1:
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
        DATA
??prepare_move_to_destination_cartesian_0:
        DC32     mks_heating_busy
        DC32     _ZN7Planner15leveling_activeE
        DC32     mksCfg
        DC32     0x47ae147b
        DC32     0x3f847ae1
          CFI EndBlock cfiBlock355

        SECTION `.init_array`:CODE:ROOT(2)
        SECTION_TYPE SHT_INIT_ARRAY, 0
        DATA
        DC32    RELOC_ARM_TARGET1 __sti__routine

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 16397 
// 
//  4 207 bytes in section .bss
//    385 bytes in section .data
//      4 bytes in section .init_array
//  3 815 bytes in section .rodata
// 52 120 bytes in section .text
// 
// 28 868 bytes of CODE  memory (+ 23 256 bytes shared)
//    288 bytes of CONST memory (+  3 527 bytes shared)
//  4 382 bytes of DATA  memory (+    210 bytes shared)
//
//Errors: none
//Warnings: 164
