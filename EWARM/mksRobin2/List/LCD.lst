###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  17:00:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCD.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCD.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\LCD.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\LCD.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCD.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LCD.c
     16          Purpose     : Link between GUI and LCD_L0
     17                        Performs most of the clipping.
     18          ---------------------------END-OF-HEADER------------------------------
     19          */
     20          
     21          #define LCD_C
     22          
     23          #include <stdio.h>
     24          #include "GUI_Private.h"
     25          #include "LCD_Private.h"
     26          #include "GUIDebug.h"
     27          
     28          /*********************************************************************
     29          *
     30          *       Defines
     31          *
     32          **********************************************************************
     33          */
     34          
     35          #define RETURN_IF_Y_OUT() \
     36            if (y < GUI_Context.ClipRect.y0) return;             \
     37            if (y > GUI_Context.ClipRect.y1) return;
     38          
     39          #define RETURN_IF_X_OUT() \
     40            if (x < GUI_Context.ClipRect.x0) return;             \
     41            if (x > GUI_Context.ClipRect.x1) return;
     42          
     43          #define CLIP_X() \
     44            if (x0 < GUI_Context.ClipRect.x0) { x0 = GUI_Context.ClipRect.x0; } \
     45            if (x1 > GUI_Context.ClipRect.x1) { x1 = GUI_Context.ClipRect.x1; }
     46          
     47          #define CLIP_Y() \
     48            if (y0 < GUI_Context.ClipRect.y0) { y0 = GUI_Context.ClipRect.y0; } \
     49            if (y1 > GUI_Context.ClipRect.y1) { y1 = GUI_Context.ClipRect.y1; }
     50          
     51          /*********************************************************************
     52          *
     53          *       Static code
     54          *
     55          **********************************************************************
     56          */
     57          /*********************************************************************
     58          *
     59          *       _GetColorIndex
     60          */

   \                                 In section .text, align 2, keep-with-next
     61          static int _GetColorIndex(int i)  /* i is 0 or 1 */ {
     62            return  (GUI_Context.DrawMode & LCD_DRAWMODE_REV) ? i-1 : i;
   \                     _GetColorIndex: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10
   \   00000002   0x7B09             LDRB     R1,[R1, #+12]
   \   00000004   0x0749             LSLS     R1,R1,#+29
   \   00000006   0xD500             BPL.N    ??_GetColorIndex_0
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \                     ??_GetColorIndex_0: (+1)
   \   0000000A   0x4770             BX       LR               ;; return
     63          }
     64          
     65          /*********************************************************************
     66          *
     67          *       Public code
     68          *
     69          **********************************************************************
     70          */
     71          /*********************************************************************
     72          *
     73          *       LCD_SetColorIndex
     74          */

   \                                 In section .text, align 2, keep-with-next
     75          void LCD_SetColorIndex(int Index) {
   \                     LCD_SetColorIndex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     76            LCD_ACOLORINDEX[_GetColorIndex(1)] = Index;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       _GetColorIndex
   \   0000000A   0x....             LDR.N    R1,??DataTable10
   \   0000000C   0xF821 0x4010      STRH     R4,[R1, R0, LSL #+1]
     77          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
     78          
     79          /*********************************************************************
     80          *
     81          *       LCD_SetBkColorIndex
     82          */

   \                                 In section .text, align 2, keep-with-next
     83          void LCD_SetBkColorIndex(int Index) {
   \                     LCD_SetBkColorIndex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     84            LCD_ACOLORINDEX[_GetColorIndex(0)] = Index;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       _GetColorIndex
   \   0000000A   0x....             LDR.N    R1,??DataTable10
   \   0000000C   0xF821 0x4010      STRH     R4,[R1, R0, LSL #+1]
     85          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
     86          
     87          /*********************************************************************
     88          *
     89          *       LCD_SetDrawMode
     90          */

   \                                 In section .text, align 2, keep-with-next
     91          LCD_DRAWMODE LCD_SetDrawMode(LCD_DRAWMODE dm) {
   \                     LCD_SetDrawMode: (+1)
   \   00000000   0xB410             PUSH     {R4}
     92            LCD_DRAWMODE OldDM = GUI_Context.DrawMode;
   \   00000002   0x....             LDR.N    R2,??DataTable10
   \   00000004   0x7B11             LDRB     R1,[R2, #+12]
     93            if ((GUI_Context.DrawMode^dm) & LCD_DRAWMODE_REV) {
   \   00000006   0xEA80 0x0301      EOR      R3,R0,R1
   \   0000000A   0x075B             LSLS     R3,R3,#+29
   \   0000000C   0xD503             BPL.N    ??LCD_SetDrawMode_0
     94              LCD_PIXELINDEX temp = LCD_BKCOLORINDEX;
   \   0000000E   0x8813             LDRH     R3,[R2, #+0]
     95              LCD_BKCOLORINDEX    = LCD_COLORINDEX;
   \   00000010   0x8854             LDRH     R4,[R2, #+2]
   \   00000012   0x8014             STRH     R4,[R2, #+0]
     96              LCD_COLORINDEX = temp;
   \   00000014   0x8053             STRH     R3,[R2, #+2]
     97            }
     98            GUI_Context.DrawMode = dm;
   \                     ??LCD_SetDrawMode_0: (+1)
   \   00000016   0x7310             STRB     R0,[R2, #+12]
     99            return OldDM;
   \   00000018   0x4608             MOV      R0,R1
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    100          }
    101          
    102          /*********************************************************************
    103          *
    104          *       LCD_DrawPixel
    105          */

   \                                 In section .text, align 2, keep-with-next
    106          void LCD_DrawPixel(int x, int y) {
    107            RETURN_IF_Y_OUT();
   \                     LCD_DrawPixel: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10
   \   00000002   0xF9B2 0x3006      LDRSH    R3,[R2, #+6]
   \   00000006   0x4299             CMP      R1,R3
   \   00000008   0xDB13             BLT.N    ??LCD_DrawPixel_0
   \   0000000A   0xF9B2 0x300A      LDRSH    R3,[R2, #+10]
   \   0000000E   0x428B             CMP      R3,R1
   \   00000010   0xDB0F             BLT.N    ??LCD_DrawPixel_0
    108            RETURN_IF_X_OUT();
   \   00000012   0xF9B2 0x3004      LDRSH    R3,[R2, #+4]
   \   00000016   0x4298             CMP      R0,R3
   \   00000018   0xDB0B             BLT.N    ??LCD_DrawPixel_0
   \   0000001A   0xF9B2 0x3008      LDRSH    R3,[R2, #+8]
   \   0000001E   0x4283             CMP      R3,R0
   \   00000020   0xDB07             BLT.N    ??LCD_DrawPixel_0
    109            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000022   0x7B13             LDRB     R3,[R2, #+12]
   \   00000024   0x07DB             LSLS     R3,R3,#+31
   \   00000026   0xD501             BPL.N    ??LCD_DrawPixel_1
    110              LCDDEV_L0_XorPixel(x, y);
   \   00000028   0x.... 0x....      B.W      LCD_L0_XorPixel
    111            } else {
    112              LCDDEV_L0_SetPixelIndex(x, y, LCD_COLORINDEX);
   \                     ??LCD_DrawPixel_1: (+1)
   \   0000002C   0x8852             LDRH     R2,[R2, #+2]
   \   0000002E   0x.... 0x....      B.W      LCD_L0_SetPixelIndex
    113            }
    114          }
   \                     ??LCD_DrawPixel_0: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    115          
    116          /*********************************************************************
    117          *
    118          *       LCD_DrawHLine
    119          */

   \                                 In section .text, align 2, keep-with-next
    120          void LCD_DrawHLine(int x0, int y,  int x1) {
   \                     LCD_DrawHLine: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    121            /* Perform clipping and check if there is something to do */
    122            RETURN_IF_Y_OUT();
   \   00000002   0x....             LDR.N    R3,??DataTable10
   \   00000004   0xF9B3 0x4006      LDRSH    R4,[R3, #+6]
   \   00000008   0x42A1             CMP      R1,R4
   \   0000000A   0xDB12             BLT.N    ??LCD_DrawHLine_0
   \   0000000C   0xF9B3 0x400A      LDRSH    R4,[R3, #+10]
   \   00000010   0x428C             CMP      R4,R1
   \   00000012   0xDB0E             BLT.N    ??LCD_DrawHLine_0
   \   00000014   0xF9B3 0x4004      LDRSH    R4,[R3, #+4]
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xDA00             BGE.N    ??LCD_DrawHLine_1
    123            CLIP_X();
   \   0000001C   0x4620             MOV      R0,R4
   \                     ??LCD_DrawHLine_1: (+1)
   \   0000001E   0xF9B3 0x3008      LDRSH    R3,[R3, #+8]
   \   00000022   0x4293             CMP      R3,R2
   \   00000024   0xDA00             BGE.N    ??LCD_DrawHLine_2
   \   00000026   0x461A             MOV      R2,R3
    124            if (x1<x0)
   \                     ??LCD_DrawHLine_2: (+1)
   \   00000028   0x4282             CMP      R2,R0
   \   0000002A   0xDB02             BLT.N    ??LCD_DrawHLine_0
    125              return;
    126            /* Call driver to draw */
    127            LCDDEV_L0_DrawHLine(x0, y, x1);
   \   0000002C   0xBC18             POP      {R3,R4}
   \   0000002E   0x.... 0x....      B.W      LCD_L0_DrawHLine
   \                     ??LCD_DrawHLine_0: (+1)
   \   00000032   0xBC11             POP      {R0,R4}
   \   00000034   0x4770             BX       LR               ;; return
    128          }
    129          
    130          /*********************************************************************
    131          *
    132          *       LCD_FillRect
    133          */

   \                                 In section .text, align 2, keep-with-next
    134          void LCD_FillRect(int x0, int y0, int x1, int y1) {
   \                     LCD_FillRect: (+1)
   \   00000000   0xB43C             PUSH     {R2-R5}
    135            /* Perform clipping and check if there is something to do */
    136            CLIP_X();
   \   00000002   0x....             LDR.N    R4,??DataTable10
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
   \   00000008   0x42A8             CMP      R0,R5
   \   0000000A   0xDA00             BGE.N    ??LCD_FillRect_0
   \   0000000C   0x4628             MOV      R0,R5
   \                     ??LCD_FillRect_0: (+1)
   \   0000000E   0xF9B4 0x5008      LDRSH    R5,[R4, #+8]
   \   00000012   0x4295             CMP      R5,R2
   \   00000014   0xDA00             BGE.N    ??LCD_FillRect_1
   \   00000016   0x462A             MOV      R2,R5
    137            if (x1<x0)
   \                     ??LCD_FillRect_1: (+1)
   \   00000018   0x4282             CMP      R2,R0
   \   0000001A   0xDB0F             BLT.N    ??LCD_FillRect_2
    138              return;
   \   0000001C   0xF9B4 0x5006      LDRSH    R5,[R4, #+6]
   \   00000020   0x42A9             CMP      R1,R5
   \   00000022   0xDA00             BGE.N    ??LCD_FillRect_3
    139            CLIP_Y();
   \   00000024   0x4629             MOV      R1,R5
   \                     ??LCD_FillRect_3: (+1)
   \   00000026   0xF9B4 0x400A      LDRSH    R4,[R4, #+10]
   \   0000002A   0x429C             CMP      R4,R3
   \   0000002C   0xDA00             BGE.N    ??LCD_FillRect_4
   \   0000002E   0x4623             MOV      R3,R4
    140            if (y1<y0)
   \                     ??LCD_FillRect_4: (+1)
   \   00000030   0x428B             CMP      R3,R1
   \   00000032   0xDB03             BLT.N    ??LCD_FillRect_2
    141              return;
    142            /* Call driver to draw */
    143            LCDDEV_L0_FillRect(x0,y0,x1,y1);
   \   00000034   0xB002             ADD      SP,SP,#+8
   \   00000036   0xBC30             POP      {R4,R5}
   \   00000038   0x.... 0x....      B.W      LCD_L0_FillRect
   \                     ??LCD_FillRect_2: (+1)
   \   0000003C   0xBC33             POP      {R0,R1,R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
    144          }
    145          
    146          /*********************************************************************
    147          *
    148          *       LCD_DrawBitmap
    149          */

   \                                 In section .text, align 2, keep-with-next
    150          void LCD_DrawBitmap(int x0, int y0, int xsize, int ysize, int xMul, int yMul,
    151                                 int BitsPerPixel, int BytesPerLine,
    152                                 const U8 GUI_UNI_PTR * pPixel, const LCD_PIXELINDEX* pTrans)
    153          {
   \                     LCD_DrawBitmap: (+1)
   \   00000000   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
    154            U8  Data = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    155            int x1, y1;
    156            /* Handle rotation if necessary */
    157            #if GUI_SUPPORT_ROTATION
    158            if (GUI_pLCD_APIList) {
   \   0000000A   0x....             LDR.N    R0,??DataTable10_1
   \   0000000C   0x6807             LDR      R7,[R0, #+0]
   \   0000000E   0x9D16             LDR      R5,[SP, #+88]
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD010             BEQ.N    ??LCD_DrawBitmap_0
    159              GUI_pLCD_APIList->pfDrawBitmap(x0, y0, xsize, ysize, xMul, yMul, BitsPerPixel, BytesPerLine, pPixel, pTrans);
   \   00000014   0x9817             LDR      R0,[SP, #+92]
   \   00000016   0x9005             STR      R0,[SP, #+20]
   \   00000018   0x9504             STR      R5,[SP, #+16]
   \   0000001A   0x9815             LDR      R0,[SP, #+84]
   \   0000001C   0x9003             STR      R0,[SP, #+12]
   \   0000001E   0x9814             LDR      R0,[SP, #+80]
   \   00000020   0x9002             STR      R0,[SP, #+8]
   \   00000022   0x9813             LDR      R0,[SP, #+76]
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x9812             LDR      R0,[SP, #+72]
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x9B08             LDR      R3,[SP, #+32]
   \   0000002C   0x9A07             LDR      R2,[SP, #+28]
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x683C             LDR      R4,[R7, #+0]
   \   00000032   0x47A0             BLX      R4
    160              return;
   \   00000034   0xE06F             B.N      ??LCD_DrawBitmap_1
    161            }
    162            #endif
    163            /* Handle the optional Y-magnification */
    164            y1 = y0 + ysize - 1;
   \                     ??LCD_DrawBitmap_0: (+1)
   \   00000036   0x4618             MOV      R0,R3
   \   00000038   0x1840             ADDS     R0,R0,R1
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
    165            x1 = x0 + xsize - 1;
   \   0000003C   0x1912             ADDS     R2,R2,R4
   \   0000003E   0x1E52             SUBS     R2,R2,#+1
    166          /*  Handle BITMAP without magnification */
    167            if ((xMul | yMul) == 1) {
   \   00000040   0x9B12             LDR      R3,[SP, #+72]
   \   00000042   0x9F13             LDR      R7,[SP, #+76]
   \   00000044   0x433B             ORRS     R3,R7,R3
   \   00000046   0x2B01             CMP      R3,#+1
   \   00000048   0xD168             BNE.N    ??LCD_DrawBitmap_2
    168              int Diff;
    169              /*  Clip y0 (top) */
    170              Diff = GUI_Context.ClipRect.y0 - y0;
   \   0000004A   0x....             LDR.N    R7,??DataTable10
   \   0000004C   0xF9B7 0x6006      LDRSH    R6,[R7, #+6]
   \   00000050   0x1A73             SUBS     R3,R6,R1
    171              if (Diff > 0) {
   \   00000052   0x2B01             CMP      R3,#+1
   \   00000054   0xDB08             BLT.N    ??LCD_DrawBitmap_3
    172                ysize -= Diff;
   \   00000056   0x9908             LDR      R1,[SP, #+32]
   \   00000058   0x1AC9             SUBS     R1,R1,R3
   \   0000005A   0x9108             STR      R1,[SP, #+32]
    173                if (ysize <= 0) {
   \   0000005C   0x2901             CMP      R1,#+1
   \   0000005E   0xDB5A             BLT.N    ??LCD_DrawBitmap_1
    174          		    return;
    175                }
    176                y0     = GUI_Context.ClipRect.y0;
   \   00000060   0x4631             MOV      R1,R6
    177                #if GUI_SUPPORT_LARGE_BITMAPS                       /* Required only for 16 bit CPUs if some bitmaps are >64kByte */
    178                  pPixel += (U32)     Diff * (U32)     BytesPerLine;
    179                #else
    180                  pPixel += (unsigned)Diff * (unsigned)BytesPerLine;
   \   00000062   0x9E15             LDR      R6,[SP, #+84]
   \   00000064   0xFB06 0x5503      MLA      R5,R6,R3,R5
    181                #endif
    182              }
    183              /*  Clip y1 (bottom) */
    184              Diff = y1 - GUI_Context.ClipRect.y1;
   \                     ??LCD_DrawBitmap_3: (+1)
   \   00000068   0xF9B7 0x300A      LDRSH    R3,[R7, #+10]
   \   0000006C   0x1AC3             SUBS     R3,R0,R3
    185              if (Diff > 0) {
   \   0000006E   0x2B01             CMP      R3,#+1
   \   00000070   0xDB04             BLT.N    ??LCD_DrawBitmap_4
    186                ysize -= Diff;
   \   00000072   0x9808             LDR      R0,[SP, #+32]
   \   00000074   0x1AC0             SUBS     R0,R0,R3
   \   00000076   0x9008             STR      R0,[SP, #+32]
    187                if (ysize <= 0) {
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xDB4C             BLT.N    ??LCD_DrawBitmap_1
    188          		    return;
    189                }
    190              }
    191              /*        Clip right side    */
    192              Diff = x1 - GUI_Context.ClipRect.x1;
   \                     ??LCD_DrawBitmap_4: (+1)
   \   0000007C   0xF9B7 0x0008      LDRSH    R0,[R7, #+8]
   \   00000080   0x1A10             SUBS     R0,R2,R0
    193              if (Diff > 0) {
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xDB02             BLT.N    ??LCD_DrawBitmap_5
    194                xsize -= Diff;
   \   00000086   0x9A07             LDR      R2,[SP, #+28]
   \   00000088   0x1A10             SUBS     R0,R2,R0
   \   0000008A   0x9007             STR      R0,[SP, #+28]
    195              }
    196              /*        Clip left side ... (The difficult side ...)    */
    197              Diff = 0;
   \                     ??LCD_DrawBitmap_5: (+1)
   \   0000008C   0x2300             MOVS     R3,#+0
   \   0000008E   0xF9B7 0x0004      LDRSH    R0,[R7, #+4]
   \   00000092   0x4284             CMP      R4,R0
   \   00000094   0xDA2F             BGE.N    ??LCD_DrawBitmap_6
    198              if (x0 < GUI_Context.ClipRect.x0) {
    199                Diff = GUI_Context.ClipRect.x0 - x0;
   \   00000096   0x1B03             SUBS     R3,R0,R4
    200          			xsize -= Diff;
   \   00000098   0x9807             LDR      R0,[SP, #+28]
   \   0000009A   0x1AC0             SUBS     R0,R0,R3
   \   0000009C   0x9007             STR      R0,[SP, #+28]
    201          			switch (BitsPerPixel) {
   \   0000009E   0x9814             LDR      R0,[SP, #+80]
   \   000000A0   0x2801             CMP      R0,#+1
   \   000000A2   0xD008             BEQ.N    ??LCD_DrawBitmap_7
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD00E             BEQ.N    ??LCD_DrawBitmap_8
   \   000000A8   0x2804             CMP      R0,#+4
   \   000000AA   0xD014             BEQ.N    ??LCD_DrawBitmap_9
   \   000000AC   0x2808             CMP      R0,#+8
   \   000000AE   0xD01A             BEQ.N    ??LCD_DrawBitmap_10
   \   000000B0   0x2810             CMP      R0,#+16
   \   000000B2   0xD01C             BEQ.N    ??LCD_DrawBitmap_11
   \   000000B4   0xE01F             B.N      ??LCD_DrawBitmap_6
    202          			case 1:
    203            			pPixel+= (Diff>>3); x0 += (Diff>>3)<<3; Diff &=7;
   \                     ??LCD_DrawBitmap_7: (+1)
   \   000000B6   0xEB05 0x05E3      ADD      R5,R5,R3, ASR #+3
   \   000000BA   0xF023 0x0007      BIC      R0,R3,#0x7
   \   000000BE   0x1904             ADDS     R4,R0,R4
   \   000000C0   0xF003 0x0307      AND      R3,R3,#0x7
    204          				break;
   \   000000C4   0xE017             B.N      ??LCD_DrawBitmap_6
    205          			case 2:
    206          	  		pPixel+= (Diff>>2); x0 += (Diff>>2)<<2; Diff &=3;
   \                     ??LCD_DrawBitmap_8: (+1)
   \   000000C6   0xEB05 0x05A3      ADD      R5,R5,R3, ASR #+2
   \   000000CA   0xF023 0x0003      BIC      R0,R3,#0x3
   \   000000CE   0x1904             ADDS     R4,R0,R4
   \   000000D0   0xF003 0x0303      AND      R3,R3,#0x3
    207          				break;
   \   000000D4   0xE00F             B.N      ??LCD_DrawBitmap_6
    208          			case 4:
    209          				pPixel+= (Diff>>1); x0 += (Diff>>1)<<1; Diff &=1;
   \                     ??LCD_DrawBitmap_9: (+1)
   \   000000D6   0xEB05 0x0563      ADD      R5,R5,R3, ASR #+1
   \   000000DA   0xF023 0x0001      BIC      R0,R3,#0x1
   \   000000DE   0x1904             ADDS     R4,R0,R4
   \   000000E0   0xF003 0x0301      AND      R3,R3,#0x1
    210          				break;
   \   000000E4   0xE007             B.N      ??LCD_DrawBitmap_6
    211          			case 8:
    212          				pPixel+= Diff;      x0 += Diff; Diff=0;
   \                     ??LCD_DrawBitmap_10: (+1)
   \   000000E6   0x195D             ADDS     R5,R3,R5
   \   000000E8   0x191C             ADDS     R4,R3,R4
   \   000000EA   0x2300             MOVS     R3,#+0
    213          				break;
   \   000000EC   0xE003             B.N      ??LCD_DrawBitmap_6
    214          			case 16:
    215          				pPixel+= (Diff<<1); x0 += Diff; Diff=0;
   \                     ??LCD_DrawBitmap_11: (+1)
   \   000000EE   0xEB05 0x0543      ADD      R5,R5,R3, LSL #+1
   \   000000F2   0x191C             ADDS     R4,R3,R4
   \   000000F4   0x2300             MOVS     R3,#+0
    216          				break;
    217          			}
    218              }
    219              if (xsize <=0) {
   \                     ??LCD_DrawBitmap_6: (+1)
   \   000000F6   0x9807             LDR      R0,[SP, #+28]
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xDB0C             BLT.N    ??LCD_DrawBitmap_1
    220          		  return;
    221              }
    222              LCDDEV_L0_DrawBitmap   (x0,y0, xsize, ysize, BitsPerPixel, BytesPerLine, pPixel, Diff, pTrans);
   \   000000FC   0x9817             LDR      R0,[SP, #+92]
   \   000000FE   0x9004             STR      R0,[SP, #+16]
   \   00000100   0x9303             STR      R3,[SP, #+12]
   \   00000102   0x9502             STR      R5,[SP, #+8]
   \   00000104   0x9815             LDR      R0,[SP, #+84]
   \   00000106   0x9001             STR      R0,[SP, #+4]
   \   00000108   0x9814             LDR      R0,[SP, #+80]
   \   0000010A   0x9000             STR      R0,[SP, #+0]
   \   0000010C   0x9B08             LDR      R3,[SP, #+32]
   \   0000010E   0x9A07             LDR      R2,[SP, #+28]
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       LCD_L0_DrawBitmap
    223            } else {
    224              /**** Handle BITMAP with magnification ***/
    225              int x,y;
    226              int yi;
    227              int Shift = 8-BitsPerPixel;
    228              for (y=y0, yi=0; yi<ysize; yi++, y+= yMul, pPixel+=BytesPerLine) {
    229                int yMax = y+yMul-1;
    230                /* Draw if within clip area (Optimization ... "if" is not required !) */
    231                if ((yMax >= GUI_Context.ClipRect.y0) && (y <= GUI_Context.ClipRect.y1)) {
    232                  int BitsLeft =0;
    233                  int xi;
    234                  const U8 GUI_UNI_PTR * pDataLine = pPixel;
    235                  for (x=x0, xi=0; xi<xsize; xi++, x+=xMul) {
    236                    U8  Index;
    237                    if (!BitsLeft) {
    238                      Data = *pDataLine++;
    239                      BitsLeft =8;
    240                    }
    241                    Index = Data>>Shift;
    242                    Data    <<= BitsPerPixel;
    243                    BitsLeft -= BitsPerPixel;
    244                    if (Index || ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) ==0)) {
    245                      LCD_PIXELINDEX  OldColor = LCD_COLORINDEX;
    246                      if (pTrans) {
    247                        LCD_COLORINDEX = *(pTrans+Index);
    248                      } else {
    249                        LCD_COLORINDEX = Index;
    250                      }
    251                      LCD_FillRect(x,y, x+xMul-1, yMax);
    252                      LCD_COLORINDEX = OldColor;
    253                    }
    254                  }
    255                }
    256              }
    257            }
    258          }
   \                     ??LCD_DrawBitmap_1: (+1)
   \   00000116   0xB009             ADD      SP,SP,#+36
   \   00000118   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??LCD_DrawBitmap_2: (+1)
   \   0000011C   0x9814             LDR      R0,[SP, #+80]
   \   0000011E   0xF1C0 0x0008      RSB      R0,R0,#+8
   \   00000122   0x9005             STR      R0,[SP, #+20]
   \   00000124   0x9100             STR      R1,[SP, #+0]
   \   00000126   0x4630             MOV      R0,R6
   \   00000128   0x9001             STR      R0,[SP, #+4]
   \   0000012A   0x....             LDR.N    R7,??DataTable10
   \   0000012C   0xE006             B.N      ??LCD_DrawBitmap_12
   \                     ??LCD_DrawBitmap_13: (+1)
   \   0000012E   0x9801             LDR      R0,[SP, #+4]
   \   00000130   0x1C40             ADDS     R0,R0,#+1
   \   00000132   0x9001             STR      R0,[SP, #+4]
   \   00000134   0x9803             LDR      R0,[SP, #+12]
   \   00000136   0x9000             STR      R0,[SP, #+0]
   \   00000138   0x9815             LDR      R0,[SP, #+84]
   \   0000013A   0x1945             ADDS     R5,R0,R5
   \                     ??LCD_DrawBitmap_12: (+1)
   \   0000013C   0x9801             LDR      R0,[SP, #+4]
   \   0000013E   0x9908             LDR      R1,[SP, #+32]
   \   00000140   0x4288             CMP      R0,R1
   \   00000142   0xDAE8             BGE.N    ??LCD_DrawBitmap_1
   \   00000144   0x9800             LDR      R0,[SP, #+0]
   \   00000146   0x9913             LDR      R1,[SP, #+76]
   \   00000148   0x1808             ADDS     R0,R1,R0
   \   0000014A   0x9003             STR      R0,[SP, #+12]
   \   0000014C   0x1E40             SUBS     R0,R0,#+1
   \   0000014E   0x9002             STR      R0,[SP, #+8]
   \   00000150   0xF9B7 0x1006      LDRSH    R1,[R7, #+6]
   \   00000154   0x4288             CMP      R0,R1
   \   00000156   0xDBEA             BLT.N    ??LCD_DrawBitmap_13
   \   00000158   0xF9B7 0x000A      LDRSH    R0,[R7, #+10]
   \   0000015C   0x9900             LDR      R1,[SP, #+0]
   \   0000015E   0x4288             CMP      R0,R1
   \   00000160   0xDBE5             BLT.N    ??LCD_DrawBitmap_13
   \   00000162   0xF04F 0x0800      MOV      R8,#+0
   \   00000166   0x9504             STR      R5,[SP, #+16]
   \   00000168   0x46A1             MOV      R9,R4
   \   0000016A   0x46C2             MOV      R10,R8
   \   0000016C   0xE00E             B.N      ??LCD_DrawBitmap_14
   \                     ??LCD_DrawBitmap_15: (+1)
   \   0000016E   0x8078             STRH     R0,[R7, #+2]
   \                     ??LCD_DrawBitmap_16: (+1)
   \   00000170   0x9B02             LDR      R3,[SP, #+8]
   \   00000172   0x9812             LDR      R0,[SP, #+72]
   \   00000174   0x4448             ADD      R0,R0,R9
   \   00000176   0x1E42             SUBS     R2,R0,#+1
   \   00000178   0x9900             LDR      R1,[SP, #+0]
   \   0000017A   0x4648             MOV      R0,R9
   \   0000017C   0x.... 0x....      BL       LCD_FillRect
   \   00000180   0xF8A7 0xB002      STRH     R11,[R7, #+2]
   \                     ??LCD_DrawBitmap_17: (+1)
   \   00000184   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   00000188   0x9812             LDR      R0,[SP, #+72]
   \   0000018A   0x4481             ADD      R9,R0,R9
   \                     ??LCD_DrawBitmap_14: (+1)
   \   0000018C   0x9807             LDR      R0,[SP, #+28]
   \   0000018E   0x4582             CMP      R10,R0
   \   00000190   0xDACD             BGE.N    ??LCD_DrawBitmap_13
   \   00000192   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000196   0xD106             BNE.N    ??LCD_DrawBitmap_18
   \   00000198   0x9804             LDR      R0,[SP, #+16]
   \   0000019A   0x1C40             ADDS     R0,R0,#+1
   \   0000019C   0x9004             STR      R0,[SP, #+16]
   \   0000019E   0x1E40             SUBS     R0,R0,#+1
   \   000001A0   0x7806             LDRB     R6,[R0, #+0]
   \   000001A2   0xF04F 0x0808      MOV      R8,#+8
   \                     ??LCD_DrawBitmap_18: (+1)
   \   000001A6   0xB2F6             UXTB     R6,R6
   \   000001A8   0x9805             LDR      R0,[SP, #+20]
   \   000001AA   0xFA46 0xF000      ASR      R0,R6,R0
   \   000001AE   0xB2C0             UXTB     R0,R0
   \   000001B0   0x9914             LDR      R1,[SP, #+80]
   \   000001B2   0x408E             LSLS     R6,R6,R1
   \   000001B4   0xEBA8 0x0801      SUB      R8,R8,R1
   \   000001B8   0x2800             CMP      R0,#+0
   \   000001BA   0xD102             BNE.N    ??LCD_DrawBitmap_19
   \   000001BC   0x7B39             LDRB     R1,[R7, #+12]
   \   000001BE   0x0789             LSLS     R1,R1,#+30
   \   000001C0   0xD4E0             BMI.N    ??LCD_DrawBitmap_17
   \                     ??LCD_DrawBitmap_19: (+1)
   \   000001C2   0xF8B7 0xB002      LDRH     R11,[R7, #+2]
   \   000001C6   0x9917             LDR      R1,[SP, #+92]
   \   000001C8   0x2900             CMP      R1,#+0
   \   000001CA   0xD0D0             BEQ.N    ??LCD_DrawBitmap_15
   \   000001CC   0xF831 0x0010      LDRH     R0,[R1, R0, LSL #+1]
   \   000001D0   0x8078             STRH     R0,[R7, #+2]
   \   000001D2   0xE7CD             B.N      ??LCD_DrawBitmap_16
    259          
    260          /*********************************************************************
    261          *
    262          *       LCD_SetClipRectMax
    263          */

   \                                 In section .text, align 2, keep-with-next
    264          void LCD_SetClipRectMax(void) {
    265            LCDDEV_L0_GetRect(&GUI_Context.ClipRect);
   \                     LCD_SetClipRectMax: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_2
   \   00000002   0x.... 0x....      B.W      LCD_L0_GetRect
    266          }
    267          
    268          /*********************************************************************
    269          *
    270          *       LCD_Init
    271          */

   \                                 In section .text, align 2, keep-with-next
    272          int LCD_Init(void) {
   \                     LCD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    273            int r = 0;
    274            GUI_DEBUG_LOG("\nLCD_Init...");
    275            LCD_SetClipRectMax();
   \   00000002   0x.... 0x....      BL       LCD_SetClipRectMax
    276            r |= LCD_L0_Init();
   \   00000006   0x.... 0x....      BL       LCD_L0_Init
   \   0000000A   0x4604             MOV      R4,R0
    277            #if GUI_NUM_LAYERS > 1
    278              r |= LCD_L0_1_Init();
    279            #endif
    280            #if GUI_NUM_LAYERS > 2
    281              r |= LCD_L0_2_Init();
    282            #endif
    283            #if GUI_NUM_LAYERS > 3
    284              r |= LCD_L0_3_Init();
    285            #endif
    286            #if GUI_NUM_LAYERS > 4
    287              r |= LCD_L0_4_Init();
    288            #endif
    289            LCD_InitLUT();
   \   0000000C   0x.... 0x....      BL       LCD_InitLUT
    290            {
    291            #if GUI_NUM_LAYERS > 1
    292              int i;
    293              for (i = GUI_NUM_LAYERS - 1; i >= 0; i--) {
    294                GUI_SelectLayer(i);
    295            #else
    296              {
    297            #endif
    298                #if (GUI_DEFAULT_BKCOLOR != GUI_INVALID_COLOR)
    299                  /* Clear video memory */
    300                  LCD_SetDrawMode(GUI_DRAWMODE_REV);
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x.... 0x....      BL       LCD_SetDrawMode
    301                  LCD_FillRect(0,0, GUI_XMAX, GUI_YMAX);
   \   00000016   0xF640 0x72FF      MOVW     R2,#+4095
   \   0000001A   0x4613             MOV      R3,R2
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0x.... 0x....      BL       LCD_FillRect
    302                  LCD_SetDrawMode(0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       LCD_SetDrawMode
    303                #endif
    304              }
    305            }
    306            /* Switch LCD on */
    307            LCD_On();
   \   0000002A   0x.... 0x....      BL       LCD_L0_On
    308            return r;
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    309          }
    310          
    311          /*********************************************************************
    312          *
    313          *       LCD_Color2Index
    314          */

   \                                 In section .text, align 2, keep-with-next
    315          int LCD_Color2Index(LCD_COLOR Color) {
    316            return LCDDEV_L0_Color2Index(Color);
   \                     LCD_Color2Index: (+1)
   \   00000000   0x.... 0x....      B.W      LCD_L0_Color2Index
    317          }
    318          
    319          /*********************************************************************
    320          *
    321          *       LCD_Index2Color
    322          */

   \                                 In section .text, align 2, keep-with-next
    323          LCD_COLOR LCD_Index2Color(int Index) {
    324            return LCDDEV_L0_Index2Color(Index);
   \                     LCD_Index2Color: (+1)
   \   00000000   0x.... 0x....      B.W      LCD_L0_Index2Color
    325          }
    326          
    327          /*********************************************************************
    328          *
    329          *       LCD_SetBkColor
    330          */

   \                                 In section .text, align 2, keep-with-next
    331          void LCD_SetBkColor(GUI_COLOR color) {
   \                     LCD_SetBkColor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    332            if (GUI_Context.BkColor != color) {
   \   00000002   0x....             LDR.N    R1,??DataTable10
   \   00000004   0x6B4A             LDR      R2,[R1, #+52]
   \   00000006   0x4282             CMP      R2,R0
   \   00000008   0xD005             BEQ.N    ??LCD_SetBkColor_0
    333              GUI_Context.BkColor = color;
   \   0000000A   0x6348             STR      R0,[R1, #+52]
    334              LCD_SetBkColorIndex(LCD_Color2Index(color));
   \   0000000C   0x.... 0x....      BL       LCD_Color2Index
   \   00000010   0xE8BD 0x4002      POP      {R1,LR}
   \   00000014   0x....             B.N      LCD_SetBkColorIndex
    335            }
    336          }
   \                     ??LCD_SetBkColor_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    337          
    338          /*********************************************************************
    339          *
    340          *       LCD_SetColor
    341          */

   \                                 In section .text, align 2, keep-with-next
    342          void LCD_SetColor(GUI_COLOR color) {
   \                     LCD_SetColor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    343            if (GUI_Context.Color != color) {
   \   00000002   0x....             LDR.N    R1,??DataTable10
   \   00000004   0x6B0A             LDR      R2,[R1, #+48]
   \   00000006   0x4282             CMP      R2,R0
   \   00000008   0xD005             BEQ.N    ??LCD_SetColor_0
    344              GUI_Context.Color = color;
   \   0000000A   0x6308             STR      R0,[R1, #+48]
    345              LCD_SetColorIndex(LCD_Color2Index(color));
   \   0000000C   0x.... 0x....      BL       LCD_Color2Index
   \   00000010   0xE8BD 0x4002      POP      {R1,LR}
   \   00000014   0x....             B.N      LCD_SetColorIndex
    346            }
    347          }
   \                     ??LCD_SetColor_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     GUI_pLCD_APIList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     GUI_Context+0x4
    348          
    349          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LCD_Color2Index
         0   -> LCD_L0_Color2Index
      72   LCD_DrawBitmap
        72   -- Indirect call
        72   -> LCD_FillRect
        72   -> LCD_L0_DrawBitmap
       8   LCD_DrawHLine
         0   -> LCD_L0_DrawHLine
       0   LCD_DrawPixel
         0   -> LCD_L0_SetPixelIndex
         0   -> LCD_L0_XorPixel
      16   LCD_FillRect
         0   -> LCD_L0_FillRect
       0   LCD_Index2Color
         0   -> LCD_L0_Index2Color
       8   LCD_Init
         8   -> LCD_FillRect
         8   -> LCD_InitLUT
         8   -> LCD_L0_Init
         8   -> LCD_L0_On
         8   -> LCD_SetClipRectMax
         8   -> LCD_SetDrawMode
       8   LCD_SetBkColor
         8   -> LCD_Color2Index
         0   -> LCD_SetBkColorIndex
       8   LCD_SetBkColorIndex
         8   -> _GetColorIndex
       0   LCD_SetClipRectMax
         0   -> LCD_L0_GetRect
       8   LCD_SetColor
         8   -> LCD_Color2Index
         0   -> LCD_SetColorIndex
       8   LCD_SetColorIndex
         8   -> _GetColorIndex
       4   LCD_SetDrawMode
       0   _GetColorIndex


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  LCD_Color2Index
     468  LCD_DrawBitmap
      54  LCD_DrawHLine
      52  LCD_DrawPixel
      64  LCD_FillRect
       4  LCD_Index2Color
      50  LCD_Init
      24  LCD_SetBkColor
      18  LCD_SetBkColorIndex
       6  LCD_SetClipRectMax
      24  LCD_SetColor
      18  LCD_SetColorIndex
      30  LCD_SetDrawMode
      12  _GetColorIndex

 
 840 bytes in section .text
 
 840 bytes of CODE memory

Errors: none
Warnings: none
