###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  17:01:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\WM\WM.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\WM\WM.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\WM.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\WM.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\WM\WM.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : WM.C
     16          Purpose     : Windows manager core
     17          ----------------------------------------------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include <string.h>           /* required for memset */
     22          
     23          #define WM_C
     24          #include "WM_Intern_ConfDep.h"
     25          
     26          #if GUI_WINSUPPORT    /* If 0, WM will not generate any code */
     27          
     28          /*********************************************************************
     29          *
     30          *                 Macros for internal use
     31          *
     32          **********************************************************************
     33          */
     34          
     35          #define ASSIGN_IF_LESS(v0,v1) if (v1<v0) v0=v1
     36          
     37          /*********************************************************************
     38          *
     39          *              Local typedefs
     40          *
     41          **********************************************************************
     42          */
     43          
     44          typedef struct {
     45            GUI_RECT ClientRect;
     46            GUI_RECT CurRect;
     47            int Cnt;
     48            int EntranceCnt;
     49          } WM_IVR_CONTEXT;
     50          
     51          /*********************************************************************
     52          *
     53          *              global data
     54          *
     55          **********************************************************************
     56          */
     57          
     58          U8                     WM_IsActive;
     59          U16                    WM__CreateFlags;
     60          WM_HWIN                WM__hCapture;
     61          WM_HWIN                WM__hWinFocus;
     62          char                   WM__CaptureReleaseAuto;
     63          WM_tfPollPID*          WM_pfPollPID;
     64          U8                     WM__PaintCallbackCnt;      /* Public for assertions only */
     65          GUI_PID_STATE          WM_PID__StateLast;
     66          
     67          #if WM_SUPPORT_TRANSPARENCY
     68            int                    WM__TransWindowCnt;
     69            WM_HWIN                WM__hATransWindow;
     70          #endif
     71          
     72          #if WM_SUPPORT_DIAG
     73            void (*WM__pfShowInvalid)(WM_HWIN hWin);
     74          #endif
     75          
     76          /*********************************************************************
     77          *
     78          *              static data
     79          *
     80          **********************************************************************
     81          */
     82          
     83          static WM_HWIN        NextDrawWin;
     84          static WM_IVR_CONTEXT _ClipContext;
     85          static char           _IsInited;
     86          
     87          /*********************************************************************
     88          *
     89          *       Static routines
     90          *
     91          **********************************************************************
     92          */
     93          /*********************************************************************
     94          *
     95          *       _CheckCriticalHandles
     96          *
     97          * Purpose:
     98          *   Checks the critical handles and resets the matching one
     99          */

   \                                 In section .text, align 2, keep-with-next
    100          static void _CheckCriticalHandles(WM_HWIN hWin) {
    101            WM_CRITICAL_HANDLE * pCH;
    102            for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
   \                     _CheckCriticalHandles: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xE006             B.N      ??_CheckCriticalHandles_0
    103              if (pCH->hWin == hWin) {
   \                     ??_CheckCriticalHandles_1: (+1)
   \   00000008   0xF9B1 0x2004      LDRSH    R2,[R1, #+4]
   \   0000000C   0x4282             CMP      R2,R0
   \   0000000E   0xD101             BNE.N    ??_CheckCriticalHandles_2
    104                pCH->hWin = 0;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x808A             STRH     R2,[R1, #+4]
    105              }
    106            }
   \                     ??_CheckCriticalHandles_2: (+1)
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \                     ??_CheckCriticalHandles_0: (+1)
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD1F6             BNE.N    ??_CheckCriticalHandles_1
    107          }
   \   0000001A   0x4770             BX       LR               ;; return
    108          
    109          /*********************************************************************
    110          *
    111          *       _DesktopHandle2Index
    112          *
    113          * Function:
    114          *   Convert the given desktop window into the display index.
    115          *
    116          * Return value:
    117          *   Desktop index if window handle is valid.
    118          *   else: -1
    119          */

   \                                 In section .text, align 2, keep-with-next
    120          static int _DesktopHandle2Index(WM_HWIN hDesktop) {
    121          #if GUI_NUM_LAYERS > 1
    122            int i;
    123            for (i = 0; i < GUI_NUM_LAYERS; i++) {
    124              if (hDesktop == WM__ahDesktopWin[i]) {
    125                return i;
    126              }
    127            }
    128          #else
    129            if (hDesktop == WM__ahDesktopWin[0]) {
   \                     _DesktopHandle2Index: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   00000004   0xF9B1 0x1022      LDRSH    R1,[R1, #+34]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD101             BNE.N    ??_DesktopHandle2Index_0
    130              return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
    131            }
    132          #endif
    133            return -1;
   \                     ??_DesktopHandle2Index_0: (+1)
   \   00000010   0xF04F 0x30FF      MOV      R0,#-1
   \   00000014   0x4770             BX       LR               ;; return
    134          }
    135          
    136          /*********************************************************************
    137          *
    138          *       _Invalidate1Abs
    139          *
    140          *  Invalidate given window, using absolute coordinates
    141          */

   \                                 In section .text, align 2, keep-with-next
    142          static void _Invalidate1Abs(WM_HWIN hWin, const GUI_RECT*pRect) {
   \                     _Invalidate1Abs: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x460D             MOV      R5,R1
    143            GUI_RECT r;
    144            WM_Obj* pWin;
    145            int Status;
    146            pWin = WM_H2P(hWin);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000A   0x4604             MOV      R4,R0
    147            Status = pWin->Status;
   \   0000000C   0x8BA0             LDRH     R0,[R4, #+28]
    148            if ((Status & WM_SF_ISVIS) == 0) {
   \   0000000E   0x0781             LSLS     R1,R0,#+30
   \   00000010   0xD52D             BPL.N    ??_Invalidate1Abs_0
    149              return;   /* Window is not visible... we are done */
    150            }
    151            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
   \   00000012   0xF640 0x0101      MOVW     R1,#+2049
   \   00000016   0x4008             ANDS     R0,R1,R0
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD028             BEQ.N    ??_Invalidate1Abs_0
    152              return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
    153            }
    154            if (WM__RectIsNZ(pRect) == 0) {
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       WM__RectIsNZ
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD023             BEQ.N    ??_Invalidate1Abs_0
    155              return;   /* Nothing to do ... */
    156            }
    157            /* Calc affected area */
    158            GUI__IntersectRects(&r, pRect, &pWin->Rect);
   \   00000026   0x4622             MOV      R2,R4
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       GUI__IntersectRects
    159            if (WM__RectIsNZ(&r)) {
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       WM__RectIsNZ
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD019             BEQ.N    ??_Invalidate1Abs_0
    160              #if WM_SUPPORT_NOTIFY_VIS_CHANGED
    161                WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
    162              #endif
    163          
    164              if (pWin->Status & WM_SF_INVALID) {
   \   0000003A   0x7F20             LDRB     R0,[R4, #+28]
   \   0000003C   0x0680             LSLS     R0,R0,#+26
   \   0000003E   0xD507             BPL.N    ??_Invalidate1Abs_1
    165                GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
   \   00000040   0xAA00             ADD      R2,SP,#+0
   \   00000042   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000046   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000004A   0x.... 0x....      BL       GUI_MergeRect
   \   0000004E   0xBD37             POP      {R0-R2,R4,R5,PC}
    166              } else {
    167                pWin->InvalidRect = r;
   \                     ??_Invalidate1Abs_1: (+1)
   \   00000050   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x2208             MOVS     R2,#+8
   \   00000058   0x.... 0x....      BL       __aeabi_memcpy
    168                pWin->Status |= WM_SF_INVALID;
   \   0000005C   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000005E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000062   0x83A0             STRH     R0,[R4, #+28]
    169                WM__NumInvalidWindows++;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000068   0x8BC1             LDRH     R1,[R0, #+30]
   \   0000006A   0x1C49             ADDS     R1,R1,#+1
   \   0000006C   0x83C1             STRH     R1,[R0, #+30]
    170                /* Optional code: Call external routine to notify that drawing is required */
    171                #ifdef GUI_X_REDRAW
    172                {
    173                  GUI_RECT r;
    174                  r = pWin->Rect;
    175                  if (WM__ClipAtParentBorders(&r,  hWin)) {
    176                    GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
    177                  }
    178                }
    179                #endif
    180                GUI_X_SIGNAL_EVENT();
    181              }
    182              /* Debug code: shows invalid areas */
    183              #if (WM_SUPPORT_DIAG)
    184                if (WM__pfShowInvalid) {
    185                  (WM__pfShowInvalid)(hWin);
    186                }
    187              #endif
    188            }
    189          }
   \                     ??_Invalidate1Abs_0: (+1)
   \   0000006E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    190          
    191          /*********************************************************************
    192          *
    193          *       _GetTopLevelWindow
    194          */
    195          #if GUI_NUM_LAYERS > 1
    196          static WM_HWIN _GetTopLevelWindow(WM_HWIN hWin) {
    197            WM_Obj* pWin;
    198            WM_HWIN hTop;
    199            while (hTop = hWin, pWin = WM_H2P(hWin), (hWin = pWin->hParent) != 0) {
    200            }
    201            return hTop;
    202          }
    203          #endif
    204          
    205          /*********************************************************************
    206          *
    207          *       ResetNextDrawWin
    208          
    209            When drawing, we have to start at the bottom window !
    210          */

   \                                 In section .text, align 2, keep-with-next
    211          static void ResetNextDrawWin(void) {
    212            NextDrawWin = WM_HWIN_NULL;
   \                     ResetNextDrawWin: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000006   0x8588             STRH     R0,[R1, #+44]
    213          }
   \   00000008   0x4770             BX       LR               ;; return
    214          
    215          
    216          /*********************************************************************
    217          *
    218          *       _GethDrawWin
    219          *
    220          * Return Window being drawn.
    221          * Normally same as pAWin, except if overlaying transparent window is drawn
    222          *
    223          */

   \                                 In section .text, align 2, keep-with-next
    224          static WM_HWIN _GethDrawWin(void) {
   \                     _GethDrawWin: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000004   0xF9B0 0x002A      LDRSH    R0,[R0, #+42]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD103             BNE.N    ??_GethDrawWin_0
    225            WM_HWIN h;
    226            #if WM_SUPPORT_TRANSPARENCY
    227              if (WM__hATransWindow) {
    228                h = WM__hATransWindow;
    229              } else
    230            #endif
    231            {
    232              h = GUI_Context.hAWin;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000010   0xF9B0 0x003C      LDRSH    R0,[R0, #+60]
    233            }
    234            return h;
   \                     ??_GethDrawWin_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    235          }
    236          
    237          
    238          
    239          
    240          
    241          /*********************************************************************
    242          *
    243          *       _SetClipRectUserIntersect
    244          */

   \                                 In section .text, align 2, keep-with-next
    245          static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
   \                     _SetClipRectUserIntersect: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000008   0x6B81             LDR      R1,[R0, #+56]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD103             BNE.N    ??_SetClipRectUserIntersect_0
    246            if (GUI_Context.WM__pUserClipRect == NULL) {
    247              LCD_SetClipRectEx(prSrc);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       LCD_SetClipRectEx
   \   00000014   0xBD13             POP      {R0,R1,R4,PC}
    248            } else {
    249              GUI_RECT r;
    250              r = *GUI_Context.WM__pUserClipRect;             
   \                     ??_SetClipRectUserIntersect_0: (+1)
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x2208             MOVS     R2,#+8
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy
    251              WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
   \   0000001E   0x.... 0x....      BL       _GethDrawWin
   \   00000022   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000026   0xA900             ADD      R1,SP,#+0
   \   00000028   0x.... 0x....      BL       WM__Client2Screen
    252              /* Set intersection as clip rect */    
    253              GUI__IntersectRect(&r, prSrc);
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       GUI__IntersectRect
    254              LCD_SetClipRectEx(&r);
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       LCD_SetClipRectEx
    255            }
    256          }
   \   0000003A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    257          
    258          
    259          /*********************************************************************
    260          *
    261          *       Public routines
    262          *
    263          **********************************************************************
    264          */
    265          /*********************************************************************
    266          *
    267          *       WM__ClipAtParentBorders
    268          *
    269          * Function:
    270          *   Iterates over the window itself and all its ancestors.
    271          *   Intersects all rectangles to
    272          *   find out which part is actually visible.
    273          *   Reduces the rectangle to the visible area.
    274          *   This routines takes into account both the rectangles of the
    275          *   ancestors as well as the WM_SF_ISVIS flag.
    276          *
    277          * Parameters
    278          *   hWin    Obvious
    279          *   pRect   Pointer to the rectangle to be clipped. May not be NULL.
    280          *           The parameter is IN/OUT.
    281          *           Note that the rectangle is clipped only if the return
    282          *           value indicates a valid rectangle remains.
    283          *
    284          * Return value:
    285          *   1: Something is or may be visible.
    286          *   0: Nothing is visible (outside of ancestors, no desktop, hidden)
    287          */

   \                                 In section .text, align 2, keep-with-next
    288          int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
   \                     WM__ClipAtParentBorders: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xE000             B.N      ??WM__ClipAtParentBorders_0
    289            WM_Obj* pWin;
    290          
    291            /* Iterate up the window hierarchy.
    292               If the window is invisible, we are done.
    293               Clip at parent boarders.
    294               We are done with iterating if hWin has no parent.
    295            */
    296            do {
    297              pWin = WM_H2P(hWin);
    298              if ((pWin->Status & WM_SF_ISVIS) == 0) {
    299                return 0;                     /* Invisible */
    300              }
    301              GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
    302              if (pWin->hParent == 0) {
    303                break;   /* hWin is now the top level window which has no parent */
    304              }
    305              hWin = pWin->hParent;                    /* Go one level up (parent)*/
   \                     ??WM__ClipAtParentBorders_1: (+1)
   \   00000008   0x4605             MOV      R5,R0
    306            } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
   \                     ??WM__ClipAtParentBorders_0: (+1)
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4606             MOV      R6,R0
   \   00000012   0x7F30             LDRB     R0,[R6, #+28]
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xD401             BMI.N    ??WM__ClipAtParentBorders_2
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD70             POP      {R4-R6,PC}
   \                     ??WM__ClipAtParentBorders_2: (+1)
   \   0000001C   0x4631             MOV      R1,R6
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       GUI__IntersectRect
   \   00000024   0xF9B6 0x0016      LDRSH    R0,[R6, #+22]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1ED             BNE.N    ??WM__ClipAtParentBorders_1
    307            
    308            /* Now check if the top level window is a desktop window. If it is not,
    309              then the window is not visible.
    310            */
    311            if (_DesktopHandle2Index(hWin) < 0) {
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       _DesktopHandle2Index
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD501             BPL.N    ??WM__ClipAtParentBorders_3
    312              return 0;           /* No desktop - (unattached) - Nothing to draw */
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}
    313            }
    314            return 1;               /* Something may be visible */
   \                     ??WM__ClipAtParentBorders_3: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    315          }
    316          
    317          /*********************************************************************
    318          *
    319          *       WM__ActivateClipRect
    320          */

   \                                 In section .text, align 2, keep-with-next
    321          void  WM__ActivateClipRect(void) {
   \                     WM__ActivateClipRect: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    322            if (WM_IsActive) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   00000006   0x7E20             LDRB     R0,[R4, #+24]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??WM__ActivateClipRect_0
    323              _SetClipRectUserIntersect(&_ClipContext.CurRect);
   \   0000000C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000010   0x.... 0x....      BL       _SetClipRectUserIntersect
   \   00000014   0xBD13             POP      {R0,R1,R4,PC}
    324            } else {    /* Window manager disabled, typically because meory device is active */
    325              GUI_RECT r;
    326              WM_Obj *pAWin;
    327              pAWin = WM_H2P(GUI_Context.hAWin);
   \                     ??WM__ActivateClipRect_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   0000001A   0xF9B0 0x003C      LDRSH    R0,[R0, #+60]
   \   0000001E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000022   0x4601             MOV      R1,R0
    328              r = pAWin->Rect;
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy
    329              #if WM_SUPPORT_TRANSPARENCY
    330                if (WM__hATransWindow) {
   \   0000002C   0xF9B4 0x102A      LDRSH    R1,[R4, #+42]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD002             BEQ.N    ??WM__ActivateClipRect_1
    331                  WM__ClipAtParentBorders(&r, WM__hATransWindow);
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       WM__ClipAtParentBorders
    332                }
    333              #endif
    334              /* Take UserClipRect into account */
    335              _SetClipRectUserIntersect(&r);
   \                     ??WM__ActivateClipRect_1: (+1)
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x.... 0x....      BL       _SetClipRectUserIntersect
    336            }
    337          }
   \   00000040   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    338          
    339          
    340          
    341          
    342          /*********************************************************************
    343          *
    344          *       WM__InsertWindowIntoList
    345          *
    346          * Routine describtion
    347          *   This routine inserts the window in the list of child windows for
    348          *   a particular parent window.
    349          *   The window is placed on top of all siblings with the same level.
    350          */

   \                                 In section .text, align 2, keep-with-next
    351          void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
   \                     WM__InsertWindowIntoList: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x000E             MOVS     R6,R1
    352            int OnTop;
    353            WM_HWIN hi;
    354            WM_Obj * pWin;
    355            WM_Obj * pParent;
    356            WM_Obj * pi;
    357          
    358            if (hParent) {
   \   00000008   0xD034             BEQ.N    ??WM__InsertWindowIntoList_0
    359              pWin = WM_H2P(hWin);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4605             MOV      R5,R0
    360              pWin->hNext = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x8368             STRH     R0,[R5, #+26]
    361              pWin->hParent = hParent;
   \   00000014   0x82EE             STRH     R6,[R5, #+22]
    362              pParent = WM_H2P(hParent);
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001C   0x4606             MOV      R6,R0
    363              OnTop   = pWin->Status & WM_CF_STAYONTOP;
   \   0000001E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000020   0xF000 0x0708      AND      R7,R0,#0x8
    364              hi = pParent->hFirstChild;
   \   00000024   0xF9B6 0x9018      LDRSH    R9,[R6, #+24]
    365              /* Put it at beginning of the list if there is no child */
    366              if (hi == 0) {   /* No child yet ... Makes things easy ! */
   \   00000028   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002C   0xD101             BNE.N    ??WM__InsertWindowIntoList_1
    367                pParent->hFirstChild = hWin;
   \   0000002E   0x8334             STRH     R4,[R6, #+24]
    368                return;                         /* Early out ... We are done */
   \   00000030   0xE020             B.N      ??WM__InsertWindowIntoList_0
    369              }
    370              /* Put it at beginning of the list if first child is a TOP window and new one is not */
    371              pi = WM_H2P(hi);
   \                     ??WM__InsertWindowIntoList_1: (+1)
   \   00000032   0x4648             MOV      R0,R9
   \   00000034   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000038   0x4680             MOV      R8,R0
    372              if (!OnTop) {
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD108             BNE.N    ??WM__InsertWindowIntoList_2
    373                if (pi->Status & WM_SF_STAYONTOP) {
   \   0000003E   0xF898 0x001C      LDRB     R0,[R8, #+28]
   \   00000042   0x0700             LSLS     R0,R0,#+28
   \   00000044   0xD504             BPL.N    ??WM__InsertWindowIntoList_2
    374                  pWin->hNext = hi;
   \   00000046   0xF8A5 0x901A      STRH     R9,[R5, #+26]
    375                  pParent->hFirstChild = hWin;
   \   0000004A   0x8334             STRH     R4,[R6, #+24]
    376                  return;                         /* Early out ... We are done */
   \   0000004C   0xE012             B.N      ??WM__InsertWindowIntoList_0
    377                }
    378              }
    379              /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
    380              do {
    381                WM_Obj* pNext;
    382                WM_HWIN hNext;
    383                if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
    384                  pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
    385                  break;
    386                }
    387                pNext = WM_H2P(hNext);
    388                if (!OnTop) {
    389                  if (pNext->Status & WM_SF_STAYONTOP) {
    390                    pi->hNext = hWin;
    391                    pWin->hNext = hNext;
    392                    break;
    393                  }
    394                }
    395                pi = pNext;
   \                     ??WM__InsertWindowIntoList_3: (+1)
   \   0000004E   0x4680             MOV      R8,R0
    396              }  while (1);
   \                     ??WM__InsertWindowIntoList_2: (+1)
   \   00000050   0xF9B8 0x601A      LDRSH    R6,[R8, #+26]
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD102             BNE.N    ??WM__InsertWindowIntoList_4
   \   00000058   0xF8A8 0x401A      STRH     R4,[R8, #+26]
   \   0000005C   0xE00A             B.N      ??WM__InsertWindowIntoList_0
   \                     ??WM__InsertWindowIntoList_4: (+1)
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000064   0x2F00             CMP      R7,#+0
   \   00000066   0xD1F2             BNE.N    ??WM__InsertWindowIntoList_3
   \   00000068   0x7F01             LDRB     R1,[R0, #+28]
   \   0000006A   0x0709             LSLS     R1,R1,#+28
   \   0000006C   0xD5EF             BPL.N    ??WM__InsertWindowIntoList_3
   \   0000006E   0xF8A8 0x401A      STRH     R4,[R8, #+26]
   \   00000072   0x836E             STRH     R6,[R5, #+26]
    397              #if WM_SUPPORT_NOTIFY_VIS_CHANGED
    398                WM__NotifyVisChanged(hWin, &pWin->Rect);
    399              #endif
    400            }
    401          }
   \                     ??WM__InsertWindowIntoList_0: (+1)
   \   00000074   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    402          
    403          /*********************************************************************
    404          *
    405          *       WM__RemoveWindowFromList
    406          */

   \                                 In section .text, align 2, keep-with-next
    407          void WM__RemoveWindowFromList(WM_HWIN hWin) {
   \                     WM__RemoveWindowFromList: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    408            WM_HWIN hi, hParent;
    409            WM_Obj * pWin, * pParent, * pi;
    410            
    411            pWin = WM_H2P(hWin);
   \   00000004   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000008   0x4605             MOV      R5,R0
    412            hParent = pWin->hParent;
   \   0000000A   0xF9B5 0x0016      LDRSH    R0,[R5, #+22]
    413            if (hParent) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD017             BEQ.N    ??WM__RemoveWindowFromList_0
    414              pParent = WM_H2P(hParent);
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000016   0x4606             MOV      R6,R0
    415              hi = pParent->hFirstChild;
   \   00000018   0xF9B6 0x1018      LDRSH    R1,[R6, #+24]
    416              if (hi == hWin) {
   \   0000001C   0x42A1             CMP      R1,R4
   \   0000001E   0xD105             BNE.N    ??WM__RemoveWindowFromList_1
    417                pi = WM_H2P(hi);
   \   00000020   0x4608             MOV      R0,R1
   \   00000022   0x.... 0x....      BL       GUI_ALLOC_h2p
    418                pParent->hFirstChild = pi->hNext;
   \   00000026   0x8B40             LDRH     R0,[R0, #+26]
   \   00000028   0x8330             STRH     R0,[R6, #+24]
   \   0000002A   0xBD70             POP      {R4-R6,PC}
    419              } else {
    420                while (hi) {
    421                  pi = WM_H2P(hi);
    422                  if (pi->hNext == hWin) {
    423                    pi->hNext = pWin->hNext;
    424                    break;
    425                  }
    426                  hi = pi->hNext;
   \                     ??WM__RemoveWindowFromList_1: (+1)
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD008             BEQ.N    ??WM__RemoveWindowFromList_0
   \   00000030   0x4608             MOV      R0,R1
   \   00000032   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000036   0xF9B0 0x101A      LDRSH    R1,[R0, #+26]
   \   0000003A   0x42A1             CMP      R1,R4
   \   0000003C   0xD1F6             BNE.N    ??WM__RemoveWindowFromList_1
   \   0000003E   0x8B69             LDRH     R1,[R5, #+26]
   \   00000040   0x8341             STRH     R1,[R0, #+26]
    427                }
    428              }
    429            }
    430          }
   \                     ??WM__RemoveWindowFromList_0: (+1)
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    431          
    432          /*********************************************************************
    433          *
    434          *       WM__DetachWindow
    435          *
    436          * Detaches the given window. The window still exists, it keeps all
    437          * children, but it is no longer visible since it is taken out of
    438          * the tree of the desktop window.
    439          */

   \                                 In section .text, align 2, keep-with-next
    440          void WM__DetachWindow(WM_HWIN hWin) {
   \                     WM__DetachWindow: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    441            WM_Obj* pWin;
    442            WM_HWIN hParent;
    443            pWin = WM_H2P(hWin);
   \   00000004   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000008   0x4605             MOV      R5,R0
    444            hParent = pWin->hParent;
    445            if (hParent) {
   \   0000000A   0xF9B5 0x0016      LDRSH    R0,[R5, #+22]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD007             BEQ.N    ??WM__DetachWindow_0
    446              WM__RemoveWindowFromList(hWin);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       WM__RemoveWindowFromList
    447              /* Clear area used by this window */
    448              WM_InvalidateArea(&pWin->Rect);
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       WM_InvalidateArea
    449              pWin->hParent = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x82E8             STRH     R0,[R5, #+22]
    450            }
    451          }
   \                     ??WM__DetachWindow_0: (+1)
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    452          
    453          
    454          /*********************************************************************
    455          *
    456          *       _DeleteAllChildren
    457          */

   \                                 In section .text, align 2, keep-with-next
    458          static void _DeleteAllChildren(WM_HWIN hChild) {
   \                     _DeleteAllChildren: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xE008             B.N      ??_DeleteAllChildren_0
    459            while (hChild) {
    460              WM_Obj* pChild = WM_H2P(hChild);
   \                     ??_DeleteAllChildren_1: (+1)
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_h2p
    461              WM_HWIN hNext = pChild->hNext;
   \   0000000C   0xF9B0 0x501A      LDRSH    R5,[R0, #+26]
    462              WM_DeleteWindow(hChild);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       WM_DeleteWindow
    463              hChild = hNext;
   \   00000016   0x002C             MOVS     R4,R5
    464            }
   \                     ??_DeleteAllChildren_0: (+1)
   \   00000018   0xD1F5             BNE.N    ??_DeleteAllChildren_1
    465          }
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    466          
    467          /*********************************************************************
    468          *
    469          *             Module internal routines
    470          *
    471          **********************************************************************
    472          */
    473          /*********************************************************************
    474          *
    475          *       WM__Client2Screen
    476          */

   \                                 In section .text, align 2, keep-with-next
    477          void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
   \                     WM__Client2Screen: (+1)
   \   00000000   0x460B             MOV      R3,R1
    478            GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
   \   00000002   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   00000006   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000000A   0x4618             MOV      R0,R3
   \   0000000C   0x.... 0x....      B.W      GUI_MoveRect
    479          }
    480          
    481          /*********************************************************************
    482          *
    483          *       WM__IsWindow
    484          */

   \                                 In section .text, align 2, keep-with-next
    485          int WM__IsWindow(WM_HWIN hWin) {
   \                     WM__IsWindow: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    486            WM_HWIN iWin;
    487            for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000008   0xF9B0 0x0020      LDRSH    R0,[R0, #+32]
   \   0000000C   0xE003             B.N      ??WM__IsWindow_0
   \                     ??WM__IsWindow_1: (+1)
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0xF9B0 0x0014      LDRSH    R0,[R0, #+20]
   \                     ??WM__IsWindow_0: (+1)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??WM__IsWindow_2
    488              if (iWin == hWin) {
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD1F7             BNE.N    ??WM__IsWindow_1
    489                return 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
    490              }
    491            }
    492            return 0;
   \                     ??WM__IsWindow_2: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    493          }
    494          
    495          /*********************************************************************
    496          *
    497          *         WM__InvalidateAreaBelow
    498          
    499            Params: pRect  Rectangle in Absolute coordinates
    500          */

   \                                 In section .text, align 2, keep-with-next
    501          void WM__InvalidateAreaBelow(const GUI_RECT* pRect, WM_HWIN StopWin) {
    502            GUI_USE_PARA(StopWin);
    503            WM_InvalidateArea(pRect);      /* Can be optimized to spare windows above */
   \                     WM__InvalidateAreaBelow: (+1)
   \   00000000   0x....             B.N      WM_InvalidateArea
    504          }
    505          
    506          /*********************************************************************
    507          *
    508          *       WM_RemoveFromLinList
    509          */

   \                                 In section .text, align 2, keep-with-next
    510          void WM__RemoveFromLinList(WM_HWIN hWin) {
   \                     WM__RemoveFromLinList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    511            WM_Obj* piWin;
    512            WM_HWIN hiWin;
    513            WM_HWIN hNext;
    514            for (hiWin = WM__FirstWin; hiWin; ) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000008   0xF9B0 0x0020      LDRSH    R0,[R0, #+32]
    515              piWin = WM_H2P(hiWin);
    516              hNext = piWin->hNextLin;
    517              if (hNext == hWin) {
    518                piWin->hNextLin = WM_H2P(hWin)->hNextLin;
    519                break;
    520              }
    521              hiWin = hNext;
   \                     ??WM__RemoveFromLinList_0: (+1)
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00B             BEQ.N    ??WM__RemoveFromLinList_1
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4605             MOV      R5,R0
   \   00000016   0xF9B5 0x0014      LDRSH    R0,[R5, #+20]
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD1F6             BNE.N    ??WM__RemoveFromLinList_0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000024   0x8A80             LDRH     R0,[R0, #+20]
   \   00000026   0x82A8             STRH     R0,[R5, #+20]
    522            }
    523          }
   \                     ??WM__RemoveFromLinList_1: (+1)
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    524          
    525          /*********************************************************************
    526          *
    527          *       _AddToLinList
    528          */

   \                                 In section .text, align 2, keep-with-next
    529          static void _AddToLinList(WM_HWIN hNew) {
   \                     _AddToLinList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    530            WM_Obj* pFirst;
    531            WM_Obj* pNew;
    532            if (WM__FirstWin) {
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000008   0xF9B1 0x0020      LDRSH    R0,[R1, #+32]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??_AddToLinList_0
    533              pFirst = WM_H2P(WM__FirstWin);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4605             MOV      R5,R0
    534              pNew   = WM_H2P(hNew);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
    535              pNew->hNextLin = pFirst->hNextLin;
   \   0000001C   0x8AA9             LDRH     R1,[R5, #+20]
   \   0000001E   0x8281             STRH     R1,[R0, #+20]
    536              pFirst->hNextLin = hNew;
   \   00000020   0x82AC             STRH     R4,[R5, #+20]
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}
    537            } else {
    538              WM__FirstWin = hNew;
   \                     ??_AddToLinList_0: (+1)
   \   00000024   0x840C             STRH     R4,[R1, #+32]
    539            }
    540          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    541          
    542          /*********************************************************************
    543          *
    544          *       WM__RectIsNZ
    545          *
    546             Check if the rectangle has some content (is non-zero)
    547             Returns 0 if the Rectangle has no content, else 1.
    548          */

   \                                 In section .text, align 2, keep-with-next
    549          int WM__RectIsNZ(const GUI_RECT* pr) {
    550            if (pr->x0 > pr->x1)
   \                     WM__RectIsNZ: (+1)
   \   00000000   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   00000004   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xDA01             BGE.N    ??WM__RectIsNZ_0
    551              return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
    552            if (pr->y0 > pr->y1)
   \                     ??WM__RectIsNZ_0: (+1)
   \   00000010   0xF9B0 0x1006      LDRSH    R1,[R0, #+6]
   \   00000014   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000018   0x4281             CMP      R1,R0
   \   0000001A   0xDA01             BGE.N    ??WM__RectIsNZ_1
    553              return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR
    554            return 1;
   \                     ??WM__RectIsNZ_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4770             BX       LR               ;; return
    555          }
    556          
    557          /*********************************************************************
    558          *
    559          *        _Findy1
    560          *
    561          */

   \                                 In section .text, align 2, keep-with-next
    562          static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
   \                     _Findy1: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0xE00F             B.N      ??_Findy1_0
    563            WM_Obj* pWin;
    564            for (; iWin; iWin = pWin->hNext) { 
    565              int Status = (pWin = WM_H2P(iWin))->Status;
    566              /* Check if this window affects us at all */    
    567              if (Status & WM_SF_ISVIS) {
    568                GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
    569                if (pParentRect) {
    570                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
    571                } else {
    572                  rWinClipped = pWin->Rect;
    573                }
    574                /* Check if this window affects us at all */    
    575                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
    576                  if ((Status & WM_SF_HASTRANS) == 0) {
    577                    if (pWin->Rect.y0 > pRect->y0) {
    578                      ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
    579                    } else {
    580                      ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
    581                    }
    582                  } else {
    583                    /* Check all children*/ 
    584                    WM_HWIN hChild;
    585                    WM_Obj* pChild;
    586                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
    587                      pChild = WM_H2P(hChild);
   \                     ??_Findy1_1: (+1)
   \   0000000A   0x4640             MOV      R0,R8
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4607             MOV      R7,R0
    588                      _Findy1(hChild, pRect, &rWinClipped);
   \   00000012   0xAA00             ADD      R2,SP,#+0
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4640             MOV      R0,R8
   \   00000018   0xF7FF 0xFFF2      BL       _Findy1
    589                    }
   \   0000001C   0xF9B7 0x801A      LDRSH    R8,[R7, #+26]
   \                     ??_Findy1_2: (+1)
   \   00000020   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000024   0xD1F1             BNE.N    ??_Findy1_1
   \                     ??_Findy1_3: (+1)
   \   00000026   0xF9B6 0x001A      LDRSH    R0,[R6, #+26]
   \                     ??_Findy1_0: (+1)
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD033             BEQ.N    ??_Findy1_4
   \   0000002E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000032   0x4606             MOV      R6,R0
   \   00000034   0x8BB7             LDRH     R7,[R6, #+28]
   \   00000036   0x07B8             LSLS     R0,R7,#+30
   \   00000038   0xD5F5             BPL.N    ??_Findy1_3
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD005             BEQ.N    ??_Findy1_5
   \   0000003E   0x462A             MOV      R2,R5
   \   00000040   0x4631             MOV      R1,R6
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       GUI__IntersectRects
   \   00000048   0xE004             B.N      ??_Findy1_6
   \                     ??_Findy1_5: (+1)
   \   0000004A   0xA800             ADD      R0,SP,#+0
   \   0000004C   0x4631             MOV      R1,R6
   \   0000004E   0x2208             MOVS     R2,#+8
   \   00000050   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??_Findy1_6: (+1)
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       GUI_RectsIntersect
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD0E2             BEQ.N    ??_Findy1_3
   \   00000060   0x07F8             LSLS     R0,R7,#+31
   \   00000062   0xD415             BMI.N    ??_Findy1_7
   \   00000064   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000068   0xF9B4 0x1002      LDRSH    R1,[R4, #+2]
   \   0000006C   0xF9B6 0x2002      LDRSH    R2,[R6, #+2]
   \   00000070   0x4291             CMP      R1,R2
   \   00000072   0xDA07             BGE.N    ??_Findy1_8
   \   00000074   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000078   0x1E4A             SUBS     R2,R1,#+1
   \   0000007A   0x4282             CMP      R2,R0
   \   0000007C   0xDAD3             BGE.N    ??_Findy1_3
   \   0000007E   0x1E48             SUBS     R0,R1,#+1
   \   00000080   0x80E0             STRH     R0,[R4, #+6]
   \   00000082   0xE7D0             B.N      ??_Findy1_3
   \                     ??_Findy1_8: (+1)
   \   00000084   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000088   0x4281             CMP      R1,R0
   \   0000008A   0xDACC             BGE.N    ??_Findy1_3
   \   0000008C   0x80E1             STRH     R1,[R4, #+6]
   \   0000008E   0xE7CA             B.N      ??_Findy1_3
   \                     ??_Findy1_7: (+1)
   \   00000090   0xF9B6 0x8018      LDRSH    R8,[R6, #+24]
   \   00000094   0xE7C4             B.N      ??_Findy1_2
    590                  }
    591                }
    592              }
    593            }
    594          }
   \                     ??_Findy1_4: (+1)
   \   00000096   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    595          
    596          /*********************************************************************
    597          *
    598          *        _Findx0
    599          */

   \                                 In section .text, align 2, keep-with-next
    600          static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
   \                     _Findx0: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
    601            WM_Obj* pWin;
    602            int r = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0xE012             B.N      ??_Findx0_0
    603            for (; hWin; hWin = pWin->hNext) { 
    604              int Status = (pWin = WM_H2P(hWin))->Status;
    605              if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
    606                GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
    607                if (pParentRect) {
    608                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
    609                } else {
    610                  rWinClipped = pWin->Rect;
    611                }
    612                /* Check if this window affects us at all */    
    613                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
    614                  if ((Status & WM_SF_HASTRANS) == 0) {
    615                    pRect->x0 = rWinClipped.x1+1;
    616                    r = 1;
    617                  } else {
    618                    /* Check all children */
    619                    WM_HWIN hChild;
    620                    WM_Obj* pChild;
    621                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
    622                      pChild = WM_H2P(hChild);
   \                     ??_Findx0_1: (+1)
   \   0000000E   0x4648             MOV      R0,R9
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4680             MOV      R8,R0
    623                      if (_Findx0(hChild, pRect, &rWinClipped)) {
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x4648             MOV      R0,R9
   \   0000001C   0xF7FF 0xFFF0      BL       _Findx0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD000             BEQ.N    ??_Findx0_2
    624                        r = 1;
   \   00000024   0x2601             MOVS     R6,#+1
    625                      }
    626                    }
   \                     ??_Findx0_2: (+1)
   \   00000026   0xF9B8 0x901A      LDRSH    R9,[R8, #+26]
   \                     ??_Findx0_3: (+1)
   \   0000002A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002E   0xD1EE             BNE.N    ??_Findx0_1
   \                     ??_Findx0_4: (+1)
   \   00000030   0xF9B7 0x001A      LDRSH    R0,[R7, #+26]
   \                     ??_Findx0_0: (+1)
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD026             BEQ.N    ??_Findx0_5
   \   00000038   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0xF8B7 0x801C      LDRH     R8,[R7, #+28]
   \   00000042   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   00000046   0xD5F3             BPL.N    ??_Findx0_4
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD005             BEQ.N    ??_Findx0_6
   \   0000004C   0x462A             MOV      R2,R5
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0x.... 0x....      BL       GUI__IntersectRects
   \   00000056   0xE004             B.N      ??_Findx0_7
   \                     ??_Findx0_6: (+1)
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x4639             MOV      R1,R7
   \   0000005C   0x2208             MOVS     R2,#+8
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??_Findx0_7: (+1)
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       GUI_RectsIntersect
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD0E0             BEQ.N    ??_Findx0_4
   \   0000006E   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000072   0xD405             BMI.N    ??_Findx0_8
   \   00000074   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x8020             STRH     R0,[R4, #+0]
   \   0000007C   0x2601             MOVS     R6,#+1
   \   0000007E   0xE7D7             B.N      ??_Findx0_4
   \                     ??_Findx0_8: (+1)
   \   00000080   0xF9B7 0x9018      LDRSH    R9,[R7, #+24]
   \   00000084   0xE7D1             B.N      ??_Findx0_3
    627                  }
    628                }
    629              }
    630            }
    631            return r;
   \                     ??_Findx0_5: (+1)
   \   00000086   0x4630             MOV      R0,R6
   \   00000088   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    632          }
    633          
    634          /*********************************************************************
    635          *
    636          *        _Findx1
    637          */

   \                                 In section .text, align 2, keep-with-next
    638          static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
   \                     _Findx1: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0xE00F             B.N      ??_Findx1_0
    639            WM_Obj* pWin;
    640            for (; hWin; hWin = pWin->hNext) { 
    641              int Status = (pWin = WM_H2P(hWin))->Status;
    642              if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
    643                GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
    644                if (pParentRect) {
    645                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
    646                } else {
    647                  rWinClipped = pWin->Rect;
    648                }
    649                /* Check if this window affects us at all */    
    650                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
    651                  if ((Status & WM_SF_HASTRANS) == 0) {
    652                    pRect->x1 = rWinClipped.x0-1;
    653                  } else {
    654                    /* Check all children */
    655                    WM_HWIN hChild;
    656                    WM_Obj* pChild;
    657                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
    658                      pChild = WM_H2P(hChild);
   \                     ??_Findx1_1: (+1)
   \   0000000A   0x4640             MOV      R0,R8
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4607             MOV      R7,R0
    659                      _Findx1(hChild, pRect, &rWinClipped);
   \   00000012   0xAA00             ADD      R2,SP,#+0
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4640             MOV      R0,R8
   \   00000018   0xF7FF 0xFFF2      BL       _Findx1
    660                    }
   \   0000001C   0xF9B7 0x801A      LDRSH    R8,[R7, #+26]
   \                     ??_Findx1_2: (+1)
   \   00000020   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000024   0xD1F1             BNE.N    ??_Findx1_1
   \                     ??_Findx1_3: (+1)
   \   00000026   0xF9B6 0x001A      LDRSH    R0,[R6, #+26]
   \                     ??_Findx1_0: (+1)
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD022             BEQ.N    ??_Findx1_4
   \   0000002E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000032   0x4606             MOV      R6,R0
   \   00000034   0x8BB7             LDRH     R7,[R6, #+28]
   \   00000036   0x07B8             LSLS     R0,R7,#+30
   \   00000038   0xD5F5             BPL.N    ??_Findx1_3
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD005             BEQ.N    ??_Findx1_5
   \   0000003E   0x462A             MOV      R2,R5
   \   00000040   0x4631             MOV      R1,R6
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       GUI__IntersectRects
   \   00000048   0xE004             B.N      ??_Findx1_6
   \                     ??_Findx1_5: (+1)
   \   0000004A   0xA800             ADD      R0,SP,#+0
   \   0000004C   0x4631             MOV      R1,R6
   \   0000004E   0x2208             MOVS     R2,#+8
   \   00000050   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??_Findx1_6: (+1)
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       GUI_RectsIntersect
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD0E2             BEQ.N    ??_Findx1_3
   \   00000060   0x07F8             LSLS     R0,R7,#+31
   \   00000062   0xD404             BMI.N    ??_Findx1_7
   \   00000064   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x80A0             STRH     R0,[R4, #+4]
   \   0000006C   0xE7DB             B.N      ??_Findx1_3
   \                     ??_Findx1_7: (+1)
   \   0000006E   0xF9B6 0x8018      LDRSH    R8,[R6, #+24]
   \   00000072   0xE7D5             B.N      ??_Findx1_2
    661                  }
    662                }
    663              }
    664            }
    665          }
   \                     ??_Findx1_4: (+1)
   \   00000074   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    666          
    667          /*********************************************************************
    668          *
    669          *       Sending messages
    670          *
    671          **********************************************************************
    672          */
    673          /*********************************************************************
    674          *
    675          *       WM_SendMessage
    676          */

   \                                 In section .text, align 2, keep-with-next
    677          void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
   \                     WM_SendMessage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    678            if (hWin) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00B             BEQ.N    ??WM_SendMessage_0
    679              WM_Obj* pWin;
    680              WM_LOCK();
    681              pWin = WM_H2P(hWin);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4601             MOV      R1,R0
    682              if (pWin->cb != NULL) {
   \   00000010   0x6908             LDR      R0,[R1, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??WM_SendMessage_0
    683                pMsg->hWin = hWin;
   \   00000016   0x80AC             STRH     R4,[R5, #+4]
    684                (*pWin->cb)(pMsg);
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x6909             LDR      R1,[R1, #+16]
   \   0000001C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000020   0x4708             BX       R1
    685              }
    686              WM_UNLOCK();
    687            }
    688          }
   \                     ??WM_SendMessage_0: (+1)
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    689          
    690          /*********************************************************************
    691          *
    692          *       WM__SendMsgNoData
    693          */

   \                                 In section .text, align 2, keep-with-next
    694          void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
   \                     WM__SendMsgNoData: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    695            WM_MESSAGE Msg;
    696            Msg.hWin  = hWin;
   \   00000002   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    697            Msg.MsgId = MsgId;
   \   00000006   0x9100             STR      R1,[SP, #+0]
    698            WM_SendMessage(hWin, &Msg);
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      BL       WM_SendMessage
    699          }
   \   0000000E   0xBD07             POP      {R0-R2,PC}       ;; return
    700          
    701          /*********************************************************************
    702          *
    703          *       WM__GetClientRectWin
    704          *
    705            Get client rectangle in windows coordinates. This means that the
    706            upper left corner is always at (0,0). 
    707          */

   \                                 In section .text, align 2, keep-with-next
    708          void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
    709            pRect->x0 = pRect->y0 = 0;
   \                     WM__GetClientRectWin: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x804A             STRH     R2,[R1, #+2]
   \   00000004   0x800A             STRH     R2,[R1, #+0]
    710            pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0x8803             LDRH     R3,[R0, #+0]
   \   0000000A   0x1AD2             SUBS     R2,R2,R3
   \   0000000C   0x808A             STRH     R2,[R1, #+4]
    711            pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
   \   0000000E   0x88C2             LDRH     R2,[R0, #+6]
   \   00000010   0x8840             LDRH     R0,[R0, #+2]
   \   00000012   0x1A10             SUBS     R0,R2,R0
   \   00000014   0x80C8             STRH     R0,[R1, #+6]
    712          }
   \   00000016   0x4770             BX       LR               ;; return
    713          
    714          /*********************************************************************
    715          *
    716          *       WM__GetInvalidRectAbs
    717          */

   \                                 In section .text, align 2, keep-with-next
    718          static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
   \                     WM__GetInvalidRectAbs: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0x4608             MOV      R0,R1
    719            *pRect = pWin->InvalidRect;
   \   00000004   0xF102 0x0108      ADD      R1,R2,#+8
   \   00000008   0x2208             MOVS     R2,#+8
   \   0000000A   0x.... 0x....      B.W      __aeabi_memcpy
    720          }
    721          
    722          /*********************************************************************
    723          *
    724          *       Invalidation functions
    725          *
    726          **********************************************************************
    727          */
    728          /*********************************************************************
    729          *
    730          *       WM_InvalidateRect
    731          *
    732          *  Invalidate a section of the window. The optional rectangle
    733          *  contains client coordinates, which are independent of the
    734          *  position of the window on the logical desktop area.
    735          */

   \                                 In section .text, align 2, keep-with-next
    736          void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
   \                     WM_InvalidateRect: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    737            GUI_RECT r;
    738            WM_Obj* pWin;
    739            int Status;
    740            if (hWin) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD02D             BEQ.N    ??WM_InvalidateRect_0
    741              WM_LOCK();
    742              pWin = WM_H2P(hWin);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4606             MOV      R6,R0
    743              Status = pWin->Status;
   \   00000012   0x8BB7             LDRH     R7,[R6, #+28]
    744              if (Status & WM_SF_ISVIS) {
   \   00000014   0x07B8             LSLS     R0,R7,#+30
   \   00000016   0xD527             BPL.N    ??WM_InvalidateRect_0
    745                r = pWin->Rect;
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x4631             MOV      R1,R6
   \   0000001C   0x2208             MOVS     R2,#+8
   \   0000001E   0x.... 0x....      BL       __aeabi_memcpy
    746                if (pRect) {
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD00C             BEQ.N    ??WM_InvalidateRect_1
    747                  GUI_RECT rPara;
    748                  rPara = *pRect;
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x4629             MOV      R1,R5
   \   0000002A   0x2208             MOVS     R2,#+8
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy
    749                  WM__Client2Screen(pWin, &rPara);
   \   00000030   0xA902             ADD      R1,SP,#+8
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       WM__Client2Screen
    750                  GUI__IntersectRect(&r, &rPara);
   \   00000038   0xA902             ADD      R1,SP,#+8
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x.... 0x....      BL       GUI__IntersectRect
    751                }
    752                if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
   \                     ??WM_InvalidateRect_1: (+1)
   \   00000040   0x4621             MOV      R1,R4
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       WM__ClipAtParentBorders
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD00D             BEQ.N    ??WM_InvalidateRect_0
    753                  if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
   \   0000004C   0xF640 0x0001      MOVW     R0,#+2049
   \   00000050   0x4038             ANDS     R0,R0,R7
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD104             BNE.N    ??WM_InvalidateRect_2
    754                    WM__InvalidateAreaBelow(&r, hWin);        /* Can be optimized to spare windows above */
   \   00000056   0x4621             MOV      R1,R4
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x.... 0x....      BL       WM__InvalidateAreaBelow
   \   0000005E   0xE003             B.N      ??WM_InvalidateRect_0
    755                  } else {
    756                    _Invalidate1Abs(hWin, &r);
   \                     ??WM_InvalidateRect_2: (+1)
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       _Invalidate1Abs
    757                  }
    758                }
    759              }
    760              WM_UNLOCK();
    761            }
    762          }
   \                     ??WM_InvalidateRect_0: (+1)
   \   00000068   0xB005             ADD      SP,SP,#+20
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    763          
    764          /*********************************************************************
    765          *
    766          *        WM_InvalidateWindow
    767          *
    768            Invalidates an entire window.
    769          */

   \                                 In section .text, align 2, keep-with-next
    770          void WM_InvalidateWindow(WM_HWIN hWin) {
    771            WM_InvalidateRect(hWin, NULL);
   \                     WM_InvalidateWindow: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      WM_InvalidateRect
    772          }
    773          
    774          /*********************************************************************
    775          *
    776          *        WM_InvalidateArea
    777          
    778            Invalidate a certain section of the display. One main reason for this is
    779            that the top window has been moved or destroyed.
    780            The coordinates given are absolute coordinates (desktop coordinates)
    781          */

   \                                 In section .text, align 2, keep-with-next
    782          void WM_InvalidateArea(const GUI_RECT* pRect) {
   \                     WM_InvalidateArea: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    783            WM_HWIN   hWin;
    784            WM_LOCK();
    785            /* Iterate over all windows */
    786            for (hWin = WM__FirstWin; hWin; hWin = WM_H2P(hWin)->hNextLin) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000008   0xF9B0 0x5020      LDRSH    R5,[R0, #+32]
   \   0000000C   0xE008             B.N      ??WM_InvalidateArea_0
    787              _Invalidate1Abs(hWin, pRect);
   \                     ??WM_InvalidateArea_1: (+1)
   \   0000000E   0x4621             MOV      R1,R4
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       _Invalidate1Abs
    788            }
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001C   0xF9B0 0x5014      LDRSH    R5,[R0, #+20]
   \                     ??WM_InvalidateArea_0: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD1F4             BNE.N    ??WM_InvalidateArea_1
    789            WM_UNLOCK();
    790          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    791          
    792          /*********************************************************************
    793          *
    794          *       manage windows stack
    795          *
    796          **********************************************************************
    797          */
    798          /*********************************************************************
    799          *
    800          *       WM_CreateWindowAsChild
    801          */

   \                                 In section .text, align 2, keep-with-next
    802          WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
    803                                         ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
    804                                         ,int NumExtraBytes) {
   \                     WM_CreateWindowAsChild: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x469A             MOV      R10,R3
    805            WM_Obj* pWin;
    806            WM_HWIN hWin;
    807            WM_ASSERT_NOT_IN_PAINT();
    808            WM_LOCK();
    809            Style |= WM__CreateFlags;
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable28
   \   00000010   0x980B             LDR      R0,[SP, #+44]
   \   00000012   0x8CA1             LDRH     R1,[R4, #+36]
   \   00000014   0xEA41 0x0500      ORR      R5,R1,R0
   \   00000018   0xF9BD 0x6028      LDRSH    R6,[SP, #+40]
    810            /* Default parent is Desktop 0 */
    811            if (!hParent) {
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD104             BNE.N    ??WM_CreateWindowAsChild_0
    812              if (WM__NumWindows) {
   \   00000020   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??WM_CreateWindowAsChild_0
    813              #if GUI_NUM_LAYERS == 1
    814                hParent = WM__ahDesktopWin[0];
   \   00000026   0xF9B4 0x6022      LDRSH    R6,[R4, #+34]
    815              #else
    816                hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
    817              #endif
    818              }
    819            }
    820            if (hParent == WM_UNATTACHED) {
   \                     ??WM_CreateWindowAsChild_0: (+1)
   \   0000002A   0xF116 0x0F01      CMN      R6,#+1
   \   0000002E   0xD100             BNE.N    ??WM_CreateWindowAsChild_1
    821              hParent = WM_HWIN_NULL;
   \   00000030   0x2600             MOVS     R6,#+0
    822            }  
    823            if (hParent) {
   \                     ??WM_CreateWindowAsChild_1: (+1)
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD018             BEQ.N    ??WM_CreateWindowAsChild_2
    824              WM_Obj* pParent = WM_H2P(hParent);
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       GUI_ALLOC_h2p
    825              x0 += pParent->Rect.x0;
   \   0000003C   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000040   0x19CF             ADDS     R7,R1,R7
    826              y0 += pParent->Rect.y0;
   \   00000042   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   00000046   0x4490             ADD      R8,R2,R8
    827              if (width==0) {
   \   00000048   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000004C   0xD104             BNE.N    ??WM_CreateWindowAsChild_3
    828                width = pParent->Rect.x1 - pParent->Rect.x0+1;
   \   0000004E   0xF9B0 0x3004      LDRSH    R3,[R0, #+4]
   \   00000052   0x1A59             SUBS     R1,R3,R1
   \   00000054   0xF101 0x0901      ADD      R9,R1,#+1
    829              }
    830              if (height==0) {
   \                     ??WM_CreateWindowAsChild_3: (+1)
   \   00000058   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000005C   0xD104             BNE.N    ??WM_CreateWindowAsChild_2
    831                height = pParent->Rect.y1 - pParent->Rect.y0+1;
   \   0000005E   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \   00000062   0x1A80             SUBS     R0,R0,R2
   \   00000064   0xF100 0x0A01      ADD      R10,R0,#+1
    832              }
    833            }
    834            if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
   \                     ??WM_CreateWindowAsChild_2: (+1)
   \   00000068   0x980D             LDR      R0,[SP, #+52]
   \   0000006A   0x3020             ADDS     R0,R0,#+32
   \   0000006C   0xB200             SXTH     R0,R0
   \   0000006E   0x.... 0x....      BL       GUI_ALLOC_AllocZero
   \   00000072   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD04B             BEQ.N    ??WM_CreateWindowAsChild_4
    835              GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
    836            } else {
    837              WM__NumWindows++;
   \   0000007A   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0x83A0             STRH     R0,[R4, #+28]
    838              pWin = WM_H2P(hWin);
   \   00000080   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000084   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000088   0x4683             MOV      R11,R0
    839              pWin->Rect.x0 = x0;
   \   0000008A   0xF8AB 0x7000      STRH     R7,[R11, #+0]
    840              pWin->Rect.y0 = y0;
   \   0000008E   0xF8AB 0x8002      STRH     R8,[R11, #+2]
    841              pWin->Rect.x1 = x0 + width - 1;
   \   00000092   0xEB09 0x0007      ADD      R0,R9,R7
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    842              pWin->Rect.y1 = y0 + height - 1;
   \   0000009C   0xEB0A 0x0008      ADD      R0,R10,R8
   \   000000A0   0x1E40             SUBS     R0,R0,#+1
   \   000000A2   0xF8AB 0x0006      STRH     R0,[R11, #+6]
    843              pWin->cb = cb;
   \   000000A6   0x980C             LDR      R0,[SP, #+48]
   \   000000A8   0xF8CB 0x0010      STR      R0,[R11, #+16]
    844              /* Copy the flags which can simply be accepted */
    845              pWin->Status |= (Style & (WM_CF_SHOW |
    846                                        WM_SF_MEMDEV |
    847                                        WM_CF_MEMDEV_ON_REDRAW |
    848                                        WM_SF_STAYONTOP |
    849                                        WM_SF_CONST_OUTLINE |
    850                                        WM_SF_HASTRANS |
    851                                        WM_CF_ANCHOR_RIGHT |
    852                                        WM_CF_ANCHOR_BOTTOM |
    853                                        WM_CF_ANCHOR_LEFT |
    854                                        WM_CF_ANCHOR_TOP |
    855                                        WM_CF_LATE_CLIP));
   \   000000AC   0xF8BB 0x001C      LDRH     R0,[R11, #+28]
   \   000000B0   0xF643 0x718F      MOVW     R1,#+16271
   \   000000B4   0x4029             ANDS     R1,R1,R5
   \   000000B6   0x4308             ORRS     R0,R1,R0
   \   000000B8   0xF8AB 0x001C      STRH     R0,[R11, #+28]
    856              /* Add to linked lists */
    857              _AddToLinList(hWin);
   \   000000BC   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000000C0   0x.... 0x....      BL       _AddToLinList
    858              WM__InsertWindowIntoList(hWin, hParent);
   \   000000C4   0x4631             MOV      R1,R6
   \   000000C6   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000000CA   0x.... 0x....      BL       WM__InsertWindowIntoList
    859              /* Activate window if WM_CF_ACTIVATE is specified */
    860              if (Style & WM_CF_ACTIVATE) {
   \   000000CE   0x06A8             LSLS     R0,R5,#+26
   \   000000D0   0xD503             BPL.N    ??WM_CreateWindowAsChild_5
    861                WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
   \   000000D2   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000000D6   0x.... 0x....      BL       WM_SelectWindow
    862              }
    863              /* Handle the Style flags, one at a time */
    864              #if WM_SUPPORT_TRANSPARENCY
    865                if (Style & WM_SF_HASTRANS) {
   \                     ??WM_CreateWindowAsChild_5: (+1)
   \   000000DA   0x07E8             LSLS     R0,R5,#+31
   \   000000DC   0xD502             BPL.N    ??WM_CreateWindowAsChild_6
    866                  WM__TransWindowCnt++;          /* Increment counter for transparency windows */
   \   000000DE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E0   0x1C40             ADDS     R0,R0,#+1
   \   000000E2   0x63A0             STR      R0,[R4, #+56]
    867                }
    868              #endif
    869              if (Style & WM_CF_BGND) {
   \                     ??WM_CreateWindowAsChild_6: (+1)
   \   000000E4   0x0668             LSLS     R0,R5,#+25
   \   000000E6   0xD503             BPL.N    ??WM_CreateWindowAsChild_7
    870                WM_BringToBottom(hWin);
   \   000000E8   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000000EC   0x.... 0x....      BL       WM_BringToBottom
    871              }
    872              if (Style & WM_CF_SHOW) {
   \                     ??WM_CreateWindowAsChild_7: (+1)
   \   000000F0   0x07A8             LSLS     R0,R5,#+30
   \   000000F2   0xD509             BPL.N    ??WM_CreateWindowAsChild_8
    873                pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
   \   000000F4   0xF8BB 0x001C      LDRH     R0,[R11, #+28]
   \   000000F8   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000FC   0xF8AB 0x001C      STRH     R0,[R11, #+28]
    874                WM_InvalidateWindow(hWin);    /* Mark content as invalid */
   \   00000100   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000104   0x.... 0x....      BL       WM_InvalidateWindow
    875              }
    876              WM__SendMsgNoData(hWin, WM_CREATE);
   \                     ??WM_CreateWindowAsChild_8: (+1)
   \   00000108   0x2101             MOVS     R1,#+1
   \   0000010A   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000010E   0x.... 0x....      BL       WM__SendMsgNoData
    877            }
    878            WM_UNLOCK();
    879            return hWin;
   \                     ??WM_CreateWindowAsChild_4: (+1)
   \   00000112   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000116   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    880          }
    881          
    882          /*********************************************************************
    883          *
    884          *       WM_CreateWindow
    885          */

   \                                 In section .text, align 2, keep-with-next
    886          WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
   \                     WM_CreateWindow: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    887            return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
   \   00000002   0x9C08             LDR      R4,[SP, #+32]
   \   00000004   0x9403             STR      R4,[SP, #+12]
   \   00000006   0x9C07             LDR      R4,[SP, #+28]
   \   00000008   0x9402             STR      R4,[SP, #+8]
   \   0000000A   0x9C06             LDR      R4,[SP, #+24]
   \   0000000C   0x9401             STR      R4,[SP, #+4]
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x9400             STR      R4,[SP, #+0]
   \   00000012   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   00000016   0xB004             ADD      SP,SP,#+16
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    888          }
    889          
    890          /*********************************************************************
    891          *
    892          *       Delete window
    893          *
    894          **********************************************************************
    895          */
    896          /*********************************************************************
    897          *
    898          *       WM_DeleteWindow
    899          */

   \                                 In section .text, align 2, keep-with-next
    900          void WM_DeleteWindow (WM_HWIN hWin) {
   \                     WM_DeleteWindow: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    901            WM_Obj* pWin;
    902            if (!hWin) {
   \   00000004   0xD043             BEQ.N    ??WM_DeleteWindow_0
    903              return;
    904            }
    905            WM_ASSERT_NOT_IN_PAINT();
    906            WM_LOCK();
    907            if (WM__IsWindow(hWin)) {
   \   00000006   0x.... 0x....      BL       WM__IsWindow
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD03F             BEQ.N    ??WM_DeleteWindow_0
    908              pWin = WM_H2P(hWin);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4605             MOV      R5,R0
    909              ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
   \   00000016   0x.... 0x....      BL       ResetNextDrawWin
    910            /* Make sure that focus is set to an existing window */
    911              if (WM__hWinFocus == hWin) {
   \   0000001A   0x.... 0x....      LDR.W    R6,??DataTable28
   \   0000001E   0xF9B6 0x0028      LDRSH    R0,[R6, #+40]
   \   00000022   0x42A0             CMP      R0,R4
   \   00000024   0xD101             BNE.N    ??WM_DeleteWindow_1
    912                WM__hWinFocus = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x8530             STRH     R0,[R6, #+40]
    913              }
    914              if (WM__hCapture == hWin) {
   \                     ??WM_DeleteWindow_1: (+1)
   \   0000002A   0xF9B6 0x0026      LDRSH    R0,[R6, #+38]
   \   0000002E   0x42A0             CMP      R0,R4
   \   00000030   0xD101             BNE.N    ??WM_DeleteWindow_2
    915                WM__hCapture = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x84F0             STRH     R0,[R6, #+38]
    916              }
    917              /* check if critical handles are affected. If so, reset the window handle to 0 */
    918              _CheckCriticalHandles(hWin);
   \                     ??WM_DeleteWindow_2: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _CheckCriticalHandles
    919              /* Inform parent */
    920              WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
   \   0000003C   0x2107             MOVS     R1,#+7
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       WM_NotifyParent
    921              /* Delete all children */
    922              _DeleteAllChildren(pWin->hFirstChild);
   \   00000044   0xF9B5 0x0018      LDRSH    R0,[R5, #+24]
   \   00000048   0x.... 0x....      BL       _DeleteAllChildren
    923              #if WM_SUPPORT_NOTIFY_VIS_CHANGED
    924                WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
    925              #endif
    926              /* Send WM_DELETE message to window in order to inform window itself */
    927              WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
   \   0000004C   0x210B             MOVS     R1,#+11
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       WM__SendMsgNoData
    928              WM__DetachWindow(hWin);
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       WM__DetachWindow
    929              /* Remove window from window stack */
    930              WM__RemoveFromLinList(hWin);
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       WM__RemoveFromLinList
    931              /* Handle transparency counter if necessary */
    932              #if WM_SUPPORT_TRANSPARENCY
    933                if (pWin->Status & WM_SF_HASTRANS) {
   \   00000060   0x7F28             LDRB     R0,[R5, #+28]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD502             BPL.N    ??WM_DeleteWindow_3
    934                  WM__TransWindowCnt--;
   \   00000066   0x6BB0             LDR      R0,[R6, #+56]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x63B0             STR      R0,[R6, #+56]
    935                }
    936              #endif
    937              /* Make sure window is no longer counted as invalid */
    938              if (pWin->Status & WM_SF_INVALID) {
   \                     ??WM_DeleteWindow_3: (+1)
   \   0000006C   0x7F28             LDRB     R0,[R5, #+28]
   \   0000006E   0x0680             LSLS     R0,R0,#+26
   \   00000070   0xD502             BPL.N    ??WM_DeleteWindow_4
    939                WM__NumInvalidWindows--;
   \   00000072   0x8BF0             LDRH     R0,[R6, #+30]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x83F0             STRH     R0,[R6, #+30]
    940              }
    941            /* Free window memory */
    942              WM__NumWindows--;
   \                     ??WM_DeleteWindow_4: (+1)
   \   00000078   0x8BB0             LDRH     R0,[R6, #+28]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x83B0             STRH     R0,[R6, #+28]
    943              GUI_ALLOC_Free(hWin);
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       GUI_ALLOC_Free
    944            /* Select a valid window */
    945              WM_SelectWindow(WM__FirstWin);
   \   00000084   0xF9B6 0x0020      LDRSH    R0,[R6, #+32]
   \   00000088   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000008C   0x....             B.N      WM_SelectWindow
    946            } else {
    947              GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
    948            }
    949            WM_UNLOCK();
    950          }
   \                     ??WM_DeleteWindow_0: (+1)
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return
    951          
    952          /*********************************************************************
    953          *
    954          *       WM_SelectWindow
    955          *
    956          *  Sets the active Window. The active Window is the one that is used for all
    957          *  drawing (and text) operations.
    958          */

   \                                 In section .text, align 2, keep-with-next
    959          WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
   \                     WM_SelectWindow: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    960            WM_HWIN hWinPrev;
    961            WM_Obj* pObj;
    962          
    963            WM_ASSERT_NOT_IN_PAINT();
    964            WM_LOCK();
    965            hWinPrev = GUI_Context.hAWin;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable28_1
   \   00000006   0xF9B4 0x503C      LDRSH    R5,[R4, #+60]
    966            if (hWin == 0) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE.N    ??WM_SelectWindow_0
    967              hWin = WM__FirstWin;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28
   \   00000012   0xF9B0 0x0020      LDRSH    R0,[R0, #+32]
    968            }
    969            /* Select new window */
    970            GUI_Context.hAWin = hWin;
   \                     ??WM_SelectWindow_0: (+1)
   \   00000016   0x87A0             STRH     R0,[R4, #+60]
    971            #if GUI_NUM_LAYERS > 1
    972            {
    973              WM_HWIN hTop;
    974              int LayerIndex;
    975              hTop = _GetTopLevelWindow(hWin);
    976              LayerIndex = _DesktopHandle2Index(hTop);
    977              if (LayerIndex >= 0) {
    978                GUI_SelectLayer(LayerIndex);
    979              }
    980            }
    981            #endif
    982            pObj = WM_H2P(hWin);
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001C   0x4606             MOV      R6,R0
    983            LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
   \   0000001E   0x.... 0x....      BL       LCD_SetClipRectMax
    984            GUI_Context.xOff = pObj->Rect.x0;
   \   00000022   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000026   0x6420             STR      R0,[R4, #+64]
    985            GUI_Context.yOff = pObj->Rect.y0;
   \   00000028   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   0000002C   0x6460             STR      R0,[R4, #+68]
    986            WM_UNLOCK();
    987            return hWinPrev;
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    988          }
    989          
    990          /*********************************************************************
    991          *
    992          *       WM_GetActiveWindow
    993          */

   \                                 In section .text, align 2, keep-with-next
    994          WM_HWIN WM_GetActiveWindow(void) {
    995            return GUI_Context.hAWin;
   \                     WM_GetActiveWindow: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000004   0xF9B0 0x003C      LDRSH    R0,[R0, #+60]
   \   00000008   0x4770             BX       LR               ;; return
    996          }
    997          
    998          
    999          /*********************************************************************
   1000          *
   1001          *       IVR calculation
   1002          *
   1003          **********************************************************************
   1004          
   1005          IVRs are invalid rectangles. When redrawing, only the portion of the
   1006          window which is
   1007            a) within the window-rectangle
   1008            b) not covered by an other window
   1009            c) marked as invalid
   1010            is actually redrawn. Unfortunately, this section is not always
   1011            rectangular. If the window is partially covered by an other window,
   1012            it consists of the sum of multiple rectangles. In all drawing
   1013            operations, we have to iterate over every one of these rectangles in
   1014            order to make sure the window is drawn completly.
   1015          Function works as follows:
   1016            STEP 1: - Set upper left coordinates to next pixel. If end of line (right border), goto next line -> (r.x0, r.y0)
   1017            STEP 2: - Check if we are done, return if we are.
   1018            STEP 3: - If we are at the left border, find max. heigtht (r.y1) by iterating over windows above
   1019            STEP 4: - Find x0 for the given y0, y1 by iterating over windows above
   1020            STEP 5: - If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
   1021            STEP 6: - Find r.x1. We have to Iterate over all windows which are above
   1022          */
   1023          
   1024          /*********************************************************************
   1025          *
   1026          *       _FindNext_IVR
   1027          */
   1028          #if WM_SUPPORT_OBSTRUCT

   \                                 In section .text, align 2, keep-with-next
   1029          static int _FindNext_IVR(void) {
   \                     _FindNext_IVR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1030            WM_HMEM hParent;
   1031            GUI_RECT r;
   1032            WM_Obj* pAWin;
   1033            WM_Obj* pParent;
   1034            r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   00000008   0xE9D4 0x0102      LDRD     R0,R1,[R4, #+8]
   \   0000000C   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   1035            /*
   1036               STEP 1:
   1037                 Set the next position which could be part of the next IVR
   1038                 This will be the first unhandle pixel in reading order, i.e. next one to the right
   1039                 or next one down if we are at the right border.
   1040            */
   1041            if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD106             BNE.N    ??_FindNext_IVR_0
   1042              r.x0 = _ClipContext.ClientRect.x0;
   \   00000016   0x8820             LDRH     R0,[R4, #+0]
   \   00000018   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1043              r.y0 = _ClipContext.ClientRect.y0;
   \   0000001C   0x8860             LDRH     R0,[R4, #+2]
   \   0000001E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   00000022   0xE013             B.N      ??_FindNext_IVR_1
   1044            } else {
   1045              r.x0 = _ClipContext.CurRect.x1+1;
   \                     ??_FindNext_IVR_0: (+1)
   \   00000024   0x89A0             LDRH     R0,[R4, #+12]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1046              r.y0 = _ClipContext.CurRect.y0;
   \   0000002C   0x8960             LDRH     R0,[R4, #+10]
   \   0000002E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1047              if (r.x0 > _ClipContext.ClientRect.x1) {
   \   00000032   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \   00000036   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xDA06             BGE.N    ??_FindNext_IVR_1
   1048          NextStripe:  /* go down to next stripe */
   1049                r.x0 = _ClipContext.ClientRect.x0;
   \                     ??_FindNext_IVR_2: (+1)
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1050                r.y0 = _ClipContext.CurRect.y1+1;
   \   00000044   0x89E0             LDRH     R0,[R4, #+14]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1051              }
   1052            }
   1053            /*
   1054               STEP 2:
   1055                 Check if we are done completely.
   1056            */
   1057            if (r.y0 >_ClipContext.ClientRect.y1) {
   \                     ??_FindNext_IVR_1: (+1)
   \   0000004C   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000050   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xDA01             BGE.N    ??_FindNext_IVR_3
   1058              return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBDFE             POP      {R1-R7,PC}
   1059            }
   1060            /* STEP 3:
   1061                 Find out the max. height (r.y1) if we are at the left border.
   1062                 Since we are using the same height for all IVRs at the same y0,
   1063                 we do this only for the leftmost one.
   1064            */
   1065            pAWin = WM_H2P(GUI_Context.hAWin);
   \                     ??_FindNext_IVR_3: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R5,??DataTable28_1
   \   00000060   0xF9B5 0x003C      LDRSH    R0,[R5, #+60]
   \   00000064   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000068   0x4606             MOV      R6,R0
   1066            if (r.x0 == _ClipContext.ClientRect.x0) {
   \   0000006A   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000006E   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD11B             BNE.N    ??_FindNext_IVR_4
   1067              r.y1 = _ClipContext.ClientRect.y1;
   \   00000076   0x88E0             LDRH     R0,[R4, #+6]
   \   00000078   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1068              r.x1 = _ClipContext.ClientRect.x1;
   \   0000007C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000007E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1069              /* Iterate over all windows which are above */
   1070              /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
   1071              for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
   \   00000082   0xF9B5 0x003C      LDRSH    R0,[R5, #+60]
   \   00000086   0xE00A             B.N      ??_FindNext_IVR_5
   1072                pParent = WM_H2P(hParent);
   \                     ??_FindNext_IVR_6: (+1)
   \   00000088   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000008C   0x4607             MOV      R7,R0
   1073                _Findy1(pParent->hNext, &r, NULL);
   \   0000008E   0x2200             MOVS     R2,#+0
   \   00000090   0xA900             ADD      R1,SP,#+0
   \   00000092   0xF9B7 0x001A      LDRSH    R0,[R7, #+26]
   \   00000096   0x.... 0x....      BL       _Findy1
   1074              }
   \   0000009A   0xF9B7 0x0016      LDRSH    R0,[R7, #+22]
   \                     ??_FindNext_IVR_5: (+1)
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD1F2             BNE.N    ??_FindNext_IVR_6
   1075              /* Check all children */
   1076              _Findy1(pAWin->hFirstChild, &r, NULL);
   \   000000A2   0x2200             MOVS     R2,#+0
   \   000000A4   0xA900             ADD      R1,SP,#+0
   \   000000A6   0xF9B6 0x0018      LDRSH    R0,[R6, #+24]
   \   000000AA   0x.... 0x....      BL       _Findy1
   1077            }
   1078            /* 
   1079              STEP 4
   1080                Find out x0 for the given y0, y1 by iterating over windows above.
   1081                if we find one that intersects, adjust x0 to the right.
   1082            */
   1083          Find_x0:
   1084            r.x1 = r.x0;
   \                     ??_FindNext_IVR_4: (+1)
   \   000000AE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000B2   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1085            /* Iterate over all windows which are above */
   1086            /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
   1087            #if 0   /* This is a planned, but not yet released optimization */
   1088              if (Status & WM_SF_DONT_CLIP_SIBLINGS)
   1089              {
   1090                hParent = pAWin->hParent;
   1091              } else
   1092            #endif
   1093            {
   1094              hParent = GUI_Context.hAWin;
   \   000000B6   0xF9B5 0x003C      LDRSH    R0,[R5, #+60]
   \   000000BA   0xE00C             B.N      ??_FindNext_IVR_7
   1095            }
   1096            for (; hParent; hParent = pParent->hParent) {
   1097              pParent = WM_H2P(hParent);
   \                     ??_FindNext_IVR_8: (+1)
   \   000000BC   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   000000C0   0x4607             MOV      R7,R0
   1098              if (_Findx0(pParent->hNext, &r, NULL)) {
   \   000000C2   0x2200             MOVS     R2,#+0
   \   000000C4   0xA900             ADD      R1,SP,#+0
   \   000000C6   0xF9B7 0x001A      LDRSH    R0,[R7, #+26]
   \   000000CA   0x.... 0x....      BL       _Findx0
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD1ED             BNE.N    ??_FindNext_IVR_4
   1099                goto Find_x0;
   1100              }
   1101            }
   \   000000D2   0xF9B7 0x0016      LDRSH    R0,[R7, #+22]
   \                     ??_FindNext_IVR_7: (+1)
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD1F0             BNE.N    ??_FindNext_IVR_8
   1102            /* Check all children */
   1103            if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
   \   000000DA   0x2200             MOVS     R2,#+0
   \   000000DC   0xA900             ADD      R1,SP,#+0
   \   000000DE   0xF9B6 0x0018      LDRSH    R0,[R6, #+24]
   \   000000E2   0x.... 0x....      BL       _Findx0
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD1E1             BNE.N    ??_FindNext_IVR_4
   1104              goto Find_x0;
   1105            }
   1106            /* 
   1107             STEP 5:
   1108               If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
   1109               Find out x1 for the given x0, y0, y1
   1110            */
   1111            r.x1 = _ClipContext.ClientRect.x1;
   \   000000EA   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \   000000EE   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1112            if (r.x1 < r.x0) {/* horizontal border reached ? */
   \   000000F2   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xDA04             BGE.N    ??_FindNext_IVR_9
   1113              _ClipContext.CurRect = r;
   \   000000FA   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000000FE   0xE9C4 0x0102      STRD     R0,R1,[R4, #+8]
   1114              goto NextStripe;
   \   00000102   0xE79C             B.N      ??_FindNext_IVR_2
   1115            }    
   1116            /* 
   1117             STEP 6:
   1118               Find r.x1. We have to Iterate over all windows which are above
   1119            */
   1120            /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
   1121            #if 0   /* This is a planned, but not yet released optimization */
   1122              if (Status & WM_SF_DONT_CLIP_SIBLINGS)
   1123              {
   1124                hParent = pAWin->hParent;
   1125              } else
   1126            #endif
   1127            {
   1128              hParent = GUI_Context.hAWin;
   \                     ??_FindNext_IVR_9: (+1)
   \   00000104   0xF9B5 0x003C      LDRSH    R0,[R5, #+60]
   \   00000108   0xE00A             B.N      ??_FindNext_IVR_10
   1129            }
   1130            for (; hParent; hParent = pParent->hParent) {
   1131              pParent = WM_H2P(hParent);
   \                     ??_FindNext_IVR_11: (+1)
   \   0000010A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000010E   0x4607             MOV      R7,R0
   1132              _Findx1(pParent->hNext, &r, NULL);
   \   00000110   0x2200             MOVS     R2,#+0
   \   00000112   0xA900             ADD      R1,SP,#+0
   \   00000114   0xF9B7 0x001A      LDRSH    R0,[R7, #+26]
   \   00000118   0x.... 0x....      BL       _Findx1
   1133            }
   \   0000011C   0xF9B7 0x0016      LDRSH    R0,[R7, #+22]
   \                     ??_FindNext_IVR_10: (+1)
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD1F2             BNE.N    ??_FindNext_IVR_11
   1134            /* Check all children */
   1135            _Findx1(pAWin->hFirstChild, &r, NULL);
   \   00000124   0x2200             MOVS     R2,#+0
   \   00000126   0xA900             ADD      R1,SP,#+0
   \   00000128   0xF9B6 0x0018      LDRSH    R0,[R6, #+24]
   \   0000012C   0x.... 0x....      BL       _Findx1
   1136            /* We are done. Return the rectangle we found in the _ClipContext. */
   1137            if (_ClipContext.Cnt >200) {
   \   00000130   0x6920             LDR      R0,[R4, #+16]
   \   00000132   0x28C9             CMP      R0,#+201
   \   00000134   0xDB01             BLT.N    ??_FindNext_IVR_12
   1138              return 0;  /* error !!! This should not happen !*/
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xBDFE             POP      {R1-R7,PC}
   1139            }
   1140            _ClipContext.CurRect = r;
   \                     ??_FindNext_IVR_12: (+1)
   \   0000013A   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000013E   0xE9C4 0x0102      STRD     R0,R1,[R4, #+8]
   1141            return 1;  /* IVR is valid ! */
   \   00000142   0x2001             MOVS     R0,#+1
   \   00000144   0xBDFE             POP      {R1-R7,PC}       ;; return
   1142          }
   1143          
   1144          #else
   1145          
   1146          static int _FindNext_IVR(void) {
   1147            if (_ClipContext.Cnt ==0) {
   1148              _ClipContext.CurRect = GUI_Context.pAWin->Rect;
   1149              return 1;  /* IVR is valid ! */
   1150            }
   1151            return 0;  /* Nothing left to draw */
   1152          }
   1153          #endif
   1154          
   1155          /*********************************************************************
   1156          *
   1157          *       WM_GetNextIVR
   1158          
   1159            Sets the next clipping rectangle. If a valid one has
   1160            been found (and set), 1 is returned in order to indicate
   1161            that the drawing operation needs to be executed.
   1162            Returning 0 signals that we have iterated over all
   1163            rectangles.
   1164          
   1165            Returns: 0 if no valid rectangle is found
   1166                     1 if rectangle has been found
   1167          */

   \                                 In section .text, align 2, keep-with-next
   1168          int  WM__GetNextIVR(void) {
   \                     WM__GetNextIVR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1169            #if GUI_SUPPORT_CURSOR
   1170              static char _CursorHidden;
   1171            #endif
   1172            /* If WM is not active, we have no rectangles to return */
   1173            if (WM_IsActive==0) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   00000006   0x7E20             LDRB     R0,[R4, #+24]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??WM__GetNextIVR_0
   1174              return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}
   1175            }
   1176            if (_ClipContext.EntranceCnt > 1) {
   \                     ??WM__GetNextIVR_0: (+1)
   \   00000010   0x6960             LDR      R0,[R4, #+20]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xDA10             BGE.N    ??WM__GetNextIVR_1
   1177              _ClipContext.EntranceCnt--;
   1178              return 0;
   1179            }
   1180            #if GUI_SUPPORT_CURSOR
   1181              if (_CursorHidden) {
   \   00000016   0xF994 0x001B      LDRSB    R0,[R4, #+27]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??WM__GetNextIVR_2
   1182                _CursorHidden = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x76E0             STRB     R0,[R4, #+27]
   1183                (*GUI_CURSOR_pfTempUnhide) ();
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4780             BLX      R0
   1184              }
   1185            #endif
   1186            ++_ClipContext.Cnt;
   \                     ??WM__GetNextIVR_2: (+1)
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   1187            /* Find next rectangle and use it as ClipRect */
   1188            if (!_FindNext_IVR()) {
   \   00000030   0x.... 0x....      BL       _FindNext_IVR
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD104             BNE.N    ??WM__GetNextIVR_3
   1189              _ClipContext.EntranceCnt--;  /* This search is over ! */
   \                     ??WM__GetNextIVR_1: (+1)
   \   00000038   0x6960             LDR      R0,[R4, #+20]
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x6160             STR      R0,[R4, #+20]
   1190              return 0;        /* Could not find an other one ! */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD10             POP      {R4,PC}
   1191            }
   1192            WM__ActivateClipRect();
   \                     ??WM__GetNextIVR_3: (+1)
   \   00000042   0x.... 0x....      BL       WM__ActivateClipRect
   1193            /* Hide cursor if necessary */
   1194            #if GUI_SUPPORT_CURSOR
   1195              if (GUI_CURSOR_pfTempHide) {
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x0008             MOVS     R0,R1
   \   0000004E   0xD003             BEQ.N    ??WM__GetNextIVR_4
   1196                _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
   \   00000050   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000054   0x4788             BLX      R1
   \   00000056   0x76E0             STRB     R0,[R4, #+27]
   1197              }
   1198            #endif
   1199            return 1;
   \                     ??WM__GetNextIVR_4: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   1200          }

   \                                 In section .bss, align 4
   \                     _ClipContext:
   \   00000000                      DS8 24
   \                     WM_IsActive:
   \   00000018                      DS8 1
   \                     WM__PaintCallbackCnt:
   \   00000019                      DS8 1
   \   0000001A                      DS8 1
   \   0000001B                      DS8 1
   \   __absolute unsigned short WM__NumWindows
   \                     WM__NumWindows:
   \   0000001C                      DS8 2
   \   __absolute unsigned short WM__NumInvalidWindows
   \                     WM__NumInvalidWindows:
   \   0000001E                      DS8 2
   \   __absolute GUI_HWIN WM__FirstWin
   \                     WM__FirstWin:
   \   00000020                      DS8 2
   \   __absolute GUI_HWIN WM__ahDesktopWin[1]
   \                     WM__ahDesktopWin:
   \   00000022                      DS8 2
   \                     WM__CreateFlags:
   \   00000024                      DS8 2
   \                     WM__hCapture:
   \   00000026                      DS8 2
   \                     WM__hWinFocus:
   \   00000028                      DS8 2
   \                     WM__hATransWindow:
   \   0000002A                      DS8 2
   \   0000002C                      DS8 2
   \   0000002E                      DS8 2
   \   __absolute GUI_COLOR WM__aBkColor[1]
   \                     WM__aBkColor:
   \   00000030                      DS8 4
   \                     WM_pfPollPID:
   \   00000034                      DS8 4
   \                     WM__TransWindowCnt:
   \   00000038                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute WM_CRITICAL_HANDLE *WM__pFirstCriticalHandle
   \                     WM__pFirstCriticalHandle:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \                     WM__CaptureReleaseAuto:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     WM_PID__StateLast:
   \   00000000                      DS8 12
   1201          
   1202          /*********************************************************************
   1203          *
   1204          *       WM__InitIVRSearch
   1205          
   1206            This routine is called from the clipping level
   1207            (the WM_ITERATE_START macro) when starting an iteration over the
   1208            visible rectangles.
   1209          
   1210            Return value:
   1211              0 : There is no valid rectangle (nothing to do ...)
   1212              1 : There is a valid rectangle
   1213          */

   \                                 In section .text, align 2, keep-with-next
   1214          int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
   \                     WM__InitIVRSearch: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4605             MOV      R5,R0
   1215            GUI_RECT r;
   1216            WM_Obj* pAWin;
   1217            GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
   1218             /* If WM is not active -> nothing to do, leave cliprect alone */
   1219            if (WM_IsActive==0) {
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   0000000A   0x7E20             LDRB     R0,[R4, #+24]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE.N    ??WM__InitIVRSearch_0
   1220              WM__ActivateClipRect();
   \   00000010   0x.... 0x....      BL       WM__ActivateClipRect
   1221              return 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE057             B.N      ??WM__InitIVRSearch_1
   1222            }
   1223            /* If we entered multiple times, leave Cliprect alone */
   1224            if (++_ClipContext.EntranceCnt > 1)
   \                     ??WM__InitIVRSearch_0: (+1)
   \   00000018   0x6960             LDR      R0,[R4, #+20]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x6160             STR      R0,[R4, #+20]
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xDB01             BLT.N    ??WM__InitIVRSearch_2
   1225              return 1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE050             B.N      ??WM__InitIVRSearch_1
   1226            pAWin = WM_H2P(GUI_Context.hAWin);
   \                     ??WM__InitIVRSearch_2: (+1)
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable28_1
   \   0000002A   0xF9B6 0x003C      LDRSH    R0,[R6, #+60]
   \   0000002E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000032   0x4607             MOV      R7,R0
   1227            _ClipContext.Cnt        = -1;
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \   00000038   0x6120             STR      R0,[R4, #+16]
   1228           /* When using callback mechanism, it is legal to reduce drawing
   1229              area to the invalid area ! */
   1230            if (WM__PaintCallbackCnt) {
   \   0000003A   0x7E60             LDRB     R0,[R4, #+25]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD004             BEQ.N    ??WM__InitIVRSearch_3
   1231              WM__GetInvalidRectAbs(pAWin, &r);
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x4638             MOV      R0,R7
   \   00000044   0x.... 0x....      BL       WM__GetInvalidRectAbs
   \   00000048   0xE007             B.N      ??WM__InitIVRSearch_4
   1232            } else {  /* Not using callback mechanism, therefor allow entire rectangle */
   1233              if (pAWin->Status & WM_SF_ISVIS) {
   \                     ??WM__InitIVRSearch_3: (+1)
   \   0000004A   0x7F38             LDRB     R0,[R7, #+28]
   \   0000004C   0x0780             LSLS     R0,R0,#+30
   \   0000004E   0xD530             BPL.N    ??WM__InitIVRSearch_5
   1234                r = pAWin->Rect;
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0x4639             MOV      R1,R7
   \   00000054   0x2208             MOVS     R2,#+8
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy
   1235              } else {
   1236                --_ClipContext.EntranceCnt;
   1237                return 0;  /* window is not even visible ! */
   1238              }
   1239            }
   1240            /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
   1241            if (pMaxRect) {
   \                     ??WM__InitIVRSearch_4: (+1)
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD003             BEQ.N    ??WM__InitIVRSearch_6
   1242              GUI__IntersectRect(&r, pMaxRect);
   \   0000005E   0x4629             MOV      R1,R5
   \   00000060   0xA800             ADD      R0,SP,#+0
   \   00000062   0x.... 0x....      BL       GUI__IntersectRect
   1243            }
   1244            /* If user has reduced the cliprect size, reduce the rectangle */
   1245            if (GUI_Context.WM__pUserClipRect) {
   \                     ??WM__InitIVRSearch_6: (+1)
   \   00000066   0x6BB1             LDR      R1,[R6, #+56]
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD012             BEQ.N    ??WM__InitIVRSearch_7
   1246              WM_Obj* pWin = pAWin;
   1247              GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
   \   0000006C   0xA802             ADD      R0,SP,#+8
   \   0000006E   0x2208             MOVS     R2,#+8
   \   00000070   0x.... 0x....      BL       __aeabi_memcpy
   1248              #if WM_SUPPORT_TRANSPARENCY
   1249                if (WM__hATransWindow) {
   \   00000074   0xF9B4 0x002A      LDRSH    R0,[R4, #+42]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD002             BEQ.N    ??WM__InitIVRSearch_8
   1250                  pWin = WM_H2P(WM__hATransWindow);
   \   0000007C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000080   0x4607             MOV      R7,R0
   1251                }   
   1252              #endif
   1253              WM__Client2Screen(pWin, &rUser);
   \                     ??WM__InitIVRSearch_8: (+1)
   \   00000082   0xA902             ADD      R1,SP,#+8
   \   00000084   0x4638             MOV      R0,R7
   \   00000086   0x.... 0x....      BL       WM__Client2Screen
   1254              GUI__IntersectRect(&r, &rUser);
   \   0000008A   0xA902             ADD      R1,SP,#+8
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       GUI__IntersectRect
   1255            }
   1256            /* For transparent windows, we need to further reduce the rectangle */
   1257            #if WM_SUPPORT_TRANSPARENCY
   1258              if (WM__hATransWindow) {
   \                     ??WM__InitIVRSearch_7: (+1)
   \   00000092   0xF9B4 0x102A      LDRSH    R1,[R4, #+42]
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD004             BEQ.N    ??WM__InitIVRSearch_9
   1259                if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
   \   0000009A   0xA800             ADD      R0,SP,#+0
   \   0000009C   0x.... 0x....      BL       WM__ClipAtParentBorders
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD006             BEQ.N    ??WM__InitIVRSearch_5
   1260                  --_ClipContext.EntranceCnt;
   1261                  return 0;           /* Nothing to draw */
   1262                }
   1263              }
   1264            #endif
   1265            /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
   1266            if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
   \                     ??WM__InitIVRSearch_9: (+1)
   \   000000A4   0xF9B6 0x103C      LDRSH    R1,[R6, #+60]
   \   000000A8   0xA800             ADD      R0,SP,#+0
   \   000000AA   0x.... 0x....      BL       WM__ClipAtParentBorders
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD104             BNE.N    ??WM__InitIVRSearch_10
   1267              --_ClipContext.EntranceCnt;
   \                     ??WM__InitIVRSearch_5: (+1)
   \   000000B2   0x6960             LDR      R0,[R4, #+20]
   \   000000B4   0x1E40             SUBS     R0,R0,#+1
   \   000000B6   0x6160             STR      R0,[R4, #+20]
   1268              return 0;           /* Nothing to draw */
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xE005             B.N      ??WM__InitIVRSearch_1
   1269            }
   1270            /* Store the rectangle and find the first rectangle of the area */
   1271            _ClipContext.ClientRect = r;
   \                     ??WM__InitIVRSearch_10: (+1)
   \   000000BC   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000000C0   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
   1272            return WM__GetNextIVR();
   \   000000C4   0x.... 0x....      BL       WM__GetNextIVR
   \                     ??WM__InitIVRSearch_1: (+1)
   \   000000C8   0xB005             ADD      SP,SP,#+20
   \   000000CA   0xBDF0             POP      {R4-R7,PC}       ;; return
   1273          }
   1274          
   1275          /*********************************************************************
   1276          *
   1277          *       WM_SetDefault
   1278          *
   1279            This routine sets the defaults for WM and the layers below.
   1280            It is used before a drawing routine is called in order to
   1281            make sure that defaults are set (in case the default settings
   1282            had been altered before by the application)
   1283          */

   \                                 In section .text, align 2, keep-with-next
   1284          void WM_SetDefault(void) {
   \                     WM_SetDefault: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1285            GL_SetDefault();
   \   00000002   0x.... 0x....      BL       GL_SetDefault
   1286            GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable28_1
   \   0000000C   0x6388             STR      R0,[R1, #+56]
   1287          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1288          
   1289          /*********************************************************************
   1290          *
   1291          *       _Paint1
   1292          */

   \                                 In section .text, align 2, keep-with-next
   1293          static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
   \                     _Paint1: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   1294            int Status = pWin->Status;
   \   00000008   0x8BB0             LDRH     R0,[R6, #+28]
   1295            /* Send WM_PAINT if window is visible and a callback is defined */
   1296            if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
   \   0000000A   0x6931             LDR      R1,[R6, #+16]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD030             BEQ.N    ??_Paint1_0
   \   00000010   0x0781             LSLS     R1,R0,#+30
   \   00000012   0xD52E             BPL.N    ??_Paint1_0
   1297              WM_MESSAGE Msg;
   1298              WM__PaintCallbackCnt++;
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable28
   \   00000018   0x7E69             LDRB     R1,[R5, #+25]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x7669             STRB     R1,[R5, #+25]
   1299              if (Status & WM_SF_LATE_CLIP) {
   \   0000001E   0x04C0             LSLS     R0,R0,#+19
   \   00000020   0xD50D             BPL.N    ??_Paint1_1
   1300                Msg.hWin   = hWin;
   \   00000022   0xF8AD 0x4004      STRH     R4,[SP, #+4]
   1301                Msg.MsgId  = WM_PAINT;
   \   00000026   0x200F             MOVS     R0,#+15
   \   00000028   0x9000             STR      R0,[SP, #+0]
   1302                Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
   \   0000002A   0xF106 0x0008      ADD      R0,R6,#+8
   \   0000002E   0x9002             STR      R0,[SP, #+8]
   1303                WM_SetDefault();
   \   00000030   0x.... 0x....      BL       WM_SetDefault
   1304                WM_SendMessage(hWin, &Msg);
   \   00000034   0xA900             ADD      R1,SP,#+0
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       WM_SendMessage
   \   0000003C   0xE016             B.N      ??_Paint1_2
   1305              } else {
   1306                WM_ITERATE_START(&pWin->InvalidRect) {
   \                     ??_Paint1_1: (+1)
   \   0000003E   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000042   0x.... 0x....      BL       WM__InitIVRSearch
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD010             BEQ.N    ??_Paint1_2
   1307                  Msg.hWin   = hWin;
   \                     ??_Paint1_3: (+1)
   \   0000004A   0xF8AD 0x4004      STRH     R4,[SP, #+4]
   1308                  Msg.MsgId  = WM_PAINT;
   \   0000004E   0x200F             MOVS     R0,#+15
   \   00000050   0x9000             STR      R0,[SP, #+0]
   1309                  Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
   \   00000052   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000056   0x9002             STR      R0,[SP, #+8]
   1310                  WM_SetDefault();
   \   00000058   0x.... 0x....      BL       WM_SetDefault
   1311                  WM_SendMessage(hWin, &Msg);
   \   0000005C   0xA900             ADD      R1,SP,#+0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       WM_SendMessage
   1312                } WM_ITERATE_END();
   \   00000064   0x.... 0x....      BL       WM__GetNextIVR
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1EE             BNE.N    ??_Paint1_3
   1313              }
   1314              WM__PaintCallbackCnt--;
   \                     ??_Paint1_2: (+1)
   \   0000006C   0x7E68             LDRB     R0,[R5, #+25]
   \   0000006E   0x1E40             SUBS     R0,R0,#+1
   \   00000070   0x7668             STRB     R0,[R5, #+25]
   1315            }
   1316          }
   \                     ??_Paint1_0: (+1)
   \   00000072   0xBD7F             POP      {R0-R6,PC}       ;; return
   1317          /*********************************************************************
   1318          *
   1319          *       _Paint1Trans
   1320          *
   1321          * Purpose:
   1322          *   Draw a transparent window as part of an other one (the active window: pAWin).
   1323          *   This is required because transparent windows are drawn as part of their
   1324          *   non-transparent parents.
   1325          * Return value:
   1326          *   0 if nothing was drawn (no invalid rect)
   1327          *   1 if something was drawn (invalid rect exists)
   1328          * Add. info:
   1329          *   It is important to restore the modified settings, especially the invalid rectangle
   1330          *   of the window. The invalid rectangle needs to be set, as it is passed as add. info
   1331          *   to the callback on WM_PAINT.
   1332          *   On traditional transparent windows, the transparent window is never drawn on its own,
   1333          *   so there is no need to restore the invalid rectangle.
   1334          *   However, with WM_SF_CONST_OUTLINE, the window itself may need to be redrawn because it
   1335          *   can be invalid. Modifying the invalid rectangle would lead to not updating the window
   1336          *   in the worst case.
   1337          */
   1338          
   1339          #if WM_SUPPORT_TRANSPARENCY

   \                                 In section .text, align 2, keep-with-next
   1340          static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
   \                     _Paint1Trans: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1341            int xPrev, yPrev;
   1342            WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
   \   00000008   0x....             LDR.N    R6,??DataTable28_1
   \   0000000A   0xF9B6 0x003C      LDRSH    R0,[R6, #+60]
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x4681             MOV      R9,R0
   1343            /* Check if we need to do any drawing */
   1344            if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0xF109 0x0008      ADD      R0,R9,#+8
   \   0000001A   0x.... 0x....      BL       GUI_RectsIntersect
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD01F             BEQ.N    ??_Paint1Trans_0
   1345              /* Save old values */
   1346              xPrev = GUI_Context.xOff;
   \   00000022   0x6C37             LDR      R7,[R6, #+64]
   1347              yPrev = GUI_Context.yOff;
   \   00000024   0xF8D6 0x8044      LDR      R8,[R6, #+68]
   1348              /* Set values for the current (transparent) window, rather than the one below */
   1349              GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
   \   00000028   0xF109 0x0208      ADD      R2,R9,#+8
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0xF105 0x0008      ADD      R0,R5,#+8
   \   00000032   0x.... 0x....      BL       GUI__IntersectRects
   1350              WM__hATransWindow = hWin;
   \   00000036   0x.... 0x....      LDR.W    R9,??DataTable28
   \   0000003A   0xF8A9 0x402A      STRH     R4,[R9, #+42]
   1351              GUI_Context.xOff = pWin->Rect.x0;
   \   0000003E   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   00000042   0x6430             STR      R0,[R6, #+64]
   1352              GUI_Context.yOff = pWin->Rect.y0;
   \   00000044   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   00000048   0x6470             STR      R0,[R6, #+68]
   1353              /* Do the actual drawing ... */
   1354              _Paint1(hWin, pWin);
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       _Paint1
   1355              /* Restore settings */
   1356              WM__hATransWindow = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF8A9 0x002A      STRH     R0,[R9, #+42]
   1357              GUI_Context.xOff = xPrev;
   \   00000058   0x6437             STR      R7,[R6, #+64]
   1358              GUI_Context.yOff = yPrev;
   \   0000005A   0xF8C6 0x8044      STR      R8,[R6, #+68]
   1359              return 1;                       /* Some drawing took place */
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE000             B.N      ??_Paint1Trans_1
   1360            }
   1361            return 0;                         /* No invalid area, so nothing was drawn */
   \                     ??_Paint1Trans_0: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??_Paint1Trans_1: (+1)
   \   00000064   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1362          }
   1363          #endif
   1364          
   1365          /*********************************************************************
   1366          *
   1367          *       _PaintTransChildren
   1368          *
   1369          * Purpose:
   1370          *   Paint transparent children. This function is obviously required
   1371          *   only if there are transparent windows.
   1372          * Function:  Obvious
   1373          * Parameter: Obvious
   1374          * Returns:   ---
   1375          */
   1376          #if WM_SUPPORT_TRANSPARENCY

   \                                 In section .text, align 2, keep-with-next
   1377          static void _PaintTransChildren(WM_Obj* pWin) {
   \                     _PaintTransChildren: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1378            WM_HWIN hChild;
   1379            WM_Obj* pChild;
   1380            if (pWin->Status & WM_SF_ISVIS) {
   \   00000004   0x7F20             LDRB     R0,[R4, #+28]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD52B             BPL.N    ??_PaintTransChildren_0
   1381              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \   0000000A   0xF9B4 0x5018      LDRSH    R5,[R4, #+24]
   \   0000000E   0xE026             B.N      ??_PaintTransChildren_1
   1382                pChild = WM_H2P(hChild);
   \                     ??_PaintTransChildren_2: (+1)
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000016   0x4606             MOV      R6,R0
   1383                if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
   1384          		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
   \   00000018   0x7F30             LDRB     R0,[R6, #+28]
   \   0000001A   0xF000 0x0003      AND      R0,R0,#0x3
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD11B             BNE.N    ??_PaintTransChildren_3
   1385                  /* Set invalid area of the window to draw */
   1386                  if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
   \   00000022   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       GUI_RectsIntersect
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD014             BEQ.N    ??_PaintTransChildren_3
   1387                    GUI_RECT InvalidRectPrev;
   1388                    InvalidRectPrev = pWin->InvalidRect;
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000036   0x2208             MOVS     R2,#+8
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
   1389                    if(_Paint1Trans(hChild, pChild)) {
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       _Paint1Trans
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??_PaintTransChildren_4
   1390                      _PaintTransChildren(pChild);
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0xF7FF 0xFFD9      BL       _PaintTransChildren
   1391                    }
   1392                    pWin->InvalidRect = InvalidRectPrev;
   \                     ??_PaintTransChildren_4: (+1)
   \   0000004E   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000052   0xA900             ADD      R1,SP,#+0
   \   00000054   0x2208             MOVS     R2,#+8
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy
   1393                  }
   1394                }
   1395              }
   \                     ??_PaintTransChildren_3: (+1)
   \   0000005A   0xF9B6 0x501A      LDRSH    R5,[R6, #+26]
   \                     ??_PaintTransChildren_1: (+1)
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD1D6             BNE.N    ??_PaintTransChildren_2
   1396            }
   1397          }
   \                     ??_PaintTransChildren_0: (+1)
   \   00000062   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1398          #endif
   1399          
   1400          /*********************************************************************
   1401          *
   1402          *       _PaintTransTopSiblings
   1403          *
   1404          * Purpose:
   1405          *   Paint transparent top siblings. This function is obviously required
   1406          *   only if there are transparent windows.
   1407          * Function:  Obvious
   1408          * Parameter: Obvious
   1409          * Returns:   ---
   1410          */
   1411          #if WM_SUPPORT_TRANSPARENCY

   \                                 In section .text, align 2, keep-with-next
   1412          static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
   \                     _PaintTransTopSiblings: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   1413            WM_HWIN hParent;
   1414            WM_Obj* pParent;
   1415            hParent = pWin->hParent;
   \   00000004   0xF9B4 0x5016      LDRSH    R5,[R4, #+22]
   1416            hWin = pWin->hNext;
   \   00000008   0xF9B4 0x601A      LDRSH    R6,[R4, #+26]
   \   0000000C   0xE01A             B.N      ??_PaintTransTopSiblings_0
   1417            while (hParent) { /* Go hierarchy up to desktop window */
   1418              for (; hWin; hWin = pWin->hNext) {
   1419                pWin = WM_H2P(hWin);
   \                     ??_PaintTransTopSiblings_1: (+1)
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000014   0x4604             MOV      R4,R0
   1420                /* paint window if it is transparent & visible */
   1421                if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
   \   00000016   0x7F20             LDRB     R0,[R4, #+28]
   \   00000018   0xF000 0x0003      AND      R0,R0,#0x3
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD103             BNE.N    ??_PaintTransTopSiblings_2
   1422                  _Paint1Trans(hWin, pWin);
   \   00000020   0x4621             MOV      R1,R4
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       _Paint1Trans
   1423                }
   1424                /* paint transparent & visible children */
   1425                _PaintTransChildren(pWin);
   \                     ??_PaintTransTopSiblings_2: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _PaintTransChildren
   1426              }
   \   0000002E   0xF9B4 0x601A      LDRSH    R6,[R4, #+26]
   \                     ??_PaintTransTopSiblings_3: (+1)
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD1EB             BNE.N    ??_PaintTransTopSiblings_1
   1427              pParent = WM_H2P(hParent);
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       GUI_ALLOC_h2p
   1428              hWin = pParent->hNext;
   \   0000003C   0xF9B0 0x601A      LDRSH    R6,[R0, #+26]
   1429              hParent = pParent->hParent;
   \   00000040   0xF9B0 0x5016      LDRSH    R5,[R0, #+22]
   1430            }
   \                     ??_PaintTransTopSiblings_0: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD1F4             BNE.N    ??_PaintTransTopSiblings_3
   1431          }
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
   1432          #endif
   1433          
   1434          /*********************************************************************
   1435          *
   1436          *       Callback for Paint message
   1437          *
   1438          * This callback is used by the window manger in conjunction with
   1439          * banding memory devices. A pointer to this routine is given to
   1440          * the banding memory device. This callback in turn will send the
   1441          * paint message to the window.
   1442          *
   1443          **********************************************************************
   1444          */
   1445          
   1446          /*********************************************************************
   1447          *
   1448          *       WM__PaintWinAndOverlays
   1449          *
   1450          * Purpose
   1451          *   Paint the given window and all overlaying windows
   1452          *   (transparent children and transparent top siblings)
   1453          */

   \                                 In section .text, align 2, keep-with-next
   1454          void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
   \                     WM__PaintWinAndOverlays: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1455            WM_HWIN hWin;
   1456            WM_Obj* pWin;
   1457            hWin = pInfo->hWin;
   \   00000002   0xF9B0 0x4000      LDRSH    R4,[R0, #+0]
   1458            pWin = pInfo->pWin;
   \   00000006   0x6845             LDR      R5,[R0, #+4]
   1459            #if WM_SUPPORT_TRANSPARENCY
   1460              /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
   1461              if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
   \   00000008   0x8BA8             LDRH     R0,[R5, #+28]
   \   0000000A   0xF640 0x0101      MOVW     R1,#+2049
   \   0000000E   0x4008             ANDS     R0,R1,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??WM__PaintWinAndOverlays_0
   1462            #endif
   1463            _Paint1(hWin, pWin);    /* Draw the window itself */
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _Paint1
   1464            #if WM_SUPPORT_TRANSPARENCY
   1465              }
   1466              if (WM__TransWindowCnt != 0) {
   \                     ??WM__PaintWinAndOverlays_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable28
   \   0000001E   0x6B80             LDR      R0,[R0, #+56]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD007             BEQ.N    ??WM__PaintWinAndOverlays_1
   1467                _PaintTransChildren(pWin);       /* Draw all transparent children */
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       _PaintTransChildren
   1468                _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000032   0x....             B.N      _PaintTransTopSiblings
   1469              }
   1470            #endif
   1471          }
   \                     ??WM__PaintWinAndOverlays_1: (+1)
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1472          
   1473          /*********************************************************************
   1474          *
   1475          *       _cbPaintMemDev
   1476          *
   1477          * Purpose:
   1478          *   This is the routine called by the banding memory device. It calls
   1479          *   the same _cbPaint Routine which is also used when drawing directly;
   1480          *   the only add. work done is adjustment of the invalid rectangle.
   1481          *   This way the invalid rectangle visible by the window callback function
   1482          *   is limited to the current band, allowing the callback to optimize
   1483          *   better.
   1484          */
   1485          #if GUI_SUPPORT_MEMDEV
   1486          static void _cbPaintMemDev(void* p) {
   1487            GUI_RECT Rect;
   1488            WM_Obj* pWin = WM_H2P(GUI_Context.hAWin);
   1489            Rect = pWin->InvalidRect;
   1490            pWin->InvalidRect = GUI_Context.ClipRect;
   1491            WM__PaintWinAndOverlays((WM_PAINTINFO*)p);
   1492            pWin->InvalidRect = Rect;
   1493          }
   1494          #endif
   1495          
   1496          /*********************************************************************
   1497          *
   1498          *       _Paint
   1499            Returns:
   1500              1: a window has been redrawn
   1501              0: No window has been drawn  
   1502          */

   \                                 In section .text, align 2, keep-with-next
   1503          static int _Paint(WM_HWIN hWin, WM_Obj* pWin) {
   \                     _Paint: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1504            int Ret = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1505            if (pWin->Status & WM_SF_INVALID) {
   \   00000008   0x7F20             LDRB     R0,[R4, #+28]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD521             BPL.N    ??_Paint_0
   1506              if (pWin->cb) {
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD010             BEQ.N    ??_Paint_1
   1507                if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
   \   00000014   0x4631             MOV      R1,R6
   \   00000016   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000001A   0x.... 0x....      BL       WM__ClipAtParentBorders
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD009             BEQ.N    ??_Paint_1
   1508                  WM_PAINTINFO Info;
   1509                  Info.hWin = hWin;
   \   00000022   0xF8AD 0x6000      STRH     R6,[SP, #+0]
   1510                  Info.pWin = pWin;
   \   00000026   0x9401             STR      R4,[SP, #+4]
   1511                  WM_SelectWindow(hWin);
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       WM_SelectWindow
   1512                  #if GUI_SUPPORT_MEMDEV
   1513                    if (pWin->Status & WM_SF_MEMDEV) {
   1514                      int Flags;
   1515                      GUI_RECT r = pWin->InvalidRect;
   1516                      Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
   1517                      /*
   1518                       * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
   1519                       */
   1520                      if (pWin->hParent == 0) {
   1521                        Flags = GUI_MEMDEV_HASTRANS;
   1522                      }
   1523                      GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
   1524                    } else
   1525                  #endif
   1526                  {
   1527                    WM__PaintWinAndOverlays(&Info);
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       WM__PaintWinAndOverlays
   1528                    Ret = 1;    /* Something has been done */
   \   00000034   0x2501             MOVS     R5,#+1
   1529                  }
   1530                }
   1531              }
   1532              /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
   1533              pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
   \                     ??_Paint_1: (+1)
   \   00000036   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000038   0xF64F 0x71DF      MOVW     R1,#+65503
   \   0000003C   0x4008             ANDS     R0,R1,R0
   \   0000003E   0x83A0             STRH     R0,[R4, #+28]
   1534              if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
   \   00000040   0x0481             LSLS     R1,R0,#+18
   \   00000042   0xD502             BPL.N    ??_Paint_2
   1535                pWin->Status |= WM_CF_MEMDEV;
   \   00000044   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000048   0x83A0             STRH     R0,[R4, #+28]
   1536              }
   1537              WM__NumInvalidWindows--;
   \                     ??_Paint_2: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable28
   \   0000004C   0x8BC1             LDRH     R1,[R0, #+30]
   \   0000004E   0x1E49             SUBS     R1,R1,#+1
   \   00000050   0x83C1             STRH     R1,[R0, #+30]
   1538            }
   1539            return Ret;      /* Nothing done */
   \                     ??_Paint_0: (+1)
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1540          }
   1541          
   1542          /*********************************************************************
   1543          *
   1544          *       _DrawNext
   1545          */

   \                                 In section .text, align 2, keep-with-next
   1546          static void _DrawNext(void) {
   \                     _DrawNext: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   1547            int UpdateRem = 1;
   \   00000004   0x2401             MOVS     R4,#+1
   1548            WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
   \   00000006   0x....             LDR.N    R5,??DataTable28
   \   00000008   0xF9B5 0x602C      LDRSH    R6,[R5, #+44]
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD101             BNE.N    ??_DrawNext_0
   \   00000010   0xF9B5 0x6020      LDRSH    R6,[R5, #+32]
   1549            GUI_CONTEXT ContextOld;
   1550            GUI_SaveContext(&ContextOld);
   \                     ??_DrawNext_0: (+1)
   \   00000014   0xA800             ADD      R0,SP,#+0
   \   00000016   0x.... 0x....      BL       GUI_SaveContext_W
   \   0000001A   0xE00C             B.N      ??_DrawNext_1
   1551            /* Make sure the next window to redraw is valid */
   1552            for (; iWin && UpdateRem; ) {
   1553              WM_Obj* pWin = WM_H2P(iWin);
   \                     ??_DrawNext_2: (+1)
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000022   0x4607             MOV      R7,R0
   1554              if (_Paint(iWin, pWin)) {
   \   00000024   0x4639             MOV      R1,R7
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       _Paint
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD000             BEQ.N    ??_DrawNext_3
   1555                UpdateRem--;  /* Only the given number of windows at a time ... */
   \   00000030   0x1E64             SUBS     R4,R4,#+1
   1556              }
   1557              iWin = pWin->hNextLin;
   \                     ??_DrawNext_3: (+1)
   \   00000032   0xF9B7 0x6014      LDRSH    R6,[R7, #+20]
   1558            }  
   \                     ??_DrawNext_1: (+1)
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD001             BEQ.N    ??_DrawNext_4
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD1EE             BNE.N    ??_DrawNext_2
   1559            NextDrawWin = iWin;   /* Remember the window */
   \                     ??_DrawNext_4: (+1)
   \   0000003E   0x85AE             STRH     R6,[R5, #+44]
   1560            GUI_RestoreContext(&ContextOld);
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       GUI_RestoreContext
   1561          }
   \   00000046   0xB013             ADD      SP,SP,#+76
   \   00000048   0xBDF0             POP      {R4-R7,PC}       ;; return
   1562          
   1563          /*********************************************************************
   1564          *
   1565          *       WM_Exec1
   1566          */

   \                                 In section .text, align 2, keep-with-next
   1567          int WM_Exec1(void) {
   \                     WM_Exec1: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1568            /* Poll PID if necessary */
   1569            if (WM_pfPollPID) {
   \   00000002   0x....             LDR.N    R4,??DataTable27_1
   \   00000004   0x6B60             LDR      R0,[R4, #+52]
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xD000             BEQ.N    ??WM_Exec1_0
   1570              WM_pfPollPID();
   \   0000000A   0x4780             BLX      R0
   1571            }
   1572            if (WM_pfHandlePID) {
   \                     ??WM_Exec1_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable28_4
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0001             MOVS     R1,R0
   \   00000012   0xD002             BEQ.N    ??WM_Exec1_1
   1573              if (WM_pfHandlePID())
   \   00000014   0x4780             BLX      R0
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD103             BNE.N    ??WM_Exec1_2
   1574                return 1;               /* We have done something ... */
   1575            }
   1576            if (GUI_PollKeyMsg()) {
   \                     ??WM_Exec1_1: (+1)
   \   0000001A   0x.... 0x....      BL       GUI_PollKeyMsg
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??WM_Exec1_3
   1577              return 1;               /* We have done something ... */
   \                     ??WM_Exec1_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xBD10             POP      {R4,PC}
   1578            }
   1579            if (WM_IsActive && WM__NumInvalidWindows) {
   \                     ??WM_Exec1_3: (+1)
   \   00000026   0x7E20             LDRB     R0,[R4, #+24]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD006             BEQ.N    ??WM_Exec1_4
   \   0000002C   0x8BE0             LDRH     R0,[R4, #+30]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ.N    ??WM_Exec1_4
   1580              WM_LOCK();
   1581              _DrawNext();
   \   00000032   0x.... 0x....      BL       _DrawNext
   1582              WM_UNLOCK();
   1583              return 1;               /* We have done something ... */
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD10             POP      {R4,PC}
   1584            }
   1585            return 0;                  /* There was nothing to do ... */
   \                     ??WM_Exec1_4: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1586          }
   1587          
   1588          /*********************************************************************
   1589          *
   1590          *       WM_Exec
   1591          */

   \                                 In section .text, align 2, keep-with-next
   1592          int WM_Exec(void) {
   \                     WM_Exec: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1593            int r = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE000             B.N      ??WM_Exec_0
   1594            while (WM_Exec1()) {
   1595              r = 1;                  /* We have done something */
   \                     ??WM_Exec_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   1596            }
   \                     ??WM_Exec_0: (+1)
   \   00000008   0x.... 0x....      BL       WM_Exec1
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD1FA             BNE.N    ??WM_Exec_1
   1597            return r;
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1598          }
   1599          
   1600          /*********************************************************************
   1601          *
   1602          *       cbBackWin
   1603          *
   1604          * Purpose
   1605          *   Callback for background window
   1606          *
   1607          */

   \                                 In section .text, align 2, keep-with-next
   1608          static void cbBackWin( WM_MESSAGE* pMsg) {
   \                     cbBackWin: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1609            const WM_KEY_INFO* pKeyInfo;
   1610            switch (pMsg->MsgId) {
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x280E             CMP      R0,#+14
   \   00000008   0xD002             BEQ.N    ??cbBackWin_0
   \   0000000A   0x280F             CMP      R0,#+15
   \   0000000C   0xD009             BEQ.N    ??cbBackWin_1
   \   0000000E   0xE012             B.N      ??cbBackWin_2
   1611            case WM_KEY:
   1612              pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
   \                     ??cbBackWin_0: (+1)
   \   00000010   0x68A0             LDR      R0,[R4, #+8]
   1613              if (pKeyInfo->PressedCnt == 1) {
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xD112             BNE.N    ??cbBackWin_3
   1614                GUI_StoreKey(pKeyInfo->Key);
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      GUI_StoreKey
   1615              }
   \                     ??cbBackWin_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable28
   \   00000024   0x6B00             LDR      R0,[R0, #+48]
   \   00000026   0xF06F 0x4170      MVN      R1,#-268435456
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD003             BEQ.N    ??cbBackWin_2
   1616              break;
   1617            case WM_PAINT:
   1618              {
   1619                int LayerIndex;
   1620                #if GUI_NUM_LAYERS > 1
   1621                  LayerIndex = _DesktopHandle2Index(pMsg->hWin);
   1622                #else
   1623                  LayerIndex = 0;
   1624                #endif
   1625                if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
   1626                  GUI_SetBkColor(WM__aBkColor[LayerIndex]);
   \   0000002E   0x.... 0x....      BL       GUI_SetBkColor
   1627                  GUI_Clear();
   \   00000032   0x.... 0x....      BL       GUI_Clear
   1628                }
   1629              }
   1630            default:
   1631              WM_DefaultProc(pMsg);
   \                     ??cbBackWin_2: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003C   0x....             B.N      WM_DefaultProc
   1632            }
   1633          }
   \                     ??cbBackWin_3: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
   1634          
   1635          /*********************************************************************
   1636          *
   1637          *       WM_Activate
   1638          */

   \                                 In section .text, align 2, keep-with-next
   1639          void WM_Activate(void) {
   1640            WM_IsActive = 1;       /* Running */
   \                     WM_Activate: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable28
   \   00000004   0x7608             STRB     R0,[R1, #+24]
   1641          }
   \   00000006   0x4770             BX       LR               ;; return
   1642          
   1643          /*********************************************************************
   1644          *
   1645          *       WM_Deactivate
   1646          */

   \                                 In section .text, align 2, keep-with-next
   1647          void WM_Deactivate(void) {
   1648            WM_IsActive = 0;       /* No clipping performed by WM */
   \                     WM_Deactivate: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable28
   \   00000004   0x7608             STRB     R0,[R1, #+24]
   1649            WM_LOCK();
   1650            LCD_SetClipRectMax();
   \   00000006   0x.... 0x....      B.W      LCD_SetClipRectMax
   1651            WM_UNLOCK();
   1652          }
   1653          
   1654          /*********************************************************************
   1655          *
   1656          *       WM_DefaultProc
   1657          *
   1658          * Purpose
   1659          *   Default callback for windows
   1660          *   Any window should call this routine in the "default" part of the
   1661          *   its callback function for messages it does not handle itself.
   1662          *
   1663          */

   \                                 In section .text, align 2, keep-with-next
   1664          void WM_DefaultProc(WM_MESSAGE* pMsg) {
   \                     WM_DefaultProc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1665            WM_HWIN hWin = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
   1666            const void *p = pMsg->Data.p;
   \   00000008   0x68A6             LDR      R6,[R4, #+8]
   1667            WM_Obj* pWin = WM_H2P(hWin);
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   1668            /* Exec message */
   1669            switch (pMsg->MsgId) {
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x290E             CMP      R1,#+14
   \   00000014   0xD011             BEQ.N    ??WM_DefaultProc_0
   \   00000016   0x2914             CMP      R1,#+20
   \   00000018   0xD006             BEQ.N    ??WM_DefaultProc_1
   \   0000001A   0x2917             CMP      R1,#+23
   \   0000001C   0xD00B             BEQ.N    ??WM_DefaultProc_2
   \   0000001E   0x2922             CMP      R1,#+34
   \   00000020   0xD011             BEQ.N    ??WM_DefaultProc_3
   \   00000022   0x2928             CMP      R1,#+40
   \   00000024   0xD013             BEQ.N    ??WM_DefaultProc_4
   \   00000026   0xE002             B.N      ??WM_DefaultProc_5
   1670            case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
   1671              WM__GetClientRectWin(pWin, (GUI_RECT*)p);
   \                     ??WM_DefaultProc_1: (+1)
   \   00000028   0x4631             MOV      R1,R6
   \   0000002A   0x.... 0x....      BL       WM__GetClientRectWin
   1672              break;
   1673            case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
   1674              pMsg->Data.v = (int)hWin;
   1675              return;                       /* Message handled */
   1676            case WM_KEY:
   1677              WM_SendToParent(hWin, pMsg);
   1678              return;                       /* Message handled */
   1679             case WM_GET_BKCOLOR:
   1680              pMsg->Data.Color = GUI_INVALID_COLOR;
   1681              return;                       /* Message handled */
   1682            case WM_NOTIFY_ENABLE:
   1683              WM_InvalidateWindow(hWin);    
   1684              return;                       /* Message handled */
   1685            }
   1686            /* Message not handled. If it queries something, we return 0 to be on the safe side. */
   1687            pMsg->Data.v = 0;
   \                     ??WM_DefaultProc_5: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x60A0             STR      R0,[R4, #+8]
   1688            pMsg->Data.p = 0;
   \   00000032   0x60A0             STR      R0,[R4, #+8]
   1689          }
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??WM_DefaultProc_2: (+1)
   \   00000036   0x60A5             STR      R5,[R4, #+8]
   \   00000038   0xBD70             POP      {R4-R6,PC}
   \                     ??WM_DefaultProc_0: (+1)
   \   0000003A   0x4621             MOV      R1,R4
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000042   0x.... 0x....      B.W      WM_SendToParent
   \                     ??WM_DefaultProc_3: (+1)
   \   00000046   0xF06F 0x4070      MVN      R0,#-268435456
   \   0000004A   0x60A0             STR      R0,[R4, #+8]
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   \                     ??WM_DefaultProc_4: (+1)
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000054   0x.... 0x....      B.W      WM_InvalidateWindow
   1690          
   1691          /*********************************************************************
   1692          *
   1693          *       WM_Init
   1694          */

   \                                 In section .text, align 2, keep-with-next
   1695          void WM_Init(void) {
   \                     WM_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1696          	if (!_IsInited) {
   \   00000004   0x....             LDR.N    R4,??DataTable28
   \   00000006   0xF994 0x001A      LDRSB    R0,[R4, #+26]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD125             BNE.N    ??WM_Init_0
   1697          	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x8420             STRH     R0,[R4, #+32]
   \   00000012   0x85A0             STRH     R0,[R4, #+44]
   1698          	  GUI_Context.WM__pUserClipRect = NULL;
   \   00000014   0x....             LDR.N    R1,??DataTable28_1
   \   00000016   0x6388             STR      R0,[R1, #+56]
   1699          	  WM__NumWindows = WM__NumInvalidWindows =0;
   \   00000018   0x61E0             STR      R0,[R4, #+28]
   1700          	  /* Make sure we have at least one window. This greatly simplifies the
   1701          		  drawing routines as they do not have to check if the window is valid.
   1702          	  */
   1703              #if GUI_NUM_LAYERS == 1
   1704                WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
   \   0000001A   0xF640 0x73FF      MOVW     R3,#+4095
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   \   00000020   0x....             LDR.N    R0,??DataTable28_5
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x461A             MOV      R2,R3
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x.... 0x....      BL       WM_CreateWindow
   \   00000032   0x8460             STRH     R0,[R4, #+34]
   1705                WM__aBkColor[0] = GUI_INVALID_COLOR;
   \   00000034   0xF06F 0x4170      MVN      R1,#-268435456
   \   00000038   0x6321             STR      R1,[R4, #+48]
   1706                WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
   \   0000003A   0x.... 0x....      BL       WM_InvalidateWindow
   1707              #else
   1708              {
   1709                int i;
   1710                for (i = 0; i < GUI_NUM_LAYERS; i++) {
   1711                  WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
   1712                  WM__aBkColor[i] = GUI_INVALID_COLOR;
   1713                  WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
   1714                }
   1715              }
   1716              #endif
   1717              /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
   1718              WM__AddCriticalHandle(&WM__CHWinModal);
   \   0000003E   0x....             LDR.N    R0,??DataTable28_6
   \   00000040   0x.... 0x....      BL       WM__AddCriticalHandle
   1719              WM__AddCriticalHandle(&WM__CHWinLast);
   \   00000044   0x....             LDR.N    R0,??DataTable28_7
   \   00000046   0x.... 0x....      BL       WM__AddCriticalHandle
   1720          
   1721              WM_SelectWindow(WM__ahDesktopWin[0]);
   \   0000004A   0xF9B4 0x0022      LDRSH    R0,[R4, #+34]
   \   0000004E   0x.... 0x....      BL       WM_SelectWindow
   1722          	  WM_Activate();
   \   00000052   0x.... 0x....      BL       WM_Activate
   1723              _IsInited =1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x76A0             STRB     R0,[R4, #+26]
   1724          	}
   1725          }
   \                     ??WM_Init_0: (+1)
   \   0000005A   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     WM__pFirstCriticalHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     _ClipContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     _ClipContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x........         DC32     GUI_CURSOR_pfTempUnhide

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x........         DC32     GUI_CURSOR_pfTempHide

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x........         DC32     WM_pfHandlePID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x........         DC32     cbBackWin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x........         DC32     WM__CHWinModal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0x........         DC32     WM__CHWinLast
   1726          
   1727          
   1728          #else
   1729            void WM(void) {} /* avoid empty object files */
   1730          #endif   /* GUI_WINSUPPORT */
   1731          
   1732          /*************************** End of file ****************************/
   1733          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ResetNextDrawWin
       0   WM_Activate
      24   WM_CreateWindow
        24   -> WM_CreateWindowAsChild
      40   WM_CreateWindowAsChild
        40   -> GUI_ALLOC_AllocZero
        40   -> GUI_ALLOC_h2p
        40   -> WM_BringToBottom
        40   -> WM_InvalidateWindow
        40   -> WM_SelectWindow
        40   -> WM__InsertWindowIntoList
        40   -> WM__SendMsgNoData
        40   -> _AddToLinList
       0   WM_Deactivate
         0   -> LCD_SetClipRectMax
      16   WM_DefaultProc
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
         0   -> WM_SendToParent
        16   -> WM__GetClientRectWin
      16   WM_DeleteWindow
        16   -> GUI_ALLOC_Free
        16   -> GUI_ALLOC_h2p
        16   -> ResetNextDrawWin
        16   -> WM_NotifyParent
         0   -> WM_SelectWindow
        16   -> WM__DetachWindow
        16   -> WM__IsWindow
        16   -> WM__RemoveFromLinList
        16   -> WM__SendMsgNoData
        16   -> _CheckCriticalHandles
        16   -> _DeleteAllChildren
       8   WM_Exec
         8   -> WM_Exec1
       8   WM_Exec1
         8   -- Indirect call
         8   -> GUI_PollKeyMsg
         8   -> _DrawNext
       0   WM_GetActiveWindow
      24   WM_Init
        24   -> WM_Activate
        24   -> WM_CreateWindow
        24   -> WM_InvalidateWindow
        24   -> WM_SelectWindow
        24   -> WM__AddCriticalHandle
      16   WM_InvalidateArea
        16   -> GUI_ALLOC_h2p
        16   -> _Invalidate1Abs
      40   WM_InvalidateRect
        40   -> GUI_ALLOC_h2p
        40   -> GUI__IntersectRect
        40   -> WM__Client2Screen
        40   -> WM__ClipAtParentBorders
        40   -> WM__InvalidateAreaBelow
        40   -> _Invalidate1Abs
        40   -> __aeabi_memcpy
       0   WM_InvalidateWindow
         0   -> WM_InvalidateRect
      16   WM_SelectWindow
        16   -> GUI_ALLOC_h2p
        16   -> LCD_SetClipRectMax
      16   WM_SendMessage
         0   -- Indirect call
        16   -> GUI_ALLOC_h2p
       8   WM_SetDefault
         8   -> GL_SetDefault
      16   WM__ActivateClipRect
        16   -> GUI_ALLOC_h2p
        16   -> WM__ClipAtParentBorders
        16   -> _SetClipRectUserIntersect
        16   -> __aeabi_memcpy
       0   WM__Client2Screen
         0   -> GUI_MoveRect
      16   WM__ClipAtParentBorders
        16   -> GUI_ALLOC_h2p
        16   -> GUI__IntersectRect
        16   -> _DesktopHandle2Index
      16   WM__DetachWindow
        16   -> GUI_ALLOC_h2p
        16   -> WM_InvalidateArea
        16   -> WM__RemoveWindowFromList
       0   WM__GetClientRectWin
       0   WM__GetInvalidRectAbs
         0   -> __aeabi_memcpy
       8   WM__GetNextIVR
         8   -- Indirect call
         8   -> WM__ActivateClipRect
         8   -> _FindNext_IVR
      40   WM__InitIVRSearch
        40   -> GUI_ALLOC_h2p
        40   -> GUI__IntersectRect
        40   -> WM__ActivateClipRect
        40   -> WM__Client2Screen
        40   -> WM__ClipAtParentBorders
        40   -> WM__GetInvalidRectAbs
        40   -> WM__GetNextIVR
        40   -> __aeabi_memcpy
      32   WM__InsertWindowIntoList
        32   -> GUI_ALLOC_h2p
       0   WM__InvalidateAreaBelow
         0   -> WM_InvalidateArea
       8   WM__IsWindow
         8   -> GUI_ALLOC_h2p
      16   WM__PaintWinAndOverlays
        16   -> _Paint1
        16   -> _PaintTransChildren
         0   -> _PaintTransTopSiblings
       0   WM__RectIsNZ
      16   WM__RemoveFromLinList
        16   -> GUI_ALLOC_h2p
      16   WM__RemoveWindowFromList
        16   -> GUI_ALLOC_h2p
      16   WM__SendMsgNoData
        16   -> WM_SendMessage
      16   _AddToLinList
        16   -> GUI_ALLOC_h2p
       0   _CheckCriticalHandles
      16   _DeleteAllChildren
        16   -> GUI_ALLOC_h2p
        16   -> WM_DeleteWindow
       0   _DesktopHandle2Index
      96   _DrawNext
        96   -> GUI_ALLOC_h2p
        96   -> GUI_RestoreContext
        96   -> GUI_SaveContext_W
        96   -> _Paint
      32   _FindNext_IVR
        32   -> GUI_ALLOC_h2p
        32   -> _Findx0
        32   -> _Findx1
        32   -> _Findy1
      40   _Findx0
        40   -> GUI_ALLOC_h2p
        40   -> GUI_RectsIntersect
        40   -> GUI__IntersectRects
        40   -> _Findx0
        40   -> __aeabi_memcpy
      32   _Findx1
        32   -> GUI_ALLOC_h2p
        32   -> GUI_RectsIntersect
        32   -> GUI__IntersectRects
        32   -> _Findx1
        32   -> __aeabi_memcpy
      32   _Findy1
        32   -> GUI_ALLOC_h2p
        32   -> GUI_RectsIntersect
        32   -> GUI__IntersectRects
        32   -> _Findy1
        32   -> __aeabi_memcpy
       0   _GethDrawWin
      24   _Invalidate1Abs
        24   -> GUI_ALLOC_h2p
        24   -> GUI_MergeRect
        24   -> GUI__IntersectRects
        24   -> WM__RectIsNZ
        24   -> __aeabi_memcpy
      24   _Paint
        24   -> WM_SelectWindow
        24   -> WM__ClipAtParentBorders
        24   -> WM__PaintWinAndOverlays
      32   _Paint1
        32   -> WM_SendMessage
        32   -> WM_SetDefault
        32   -> WM__GetNextIVR
        32   -> WM__InitIVRSearch
      32   _Paint1Trans
        32   -> GUI_ALLOC_h2p
        32   -> GUI_RectsIntersect
        32   -> GUI__IntersectRects
        32   -> _Paint1
      24   _PaintTransChildren
        24   -> GUI_ALLOC_h2p
        24   -> GUI_RectsIntersect
        24   -> _Paint1Trans
        24   -> _PaintTransChildren
        24   -> __aeabi_memcpy
      16   _PaintTransTopSiblings
        16   -> GUI_ALLOC_h2p
        16   -> _Paint1Trans
        16   -> _PaintTransChildren
      16   _SetClipRectUserIntersect
        16   -> GUI_ALLOC_h2p
        16   -> GUI__IntersectRect
        16   -> LCD_SetClipRectEx
        16   -> WM__Client2Screen
        16   -> _GethDrawWin
        16   -> __aeabi_memcpy
       8   cbBackWin
         8   -> GUI_Clear
         8   -> GUI_SetBkColor
         0   -> GUI_StoreKey
         0   -> WM_DefaultProc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
      10  ResetNextDrawWin
       8  WM_Activate
      26  WM_CreateWindow
     282  WM_CreateWindowAsChild
      10  WM_Deactivate
      88  WM_DefaultProc
     144  WM_DeleteWindow
      20  WM_Exec
      62  WM_Exec1
      10  WM_GetActiveWindow
      92  WM_Init
      38  WM_InvalidateArea
     108  WM_InvalidateRect
       4  WM_InvalidateWindow
      12  WM_PID__StateLast
      50  WM_SelectWindow
      36  WM_SendMessage
      16  WM_SetDefault
      66  WM__ActivateClipRect
       1  WM__CaptureReleaseAuto
      16  WM__Client2Screen
      62  WM__ClipAtParentBorders
      36  WM__DetachWindow
      24  WM__GetClientRectWin
      14  WM__GetInvalidRectAbs
      92  WM__GetNextIVR
     204  WM__InitIVRSearch
     120  WM__InsertWindowIntoList
       2  WM__InvalidateAreaBelow
      38  WM__IsWindow
      54  WM__PaintWinAndOverlays
      36  WM__RectIsNZ
      42  WM__RemoveFromLinList
      68  WM__RemoveWindowFromList
      16  WM__SendMsgNoData
       4  WM__pFirstCriticalHandle
      40  _AddToLinList
      28  _CheckCriticalHandles
      60  _ClipContext
          WM_IsActive
          WM__PaintCallbackCnt
          _IsInited
          _CursorHidden
          WM__NumWindows
          WM__NumInvalidWindows
          WM__FirstWin
          WM__ahDesktopWin
          WM__CreateFlags
          WM__hCapture
          WM__hWinFocus
          WM__hATransWindow
          NextDrawWin
          WM__aBkColor
          WM_pfPollPID
          WM__TransWindowCnt
      28  _DeleteAllChildren
      22  _DesktopHandle2Index
      74  _DrawNext
     326  _FindNext_IVR
     140  _Findx0
     120  _Findx1
     154  _Findy1
      22  _GethDrawWin
     112  _Invalidate1Abs
      86  _Paint
     116  _Paint1
     104  _Paint1Trans
     100  _PaintTransChildren
      74  _PaintTransTopSiblings
      60  _SetClipRectUserIntersect
      64  cbBackWin

 
    77 bytes in section .bss
 3 604 bytes in section .text
 
 3 604 bytes of CODE memory
    77 bytes of DATA memory

Errors: none
Warnings: none
