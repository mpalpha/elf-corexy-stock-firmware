###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  16:59:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\GUI_ARRAY.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\GUI_ARRAY.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\GUI_ARRAY.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\GUI_ARRAY.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\GUI_ARRAY.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUI_ARRAY.c
     16          Purpose     : Array handling routines
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include "GUI_ARRAY.h"
     21          #include <string.h>
     22          
     23          #if GUI_WINSUPPORT
     24          
     25          /*********************************************************************
     26          *
     27          *       public code
     28          *
     29          **********************************************************************
     30          */
     31          /*********************************************************************
     32          *
     33          *       GUI_ARRAY_GetNumItems
     34          */

   \                                 In section .text, align 2, keep-with-next
     35          unsigned int GUI_ARRAY_GetNumItems(const GUI_ARRAY* pThis) {
     36            GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
     37          
     38            return pThis->NumItems;
   \                     GUI_ARRAY_GetNumItems: (+1)
   \   00000000   0x8800             LDRH     R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return
     39          }
     40          
     41          /*********************************************************************
     42          *
     43          *       GUI_ARRAY_AddItem
     44          *
     45          * Purpose:
     46          *   Add an item to a GUI_ARRAY.
     47          *   If the SIze is > 0, a memory block is allocated for storage.
     48          *   If on top of this a pointer is specified, the memory block holding
     49          *   the copy of the item is initialized.
     50          *
     51          * Return value:
     52          *   If O.K. : 0
     53          *   On error: 1
     54          *   
     55          */

   \                                 In section .text, align 2, keep-with-next
     56          int GUI_ARRAY_AddItem(GUI_ARRAY* pThis, const void *pNew, int Len) {
   \                     GUI_ARRAY_AddItem: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4611             MOV      R1,R2
     57            WM_HMEM hNewItem = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
     58            WM_HMEM hNewBuffer;
     59            WM_HMEM *pNewBuffer;
     60            int r = 0;
   \   0000000C   0x4634             MOV      R4,R6
     61          
     62            GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
     63          
     64            WM_LOCK();
     65            /* Alloc memory for new item */
     66            if (Len) {
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD005             BEQ.N    ??GUI_ARRAY_AddItem_0
     67              if ((hNewItem = GUI_ALLOC_AllocInit(pNew, Len)) == 0) {
   \   00000012   0xB209             SXTH     R1,R1
   \   00000014   0x.... 0x....      BL       GUI_ALLOC_AllocInit
   \   00000018   0x0006             MOVS     R6,R0
   \   0000001A   0xD100             BNE.N    ??GUI_ARRAY_AddItem_0
     68                GUI_DEBUG_ERROROUT("GUI_ARRAY_AddItem failed to alloc buffer");
     69                r = 1;            /* Error */
   \   0000001C   0x2401             MOVS     R4,#+1
     70              }
     71            }
     72            /* Put handle of new item into the array */
     73            if (r == 0) {
   \                     ??GUI_ARRAY_AddItem_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD118             BNE.N    ??GUI_ARRAY_AddItem_1
     74              int NumItems;
     75              NumItems = pThis->NumItems;
   \   00000022   0x882F             LDRH     R7,[R5, #+0]
     76              /* Add the handle to new item to the buffer */
     77              hNewBuffer = GUI_ALLOC_Realloc(pThis->haHandle, (NumItems + 1) * sizeof(WM_HMEM));
   \   00000024   0x1C78             ADDS     R0,R7,#+1
   \   00000026   0x0041             LSLS     R1,R0,#+1
   \   00000028   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   0000002C   0x.... 0x....      BL       GUI_ALLOC_Realloc
   \   00000030   0x4680             MOV      R8,R0
     78              if (hNewBuffer == 0) {
   \   00000032   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000036   0xD104             BNE.N    ??GUI_ARRAY_AddItem_2
     79                GUI_DEBUG_ERROROUT("GUI_ARRAY_AddItem failed to alloc buffer");
     80                GUI_ALLOC_Free(hNewItem);
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x.... 0x....      BL       GUI_ALLOC_Free
     81                r = 1;            /* Error */
   \   0000003E   0x2401             MOVS     R4,#+1
   \   00000040   0xE008             B.N      ??GUI_ARRAY_AddItem_1
     82              } else {
     83                pNewBuffer = (WM_HMEM*) GUI_ALLOC_h2p(hNewBuffer);
   \                     ??GUI_ARRAY_AddItem_2: (+1)
   \   00000042   0x.... 0x....      BL       GUI_ALLOC_h2p
     84                *(pNewBuffer + NumItems) = hNewItem;
   \   00000046   0xF820 0x6017      STRH     R6,[R0, R7, LSL #+1]
     85                pThis->haHandle = hNewBuffer;
   \   0000004A   0xF8A5 0x8002      STRH     R8,[R5, #+2]
     86                pThis->NumItems++;
   \   0000004E   0x8828             LDRH     R0,[R5, #+0]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x8028             STRH     R0,[R5, #+0]
     87              }
     88            }
     89            WM_UNLOCK();
     90            return r;
   \                     ??GUI_ARRAY_AddItem_1: (+1)
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     91          }
     92          
     93          /*********************************************************************
     94          *
     95          *       GUI_ARRAY_Delete
     96          *
     97          * Purpose:
     98          *  Free all allocated memory blocks
     99          *
    100          * Add. info:
    101          *   Locking is not required, since this routine is considered internal
    102          *   and should only be called after locking.
    103          */

   \                                 In section .text, align 2, keep-with-next
    104          void GUI_ARRAY_Delete(GUI_ARRAY* pThis) {
   \                     GUI_ARRAY_Delete: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    105            int i;
    106            WM_HMEM ha;
    107            WM_HMEM* pa;
    108          
    109            GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
    110          
    111            ha = pThis->haHandle;
   \   00000004   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
    112            if (ha) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD011             BEQ.N    ??GUI_ARRAY_Delete_0
    113              pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4605             MOV      R5,R0
    114              /* Free the attached items, one at a time */
    115              for (i = 0; i < pThis->NumItems; i++) {
   \   00000012   0x2600             MOVS     R6,#+0
   \   00000014   0xE004             B.N      ??GUI_ARRAY_Delete_1
    116                GUI_ALLOC_FreePtr(pa+i);
   \                     ??GUI_ARRAY_Delete_2: (+1)
   \   00000016   0xEB05 0x0046      ADD      R0,R5,R6, LSL #+1
   \   0000001A   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    117              }
   \   0000001E   0x1C76             ADDS     R6,R6,#+1
   \                     ??GUI_ARRAY_Delete_1: (+1)
   \   00000020   0x8820             LDRH     R0,[R4, #+0]
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xDBF7             BLT.N    ??GUI_ARRAY_Delete_2
    118              /* Free the handle buffer */
    119              GUI_ALLOC_FreePtr(&pThis->haHandle);
   \   00000026   0x1CA0             ADDS     R0,R4,#+2
   \   00000028   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    120              pThis->NumItems = 0;                    /* For safety, in case the array is used after it has been deleted */
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x8020             STRH     R0,[R4, #+0]
    121            }
    122            #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    123              pThis->InitState = GUI_ARRAY_STATE_DELETED;
    124            #endif
    125          }
   \                     ??GUI_ARRAY_Delete_0: (+1)
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    126          
    127          /*********************************************************************
    128          *
    129          *       GUI_ARRAY_SethItem
    130          *
    131          * Purpose:
    132          *   Sets an item.
    133          *
    134          * Returns:
    135          *   1: if operation has failed
    136          *   0: OK
    137          *
    138          * Notes:
    139          *   (1) Replacing Items
    140          *       If the item is already assigned
    141          *       (Which means the handle is already != 0), it is freeed. However,
    142          *       the handle is treated as a handle to a data item, not an object.
    143          *       This means the data item is freed, but if the pointer points to
    144          *       an object, the destructor of the object is not called.
    145          */

   \                                 In section .text, align 2, keep-with-next
    146          int GUI_ARRAY_SethItem(GUI_ARRAY* pThis, unsigned int Index, WM_HMEM hItem) {
   \                     GUI_ARRAY_SethItem: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4603             MOV      R3,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
    147            WM_HMEM ha;
    148            WM_HMEM* pa;
    149            int r = 1;
   \   00000008   0x2001             MOVS     R0,#+1
    150          
    151            GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
    152          
    153            if (Index < (unsigned)pThis->NumItems) {
   \   0000000A   0x8819             LDRH     R1,[R3, #+0]
   \   0000000C   0x428C             CMP      R4,R1
   \   0000000E   0xD20D             BCS.N    ??GUI_ARRAY_SethItem_0
    154              ha = pThis->haHandle;
   \   00000010   0xF9B3 0x1002      LDRSH    R1,[R3, #+2]
    155              if (ha) {
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD009             BEQ.N    ??GUI_ARRAY_SethItem_0
    156                pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
   \   00000018   0x4608             MOV      R0,R1
   \   0000001A   0x.... 0x....      BL       GUI_ALLOC_h2p
    157                pa += Index;
   \   0000001E   0xEB00 0x0444      ADD      R4,R0,R4, LSL #+1
    158                GUI_ALLOC_FreePtr(pa);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    159                *pa = hItem;
   \   00000028   0x8025             STRH     R5,[R4, #+0]
    160                r = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
    161              }
    162            }
    163            return r;
   \                     ??GUI_ARRAY_SethItem_0: (+1)
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    164          }
    165          
    166          /*********************************************************************
    167          *
    168          *       GUI_ARRAY_SetItem
    169          *
    170          * Purpose:
    171          *   Sets an item, returning the handle.
    172          *   If a data pointer is given, the allocated memory is initialized from it thru memcpy.
    173          *
    174          * Returns:
    175          *   Handle of the allocated memory block
    176          *   
    177          * Notes:
    178          *   (1) Replacing Items
    179          *       If the item is already assigned
    180          *       (Which means the handle is already != 0), it is freeed. However,
    181          *       the handle is treated as a handle to a data item, not an object.
    182          *       This means the data item is freed, but if the pointer points to
    183          *       an object, the destructor of the object is not called.
    184          */

   \                                 In section .text, align 2, keep-with-next
    185          WM_HMEM  GUI_ARRAY_SetItem(GUI_ARRAY* pThis, unsigned int Index, const void* pData, int Len) {
   \                     GUI_ARRAY_SetItem: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460E             MOV      R6,R1
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x461D             MOV      R5,R3
    186            WM_HMEM hItem = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    187          
    188            GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
    189          
    190            if (Index < (unsigned)pThis->NumItems) {
   \   0000000A   0x8801             LDRH     R1,[R0, #+0]
   \   0000000C   0x428E             CMP      R6,R1
   \   0000000E   0xD228             BCS.N    ??GUI_ARRAY_SetItem_0
    191              WM_HMEM ha;
    192              ha = pThis->haHandle;
   \   00000010   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
    193              if (ha) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD024             BEQ.N    ??GUI_ARRAY_SetItem_0
    194                WM_HMEM* pa;
    195                pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
    196                pa += Index;
   \   0000001C   0xEB00 0x0646      ADD      R6,R0,R6, LSL #+1
    197                hItem = *pa;
   \   00000020   0xF9B6 0x7000      LDRSH    R7,[R6, #+0]
    198                /*
    199                 * If a buffer is already available, a new buffer is only needed when the
    200                 * new item has a different size.
    201                 */
    202                if (hItem) {
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD005             BEQ.N    ??GUI_ARRAY_SetItem_1
    203                  if (GUI_ALLOC_GetSize(hItem) != Len) {
   \   00000028   0x4638             MOV      R0,R7
   \   0000002A   0x.... 0x....      BL       GUI_ALLOC_GetSize
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD000             BEQ.N    ??GUI_ARRAY_SetItem_1
    204                    hItem = 0;
   \   00000032   0x2700             MOVS     R7,#+0
    205                  }
    206                }
    207                /*
    208                 * Allocate a new buffer and free the old one (if needed). 
    209                 */
    210                if (!hItem) {
   \                     ??GUI_ARRAY_SetItem_1: (+1)
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD109             BNE.N    ??GUI_ARRAY_SetItem_2
    211                  hItem = GUI_ALLOC_AllocZero(Len);
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0xB200             SXTH     R0,R0
   \   0000003C   0x.... 0x....      BL       GUI_ALLOC_AllocZero
   \   00000040   0x0007             MOVS     R7,R0
    212                  if (hItem) {
   \   00000042   0xD003             BEQ.N    ??GUI_ARRAY_SetItem_2
    213                    GUI_ALLOC_FreePtr(pa);
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    214                    *pa = hItem;
   \   0000004A   0x8037             STRH     R7,[R6, #+0]
    215                  }
    216                }
    217                /*
    218                 * Set the item (if needed)
    219                 */
    220                if (pData && hItem) {
   \                     ??GUI_ARRAY_SetItem_2: (+1)
   \   0000004C   0x2C00             CMP      R4,#+0
   \   0000004E   0xD008             BEQ.N    ??GUI_ARRAY_SetItem_0
   \   00000050   0x2F00             CMP      R7,#+0
   \   00000052   0xD006             BEQ.N    ??GUI_ARRAY_SetItem_0
    221                  char* pItem = (char*) GUI_ALLOC_h2p(hItem);
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       GUI_ALLOC_h2p
    222                  memcpy(pItem, pData, Len);
   \   0000005A   0x462A             MOV      R2,R5
   \   0000005C   0x4621             MOV      R1,R4
   \   0000005E   0x.... 0x....      BL       memcpy
    223                }
    224              }
    225            }
    226            return hItem;
   \                     ??GUI_ARRAY_SetItem_0: (+1)
   \   00000062   0x4638             MOV      R0,R7
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    227          }
    228          
    229          /*********************************************************************
    230          *
    231          *       GUI_ARRAY_GethItem
    232          *
    233          * Purpose:
    234          *   Gets the handle of specified item
    235          *
    236          * Notes:
    237          *   (1) Index out of bounds
    238          *   It is permitted to specify an index larger than the
    239          *   array size. In this case, a 0-handle is returned.
    240          */

   \                                 In section .text, align 2, keep-with-next
    241          WM_HMEM GUI_ARRAY_GethItem(const GUI_ARRAY* pThis, unsigned int Index) {
   \                     GUI_ARRAY_GethItem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x460C             MOV      R4,R1
    242            WM_HMEM h = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    243          
    244            GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
    245          
    246            if (Index < (unsigned)pThis->NumItems) {
   \   00000008   0x8811             LDRH     R1,[R2, #+0]
   \   0000000A   0x428C             CMP      R4,R1
   \   0000000C   0xD208             BCS.N    ??GUI_ARRAY_GethItem_0
    247              WM_HMEM  ha;
    248              WM_HMEM* pa;
    249              ha = pThis->haHandle;
   \   0000000E   0xF9B2 0x1002      LDRSH    R1,[R2, #+2]
    250              if (ha) {
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD004             BEQ.N    ??GUI_ARRAY_GethItem_0
    251                pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x.... 0x....      BL       GUI_ALLOC_h2p
    252                h = *(pa + Index);
   \   0000001C   0xF930 0x0014      LDRSH    R0,[R0, R4, LSL #+1]
    253              }
    254            }
    255            return h;
   \                     ??GUI_ARRAY_GethItem_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    256          }
    257          
    258          /*********************************************************************
    259          *
    260          *       GUI_ARRAY_GetpItem
    261          *
    262          * Purpose:
    263          *   Gets the pointer of specified item
    264          *
    265          * Notes:
    266          *   (1) Index out of bounds
    267          *       It is permitted to specify an index larger than the
    268          *       array size. In this case, a 0-handle is returned.
    269          *   (2) Locking
    270          *       It is the caller's responsibility to lock before calling this
    271          *       function.
    272          */

   \                                 In section .text, align 2, keep-with-next
    273          void* GUI_ARRAY_GetpItem(const GUI_ARRAY* pThis, unsigned int Index) {
   \                     GUI_ARRAY_GetpItem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    274            void* p = NULL;
   \   00000002   0x2400             MOVS     R4,#+0
    275            WM_HMEM h;
    276          
    277            GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
    278          
    279            h = GUI_ARRAY_GethItem(pThis, Index);
   \   00000004   0x.... 0x....      BL       GUI_ARRAY_GethItem
    280            if (h) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??GUI_ARRAY_GetpItem_0
    281              p = WM_H2P(h);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000010   0x4604             MOV      R4,R0
    282            }
    283            return p;
   \                     ??GUI_ARRAY_GetpItem_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    284          }
    285          
    286          /*********************************************************************
    287          *
    288          *       Debug support
    289          *
    290          **********************************************************************
    291          *
    292          * Purpose:
    293          *   The routines below are required only at higher debug levels
    294          */
    295          
    296          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    297          
    298          /*********************************************************************
    299          *
    300          *       GUI_ARRAY_Create
    301          *
    302          * Purpose:
    303          */
    304          void GUI_ARRAY_Create(GUI_ARRAY * pThis) {
    305            GUI_DEBUG_ERROROUT_IF(pThis->InitState != GUI_ARRAY_STATE_NOT_CREATED, "GUI_ARRAY_Create: GUI_ARRAY not initialized to 0");
    306            pThis->InitState = GUI_ARRAY_STATE_CREATED;
    307          }
    308          
    309          
    310          /*********************************************************************
    311          *
    312          *       GUI_ARRAY_Check
    313          *
    314          * Purpose:
    315          */
    316          void GUI_ARRAY_Check(const GUI_ARRAY * pThis) {
    317            if (pThis->InitState == GUI_ARRAY_STATE_DELETED) {
    318              GUI_DEBUG_ERROROUT("GUI_ARRAY_Check: GUI_ARRAY has been deleted");
    319            } else if (pThis->InitState == GUI_ARRAY_STATE_NOT_CREATED) {
    320              GUI_DEBUG_ERROROUT("GUI_ARRAY_Check: GUI_ARRAY has not been created");
    321            } else if (pThis->InitState != GUI_ARRAY_STATE_CREATED) {
    322              GUI_DEBUG_ERROROUT("GUI_ARRAY_Check: GUI_ARRAY in unknown state");
    323            }
    324          }
    325          
    326          #endif /* GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL */
    327          
    328          
    329          #else  /* avoid empty object files */
    330          
    331          void GUI_ARRAY_C(void);
    332          void GUI_ARRAY_C(void){}
    333          
    334          #endif /* GUI_WINSUPPORT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   GUI_ARRAY_AddItem
        24   -> GUI_ALLOC_AllocInit
        24   -> GUI_ALLOC_Free
        24   -> GUI_ALLOC_Realloc
        24   -> GUI_ALLOC_h2p
      16   GUI_ARRAY_Delete
        16   -> GUI_ALLOC_FreePtr
        16   -> GUI_ALLOC_h2p
       0   GUI_ARRAY_GetNumItems
       8   GUI_ARRAY_GethItem
         8   -> GUI_ALLOC_h2p
       8   GUI_ARRAY_GetpItem
         8   -> GUI_ALLOC_h2p
         8   -> GUI_ARRAY_GethItem
      24   GUI_ARRAY_SetItem
        24   -> GUI_ALLOC_AllocZero
        24   -> GUI_ALLOC_FreePtr
        24   -> GUI_ALLOC_GetSize
        24   -> GUI_ALLOC_h2p
        24   -> memcpy
      16   GUI_ARRAY_SethItem
        16   -> GUI_ALLOC_FreePtr
        16   -> GUI_ALLOC_h2p


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      90  GUI_ARRAY_AddItem
      50  GUI_ARRAY_Delete
       4  GUI_ARRAY_GetNumItems
      34  GUI_ARRAY_GethItem
      22  GUI_ARRAY_GetpItem
     102  GUI_ARRAY_SetItem
      46  GUI_ARRAY_SethItem

 
 348 bytes in section .text
 
 348 bytes of CODE memory

Errors: none
Warnings: none
