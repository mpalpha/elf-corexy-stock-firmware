###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  16:59:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\BUTTON_Get.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\BUTTON_Get.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\BUTTON_Get.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\BUTTON_Get.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\BUTTON_Get.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : BUTTON_Get.c
     16          Purpose     : Button widget, various (optional) Get routines
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <string.h>
     21          #include "BUTTON.h"
     22          #include "BUTTON_Private.h"
     23          #include "GUI_Protected.h"
     24          
     25          #if GUI_WINSUPPORT
     26          
     27          /*********************************************************************
     28          *
     29          *       Exported functions
     30          *
     31          **********************************************************************
     32          */
     33          /*********************************************************************
     34          *
     35          *       BUTTON_GetBkColor  
     36          */

   \                                 In section .text, align 2, keep-with-next
     37          GUI_COLOR BUTTON_GetBkColor(BUTTON_Handle hObj,unsigned int Index) {
   \                     BUTTON_GetBkColor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x460C             MOV      R4,R1
     38            GUI_COLOR Color = 0;
   \   00000006   0x2000             MOVS     R0,#+0
     39            if (hObj && (Index < 2)) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD007             BEQ.N    ??BUTTON_GetBkColor_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD205             BCS.N    ??BUTTON_GetBkColor_0
     40              BUTTON_Obj * pObj;
     41              WM_LOCK();
     42              pObj = BUTTON_H2P(hObj);
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_h2p
     43              Color = pObj->Props.aBkColor[Index];
   \   00000016   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   0000001A   0x6A80             LDR      R0,[R0, #+40]
     44              WM_UNLOCK();
     45            }
     46            return Color;
   \                     ??BUTTON_GetBkColor_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
     47          }
     48          
     49          /*********************************************************************
     50          *
     51          *       BUTTON_GetFont     
     52          */

   \                                 In section .text, align 2, keep-with-next
     53          const GUI_FONT GUI_UNI_PTR * BUTTON_GetFont(BUTTON_Handle hObj) {
   \                     BUTTON_GetFont: (+1)
   \   00000000   0x4601             MOV      R1,R0
     54            const GUI_FONT GUI_UNI_PTR * pFont = 0;
   \   00000002   0x2000             MOVS     R0,#+0
     55            if (hObj) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD100             BNE.N    ??BUTTON_GetFont_0
   \   00000008   0x4770             BX       LR
     56              BUTTON_Obj * pObj;
     57              WM_LOCK();
     58              pObj = BUTTON_H2P(hObj);
   \                     ??BUTTON_GetFont_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
     59              pFont = pObj->Props.pFont;
   \   00000012   0x6C00             LDR      R0,[R0, #+64]
     60              WM_UNLOCK();
     61            }
     62            return pFont;
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
     63          }
     64          
     65          /*********************************************************************
     66          *
     67          *       BUTTON_GetText  
     68          */

   \                                 In section .text, align 2, keep-with-next
     69          void BUTTON_GetText(BUTTON_Handle hObj, char * pBuffer, int MaxLen) {
   \                     BUTTON_GetText: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
     70            if (hObj) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD019             BEQ.N    ??BUTTON_GetText_0
     71              BUTTON_Obj * pObj;
     72              WM_LOCK();
     73              pObj = BUTTON_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
     74              if (pObj->hpText) {
   \   0000000E   0xF9B0 0x0048      LDRSH    R0,[R0, #+72]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD011             BEQ.N    ??BUTTON_GetText_1
     75                const char * pText = (const char*) GUI_ALLOC_h2p(pObj->hpText);
   \   00000016   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000001A   0x4606             MOV      R6,R0
     76                int Len = strlen(pText);
   \   0000001C   0x.... 0x....      BL       strlen
   \   00000020   0x4607             MOV      R7,R0
     77                if (Len > (MaxLen - 1))
   \   00000022   0x1E68             SUBS     R0,R5,#+1
   \   00000024   0x42B8             CMP      R0,R7
   \   00000026   0xDA00             BGE.N    ??BUTTON_GetText_2
     78                  Len = MaxLen - 1;
   \   00000028   0x4607             MOV      R7,R0
     79                memcpy((void *)pBuffer, (const void *)pText, Len);
   \                     ??BUTTON_GetText_2: (+1)
   \   0000002A   0x463A             MOV      R2,R7
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       memcpy
     80                *(pBuffer + Len) = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x5538             STRB     R0,[R7, R4]
   \   00000038   0xBDF1             POP      {R0,R4-R7,PC}
     81              } else {
     82                *pBuffer = 0;     /* Empty string */
   \                     ??BUTTON_GetText_1: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7020             STRB     R0,[R4, #+0]
     83              }
     84              WM_UNLOCK();
     85            }
     86          }
   \                     ??BUTTON_GetText_0: (+1)
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     87          
     88          /*********************************************************************
     89          *
     90          *       BUTTON_GetTextColor  
     91          */

   \                                 In section .text, align 2, keep-with-next
     92          GUI_COLOR BUTTON_GetTextColor(BUTTON_Handle hObj,unsigned int Index) {
   \                     BUTTON_GetTextColor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x460C             MOV      R4,R1
     93            GUI_COLOR Color = 0;
   \   00000006   0x2000             MOVS     R0,#+0
     94            if (hObj && (Index < 2)) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD007             BEQ.N    ??BUTTON_GetTextColor_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD205             BCS.N    ??BUTTON_GetTextColor_0
     95              BUTTON_Obj * pObj;
     96              WM_LOCK();
     97              pObj = BUTTON_H2P(hObj);
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x.... 0x....      BL       GUI_ALLOC_h2p
     98              Color = pObj->Props.aTextColor[Index];
   \   00000016   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   0000001A   0x6B40             LDR      R0,[R0, #+52]
     99              WM_UNLOCK();
    100            }
    101            return Color;
   \                     ??BUTTON_GetTextColor_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    102          }
    103          
    104          #else                            /* Avoid problems with empty object modules */
    105            void BUTTON_Get_C(void) {}
    106          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BUTTON_GetBkColor
         8   -> GUI_ALLOC_h2p
       8   BUTTON_GetFont
         8   -> GUI_ALLOC_h2p
      24   BUTTON_GetText
        24   -> GUI_ALLOC_h2p
        24   -> memcpy
        24   -> strlen
       8   BUTTON_GetTextColor
         8   -> GUI_ALLOC_h2p


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      30  BUTTON_GetBkColor
      22  BUTTON_GetFont
      64  BUTTON_GetText
      30  BUTTON_GetTextColor

 
 146 bytes in section .text
 
 146 bytes of CODE memory

Errors: none
Warnings: none
