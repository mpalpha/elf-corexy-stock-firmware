###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  17:00:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCD_RotateCCW.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCD_RotateCCW.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\LCD_RotateCCW.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\LCD_RotateCCW.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCD_RotateCCW.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LCD_RotateCCW.c
     16          Purpose     : Implementation of GUI_SetRotation
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include "GUI_Private.h"
     21          #include "LCD.h"
     22          #if GUI_WINSUPPORT
     23            #include "WM.h"
     24          #endif
     25          
     26          #if GUI_SUPPORT_ROTATION
     27          
     28          /*********************************************************************
     29          *
     30          *       Static code
     31          *
     32          **********************************************************************
     33          */
     34          /*********************************************************************
     35          *
     36          *       _DrawBitLine1BPP
     37          */

   \                                 In section .text, align 2, keep-with-next
     38          static void  _DrawBitLine1BPP(int x, int y, U8 const GUI_UNI_PTR *p, int Diff, int xsize, const LCD_PIXELINDEX*pTrans) {
   \                     _DrawBitLine1BPP: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461E             MOV      R6,R3
   \   0000000A   0x9809             LDR      R0,[SP, #+36]
     39            LCD_PIXELINDEX Index0 = *(pTrans+0);
   \   0000000C   0x8807             LDRH     R7,[R0, #+0]
     40            LCD_PIXELINDEX Index1 = *(pTrans+1);
   \   0000000E   0xF8B0 0x8002      LDRH     R8,[R0, #+2]
     41            y -= Diff;
   \   00000012   0xEBA1 0x0906      SUB      R9,R1,R6
   \   00000016   0xF8DD 0xA020      LDR      R10,[SP, #+32]
     42            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   0000001A   0x....             LDR.N    R0,??DataTable3
   \   0000001C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000001E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000022   0xD003             BEQ.N    ??_DrawBitLine1BPP_0
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD018             BEQ.N    ??_DrawBitLine1BPP_1
   \   00000028   0xD32C             BCC.N    ??_DrawBitLine1BPP_2
   \   0000002A   0xE045             B.N      ??_DrawBitLine1BPP_3
     43            case 0:
     44              do {
     45                LCDDEV_L0_SetPixelIndex(x, y, (*p & (0x80 >> Diff)) ? Index1 : Index0);
   \                     ??_DrawBitLine1BPP_0: (+1)
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x2180             MOVS     R1,#+128
   \   00000030   0x4131             ASRS     R1,R1,R6
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD001             BEQ.N    ??_DrawBitLine1BPP_4
   \   00000036   0x4642             MOV      R2,R8
   \   00000038   0xE000             B.N      ??_DrawBitLine1BPP_5
   \                     ??_DrawBitLine1BPP_4: (+1)
   \   0000003A   0x463A             MOV      R2,R7
   \                     ??_DrawBitLine1BPP_5: (+1)
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       LCD_L0_SetPixelIndex
     46                y--;
   \   00000044   0xF1A9 0x0901      SUB      R9,R9,#+1
     47          			if (++Diff == 8) {
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \   0000004A   0x2E08             CMP      R6,#+8
   \   0000004C   0xD101             BNE.N    ??_DrawBitLine1BPP_6
     48                  Diff = 0;
   \   0000004E   0x2600             MOVS     R6,#+0
     49          				p++;
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
     50          			}
     51          		} while (--xsize);
   \                     ??_DrawBitLine1BPP_6: (+1)
   \   00000052   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000056   0xD1E9             BNE.N    ??_DrawBitLine1BPP_0
   \   00000058   0xE02E             B.N      ??_DrawBitLine1BPP_3
     52              break;
     53            case LCD_DRAWMODE_TRANS:
     54              do {
     55            		if (*p & (0x80 >> Diff))
   \                     ??_DrawBitLine1BPP_1: (+1)
   \   0000005A   0x7828             LDRB     R0,[R5, #+0]
   \   0000005C   0x2180             MOVS     R1,#+128
   \   0000005E   0x4131             ASRS     R1,R1,R6
   \   00000060   0x4208             TST      R0,R1
   \   00000062   0xD004             BEQ.N    ??_DrawBitLine1BPP_7
     56                  LCDDEV_L0_SetPixelIndex(x, y, Index1);
   \   00000064   0x4642             MOV      R2,R8
   \   00000066   0x4649             MOV      R1,R9
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       LCD_L0_SetPixelIndex
     57                y--;
   \                     ??_DrawBitLine1BPP_7: (+1)
   \   0000006E   0xF1A9 0x0901      SUB      R9,R9,#+1
     58          			if (++Diff == 8) {
   \   00000072   0x1C76             ADDS     R6,R6,#+1
   \   00000074   0x2E08             CMP      R6,#+8
   \   00000076   0xD101             BNE.N    ??_DrawBitLine1BPP_8
     59                  Diff = 0;
   \   00000078   0x2600             MOVS     R6,#+0
     60          				p++;
   \   0000007A   0x1C6D             ADDS     R5,R5,#+1
     61          			}
     62          		} while (--xsize);
   \                     ??_DrawBitLine1BPP_8: (+1)
   \   0000007C   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000080   0xD1EB             BNE.N    ??_DrawBitLine1BPP_1
   \   00000082   0xE019             B.N      ??_DrawBitLine1BPP_3
     63              break;
     64            case LCD_DRAWMODE_XOR:;
     65              do {
     66            		if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_2: (+1)
   \   00000084   0x7828             LDRB     R0,[R5, #+0]
   \   00000086   0x2180             MOVS     R1,#+128
   \   00000088   0x4131             ASRS     R1,R1,R6
   \   0000008A   0x4208             TST      R0,R1
   \   0000008C   0xD00A             BEQ.N    ??_DrawBitLine1BPP_9
     67                  int Pixel = LCD_L0_GetPixelIndex(x, y);
   \   0000008E   0x4649             MOV      R1,R9
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       LCD_L0_GetPixelIndex
     68                  LCDDEV_L0_SetPixelIndex(x, y, LCD_NUM_COLORS - 1 - Pixel);
   \   00000096   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000009A   0x1A0A             SUBS     R2,R1,R0
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       LCD_L0_SetPixelIndex
     69                }
     70                y--;
   \                     ??_DrawBitLine1BPP_9: (+1)
   \   000000A4   0xF1A9 0x0901      SUB      R9,R9,#+1
     71          			if (++Diff == 8) {
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
   \   000000AA   0x2E08             CMP      R6,#+8
   \   000000AC   0xD101             BNE.N    ??_DrawBitLine1BPP_10
     72                  Diff = 0;
   \   000000AE   0x2600             MOVS     R6,#+0
     73          				p++;
   \   000000B0   0x1C6D             ADDS     R5,R5,#+1
     74          			}
     75          		} while (--xsize);
   \                     ??_DrawBitLine1BPP_10: (+1)
   \   000000B2   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   000000B6   0xD1E5             BNE.N    ??_DrawBitLine1BPP_2
     76              break;
     77          	}
     78          }
   \                     ??_DrawBitLine1BPP_3: (+1)
   \   000000B8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
     79          
     80          /*********************************************************************
     81          *
     82          *       _DrawBitmap
     83          *
     84          * Purpose:
     85          *   Draws a bitmap (1bpp) counter clockwise.
     86          */

   \                                 In section .text, align 2, keep-with-next
     87          static void _DrawBitmap(int x0, int y0,
     88                                 int xsize, int ysize,
     89                                 int BitsPerPixel, 
     90                                 int BytesPerLine,
     91                                 const U8 GUI_UNI_PTR * pData, int Diff,
     92                                 const LCD_PIXELINDEX* pTrans)
     93          {
   \                     _DrawBitmap: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
     94            int i;
     95            /* Use _DrawBitLineXBPP */
     96            for (i=0; i<ysize; i++) {
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x9F0E             LDR      R7,[SP, #+56]
   \   0000000E   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   \   00000012   0xF8DD 0x9040      LDR      R9,[SP, #+64]
   \   00000016   0xF8DD 0xA044      LDR      R10,[SP, #+68]
   \   0000001A   0xF8DD 0xB048      LDR      R11,[SP, #+72]
   \   0000001E   0xE00D             B.N      ??_DrawBitmap_0
     97              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_1: (+1)
   \   00000020   0x2F01             CMP      R7,#+1
   \   00000022   0xD109             BNE.N    ??_DrawBitmap_2
     98              case 1:
     99                _DrawBitLine1BPP(x0 + i, y0, pData, Diff, xsize, pTrans);
   \   00000024   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \   00000028   0x9400             STR      R4,[SP, #+0]
   \   0000002A   0x4653             MOV      R3,R10
   \   0000002C   0x464A             MOV      R2,R9
   \   0000002E   0x9904             LDR      R1,[SP, #+16]
   \   00000030   0x9803             LDR      R0,[SP, #+12]
   \   00000032   0x1830             ADDS     R0,R6,R0
   \   00000034   0x.... 0x....      BL       _DrawBitLine1BPP
    100                break;
    101              }
    102              pData += BytesPerLine;
   \                     ??_DrawBitmap_2: (+1)
   \   00000038   0x44C1             ADD      R9,R8,R9
    103            }
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \                     ??_DrawBitmap_0: (+1)
   \   0000003C   0x42AE             CMP      R6,R5
   \   0000003E   0xDBEF             BLT.N    ??_DrawBitmap_1
    104          }
   \   00000040   0xB005             ADD      SP,SP,#+20
   \   00000042   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    105          
    106          /*********************************************************************
    107          *
    108          *       _Rect2TextRect
    109          *
    110          * Purpose:
    111          *   This function transforms a given rectangle (window coordinates)
    112          *   to the rectangle used to clip the text.
    113          */

   \                                 In section .text, align 2, keep-with-next
    114          static void _Rect2TextRect(GUI_RECT * pRect) {
    115            int x1, y1;
    116            x1 = pRect->x1;
   \                     _Rect2TextRect: (+1)
   \   00000000   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
    117            y1 = pRect->y1;
    118            pRect->x1 = pRect->x0 + (y1 - pRect->y0);
   \   00000004   0x8802             LDRH     R2,[R0, #+0]
   \   00000006   0x88C3             LDRH     R3,[R0, #+6]
   \   00000008   0x189A             ADDS     R2,R3,R2
   \   0000000A   0x8843             LDRH     R3,[R0, #+2]
   \   0000000C   0x1AD2             SUBS     R2,R2,R3
   \   0000000E   0x8082             STRH     R2,[R0, #+4]
    119            pRect->y1 = pRect->y0 + (x1 - pRect->x0);
   \   00000010   0x461A             MOV      R2,R3
   \   00000012   0x1889             ADDS     R1,R1,R2
   \   00000014   0x8802             LDRH     R2,[R0, #+0]
   \   00000016   0x1A89             SUBS     R1,R1,R2
   \   00000018   0x80C1             STRH     R1,[R0, #+6]
    120          }
   \   0000001A   0x4770             BX       LR               ;; return
    121          
    122          /*********************************************************************
    123          *
    124          *       _TransformPointCCW
    125          *
    126          * Purpose:
    127          *   This function transforms an unrotated point (window
    128          *   coordinates) into a rotated point in desktop coordinates
    129          *   and handles the rotation of the current text rectangle.
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          static void _TransformPointCCW(int * pXPos, int * pYPos) {
   \                     _TransformPointCCW: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    132            GUI_RECT ClientRect = {0};
   \   00000006   0x.... 0x....      ADR.W    R0,`?<Constant {0}>`
   \   0000000A   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000000E   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
    133            int xPos, yPos, xNumPixel, yNumPixel;
    134            /* Get the client rectangle */
    135            #if GUI_WINSUPPORT
    136              WM_GetWindowRect(&ClientRect);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       WM_GetWindowRect
    137            #else
    138              GUI_GetClientRect(&ClientRect);
    139            #endif
    140            xNumPixel = LCD_GetXSize() - 1;
   \   00000018   0x.... 0x....      BL       LCD_GetXSize
   \   0000001C   0x1E46             SUBS     R6,R0,#+1
    141            yNumPixel = LCD_GetYSize() - 1;
   \   0000001E   0x.... 0x....      BL       LCD_GetYSize
   \   00000022   0x1E40             SUBS     R0,R0,#+1
    142            if (ClientRect.x1 > xNumPixel) {
   \   00000024   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   00000028   0x428E             CMP      R6,R1
   \   0000002A   0xDA01             BGE.N    ??_TransformPointCCW_0
    143              ClientRect.x1 = xNumPixel;
   \   0000002C   0xF8AD 0x6004      STRH     R6,[SP, #+4]
    144            }
    145            if (ClientRect.y1 > yNumPixel) {
   \                     ??_TransformPointCCW_0: (+1)
   \   00000030   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xDA01             BGE.N    ??_TransformPointCCW_1
    146              ClientRect.y1 = yNumPixel;
   \   00000038   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    147            }
    148            /* Save old positions */
    149            xPos = *pXPos;
   \                     ??_TransformPointCCW_1: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
    150            yPos = *pYPos;
    151            /* Rotate and add window origin */
    152            *pXPos = ClientRect.x0 + yPos;
   \   0000003E   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000042   0x682A             LDR      R2,[R5, #+0]
   \   00000044   0x1851             ADDS     R1,R2,R1
   \   00000046   0x6021             STR      R1,[R4, #+0]
    153            *pYPos = ClientRect.y1 - xPos;
   \   00000048   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   0000004C   0x1A08             SUBS     R0,R1,R0
   \   0000004E   0x6028             STR      R0,[R5, #+0]
    154            /* Handle rotation of text rectangle */
    155            *pXPos = *pXPos + GUI_RectDispString.x0 - GUI_RectDispString.y0;
   \   00000050   0x....             LDR.N    R0,??DataTable3_1
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   00000058   0x1851             ADDS     R1,R2,R1
   \   0000005A   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   0000005E   0x1A89             SUBS     R1,R1,R2
   \   00000060   0x6021             STR      R1,[R4, #+0]
    156            *pYPos = *pYPos + GUI_RectDispString.y1 - (ClientRect.y1 - ClientRect.y0) + GUI_RectDispString.x0;
   \   00000062   0x6829             LDR      R1,[R5, #+0]
   \   00000064   0xF9B0 0x2006      LDRSH    R2,[R0, #+6]
   \   00000068   0x1851             ADDS     R1,R2,R1
   \   0000006A   0xF9BD 0x2006      LDRSH    R2,[SP, #+6]
   \   0000006E   0x1A89             SUBS     R1,R1,R2
   \   00000070   0xF9BD 0x2002      LDRSH    R2,[SP, #+2]
   \   00000074   0x1851             ADDS     R1,R2,R1
   \   00000076   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000007A   0x1840             ADDS     R0,R0,R1
   \   0000007C   0x6028             STR      R0,[R5, #+0]
    157          }
   \   0000007E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    158          
    159          /*********************************************************************
    160          *
    161          *       _DrawBitmapCCW
    162          */

   \                                 In section .text, align 2, keep-with-next
    163          static void _DrawBitmapCCW(int x0, int y0, int xsize, int ysize, int xMul, int yMul,
    164                                     int BitsPerPixel, int BytesPerLine,
    165                                     const U8 GUI_UNI_PTR * pPixel, const LCD_PIXELINDEX* pTrans)
    166          {
   \                     _DrawBitmapCCW: (+1)
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x4614             MOV      R4,R2
    167            U8  Data = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    168            int x1, y1;
    169            /* Handle the optional Y-magnification */
    170            y1 = y0 + ysize - 1;
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x4619             MOV      R1,R3
   \   0000000E   0x1808             ADDS     R0,R1,R0
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x9006             STR      R0,[SP, #+24]
    171            x1 = x0 + xsize - 1;
   \   00000014   0x9808             LDR      R0,[SP, #+32]
   \   00000016   0x1820             ADDS     R0,R4,R0
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x9005             STR      R0,[SP, #+20]
    172            /* Rotate positions */
    173            _TransformPointCCW(&x0, &y0);
   \   0000001C   0xA909             ADD      R1,SP,#+36
   \   0000001E   0xA808             ADD      R0,SP,#+32
   \   00000020   0x.... 0x....      BL       _TransformPointCCW
    174            _TransformPointCCW(&x1, &y1);
   \   00000024   0xA906             ADD      R1,SP,#+24
   \   00000026   0xA805             ADD      R0,SP,#+20
   \   00000028   0x.... 0x....      BL       _TransformPointCCW
   \   0000002C   0x9D18             LDR      R5,[SP, #+96]
    175            /*  Handle BITMAP without magnification */
    176            if ((xMul == 1) && (yMul == 1)) {
   \   0000002E   0x9814             LDR      R0,[SP, #+80]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD14E             BNE.N    ??_DrawBitmapCCW_0
   \   00000034   0x9815             LDR      R0,[SP, #+84]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD14B             BNE.N    ??_DrawBitmapCCW_0
    177              int Diff = 0;
   \   0000003A   0x4630             MOV      R0,R6
    178              /* Clip top */
    179              if (y1 < GUI_Context.ClipRect.y0) {
   \   0000003C   0x....             LDR.N    R7,??DataTable3
   \   0000003E   0xF9B7 0x1006      LDRSH    R1,[R7, #+6]
   \   00000042   0x9A06             LDR      R2,[SP, #+24]
   \   00000044   0x428A             CMP      R2,R1
   \   00000046   0xDA01             BGE.N    ??_DrawBitmapCCW_1
    180                int Diff = GUI_Context.ClipRect.y0 - y1;
    181                xsize -= Diff;
   \   00000048   0x1A61             SUBS     R1,R4,R1
   \   0000004A   0x1854             ADDS     R4,R2,R1
   \                     ??_DrawBitmapCCW_1: (+1)
   \   0000004C   0xF9B7 0x100A      LDRSH    R1,[R7, #+10]
   \   00000050   0x9A09             LDR      R2,[SP, #+36]
   \   00000052   0x4291             CMP      R1,R2
   \   00000054   0xDA0E             BGE.N    ??_DrawBitmapCCW_2
    182              }
    183              /* Clip bottom */
    184              if (y0 > GUI_Context.ClipRect.y1) {
    185                Diff = y0 - GUI_Context.ClipRect.y1;
   \   00000056   0x4610             MOV      R0,R2
   \   00000058   0x1A40             SUBS     R0,R0,R1
    186          			xsize -= Diff;
   \   0000005A   0x1A24             SUBS     R4,R4,R0
    187          			switch (BitsPerPixel) {
   \   0000005C   0x9916             LDR      R1,[SP, #+88]
   \   0000005E   0x2901             CMP      R1,#+1
   \   00000060   0xD108             BNE.N    ??_DrawBitmapCCW_2
    188          			case 1:
    189            			pPixel += (Diff >> 3); y0 -= (Diff >> 3) << 3; Diff &= 7;
   \   00000062   0xEB05 0x05E0      ADD      R5,R5,R0, ASR #+3
   \   00000066   0x4611             MOV      R1,R2
   \   00000068   0xF020 0x0207      BIC      R2,R0,#0x7
   \   0000006C   0x1A89             SUBS     R1,R1,R2
   \   0000006E   0x9109             STR      R1,[SP, #+36]
   \   00000070   0xF000 0x0007      AND      R0,R0,#0x7
    190          				break;
    191          			}
    192              }
    193              if (ysize <= 0) {
   \                     ??_DrawBitmapCCW_2: (+1)
   \   00000074   0x990A             LDR      R1,[SP, #+40]
   \   00000076   0x2901             CMP      R1,#+1
   \   00000078   0xDB28             BLT.N    ??_DrawBitmapCCW_3
    194          		  return;
   \   0000007A   0xF9B7 0x1008      LDRSH    R1,[R7, #+8]
   \   0000007E   0x9A05             LDR      R2,[SP, #+20]
   \   00000080   0x4291             CMP      R1,R2
   \   00000082   0xDA04             BGE.N    ??_DrawBitmapCCW_4
    195              }
    196              /* Clip right side */
    197              if (x1 > GUI_Context.ClipRect.x1) {
    198                int Diff = x1 - GUI_Context.ClipRect.x1;
    199                ysize -= Diff;
   \   00000084   0x9A0A             LDR      R2,[SP, #+40]
   \   00000086   0x9B05             LDR      R3,[SP, #+20]
   \   00000088   0x1AD2             SUBS     R2,R2,R3
   \   0000008A   0x1889             ADDS     R1,R1,R2
   \   0000008C   0x910A             STR      R1,[SP, #+40]
   \                     ??_DrawBitmapCCW_4: (+1)
   \   0000008E   0xF9B7 0x1004      LDRSH    R1,[R7, #+4]
   \   00000092   0x9A08             LDR      R2,[SP, #+32]
   \   00000094   0x428A             CMP      R2,R1
   \   00000096   0xDA09             BGE.N    ??_DrawBitmapCCW_5
    200              }
    201              /* Clip left side */
    202              if (x0 < GUI_Context.ClipRect.x0) {
    203                int Diff = GUI_Context.ClipRect.x0 - x0;
   \   00000098   0x1A89             SUBS     R1,R1,R2
    204                pPixel += Diff * BytesPerLine;
   \   0000009A   0x9A17             LDR      R2,[SP, #+92]
   \   0000009C   0xFB02 0x5501      MLA      R5,R2,R1,R5
    205                x0 += Diff;
   \   000000A0   0x9A08             LDR      R2,[SP, #+32]
   \   000000A2   0x188A             ADDS     R2,R1,R2
   \   000000A4   0x9208             STR      R2,[SP, #+32]
    206                ysize -= Diff;
   \   000000A6   0x9A0A             LDR      R2,[SP, #+40]
   \   000000A8   0x1A51             SUBS     R1,R2,R1
   \   000000AA   0x910A             STR      R1,[SP, #+40]
    207              }
    208              if (xsize <= 0) {
   \                     ??_DrawBitmapCCW_5: (+1)
   \   000000AC   0x2C01             CMP      R4,#+1
   \   000000AE   0xDB0D             BLT.N    ??_DrawBitmapCCW_3
    209          		  return;
    210              }
    211              _DrawBitmap(x0, y0, xsize, ysize, BitsPerPixel, BytesPerLine, pPixel, Diff, pTrans);
   \   000000B0   0x9919             LDR      R1,[SP, #+100]
   \   000000B2   0x9104             STR      R1,[SP, #+16]
   \   000000B4   0x9003             STR      R0,[SP, #+12]
   \   000000B6   0x9502             STR      R5,[SP, #+8]
   \   000000B8   0x9817             LDR      R0,[SP, #+92]
   \   000000BA   0x9001             STR      R0,[SP, #+4]
   \   000000BC   0x9816             LDR      R0,[SP, #+88]
   \   000000BE   0x9000             STR      R0,[SP, #+0]
   \   000000C0   0x9B0A             LDR      R3,[SP, #+40]
   \   000000C2   0x4622             MOV      R2,R4
   \   000000C4   0x9909             LDR      R1,[SP, #+36]
   \   000000C6   0x9808             LDR      R0,[SP, #+32]
   \   000000C8   0x.... 0x....      BL       _DrawBitmap
    212            } else {
    213              /* Handle BITMAP with magnification */
    214              int x, y, xi, yi;
    215              int Shift = 8 - BitsPerPixel;
    216              for (x = x0, xi = 0; xi < ysize; xi++, x += yMul, pPixel += BytesPerLine) {
    217                int xMax = x + yMul - 1;
    218                if ((xMax >= GUI_Context.ClipRect.x0) && (x <= GUI_Context.ClipRect.x1)) {
    219                  int BitsLeft = 0;
    220                  const U8 GUI_UNI_PTR * pDataLine = pPixel;
    221                  for (y = y0, yi = 0; yi < xsize; yi++, y -= xMul) {
    222                    U8  Index;
    223                    if (!BitsLeft) {
    224                      Data = *pDataLine++;
    225                      BitsLeft =8;
    226                    }
    227                    Index = Data >> Shift;
    228                    Data    <<= BitsPerPixel;
    229                    BitsLeft -= BitsPerPixel;
    230                    if (Index || ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0)) {
    231                      LCD_PIXELINDEX OldColor = LCD_COLORINDEX;
    232                      if (pTrans) {
    233                        LCD_COLORINDEX = *(pTrans + Index);
    234                      } else {
    235                        LCD_COLORINDEX = Index;
    236                      }
    237                      LCD_FillRect(x, y - xMul + 1, xMax, y);
    238                      LCD_COLORINDEX = OldColor;
    239                    }
    240                  }
    241                }
    242              }
    243            }
    244          }
   \                     ??_DrawBitmapCCW_3: (+1)
   \   000000CC   0xB00B             ADD      SP,SP,#+44
   \   000000CE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??_DrawBitmapCCW_0: (+1)
   \   000000D2   0x9816             LDR      R0,[SP, #+88]
   \   000000D4   0xF1C0 0x0008      RSB      R0,R0,#+8
   \   000000D8   0x9007             STR      R0,[SP, #+28]
   \   000000DA   0x9808             LDR      R0,[SP, #+32]
   \   000000DC   0x9000             STR      R0,[SP, #+0]
   \   000000DE   0x4630             MOV      R0,R6
   \   000000E0   0x9001             STR      R0,[SP, #+4]
   \   000000E2   0x....             LDR.N    R7,??DataTable3
   \   000000E4   0xE006             B.N      ??_DrawBitmapCCW_6
   \                     ??_DrawBitmapCCW_7: (+1)
   \   000000E6   0x9801             LDR      R0,[SP, #+4]
   \   000000E8   0x1C40             ADDS     R0,R0,#+1
   \   000000EA   0x9001             STR      R0,[SP, #+4]
   \   000000EC   0x9803             LDR      R0,[SP, #+12]
   \   000000EE   0x9000             STR      R0,[SP, #+0]
   \   000000F0   0x9817             LDR      R0,[SP, #+92]
   \   000000F2   0x1945             ADDS     R5,R0,R5
   \                     ??_DrawBitmapCCW_6: (+1)
   \   000000F4   0x9801             LDR      R0,[SP, #+4]
   \   000000F6   0x990A             LDR      R1,[SP, #+40]
   \   000000F8   0x4288             CMP      R0,R1
   \   000000FA   0xDAE7             BGE.N    ??_DrawBitmapCCW_3
   \   000000FC   0x9800             LDR      R0,[SP, #+0]
   \   000000FE   0x9915             LDR      R1,[SP, #+84]
   \   00000100   0x1808             ADDS     R0,R1,R0
   \   00000102   0x9003             STR      R0,[SP, #+12]
   \   00000104   0x1E40             SUBS     R0,R0,#+1
   \   00000106   0x9002             STR      R0,[SP, #+8]
   \   00000108   0xF9B7 0x1004      LDRSH    R1,[R7, #+4]
   \   0000010C   0x4288             CMP      R0,R1
   \   0000010E   0xDBEA             BLT.N    ??_DrawBitmapCCW_7
   \   00000110   0xF9B7 0x0008      LDRSH    R0,[R7, #+8]
   \   00000114   0x9900             LDR      R1,[SP, #+0]
   \   00000116   0x4288             CMP      R0,R1
   \   00000118   0xDBE5             BLT.N    ??_DrawBitmapCCW_7
   \   0000011A   0xF04F 0x0800      MOV      R8,#+0
   \   0000011E   0x9504             STR      R5,[SP, #+16]
   \   00000120   0xF8DD 0x9024      LDR      R9,[SP, #+36]
   \   00000124   0x46C2             MOV      R10,R8
   \   00000126   0xE010             B.N      ??_DrawBitmapCCW_8
   \                     ??_DrawBitmapCCW_9: (+1)
   \   00000128   0x8078             STRH     R0,[R7, #+2]
   \                     ??_DrawBitmapCCW_10: (+1)
   \   0000012A   0x464B             MOV      R3,R9
   \   0000012C   0x9A02             LDR      R2,[SP, #+8]
   \   0000012E   0x9814             LDR      R0,[SP, #+80]
   \   00000130   0xEBA9 0x0000      SUB      R0,R9,R0
   \   00000134   0x1C41             ADDS     R1,R0,#+1
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x.... 0x....      BL       LCD_FillRect
   \   0000013C   0xF8A7 0xB002      STRH     R11,[R7, #+2]
   \                     ??_DrawBitmapCCW_11: (+1)
   \   00000140   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   00000144   0x9814             LDR      R0,[SP, #+80]
   \   00000146   0xEBA9 0x0900      SUB      R9,R9,R0
   \                     ??_DrawBitmapCCW_8: (+1)
   \   0000014A   0x45A2             CMP      R10,R4
   \   0000014C   0xDACB             BGE.N    ??_DrawBitmapCCW_7
   \   0000014E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000152   0xD106             BNE.N    ??_DrawBitmapCCW_12
   \   00000154   0x9804             LDR      R0,[SP, #+16]
   \   00000156   0x1C40             ADDS     R0,R0,#+1
   \   00000158   0x9004             STR      R0,[SP, #+16]
   \   0000015A   0x1E40             SUBS     R0,R0,#+1
   \   0000015C   0x7806             LDRB     R6,[R0, #+0]
   \   0000015E   0xF04F 0x0808      MOV      R8,#+8
   \                     ??_DrawBitmapCCW_12: (+1)
   \   00000162   0xB2F6             UXTB     R6,R6
   \   00000164   0x9807             LDR      R0,[SP, #+28]
   \   00000166   0xFA46 0xF000      ASR      R0,R6,R0
   \   0000016A   0xB2C0             UXTB     R0,R0
   \   0000016C   0x9916             LDR      R1,[SP, #+88]
   \   0000016E   0x408E             LSLS     R6,R6,R1
   \   00000170   0xEBA8 0x0801      SUB      R8,R8,R1
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD102             BNE.N    ??_DrawBitmapCCW_13
   \   00000178   0x7B39             LDRB     R1,[R7, #+12]
   \   0000017A   0x0789             LSLS     R1,R1,#+30
   \   0000017C   0xD4E0             BMI.N    ??_DrawBitmapCCW_11
   \                     ??_DrawBitmapCCW_13: (+1)
   \   0000017E   0xF8B7 0xB002      LDRH     R11,[R7, #+2]
   \   00000182   0x9919             LDR      R1,[SP, #+100]
   \   00000184   0x2900             CMP      R1,#+0
   \   00000186   0xD0CF             BEQ.N    ??_DrawBitmapCCW_9
   \   00000188   0xF831 0x0010      LDRH     R0,[R1, R0, LSL #+1]
   \   0000018C   0x8078             STRH     R0,[R7, #+2]
   \   0000018E   0xE7CC             B.N      ??_DrawBitmapCCW_10
    245          
    246          /*********************************************************************
    247          *
    248          *       Global data
    249          *
    250          **********************************************************************
    251          */
    252          /*********************************************************************
    253          *
    254          *       LCD_APIListCCW
    255          *
    256          * Purpose:
    257          *   Function pointer table for rotating text CCW
    258          */

   \                                 In section .data, align 4
    259          tLCD_APIList LCD_APIListCCW = {
   \                     LCD_APIListCCW:
   \   00000000   0x........         DC32 _DrawBitmapCCW, _Rect2TextRect
   \              0x........   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     GUI_RectDispString

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
    260            (tLCD_DrawBitmap*)&_DrawBitmapCCW,
    261            &_Rect2TextRect
    262          };
    263          
    264          #else
    265          void LCD_RotateCCW_C(void);
    266          void LCD_RotateCCW_C(void){}
    267          #endif
    268          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   _DrawBitLine1BPP
        32   -> LCD_L0_GetPixelIndex
        32   -> LCD_L0_SetPixelIndex
      56   _DrawBitmap
        56   -> _DrawBitLine1BPP
      80   _DrawBitmapCCW
        80   -> LCD_FillRect
        80   -> _DrawBitmap
        80   -> _TransformPointCCW
       0   _Rect2TextRect
      24   _TransformPointCCW
        24   -> LCD_GetXSize
        24   -> LCD_GetYSize
        24   -> WM_GetWindowRect


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {0}>
       4  ??DataTable3
       4  ??DataTable3_1
       8  LCD_APIListCCW
     188  _DrawBitLine1BPP
      70  _DrawBitmap
     400  _DrawBitmapCCW
      28  _Rect2TextRect
     128  _TransformPointCCW

 
   8 bytes in section .data
 830 bytes in section .text
 
 830 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
