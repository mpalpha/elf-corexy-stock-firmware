###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  17:00:47
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCDRLE8.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCDRLE8.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\LCDRLE8.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\LCDRLE8.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCDRLE8.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : LCDRLE8.c
     16          Purpose     : Drawing routines for run length encoded bitmaps
     17                        with 8 bpp
     18          ---------------------------END-OF-HEADER------------------------------
     19          */
     20          
     21          #include <stddef.h>           /* needed for definition of NULL */
     22          #include "GUI_Private.h"
     23          #include "LCD_Private.h"
     24          
     25          /*********************************************************************
     26          *
     27          *       Static data
     28          *
     29          **********************************************************************
     30          */
     31          
     32          static struct {
     33            int x,y;
     34            const U8 GUI_UNI_PTR * pPixel;
     35            const U8 GUI_UNI_PTR * pPixelStart;

   \                                 In section .bss, align 4
     36          } Cache;
   \                     Cache:
   \   00000000                      DS8 16
     37          
     38          /*********************************************************************
     39          *
     40          *       Static code
     41          *
     42          **********************************************************************
     43          */
     44          /*********************************************************************
     45          *
     46          *       _DrawBitmap_RLE8
     47          */

   \                                 In section .text, align 2, keep-with-next
     48          static void _DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR * pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag) {
   \                     _DrawBitmap_RLE8: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x9E10             LDR      R6,[SP, #+64]
     49            LCD_PIXELINDEX aColorIndex[2];
     50            LCD_PIXELINDEX PixelIndex;
     51            int xi,y;
     52            int xL, yL;
     53            const U8 GUI_UNI_PTR * pPixelOrg = pPixel;
   \   0000000A   0x4637             MOV      R7,R6
     54            char NoTrans = !(GUI_Context.DrawMode & LCD_DRAWMODE_TRANS);
   \   0000000C   0x....             LDR.N    R5,??DataTable1
   \   0000000E   0x7B28             LDRB     R0,[R5, #+12]
   \   00000010   0x0840             LSRS     R0,R0,#+1
   \   00000012   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000016   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000001A   0x9003             STR      R0,[SP, #+12]
     55            const LCD_PIXELINDEX* pTrans =NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9000             STR      R0,[SP, #+0]
     56            char IsMagnified = ((yMag | xMag) != 1);
   \   00000020   0x9813             LDR      R0,[SP, #+76]
   \   00000022   0x9912             LDR      R1,[SP, #+72]
   \   00000024   0x4308             ORRS     R0,R1,R0
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD002             BEQ.N    ??_DrawBitmap_RLE8_0
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0xE001             B.N      ??_DrawBitmap_RLE8_1
   \                     ??_DrawBitmap_RLE8_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9001             STR      R0,[SP, #+4]
     57            aColorIndex[0] = LCD_ACOLORINDEX[0];
   \                     ??_DrawBitmap_RLE8_1: (+1)
   \   00000034   0x8828             LDRH     R0,[R5, #+0]
   \   00000036   0xF8AD 0x000A      STRH     R0,[SP, #+10]
     58            aColorIndex[1] = LCD_ACOLORINDEX[1];
   \   0000003A   0x8868             LDRH     R0,[R5, #+2]
   \   0000003C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \   00000040   0x9811             LDR      R0,[SP, #+68]
     59            /* Handle color translation */
     60            if ((pLogPal) && (pLogPal->pPalEntries)) {
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD008             BEQ.N    ??_DrawBitmap_RLE8_2
   \   00000046   0x6881             LDR      R1,[R0, #+8]
   \   00000048   0x2900             CMP      R1,#+0
   \   0000004A   0xD005             BEQ.N    ??_DrawBitmap_RLE8_2
     61              if ((pTrans = LCD_GetpPalConvTable(pLogPal)) == NULL) {
   \   0000004C   0x.... 0x....      BL       LCD_GetpPalConvTable
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xF000 0x80CD      BEQ.W    ??_DrawBitmap_RLE8_3
     62                return;
     63              }
     64            }
     65           /* Check if we can limit the number of lines due to clipping) */
     66            if (yMag == 1) {
   \                     ??_DrawBitmap_RLE8_2: (+1)
   \   00000058   0x9813             LDR      R0,[SP, #+76]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD108             BNE.N    ??_DrawBitmap_RLE8_4
     67              if (ysize > GUI_Context.ClipRect.y1 - y0 + 1)
   \   0000005E   0xF9B5 0x000A      LDRSH    R0,[R5, #+10]
   \   00000062   0x9904             LDR      R1,[SP, #+16]
   \   00000064   0x1A40             SUBS     R0,R0,R1
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x9906             LDR      R1,[SP, #+24]
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xDA00             BGE.N    ??_DrawBitmap_RLE8_4
     68                ysize = GUI_Context.ClipRect.y1 - y0 + 1;
   \   0000006E   0x9006             STR      R0,[SP, #+24]
     69            }
     70            /* Init variables for looping */
     71            xi=0;
   \                     ??_DrawBitmap_RLE8_4: (+1)
   \   00000070   0xF04F 0x0900      MOV      R9,#+0
     72            y =0;
   \   00000074   0x46C8             MOV      R8,R9
   \   00000076   0x9801             LDR      R0,[SP, #+4]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD110             BNE.N    ??_DrawBitmap_RLE8_5
     73            /* Check if we can use the cache to save some unnecessary iterations */
     74            if (!IsMagnified) {
     75              int yDiff = GUI_Context.ClipRect.y0 - y0;
     76              if ((Cache.pPixelStart == pPixel) && (yDiff > Cache.y)) {
   \   0000007C   0x....             LDR.N    R0,??DataTable1_1
   \   0000007E   0x68C0             LDR      R0,[R0, #+12]
   \   00000080   0x42B0             CMP      R0,R6
   \   00000082   0xD10C             BNE.N    ??_DrawBitmap_RLE8_5
   \   00000084   0x....             LDR.N    R0,??DataTable1_1
   \   00000086   0x6840             LDR      R0,[R0, #+4]
   \   00000088   0xF9B5 0x1006      LDRSH    R1,[R5, #+6]
   \   0000008C   0x9A04             LDR      R2,[SP, #+16]
   \   0000008E   0x1A89             SUBS     R1,R1,R2
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xDA04             BGE.N    ??_DrawBitmap_RLE8_5
     77                /* Accept cache values */
     78                y = Cache.y;
   \   00000094   0x4680             MOV      R8,R0
     79                xi = Cache.x;
   \   00000096   0x....             LDR.N    R0,??DataTable1_1
   \   00000098   0xF8D0 0x9000      LDR      R9,[R0, #+0]
     80                pPixel = Cache.pPixel;
   \   0000009C   0x6886             LDR      R6,[R0, #+8]
     81              }
     82            }
     83            /* Init values for caching */
     84            Cache.pPixel = Cache.pPixelStart = pPixelOrg;
   \                     ??_DrawBitmap_RLE8_5: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable1_1
   \   000000A0   0x60C7             STR      R7,[R0, #+12]
   \   000000A2   0x4638             MOV      R0,R7
   \   000000A4   0x....             LDR.N    R1,??DataTable1_1
   \   000000A6   0x6088             STR      R0,[R1, #+8]
     85            Cache.x = Cache.y = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x6048             STR      R0,[R1, #+4]
   \   000000AC   0x6008             STR      R0,[R1, #+0]
     86            /* Repeat until we have reached bottom */
     87            for (; y < ysize; ) {
   \                     ??_DrawBitmap_RLE8_6: (+1)
   \   000000AE   0x9806             LDR      R0,[SP, #+24]
   \   000000B0   0x4580             CMP      R8,R0
   \   000000B2   0xF280 0x8098      BGE.W    ??_DrawBitmap_RLE8_7
     88              U8 Cmd  = *pPixel++;
   \   000000B6   0xF816 0xBB01      LDRB     R11,[R6], #+1
     89              U8 Data = *pPixel++;
   \   000000BA   0xF816 0x7B01      LDRB     R7,[R6], #+1
     90              if (Cmd) {
   \   000000BE   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000C2   0xF000 0x8083      BEQ.W    ??_DrawBitmap_RLE8_8
     91                /* Save cache info */
     92                Cache.pPixel = pPixel-2;
   \   000000C6   0x1EB0             SUBS     R0,R6,#+2
   \   000000C8   0x....             LDR.N    R1,??DataTable1_1
   \   000000CA   0x6088             STR      R0,[R1, #+8]
     93                Cache.x = xi;
   \   000000CC   0x4608             MOV      R0,R1
   \   000000CE   0xF8C0 0x9000      STR      R9,[R0, #+0]
     94                Cache.y = y;
   \   000000D2   0xF8C0 0x8004      STR      R8,[R0, #+4]
     95                LCD_ACOLORINDEX[1] = pTrans ? *(pTrans+Data) : Data;
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD002             BEQ.N    ??_DrawBitmap_RLE8_9
   \   000000DC   0xF830 0x0017      LDRH     R0,[R0, R7, LSL #+1]
   \   000000E0   0xE000             B.N      ??_DrawBitmap_RLE8_10
   \                     ??_DrawBitmap_RLE8_9: (+1)
   \   000000E2   0x4638             MOV      R0,R7
   \                     ??_DrawBitmap_RLE8_10: (+1)
   \   000000E4   0x8068             STRH     R0,[R5, #+2]
   \   000000E6   0xE011             B.N      ??_DrawBitmap_RLE8_11
     96                while (Cmd) {
     97                  int xi1 = xi+Cmd;
     98                  if (xi1>=xsize)
     99                    xi1 = xsize;
    100                  Cmd -= (xi1-xi);
    101                  if (Data || NoTrans) {  /* Skip transparent pixels */
    102                    if (IsMagnified) {
    103                      xL = xMag * xi + x0;
    104                      yL = yMag * y + y0;
    105                      LCD_FillRect(xL, yL, xL + xMag * (xi1 - xi) -1 , yL + yMag - 1);
    106                    } else {
    107                      LCD_DrawHLine(x0+xi, y + y0, xi1+x0-1);
   \                     ??_DrawBitmap_RLE8_12: (+1)
   \   000000E8   0xEB04 0x000A      ADD      R0,R4,R10
   \   000000EC   0x1E42             SUBS     R2,R0,#+1
   \   000000EE   0x9804             LDR      R0,[SP, #+16]
   \   000000F0   0xEB00 0x0108      ADD      R1,R0,R8
   \   000000F4   0xEB09 0x0004      ADD      R0,R9,R4
   \   000000F8   0x.... 0x....      BL       LCD_DrawHLine
    108                    }
    109                  }
    110                  xi =xi1;
   \                     ??_DrawBitmap_RLE8_13: (+1)
   \   000000FC   0x46D1             MOV      R9,R10
    111                  if (xi1==xsize) {
   \   000000FE   0x9805             LDR      R0,[SP, #+20]
   \   00000100   0x4582             CMP      R10,R0
   \   00000102   0xD103             BNE.N    ??_DrawBitmap_RLE8_11
    112                    y++;
   \   00000104   0xF108 0x0801      ADD      R8,R8,#+1
    113                    xi=0;
   \   00000108   0xF04F 0x0900      MOV      R9,#+0
    114                  }
   \                     ??_DrawBitmap_RLE8_11: (+1)
   \   0000010C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000110   0xD0CD             BEQ.N    ??_DrawBitmap_RLE8_6
   \   00000112   0xEB0B 0x0A09      ADD      R10,R11,R9
   \   00000116   0x9805             LDR      R0,[SP, #+20]
   \   00000118   0x4582             CMP      R10,R0
   \   0000011A   0xDD00             BLE.N    ??_DrawBitmap_RLE8_14
   \   0000011C   0x4682             MOV      R10,R0
   \                     ??_DrawBitmap_RLE8_14: (+1)
   \   0000011E   0xEBAB 0x000A      SUB      R0,R11,R10
   \   00000122   0xEB09 0x0B00      ADD      R11,R9,R0
   \   00000126   0xFA5F 0xFB8B      UXTB     R11,R11
   \   0000012A   0x9803             LDR      R0,[SP, #+12]
   \   0000012C   0x4338             ORRS     R0,R0,R7
   \   0000012E   0xD0E5             BEQ.N    ??_DrawBitmap_RLE8_13
   \   00000130   0x9801             LDR      R0,[SP, #+4]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD0D8             BEQ.N    ??_DrawBitmap_RLE8_12
   \   00000136   0x9812             LDR      R0,[SP, #+72]
   \   00000138   0xFB09 0x4000      MLA      R0,R9,R0,R4
   \   0000013C   0x9913             LDR      R1,[SP, #+76]
   \   0000013E   0x9A04             LDR      R2,[SP, #+16]
   \   00000140   0xFB08 0x2101      MLA      R1,R8,R1,R2
   \   00000144   0x9A13             LDR      R2,[SP, #+76]
   \   00000146   0x1852             ADDS     R2,R2,R1
   \   00000148   0x1E53             SUBS     R3,R2,#+1
   \   0000014A   0x9A12             LDR      R2,[SP, #+72]
   \   0000014C   0xEBAA 0x0C09      SUB      R12,R10,R9
   \   00000150   0xFB0C 0x0202      MLA      R2,R12,R2,R0
   \   00000154   0x1E52             SUBS     R2,R2,#+1
   \   00000156   0x.... 0x....      BL       LCD_FillRect
   \   0000015A   0xE7CF             B.N      ??_DrawBitmap_RLE8_13
    115                }
    116              } else {
    117                do {
    118                  U8 Index = *pPixel++;
    119                  if (Index || NoTrans) {  /* Skip transparent pixels */
    120                    int x = x0+xi;
    121                    PixelIndex = pTrans ? *(pTrans+Index) : Index;
    122                    if (IsMagnified) {
   \                     ??_DrawBitmap_RLE8_15: (+1)
   \   0000015C   0x9901             LDR      R1,[SP, #+4]
   \   0000015E   0x2900             CMP      R1,#+0
   \   00000160   0xD012             BEQ.N    ??_DrawBitmap_RLE8_16
    123                      LCD_SetColorIndex(PixelIndex);
   \   00000162   0x4610             MOV      R0,R2
   \   00000164   0x.... 0x....      BL       LCD_SetColorIndex
    124                      xL = xMag * xi + x0;
   \   00000168   0x9812             LDR      R0,[SP, #+72]
   \   0000016A   0xFB09 0x4000      MLA      R0,R9,R0,R4
    125                      yL = yMag * y + y0;
   \   0000016E   0x9913             LDR      R1,[SP, #+76]
   \   00000170   0x9A04             LDR      R2,[SP, #+16]
   \   00000172   0xFB08 0x2101      MLA      R1,R8,R1,R2
    126                      LCD_FillRect(xL, yL, xL + xMag -1 , yL + yMag - 1);
   \   00000176   0x9A13             LDR      R2,[SP, #+76]
   \   00000178   0x1852             ADDS     R2,R2,R1
   \   0000017A   0x1E53             SUBS     R3,R2,#+1
   \   0000017C   0x9A12             LDR      R2,[SP, #+72]
   \   0000017E   0x1812             ADDS     R2,R2,R0
   \   00000180   0x1E52             SUBS     R2,R2,#+1
   \   00000182   0x.... 0x....      BL       LCD_FillRect
   \   00000186   0xE00F             B.N      ??_DrawBitmap_RLE8_17
    127                    } else {
    128                      #if 1 /* High speed variant */
    129                        if (y + y0>= GUI_Context.ClipRect.y0)
   \                     ??_DrawBitmap_RLE8_16: (+1)
   \   00000188   0x9904             LDR      R1,[SP, #+16]
   \   0000018A   0x4441             ADD      R1,R1,R8
   \   0000018C   0xF9B5 0x3006      LDRSH    R3,[R5, #+6]
   \   00000190   0x4299             CMP      R1,R3
   \   00000192   0xDB09             BLT.N    ??_DrawBitmap_RLE8_17
    130                          if (x >= GUI_Context.ClipRect.x0)
   \   00000194   0xF9B5 0x3004      LDRSH    R3,[R5, #+4]
   \   00000198   0x4298             CMP      R0,R3
   \   0000019A   0xDB05             BLT.N    ??_DrawBitmap_RLE8_17
    131                            if (x <= GUI_Context.ClipRect.x1)
   \   0000019C   0xF9B5 0x3008      LDRSH    R3,[R5, #+8]
   \   000001A0   0x4283             CMP      R3,R0
   \   000001A2   0xDB01             BLT.N    ??_DrawBitmap_RLE8_17
    132                              LCDDEV_L0_SetPixelIndex(x, y + y0, PixelIndex);
   \   000001A4   0x.... 0x....      BL       LCD_L0_SetPixelIndex
    133                      #else
    134                        LCD_SetPixelIndex(x, y + y0, PixelIndex);
    135                      #endif
    136                    }
    137                  }
    138                  if (++xi >= xsize) {
   \                     ??_DrawBitmap_RLE8_17: (+1)
   \   000001A8   0xF109 0x0901      ADD      R9,R9,#+1
   \   000001AC   0x9805             LDR      R0,[SP, #+20]
   \   000001AE   0x4581             CMP      R9,R0
   \   000001B0   0xDB07             BLT.N    ??_DrawBitmap_RLE8_18
    139                    xi=0; y++;
   \   000001B2   0xF04F 0x0900      MOV      R9,#+0
   \   000001B6   0xF108 0x0801      ADD      R8,R8,#+1
    140                    if (y >= ysize)
   \   000001BA   0x9806             LDR      R0,[SP, #+24]
   \   000001BC   0x4580             CMP      R8,R0
   \   000001BE   0xF6BF 0xAF76      BGE.W    ??_DrawBitmap_RLE8_6
    141                      break;
    142                  }
    143                } while (--Data);
   \                     ??_DrawBitmap_RLE8_18: (+1)
   \   000001C2   0x1E7F             SUBS     R7,R7,#+1
   \   000001C4   0xB2FF             UXTB     R7,R7
   \   000001C6   0x2F00             CMP      R7,#+0
   \   000001C8   0xF43F 0xAF71      BEQ.W    ??_DrawBitmap_RLE8_6
   \                     ??_DrawBitmap_RLE8_8: (+1)
   \   000001CC   0xF816 0x2B01      LDRB     R2,[R6], #+1
   \   000001D0   0x9803             LDR      R0,[SP, #+12]
   \   000001D2   0x4310             ORRS     R0,R0,R2
   \   000001D4   0xD0E8             BEQ.N    ??_DrawBitmap_RLE8_17
   \   000001D6   0xEB09 0x0004      ADD      R0,R9,R4
   \   000001DA   0x9900             LDR      R1,[SP, #+0]
   \   000001DC   0x2900             CMP      R1,#+0
   \   000001DE   0xD0BD             BEQ.N    ??_DrawBitmap_RLE8_15
   \   000001E0   0xF831 0x2012      LDRH     R2,[R1, R2, LSL #+1]
   \   000001E4   0xE7BA             B.N      ??_DrawBitmap_RLE8_15
    144              }
    145            }
    146            LCD_ACOLORINDEX[0] = aColorIndex[0];
   \                     ??_DrawBitmap_RLE8_7: (+1)
   \   000001E6   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \   000001EA   0x8028             STRH     R0,[R5, #+0]
    147            LCD_ACOLORINDEX[1] = aColorIndex[1];
   \   000001EC   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000001F0   0x8068             STRH     R0,[R5, #+2]
    148          }
   \                     ??_DrawBitmap_RLE8_3: (+1)
   \   000001F2   0xB007             ADD      SP,SP,#+28
   \   000001F4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    149          
    150          /*********************************************************************
    151          *
    152          *       Public data
    153          *
    154          **********************************************************************
    155          */
    156          /*********************************************************************
    157          *
    158          *       GUI_BitmapMethodsRLE8
    159          */

   \                                 In section .rodata, align 4, keep-with-next
    160          const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8 = {
   \                     GUI_BitmapMethodsRLE8:
   \   00000000   0x........         DC32 _DrawBitmap_RLE8, 0H
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     Cache
    161            _DrawBitmap_RLE8,
    162            NULL
    163          };
    164          
    165          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   _DrawBitmap_RLE8
        64   -> LCD_DrawHLine
        64   -> LCD_FillRect
        64   -> LCD_GetpPalConvTable
        64   -> LCD_L0_SetPixelIndex
        64   -> LCD_SetColorIndex


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      16  Cache
       8  GUI_BitmapMethodsRLE8
     504  _DrawBitmap_RLE8

 
  16 bytes in section .bss
   8 bytes in section .rodata
 512 bytes in section .text
 
 512 bytes of CODE  memory
   8 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
