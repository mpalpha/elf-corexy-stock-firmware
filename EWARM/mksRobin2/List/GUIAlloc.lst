###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  16:59:57
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUIAlloc.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUIAlloc.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\GUIAlloc.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\GUIAlloc.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\GUIAlloc.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUIAlloc.C
     16          Purpose     : Dynamic memory management
     17          ----------------------------------------------------------------------
     18          */
     19          
     20          #include <stddef.h>           /* needed for definition of NULL */
     21          #include <string.h>           /* for memcpy, memset */
     22          
     23          #include "GUI_Protected.h"
     24          #include "GUIDebug.h"
     25          
     26          /*********************************************************************
     27          *
     28          *       Internal memory management
     29          *
     30          **********************************************************************
     31          */
     32          
     33          #ifndef GUI_ALLOC_ALLOC
     34          
     35          #if GUI_ALLOC_SIZE==0
     36            #error GUI_ALLOC_SIZE needs to be > 0 when using this module
     37          #endif
     38          
     39          /*********************************************************************
     40          *
     41          *       Defines, config defaults
     42          *
     43          **********************************************************************
     44          */
     45          
     46          /* Permit automatic defragmentation when necessary */
     47          #ifndef GUI_ALLOC_AUTDEFRAG
     48            #define GUI_ALLOC_AUTDEFRAG 1
     49          #endif
     50          
     51          #ifndef GUI_BLOCK_ALIGN        /* 2 means 4 bytes, 1 means 2 bytes      */
     52            #define GUI_BLOCK_ALIGN 2    /* 1 can be used on 16-bit CPUs and CPUs */
     53          #endif                         /* which do not require aligned 32-bit   */
     54                                         /* values (such as x86)                  */ 
     55          
     56          #ifndef GUI_MAXBLOCKS
     57            #define GUI_MAXBLOCKS (2 + GUI_ALLOC_SIZE / 32)
     58          #endif
     59          
     60          #ifndef GUI_ALLOC_LOCATION
     61            #define GUI_ALLOC_LOCATION
     62          #endif
     63          
     64          #ifndef GUI_MEM_ALLOC          /* Allows us in some systems to place the GUI memory */
     65            #define GUI_MEM_ALLOC        /* in a different memory space ... eg "__far"        */
     66          #endif
     67          
     68          /*********************************************************************
     69          *
     70          *       Defines
     71          *
     72          **********************************************************************
     73          */
     74          
     75          #define Min(v0,v1) ((v0>v1) ? v1 : v0)
     76          #define Max(v0,v1) ((v0>v1) ? v0 : v1)
     77          #define ASSIGN_IF_LESS(v0,v1) if (v1<v0) v0=v1
     78          #define HMEM2PTR(hMem) (void*)&GUI_Heap.abHeap[aBlock[hMem].Off]
     79          
     80          #if GUI_MAXBLOCKS >= 256
     81            #define HANDLE U16
     82          #else
     83            #define HANDLE U8
     84          #endif
     85          
     86          /*********************************************************************
     87          *
     88          *       Types
     89          *
     90          **********************************************************************
     91          */
     92          
     93          typedef union {
     94            int aintHeap[GUI_ALLOC_SIZE / 4];   /* required for proper alignement */
     95            U8  abHeap[GUI_ALLOC_SIZE];
     96          } GUI_HEAP;
     97          
     98          typedef struct {
     99            GUI_ALLOC_DATATYPE Off;       /* Offset of memory area          */
    100            GUI_ALLOC_DATATYPE Size;      /* usable size of allocated block */
    101            HANDLE Next;         /* next handle in linked list     */
    102            HANDLE Prev;
    103          } tBlock;
    104          
    105          /*********************************************************************
    106          *
    107          *       Static data
    108          *
    109          **********************************************************************
    110          */
    111          

   \                                 In section .bss, align 4
    112          GUI_MEM_ALLOC GUI_HEAP GUI_Heap GUI_ALLOC_LOCATION;         /* Public for debugging only */
    113          
    114          static tBlock aBlock[GUI_MAXBLOCKS];
   \                     aBlock:
   \   00000000                      DS8 1164
   \                     GUI_Heap:
   \   0000048C                      DS8 6144
    115          
    116          struct {
    117            int       NumUsedBlocks, NumFreeBlocks, NumFreeBlocksMin; /* For statistical purposes only */
    118            GUI_ALLOC_DATATYPE NumUsedBytes,  NumFreeBytes,  NumFreeBytesMin;

   \                                 In section .bss, align 4
    119          } GUI_ALLOC;
    120          
    121          static char   IsInitialized =0;
   \                     IsInitialized:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     GUI_ALLOC:
   \   00000004                      DS8 20
    122          
    123          /*********************************************************************
    124          *
    125          *       Static code
    126          *
    127          **********************************************************************
    128          */
    129          /*********************************************************************
    130          *
    131          *       _Size2LegalSize
    132          *
    133          * Return value:
    134          *   Legal allocation size
    135          */

   \                                 In section .text, align 2, keep-with-next
    136          static GUI_ALLOC_DATATYPE _Size2LegalSize(GUI_ALLOC_DATATYPE size) {
    137            return (size + ((1 << GUI_BLOCK_ALIGN) - 1)) & ~((1 << GUI_BLOCK_ALIGN) - 1);
   \                     _Size2LegalSize: (+1)
   \   00000000   0x1CC0             ADDS     R0,R0,#+3
   \   00000002   0xF020 0x0003      BIC      R0,R0,#0x3
   \   00000006   0xB200             SXTH     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
    138          }
    139            
    140          /*********************************************************************
    141          *
    142          *       _GetSize
    143          */

   \                                 In section .text, align 2, keep-with-next
    144          static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
    145            return aBlock[hMem].Size;
   \                     _GetSize: (+1)
   \   00000000   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000004   0x....             LDR.N    R0,??DataTable10
   \   00000006   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   0000000A   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   0000000E   0x4770             BX       LR               ;; return
    146          }
    147          
    148          /*********************************************************************
    149          *
    150          *       _Free
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          static void _Free(GUI_HMEM hMem) {
   \                     _Free: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    153            GUI_ALLOC_DATATYPE Size;
    154            GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
    155            /* Do some error checking ... */
    156            #if GUI_DEBUG_LEVEL>0
    157              /* Block not allocated ? */
    158              if (aBlock[hMem].Size == 0) {
   \   00000002   0x2106             MOVS     R1,#+6
   \   00000004   0x....             LDR.N    R2,??DataTable10
   \   00000006   0xFB01 0x2300      MLA      R3,R1,R0,R2
   \   0000000A   0xF9B3 0x4002      LDRSH    R4,[R3, #+2]
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD018             BEQ.N    ??_Free_0
    159                GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
    160                return;
    161              }
    162            #endif
    163            Size = aBlock[hMem].Size;
    164            #ifdef WIN32
    165              GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
    166            #endif
    167            GUI_ALLOC.NumFreeBytes += Size;
   \   00000012   0x....             LDR.N    R0,??DataTable10_1
   \   00000014   0x8A45             LDRH     R5,[R0, #+18]
   \   00000016   0x1965             ADDS     R5,R4,R5
   \   00000018   0x8245             STRH     R5,[R0, #+18]
    168            GUI_ALLOC.NumUsedBytes -= Size;
   \   0000001A   0x8A05             LDRH     R5,[R0, #+16]
   \   0000001C   0x1B2C             SUBS     R4,R5,R4
   \   0000001E   0x8204             STRH     R4,[R0, #+16]
    169            aBlock[hMem].Size = 0;
   \   00000020   0x2400             MOVS     R4,#+0
   \   00000022   0x805C             STRH     R4,[R3, #+2]
    170            {
    171              int Next = aBlock[hMem].Next;
   \   00000024   0x791C             LDRB     R4,[R3, #+4]
    172              int Prev = aBlock[hMem].Prev;
   \   00000026   0x795B             LDRB     R3,[R3, #+5]
    173              aBlock[Prev].Next = Next;
   \   00000028   0xFB01 0x2503      MLA      R5,R1,R3,R2
   \   0000002C   0x712C             STRB     R4,[R5, #+4]
    174              if (Next) {
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD002             BEQ.N    ??_Free_1
    175                aBlock[Next].Prev = Prev;
   \   00000032   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000036   0x714B             STRB     R3,[R1, #+5]
    176              }
    177            }  
    178            GUI_ALLOC.NumFreeBlocks++;
   \                     ??_Free_1: (+1)
   \   00000038   0x6881             LDR      R1,[R0, #+8]
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
   \   0000003C   0x6081             STR      R1,[R0, #+8]
    179            GUI_ALLOC.NumUsedBlocks--;
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0x6041             STR      R1,[R0, #+4]
    180          }
   \                     ??_Free_0: (+1)
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0x4770             BX       LR               ;; return
    181          
    182          /*********************************************************************
    183          *
    184          *       _FindFreeHandle
    185          *
    186          * Return value:
    187          *   Free handle
    188          */

   \                                 In section .text, align 2, keep-with-next
    189          static GUI_HMEM _FindFreeHandle(void) {
    190            int i;
    191            for (i=1; i< GUI_MAXBLOCKS; i++) {
   \                     _FindFreeHandle: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable10
   \   00000004   0xE000             B.N      ??_FindFreeHandle_0
   \                     ??_FindFreeHandle_1: (+1)
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \                     ??_FindFreeHandle_0: (+1)
   \   00000008   0x28C2             CMP      R0,#+194
   \   0000000A   0xDA09             BGE.N    ??_FindFreeHandle_2
    192              if (aBlock[i].Size ==0)
   \   0000000C   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000010   0xEB02 0x0141      ADD      R1,R2,R1, LSL #+1
   \   00000014   0xF9B1 0x1002      LDRSH    R1,[R1, #+2]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD1F4             BNE.N    ??_FindFreeHandle_1
    193          	  return i;
   \   0000001C   0xB200             SXTH     R0,R0
   \   0000001E   0x4770             BX       LR
    194            }
    195            GUI_DEBUG_ERROROUT1("Insufficient memory handles configured (GUI_MAXBLOCKS == %d (See GUIConf.h))", GUI_MAXBLOCKS);
    196            return GUI_HMEM_NULL;
   \                     ??_FindFreeHandle_2: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    197          }
    198          
    199          /*********************************************************************
    200          *
    201          *       _FindHole
    202          *
    203          * Return value:
    204          *   Offset to the memory hole (if available)
    205          *   -1 if not available
    206          */

   \                                 In section .text, align 2, keep-with-next
    207          static GUI_HMEM _FindHole(GUI_ALLOC_DATATYPE Size) {
   \                     _FindHole: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x4601             MOV      R1,R0
    208            int i, iNext;
    209            for (i=0; (iNext = aBlock[i].Next) != 0; i = iNext) {
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x....             LDR.N    R6,??DataTable10
   \   0000000A   0xE000             B.N      ??_FindHole_0
   \                     ??_FindHole_1: (+1)
   \   0000000C   0x4618             MOV      R0,R3
   \                     ??_FindHole_0: (+1)
   \   0000000E   0x2406             MOVS     R4,#+6
   \   00000010   0xFB04 0xF500      MUL      R5,R4,R0
   \   00000014   0x19AF             ADDS     R7,R5,R6
   \   00000016   0x793B             LDRB     R3,[R7, #+4]
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xD00B             BEQ.N    ??_FindHole_2
    210              int NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
    211              if (NumFreeBytes>=Size) {
   \   0000001C   0xFB04 0x6403      MLA      R4,R4,R3,R6
   \   00000020   0xF9B4 0x4000      LDRSH    R4,[R4, #+0]
   \   00000024   0x5FAD             LDRSH    R5,[R5, R6]
   \   00000026   0x1B64             SUBS     R4,R4,R5
   \   00000028   0xF9B7 0x5002      LDRSH    R5,[R7, #+2]
   \   0000002C   0x1B64             SUBS     R4,R4,R5
   \   0000002E   0x4294             CMP      R4,R2
   \   00000030   0xDBEC             BLT.N    ??_FindHole_1
    212                return i;
   \   00000032   0xE009             B.N      ??_FindHole_3
    213              }
    214            }
    215            /* Check last block */
    216            if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
   \                     ??_FindHole_2: (+1)
   \   00000034   0x5FA9             LDRSH    R1,[R5, R6]
   \   00000036   0xF5C1 0x51C0      RSB      R1,R1,#+6144
   \   0000003A   0xF9B7 0x3002      LDRSH    R3,[R7, #+2]
   \   0000003E   0x1AC9             SUBS     R1,R1,R3
   \   00000040   0x4291             CMP      R1,R2
   \   00000042   0xDA01             BGE.N    ??_FindHole_3
    217              return i;
    218            }
    219            return -1;
   \   00000044   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??_FindHole_3: (+1)
   \   00000048   0xBCF0             POP      {R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
    220          }
    221          
    222          /*********************************************************************
    223          *
    224          *       _CreateHole
    225          *
    226          * Return value:
    227          *   Offset to the memory hole (if available)
    228          *   -1 if not available
    229          */

   \                                 In section .text, align 2, keep-with-next
    230          static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
   \                     _CreateHole: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    231            int i, iNext;
    232            int r = -1;
   \   00000006   0xF04F 0x35FF      MOV      R5,#-1
    233            for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x....             LDR.N    R6,??DataTable10
   \   0000000E   0xE02B             B.N      ??_CreateHole_0
    234              GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
    235              if (NumFreeBytes < Size) {
   \                     ??_CreateHole_1: (+1)
   \   00000010   0xFB03 0xF807      MUL      R8,R3,R7
   \   00000014   0xF838 0x2006      LDRH     R2,[R8, R6]
   \   00000018   0x5B83             LDRH     R3,[R0, R6]
   \   0000001A   0x1AD2             SUBS     R2,R2,R3
   \   0000001C   0x884B             LDRH     R3,[R1, #+2]
   \   0000001E   0x1AD2             SUBS     R2,R2,R3
   \   00000020   0xB212             SXTH     R2,R2
   \   00000022   0x42A2             CMP      R2,R4
   \   00000024   0xDA1F             BGE.N    ??_CreateHole_2
    236                GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
   \   00000026   0xF838 0x2006      LDRH     R2,[R8, R6]
   \   0000002A   0x5B80             LDRH     R0,[R0, R6]
   \   0000002C   0x1A10             SUBS     R0,R2,R0
   \   0000002E   0x4619             MOV      R1,R3
   \   00000030   0xEBA0 0x0901      SUB      R9,R0,R1
   \   00000034   0xFA0F 0xF989      SXTH     R9,R9
    237                if (NumBytesBeforeBlock) {
   \   00000038   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003C   0xD013             BEQ.N    ??_CreateHole_2
    238                  U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
   \   0000003E   0xF938 0x0006      LDRSH    R0,[R8, R6]
   \   00000042   0x1980             ADDS     R0,R0,R6
   \   00000044   0xF200 0x418C      ADDW     R1,R0,#+1164
    239                  memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
   \   00000048   0xEB08 0x0006      ADD      R0,R8,R6
   \   0000004C   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \   00000050   0xF1C9 0x0000      RSB      R0,R9,#+0
   \   00000054   0x1840             ADDS     R0,R0,R1
   \   00000056   0x.... 0x....      BL       memmove
    240                  aBlock[iNext].Off -=NumBytesBeforeBlock;
   \   0000005A   0xF838 0x0006      LDRH     R0,[R8, R6]
   \   0000005E   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000062   0xF828 0x0006      STRH     R0,[R8, R6]
    241                }
    242              }
    243            }
   \                     ??_CreateHole_2: (+1)
   \   00000066   0x463A             MOV      R2,R7
   \                     ??_CreateHole_0: (+1)
   \   00000068   0x2306             MOVS     R3,#+6
   \   0000006A   0xFB03 0xF002      MUL      R0,R3,R2
   \   0000006E   0x1981             ADDS     R1,R0,R6
   \   00000070   0x790F             LDRB     R7,[R1, #+4]
   \   00000072   0x2F00             CMP      R7,#+0
   \   00000074   0xD1CC             BNE.N    ??_CreateHole_1
    244            /* Check last block */
    245            if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
   \   00000076   0x5F80             LDRSH    R0,[R0, R6]
   \   00000078   0xF5C0 0x50C0      RSB      R0,R0,#+6144
   \   0000007C   0xF9B1 0x1002      LDRSH    R1,[R1, #+2]
   \   00000080   0x1A40             SUBS     R0,R0,R1
   \   00000082   0x42A0             CMP      R0,R4
   \   00000084   0xDB00             BLT.N    ??_CreateHole_3
    246              r = i;
   \   00000086   0x4615             MOV      R5,R2
    247            }
    248            return r;
   \                     ??_CreateHole_3: (+1)
   \   00000088   0x4628             MOV      R0,R5
   \   0000008A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    249          }
    250          
    251          /*********************************************************************
    252          *
    253          *       _CheckInit
    254          */

   \                                 In section .text, align 2, keep-with-next
    255          static void _CheckInit(void) {
    256            if (!IsInitialized) {
   \                     _CheckInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1
   \   00000002   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD100             BNE.N    ??_CheckInit_0
    257              GUI_ALLOC_Init();
   \   0000000A   0x....             B.N      GUI_ALLOC_Init
    258            }
    259          }
   \                     ??_CheckInit_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    260          
    261          /*********************************************************************
    262          *
    263          *       _Alloc
    264          */

   \                                 In section .text, align 2, keep-with-next
    265          static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
   \                     _Alloc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    266            GUI_HMEM hMemNew, hMemIns;
    267            _CheckInit();
   \   00000006   0x.... 0x....      BL       _CheckInit
    268            size = _Size2LegalSize(size);
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _Size2LegalSize
   \   00000010   0x4604             MOV      R4,R0
    269            /* Check if memory is available at all ...*/
    270            if (size > GUI_ALLOC.NumFreeBytes) {
   \   00000012   0x....             LDR.N    R5,??DataTable10_1
   \   00000014   0xF9B5 0x0012      LDRSH    R0,[R5, #+18]
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xDB0F             BLT.N    ??_Alloc_0
    271              GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
    272              return 0;
    273            }
    274            /* Locate free handle */
    275            if ((hMemNew = _FindFreeHandle()) == 0)
   \   0000001C   0x.... 0x....      BL       _FindFreeHandle
   \   00000020   0x0006             MOVS     R6,R0
   \   00000022   0xD00B             BEQ.N    ??_Alloc_0
    276              return 0;
    277            /* Locate or Create hole of sufficient size */
    278            hMemIns = _FindHole(size);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _FindHole
    279            #if GUI_ALLOC_AUTDEFRAG
    280              if (hMemIns == -1) {
   \   0000002A   0xF110 0x0F01      CMN      R0,#+1
   \   0000002E   0xD102             BNE.N    ??_Alloc_1
    281                hMemIns = _CreateHole(size);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       _CreateHole
    282              }
    283            #endif
    284            /* Occupy hole */
    285            if (hMemIns==-1) {
   \                     ??_Alloc_1: (+1)
   \   00000036   0xF110 0x0F01      CMN      R0,#+1
   \   0000003A   0xD101             BNE.N    ??_Alloc_2
    286              GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
    287              return 0;
   \                     ??_Alloc_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE034             B.N      ??_Alloc_3
    288          	}
    289            {
    290              GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
   \                     ??_Alloc_2: (+1)
   \   00000040   0x2106             MOVS     R1,#+6
   \   00000042   0xFB01 0xF700      MUL      R7,R1,R0
   \   00000046   0x....             LDR.N    R2,??DataTable10
   \   00000048   0x18BB             ADDS     R3,R7,R2
   \   0000004A   0x5ABF             LDRH     R7,[R7, R2]
   \   0000004C   0xF8B3 0xC002      LDRH     R12,[R3, #+2]
   \   00000050   0x4467             ADD      R7,R12,R7
    291              int Next = aBlock[hMemIns].Next;
   \   00000052   0xF893 0xC004      LDRB     R12,[R3, #+4]
    292              aBlock[hMemNew].Size  = size;
   \   00000056   0xFB01 0xFE06      MUL      LR,R1,R6
   \   0000005A   0xEB0E 0x0802      ADD      R8,LR,R2
   \   0000005E   0xF8A8 0x4002      STRH     R4,[R8, #+2]
    293              aBlock[hMemNew].Off   = Off;
   \   00000062   0xF82E 0x7002      STRH     R7,[LR, R2]
    294              if ((aBlock[hMemNew].Next  = Next) >0) {
   \   00000066   0xF888 0xC004      STRB     R12,[R8, #+4]
   \   0000006A   0x4667             MOV      R7,R12
   \   0000006C   0x2F00             CMP      R7,#+0
   \   0000006E   0xD002             BEQ.N    ??_Alloc_4
    295                aBlock[Next].Prev = hMemNew;  
   \   00000070   0xFB01 0x210C      MLA      R1,R1,R12,R2
   \   00000074   0x714E             STRB     R6,[R1, #+5]
    296              }
    297              aBlock[hMemNew].Prev  = hMemIns;
   \                     ??_Alloc_4: (+1)
   \   00000076   0xF888 0x0005      STRB     R0,[R8, #+5]
    298              aBlock[hMemIns].Next  = hMemNew;
   \   0000007A   0x711E             STRB     R6,[R3, #+4]
    299            }
    300            /* Keep track of number of blocks and av. memory */
    301            GUI_ALLOC.NumUsedBlocks++;
   \   0000007C   0x6868             LDR      R0,[R5, #+4]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0x6068             STR      R0,[R5, #+4]
    302            GUI_ALLOC.NumFreeBlocks--;
   \   00000082   0x68A8             LDR      R0,[R5, #+8]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x60A8             STR      R0,[R5, #+8]
    303            if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
   \   00000088   0x68E9             LDR      R1,[R5, #+12]
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xDA00             BGE.N    ??_Alloc_5
    304              GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
   \   0000008E   0x60E8             STR      R0,[R5, #+12]
    305            }
    306            GUI_ALLOC.NumUsedBytes += size;
   \                     ??_Alloc_5: (+1)
   \   00000090   0x8A28             LDRH     R0,[R5, #+16]
   \   00000092   0x1820             ADDS     R0,R4,R0
   \   00000094   0x8228             STRH     R0,[R5, #+16]
    307            GUI_ALLOC.NumFreeBytes -= size;
   \   00000096   0x8A68             LDRH     R0,[R5, #+18]
   \   00000098   0x1B00             SUBS     R0,R0,R4
   \   0000009A   0x8268             STRH     R0,[R5, #+18]
    308            if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
   \   0000009C   0xF9B5 0x1014      LDRSH    R1,[R5, #+20]
   \   000000A0   0xB200             SXTH     R0,R0
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xDA00             BGE.N    ??_Alloc_6
    309              GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
   \   000000A6   0x82A8             STRH     R0,[R5, #+20]
    310            }
    311            return hMemNew;
   \                     ??_Alloc_6: (+1)
   \   000000A8   0x4630             MOV      R0,R6
   \                     ??_Alloc_3: (+1)
   \   000000AA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    312          }
    313          
    314          /*********************************************************************
    315          *
    316          *       Exported routines
    317          *
    318          **********************************************************************
    319          */
    320          /*********************************************************************
    321          *
    322          *       GUI_ALLOC_Init
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          void GUI_ALLOC_Init(void) {
    325            GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
    326            GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
   \                     GUI_ALLOC_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1
   \   00000002   0x21C1             MOVS     R1,#+193
   \   00000004   0x6081             STR      R1,[R0, #+8]
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    327            GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
   \   00000008   0xF44F 0x51C0      MOV      R1,#+6144
   \   0000000C   0x8241             STRH     R1,[R0, #+18]
   \   0000000E   0x8281             STRH     R1,[R0, #+20]
    328            GUI_ALLOC.NumUsedBlocks = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6041             STR      R1,[R0, #+4]
    329            GUI_ALLOC.NumUsedBytes = 0;
   \   00000014   0x8201             STRH     R1,[R0, #+16]
    330            aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
   \   00000016   0x....             LDR.N    R1,??DataTable10
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0x804A             STRH     R2,[R1, #+2]
    331            aBlock[0].Off  = 0;
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x800A             STRH     R2,[R1, #+0]
    332            aBlock[0].Next = 0;
   \   00000020   0x710A             STRB     R2,[R1, #+4]
    333            IsInitialized =1;
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x7001             STRB     R1,[R0, #+0]
    334          }
   \   00000026   0x4770             BX       LR               ;; return
    335          
    336          /*********************************************************************
    337          *
    338          *       GUI_ALLOC_AllocNoInit
    339          */

   \                                 In section .text, align 2, keep-with-next
    340          GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
    341            GUI_HMEM hMem;
    342            if (Size == 0) {
   \                     GUI_ALLOC_AllocNoInit: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??GUI_ALLOC_AllocNoInit_0
    343              return (GUI_HMEM)0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR
    344            }
    345            GUI_LOCK();
    346            GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
    347            hMem = _Alloc(Size);
    348            GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
    349            GUI_UNLOCK();
    350            return hMem;
   \                     ??GUI_ALLOC_AllocNoInit_0: (+1)
   \   00000008   0x....             B.N      _Alloc
    351          }
    352          
    353          /*********************************************************************
    354          *
    355          *       GUI_ALLOC_h2p
    356          */

   \                                 In section .text, align 2, keep-with-next
    357          void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
    358            GUI_ASSERT_LOCK();
    359            #if GUI_DEBUG_LEVEL > 0
    360              if (!hMem) {
   \                     GUI_ALLOC_h2p: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??GUI_ALLOC_h2p_0
    361                GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
    362                return 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR
    363              }
    364              if (aBlock[hMem].Size == 0) {
    365                GUI_DEBUG_ERROROUT("Dereferencing free block");
    366              }
    367          
    368            #endif
    369            return HMEM2PTR(hMem);
   \                     ??GUI_ALLOC_h2p_0: (+1)
   \   00000008   0x....             LDR.N    R1,??DataTable10
   \   0000000A   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   0000000E   0x0050             LSLS     R0,R2,#+1
   \   00000010   0x5E40             LDRSH    R0,[R0, R1]
   \   00000012   0x1840             ADDS     R0,R0,R1
   \   00000014   0xF200 0x408C      ADDW     R0,R0,#+1164
   \   00000018   0x4770             BX       LR               ;; return
    370          }
    371          
    372          /*********************************************************************
    373          *
    374          *       GUI_ALLOC_GetNumFreeBytes
    375          */

   \                                 In section .text, align 2, keep-with-next
    376          GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
   \                     GUI_ALLOC_GetNumFreeBytes: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    377            _CheckInit();
   \   00000002   0x.... 0x....      BL       _CheckInit
    378            return GUI_ALLOC.NumFreeBytes;  
   \   00000006   0x....             LDR.N    R0,??DataTable10_1
   \   00000008   0xF9B0 0x0012      LDRSH    R0,[R0, #+18]
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    379          }
    380          
    381          /*********************************************************************
    382          *
    383          *       GUI_ALLOC_GetMaxSize
    384          *
    385          * Purpose:
    386          *   Returns the biggest available blocksize (without relocation).
    387          */

   \                                 In section .text, align 2, keep-with-next
    388          GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
   \                     GUI_ALLOC_GetMaxSize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    389            GUI_ALLOC_DATATYPE r = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    390            GUI_ALLOC_DATATYPE NumFreeBytes;
    391            int i, iNext;
    392          
    393            GUI_LOCK();
    394            _CheckInit();
   \   00000004   0x.... 0x....      BL       _CheckInit
    395            for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xE00A             B.N      ??GUI_ALLOC_GetMaxSize_0
    396              NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
   \                     ??GUI_ALLOC_GetMaxSize_1: (+1)
   \   0000000C   0xFB02 0x1200      MLA      R2,R2,R0,R1
   \   00000010   0x8812             LDRH     R2,[R2, #+0]
   \   00000012   0x5A59             LDRH     R1,[R3, R1]
   \   00000014   0x1A51             SUBS     R1,R2,R1
   \   00000016   0x886A             LDRH     R2,[R5, #+2]
   \   00000018   0x1A89             SUBS     R1,R1,R2
    397              if (NumFreeBytes > r) {
   \   0000001A   0xB209             SXTH     R1,R1
   \   0000001C   0x428C             CMP      R4,R1
   \   0000001E   0xDA00             BGE.N    ??GUI_ALLOC_GetMaxSize_0
   \   00000020   0x460C             MOV      R4,R1
    398                r = NumFreeBytes;
    399              }
    400            }
   \                     ??GUI_ALLOC_GetMaxSize_0: (+1)
   \   00000022   0x2206             MOVS     R2,#+6
   \   00000024   0xFB02 0xF300      MUL      R3,R2,R0
   \   00000028   0x....             LDR.N    R1,??DataTable10
   \   0000002A   0x185D             ADDS     R5,R3,R1
   \   0000002C   0x7928             LDRB     R0,[R5, #+4]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EC             BNE.N    ??GUI_ALLOC_GetMaxSize_1
    401            /* Check last block */
    402            NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
   \   00000032   0x5A58             LDRH     R0,[R3, R1]
   \   00000034   0xF5C0 0x50C0      RSB      R0,R0,#+6144
   \   00000038   0x8869             LDRH     R1,[R5, #+2]
   \   0000003A   0x1A40             SUBS     R0,R0,R1
    403            if (NumFreeBytes > r) {
   \   0000003C   0xB200             SXTH     R0,R0
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xDA00             BGE.N    ??GUI_ALLOC_GetMaxSize_2
   \   00000042   0x4604             MOV      R4,R0
    404              r = NumFreeBytes;
    405            }
    406            GUI_UNLOCK();
    407            return r;
   \                     ??GUI_ALLOC_GetMaxSize_2: (+1)
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    408          }
    409          
    410          #else
    411          
    412          /*********************************************************************
    413          *
    414          *       External memory management functions
    415          *
    416          * The functions below will generate code only if the GUI memory
    417          * management is not used (GUI_ALLOC_ALLOC defined).
    418          *
    419          * Note:
    420          * The memory block allocated is bigger than the requested one, as we
    421          * store some add. information (size of the memory block) there.
    422          *
    423          **********************************************************************
    424          */
    425          
    426          typedef struct {
    427            union {
    428              GUI_ALLOC_DATATYPE Size;
    429              int Dummy;               /* Needed to guarantee alignment on 32 / 64 bit CPUs */
    430            } Info;      /* Unnamed would be best, but is not supported by all compilers */
    431          } INFO;
    432          
    433          /*********************************************************************
    434          *
    435          *       _GetSize
    436          */
    437          static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
    438            INFO * pInfo;
    439            pInfo = (INFO *)GUI_ALLOC_H2P(hMem);
    440            return pInfo->Info.Size;
    441          }
    442          
    443          /*********************************************************************
    444          *
    445          *       _Free
    446          */
    447          static void _Free(GUI_HMEM  hMem) {
    448            GUI_ALLOC_FREE(hMem);
    449          }
    450          
    451          /*********************************************************************
    452          *
    453          *       GUI_ALLOC_AllocNoInit
    454          */
    455          GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
    456            GUI_HMEM hMem;
    457            if (Size == 0) {
    458              return (GUI_HMEM)0;
    459            }
    460            hMem= GUI_ALLOC_ALLOC(Size + sizeof(INFO));
    461            /* Init info structure */
    462            if (hMem) {
    463              INFO * pInfo;
    464              pInfo = (INFO *)GUI_ALLOC_H2P(hMem);
    465              pInfo->Info.Size = Size;
    466            }
    467            return hMem;
    468          }
    469          
    470          /*********************************************************************
    471          *
    472          *       GUI_ALLOC_h2p
    473          */
    474          void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
    475            U8* p = (U8*)GUI_ALLOC_H2P(hMem);    /* Pointer to memory block from memory manager */
    476            p += sizeof(INFO);                   /* Convert to pointer to usable area */
    477            return p;
    478          }
    479          
    480          /*********************************************************************
    481          *
    482          *       GUI_ALLOC_GetMaxSize
    483          */
    484          GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
    485            return GUI_ALLOC_GETMAXSIZE();
    486          }
    487          
    488          /*********************************************************************
    489          *
    490          *       GUI_ALLOC_Init
    491          */
    492          void GUI_ALLOC_Init(void) {
    493            #ifdef GUI_ALLOC_INIT
    494              GUI_ALLOC_INIT();
    495            #endif
    496          }
    497          
    498          #endif
    499          
    500          /*********************************************************************
    501          *
    502          *       Public code, common memory management functions
    503          *
    504          **********************************************************************
    505          */
    506          /*********************************************************************
    507          *
    508          *       GUI_ALLOC_GetSize
    509          */

   \                                 In section .text, align 2, keep-with-next
    510          GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
    511            /* Do the error checking first */
    512            #if GUI_DEBUG_LEVEL>0
    513              if (!hMem) {
   \                     GUI_ALLOC_GetSize: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??GUI_ALLOC_GetSize_0
    514                GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
    515                return 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR
    516              }
    517            #endif
    518            return _GetSize(hMem);
   \                     ??GUI_ALLOC_GetSize_0: (+1)
   \   00000008   0x....             B.N      _GetSize
    519          }
    520          
    521          /*********************************************************************
    522          *
    523          *       GUI_ALLOC_Free
    524          */

   \                                 In section .text, align 2, keep-with-next
    525          void GUI_ALLOC_Free(GUI_HMEM hMem) {
    526            if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
   \                     GUI_ALLOC_Free: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??GUI_ALLOC_Free_0
    527              return;
    528            }
    529            GUI_LOCK();
    530            GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
    531            _Free(hMem);
   \   00000004   0x....             B.N      _Free
   \                     ??GUI_ALLOC_Free_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    532            GUI_UNLOCK();
    533          }
    534          
    535          
    536          /*********************************************************************
    537          *
    538          *       GUI_ALLOC_FreePtr
    539          */

   \                                 In section .text, align 2, keep-with-next
    540          void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
   \                     GUI_ALLOC_FreePtr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    541            GUI_LOCK();
    542            GUI_ALLOC_Free(*ph);
   \   00000004   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_Free
    543            *ph =0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x8020             STRH     R0,[R4, #+0]
    544            GUI_UNLOCK();
    545          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     aBlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     IsInitialized
    546          
    547          
    548          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GUI_ALLOC_AllocNoInit
         0   -> _Alloc
       0   GUI_ALLOC_Free
         0   -> _Free
       8   GUI_ALLOC_FreePtr
         8   -> GUI_ALLOC_Free
      16   GUI_ALLOC_GetMaxSize
        16   -> _CheckInit
       8   GUI_ALLOC_GetNumFreeBytes
         8   -> _CheckInit
       0   GUI_ALLOC_GetSize
         0   -> _GetSize
       0   GUI_ALLOC_Init
       0   GUI_ALLOC_h2p
      24   _Alloc
        24   -> _CheckInit
        24   -> _CreateHole
        24   -> _FindFreeHandle
        24   -> _FindHole
        24   -> _Size2LegalSize
       0   _CheckInit
         0   -> GUI_ALLOC_Init
      32   _CreateHole
        32   -> memmove
       0   _FindFreeHandle
      16   _FindHole
       8   _Free
       0   _GetSize
       0   _Size2LegalSize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
      10  GUI_ALLOC_AllocNoInit
       8  GUI_ALLOC_Free
      18  GUI_ALLOC_FreePtr
      72  GUI_ALLOC_GetMaxSize
      14  GUI_ALLOC_GetNumFreeBytes
      10  GUI_ALLOC_GetSize
      40  GUI_ALLOC_Init
      26  GUI_ALLOC_h2p
      24  IsInitialized
          GUI_ALLOC
     174  _Alloc
      14  _CheckInit
     142  _CreateHole
      36  _FindFreeHandle
      76  _FindHole
      72  _Free
      16  _GetSize
      10  _Size2LegalSize
    7308  aBlock
          GUI_Heap

 
 7 332 bytes in section .bss
   746 bytes in section .text
 
   746 bytes of CODE memory
 7 332 bytes of DATA memory

Errors: none
Warnings: none
