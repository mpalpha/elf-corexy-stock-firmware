///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       25/Feb/2020  17:00:42
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCDL0Delta.c
//    Command line =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCDL0Delta.c
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        -lA
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
//        --diag_suppress Pa050 -o
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
//        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\LCDL0Delta.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        PUBLIC LCDL0Delta_c
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Core\LCDL0Delta.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/GUI
//    4 *                        Universal graphic software for embedded applications
//    5 *
//    6 *                       (c) Copyright 2002, Micrium Inc., Weston, FL
//    7 *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
//    8 *
//    9 *              µC/GUI is protected by international copyright laws. Knowledge of the
//   10 *              source code may not be used to write a similar product. This file may
//   11 *              only be used in accordance with a license and should not be redistributed
//   12 *              in any way. We appreciate your understanding and fairness.
//   13 *
//   14 ----------------------------------------------------------------------
//   15 File        : LCDL0Delta.c
//   16 Purpose     : Link between GUI and LCD_L0... if delta display needs to
//   17               be supported
//   18 ---------------------------END-OF-HEADER------------------------------
//   19 */
//   20 
//   21 #include <stddef.h>             /* needed for definition of NULL */
//   22 #include "GUI_Private.h"
//   23 #include "GUIDebug.h"
//   24 #include "LCD_Private.h"        /* private modul definitions & config */
//   25 
//   26 #if LCD_DELTA_MODE
//   27 
//   28 /*********************************************************************
//   29 *
//   30 *       Static data
//   31 *
//   32 **********************************************************************
//   33 */
//   34 static       U8             _aPixelData_0[LCD_XSIZE];
//   35 static       U8             _aPixelData_1[LCD_XSIZE];
//   36 static const GUI_LOGPALETTE _Pal;
//   37 static       GUI_BITMAP     _Bm;
//   38 static       int            _y;
//   39 static       U8             _aRGB[3];
//   40 
//   41 /*********************************************************************
//   42 *
//   43 *       Static code
//   44 *
//   45 **********************************************************************
//   46 */
//   47 /*********************************************************************
//   48 *
//   49 *       _SetRGB
//   50 */
//   51 static void _SetRGB(LCD_PIXELINDEX ColorIndex) {
//   52   _aRGB[0] = ColorIndex & 0x00f;
//   53   _aRGB[1] = (ColorIndex & 0x0f0) >> 4;
//   54   _aRGB[2] = (ColorIndex & 0xf00) >> 8;
//   55 }
//   56 
//   57 /*********************************************************************
//   58 *
//   59 *       _SetPixel
//   60 */
//   61 static void _SetPixelIndex(int x, LCD_PIXELINDEX ColorIndex) {
//   62   _SetRGB(ColorIndex);
//   63   _aPixelData_0[x] = _aRGB[(x + (_y & 1)) % 3];
//   64 }
//   65 
//   66 /*********************************************************************
//   67 *
//   68 *       _InitBM
//   69 */
//   70 static void _InitBM(int xsize, int x0) {
//   71   _Bm.XSize        = xsize;
//   72   _Bm.YSize        = 1;
//   73   _Bm.BytesPerLine = xsize;
//   74   _Bm.BitsPerPixel = 8;
//   75   _Bm.pfDraw       = 0;
//   76   _Bm.pData        = &_aPixelData_0[x0];
//   77   _Bm.pPal         = &_Pal;
//   78   _Bm.pfDraw       = 0;
//   79 }
//   80 
//   81 /*********************************************************************
//   82 *
//   83 *       _DrawBitLine1BPP
//   84 */
//   85 static void _DrawBitLine1BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
//   86   int xx;
//   87   LCD_PIXELINDEX Index0 = *(pTrans+0);
//   88   LCD_PIXELINDEX Index1 = *(pTrans+1);
//   89   x += Diff;
//   90   xx = x;
//   91   switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
//   92   case 0:
//   93     do {
//   94       _SetPixelIndex(xx++, (*p & (0x80 >> Diff)) ? Index1 : Index0);
//   95 			if (++Diff == 8) {
//   96         Diff = 0;
//   97 				p++;
//   98 			}
//   99 		} while (--xsize);
//  100     break;
//  101   case LCD_DRAWMODE_TRANS:
//  102     do {
//  103   		if (*p & (0x80 >> Diff)) {
//  104         _SetPixelIndex(xx, Index1);
//  105       } else {
//  106         _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  107       }
//  108       xx++;
//  109 			if (++Diff == 8) {
//  110         Diff = 0;
//  111 				p++;
//  112 			}
//  113 		} while (--xsize);
//  114     break;
//  115   case LCD_DRAWMODE_XOR:;
//  116     do {
//  117   		if (*p & (0x80 >> Diff)) {
//  118         int Pixel = LCD_L0_GetPixelIndex(xx, _y);
//  119         _SetPixelIndex(xx, LCD_NUM_COLORS - 1 - Pixel);
//  120       }
//  121       xx++;
//  122 			if (++Diff == 8) {
//  123         Diff = 0;
//  124 				p++;
//  125 			}
//  126 		} while (--xsize);
//  127     break;
//  128 	}
//  129   LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
//  130 }
//  131 
//  132 /*********************************************************************
//  133 *
//  134 *       _DrawBitLine2BPP
//  135 */
//  136 static void _DrawBitLine2BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
//  137   int xx;
//  138   LCD_PIXELINDEX Pixels = *p;
//  139   int CurrentPixel = Diff;
//  140   x += Diff;
//  141   xx = x;
//  142   switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
//  143   case 0:
//  144     if (pTrans) {
//  145       do {
//  146         int Shift = (3 - CurrentPixel) << 1;
//  147         int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  148         LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
//  149         _SetPixelIndex(xx++, PixelIndex);
//  150         if (++CurrentPixel == 4) {
//  151           CurrentPixel = 0;
//  152           Pixels = *(++p);
//  153         }
//  154 		  } while (--xsize);
//  155     } else {
//  156       do {
//  157         int Shift = (3 - CurrentPixel) << 1;
//  158         int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  159         _SetPixelIndex(xx++, Index);
//  160         if (++CurrentPixel == 4) {
//  161           CurrentPixel = 0;
//  162           Pixels = *(++p);
//  163         }
//  164 		  } while (--xsize);
//  165     }
//  166     break;
//  167   case LCD_DRAWMODE_TRANS:
//  168     if (pTrans) {
//  169       do {
//  170         int Shift = (3 - CurrentPixel) << 1;
//  171         int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  172         if (Index) {
//  173           LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
//  174           _SetPixelIndex(xx, PixelIndex);
//  175         } else {
//  176           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  177         }
//  178         xx++;
//  179         if (++CurrentPixel == 4) {
//  180           CurrentPixel = 0;
//  181           Pixels = *(++p);
//  182         }
//  183 		  } while (--xsize);
//  184     } else {
//  185       do {
//  186         int Shift = (3 - CurrentPixel) << 1;
//  187         int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
//  188         if (Index) {
//  189           _SetPixelIndex(xx, Index);
//  190         } else {
//  191           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  192         }
//  193         xx++;
//  194         if (++CurrentPixel == 4) {
//  195           CurrentPixel = 0;
//  196           Pixels = *(++p);
//  197         }
//  198 		  } while (--xsize);
//  199     }
//  200     break;
//  201   }
//  202   LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
//  203 }
//  204 
//  205 /*********************************************************************
//  206 *
//  207 *       _DrawBitLine4BPP
//  208 */
//  209 static void _DrawBitLine4BPP(int x, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
//  210   int xx;
//  211   U8 Pixels = *p;
//  212   int CurrentPixel = Diff;
//  213   x += Diff;
//  214   xx = x;
//  215   switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
//  216   case 0:
//  217     if (pTrans) {
//  218       do {
//  219         int Shift = (1 - CurrentPixel) << 2;
//  220         int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  221         LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
//  222         _SetPixelIndex(xx++, PixelIndex);
//  223         if (++CurrentPixel == 2) {
//  224           CurrentPixel = 0;
//  225           Pixels = *(++p);
//  226         }
//  227 		  } while (--xsize);
//  228     } else {
//  229       do {
//  230         int Shift = (1 - CurrentPixel) << 2;
//  231         int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  232         _SetPixelIndex(xx++, Index);
//  233         if (++CurrentPixel == 2) {
//  234           CurrentPixel = 0;
//  235           Pixels = *(++p);
//  236         }
//  237 		  } while (--xsize);
//  238     }
//  239     break;
//  240   case LCD_DRAWMODE_TRANS:
//  241     if (pTrans) {
//  242       do {
//  243         int Shift = (1 - CurrentPixel) << 2;
//  244         int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  245         if (Index) {
//  246           U8 PixelIndex = *(pTrans + Index);
//  247           _SetPixelIndex(xx, PixelIndex);
//  248         } else {
//  249           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  250         }
//  251         xx++;
//  252         if (++CurrentPixel == 2) {
//  253           CurrentPixel = 0;
//  254           Pixels = *(++p);
//  255         }
//  256 		  } while (--xsize);
//  257     } else {
//  258       do {
//  259         int Shift = (1 - CurrentPixel) << 2;
//  260         int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
//  261         if (Index) {
//  262           _SetPixelIndex(xx, Index);
//  263         } else {
//  264           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  265         }
//  266         xx++;
//  267         if (++CurrentPixel == 2) {
//  268           CurrentPixel = 0;
//  269           Pixels = *(++p);
//  270         }
//  271 		  } while (--xsize);
//  272     }
//  273     break;
//  274   }
//  275   LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
//  276 }
//  277 
//  278 /*********************************************************************
//  279 *
//  280 *       _DrawBitLine8BPP
//  281 */
//  282 static void _DrawBitLine8BPP(int x, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
//  283   int xx = x;
//  284   LCD_PIXELINDEX Pixel;
//  285   switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
//  286   case 0:
//  287     if (pTrans) {
//  288       for (; xsize > 0; xsize--, xx++, p++) {
//  289         Pixel = *p;
//  290         _SetPixelIndex(xx, *(pTrans + Pixel));
//  291       }
//  292     } else {
//  293       for (; xsize > 0; xsize--, xx++, p++) {
//  294         _SetPixelIndex(xx, *p);
//  295       }
//  296     }
//  297     break;
//  298   case LCD_DRAWMODE_TRANS:
//  299     if (pTrans) {
//  300       for (; xsize > 0; xsize--, xx++, p++) {
//  301         Pixel = *p;
//  302         if (Pixel) {
//  303           _SetPixelIndex(xx, *(pTrans + Pixel));
//  304         } else {
//  305           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  306         }
//  307       }
//  308     } else {
//  309       for (; xsize > 0; xsize--, xx++, p++) {
//  310         Pixel = *p;
//  311         if (Pixel) {
//  312           _SetPixelIndex(xx, Pixel);
//  313         } else {
//  314           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  315         }
//  316       }
//  317     }
//  318     break;
//  319   }
//  320   LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
//  321 }
//  322 
//  323 /*********************************************************************
//  324 *
//  325 *       _DrawBitLine16BPP
//  326 */
//  327 static void _DrawBitLine16BPP(int x, U16 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
//  328   int xx = x;
//  329   LCD_PIXELINDEX pixel;
//  330   if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0) {
//  331     if (pTrans) {
//  332       for (; xsize > 0; xsize--, xx++, p++) {
//  333         pixel = *p;
//  334         _SetPixelIndex(xx, *(pTrans + pixel));
//  335       }
//  336     } else {
//  337       for (;xsize > 0; xsize--, xx++, p++) {
//  338         _SetPixelIndex(xx, *p);
//  339       }
//  340     }
//  341   } else {
//  342     if (pTrans) {
//  343       for (; xsize > 0; xsize--, xx++, p++) {
//  344         pixel = *p;
//  345         if (pixel) {
//  346           _SetPixelIndex(xx, *(pTrans + pixel));
//  347         } else {
//  348           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  349         }
//  350       }
//  351     } else {
//  352       for (; xsize > 0; xsize--, xx++, p++) {
//  353         pixel = *p;
//  354         if (pixel) {
//  355           _SetPixelIndex(xx, pixel);
//  356         } else {
//  357           _SetPixelIndex(xx, LCD_L0_GetPixelIndex(xx, _y));
//  358         }
//  359       }
//  360     }
//  361   }
//  362   LCD_L0_DrawBitmap(x, _y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
//  363 }
//  364 
//  365 /*********************************************************************
//  366 *
//  367 *       Public code
//  368 *
//  369 **********************************************************************
//  370 */
//  371 /*********************************************************************
//  372 *
//  373 *       LCD_L0_DELTA_DrawBitmap
//  374 */
//  375 void LCD_L0_DELTA_DrawBitmap(int x0, int y0,
//  376                              int xsize, int ysize,
//  377                              int BitsPerPixel, 
//  378                              int BytesPerLine,
//  379                              const U8 GUI_UNI_PTR * pData, int Diff,
//  380                              const LCD_PIXELINDEX* pTrans)
//  381 {
//  382   int i;
//  383   _InitBM(xsize, x0 + Diff);
//  384   for (i = 0; i < ysize; i++) {
//  385     _y = i + y0;
//  386     switch (BitsPerPixel) {
//  387     case 1:
//  388       _DrawBitLine1BPP(x0, pData, Diff, xsize, pTrans);
//  389       break;
//  390     #if (LCD_MAX_LOG_COLORS > 2)
//  391       case 2:
//  392         _DrawBitLine2BPP(x0, pData, Diff, xsize, pTrans);
//  393         break;
//  394     #endif
//  395     #if (LCD_MAX_LOG_COLORS > 4)
//  396       case 4:
//  397         _DrawBitLine4BPP(x0, pData, Diff, xsize, pTrans);
//  398         break;
//  399     #endif
//  400     #if (LCD_MAX_LOG_COLORS > 16)
//  401       case 8:
//  402         _DrawBitLine8BPP(x0, pData, xsize, pTrans);
//  403         break;
//  404     #endif
//  405     #if (LCD_BITSPERPIXEL > 8)
//  406       case 16:
//  407         _DrawBitLine16BPP(x0, (const U16 *)pData, xsize, pTrans);
//  408         break;
//  409     #endif
//  410     }
//  411     pData += BytesPerLine;
//  412   }
//  413 }
//  414 
//  415 /*********************************************************************
//  416 *
//  417 *       LCD_L0_DELTA_DrawHLine
//  418 */
//  419 void LCD_L0_DELTA_DrawHLine(int x0, int y,  int x1) {
//  420   if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
//  421     for (; x0 <= x1; x0++) {
//  422       LCD_L0_XorPixel(x0, y);
//  423     }
//  424   } else {
//  425     LCD_L0_DELTA_FillRect(x0, y, x1, y);
//  426   }
//  427 }
//  428 
//  429 /*********************************************************************
//  430 *
//  431 *       LCD_L0_DELTA_DrawVLine
//  432 */
//  433 void LCD_L0_DELTA_DrawVLine(int x , int y0,  int y1) {
//  434   if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
//  435     for (; y0 <= y1; y0++) {
//  436       LCD_L0_XorPixel(x, y0);
//  437     }
//  438   } else {
//  439     int aIndex[2];
//  440     _SetRGB(LCD_COLORINDEX);
//  441     aIndex[0] = x % 3;
//  442     aIndex[1] = (x + 1) % 3;
//  443     for (; y0 <= y1; y0++) {
//  444       LCD_L0_SetPixelIndex(x, y0, _aRGB[aIndex[y0 & 1]]);
//  445     }
//  446   }
//  447 }
//  448 
//  449 /*********************************************************************
//  450 *
//  451 *       LCD_L0_DELTA_FillRect
//  452 */
//  453 void LCD_L0_DELTA_FillRect(int x0, int y0, int x1, int y1) {
//  454   if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
//  455     for (; y0 <= y1; y0++) {
//  456       LCD_L0_DELTA_DrawHLine(x0, y0, x1);
//  457     }
//  458   } else {
//  459     int x, y, aInit_0 = 0, aInit_1 = 0;
//  460     _InitBM(x1 - x0 + 1, x0);/**/
//  461     _SetRGB(LCD_COLORINDEX);
//  462     for (y = y0; y <= y1; y++) {
//  463       int Index = y & 1;
//  464       if (Index) {
//  465         if (!aInit_1) {
//  466           for (x = x0; x <= x1; x++) {
//  467             _aPixelData_1[x] = _aRGB[(x + 1) % 3];
//  468           }
//  469           aInit_1 = 1;
//  470         }
//  471         LCD_L0_DrawBitmap(x0, y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, &_aPixelData_1[x0], 0, 0);
//  472       } else {
//  473         if (!aInit_0) {
//  474           for (x = x0; x <= x1; x++) {
//  475             _aPixelData_0[x] = _aRGB[x % 3];
//  476           }
//  477           aInit_0 = 1;
//  478         }
//  479         LCD_L0_DrawBitmap(x0, y, _Bm.XSize, 1, _Bm.BitsPerPixel, _Bm.BytesPerLine, _Bm.pData, 0, 0);
//  480      }
//  481     }
//  482   }
//  483 }
//  484 
//  485 /*********************************************************************
//  486 *
//  487 *       LCD_L0_DELTA_GetPixelIndex
//  488 */
//  489 unsigned int LCD_L0_DELTA_GetPixelIndex(int x, int y) {
//  490   return LCD_L0_GetPixelIndex(x, y);
//  491 }
//  492 
//  493 /*********************************************************************
//  494 *
//  495 *       LCD_L0_DELTA_SetPixelIndex
//  496 */
//  497 void LCD_L0_DELTA_SetPixelIndex(int x, int y, int ColorIndex) {
//  498   LCD_L0_SetPixelIndex(x, y, ColorIndex);
//  499 }
//  500 
//  501 /*********************************************************************
//  502 *
//  503 *       LCD_L0_DELTA_XorPixel
//  504 */
//  505 void LCD_L0_DELTA_XorPixel(int x, int y) {
//  506   LCD_L0_XorPixel(x, y);
//  507 }
//  508 
//  509 #else
//  510 
//  511 void LCDL0Delta_c(void);

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function LCDL0Delta_c
          CFI NoCalls
        THUMB
//  512 void LCDL0Delta_c(void) { } /* avoid empty object files */
LCDL0Delta_c:
        BX       LR               ;; return
          CFI EndBlock cfiBlock0

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  513 
//  514 #endif
//  515 
//  516 /*************************** End of file ****************************/
// 
// 2 bytes in section .text
// 
// 2 bytes of CODE memory
//
//Errors: none
//Warnings: none
