###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  16:59:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\FRAMEWIN.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\FRAMEWIN.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertColor\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/ConvertMono\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Core\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Font\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/AntiAlias\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/GUIDemo\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/LCDDriver\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MemDev\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/MultiLayer\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/Widget\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI/WM\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/GUI_X\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Ucgui/Config\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\FRAMEWIN.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\FRAMEWIN.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Ucgui\GUI\Widget\FRAMEWIN.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : FRAMEWIN.c
     16          Purpose     : Implementation of framewindow widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "FRAMEWIN_Private.h"
     23          #include "GUI_Protected.h"
     24          #include "WM_Intern.h"
     25          
     26          #if GUI_WINSUPPORT
     27          
     28          /******************************************************************
     29          *
     30          *        Config defaults
     31          *
     32          *******************************************************************
     33          */
     34          
     35          /* Support for 3D effects */
     36          #ifndef FRAMEWIN_CLIENTCOLOR_DEFAULT
     37            #define FRAMEWIN_CLIENTCOLOR_DEFAULT 0xc0c0c0
     38          #endif
     39          
     40          /* Default for top frame size */
     41          #ifndef FRAMEWIN_TITLEHEIGHT_DEFAULT
     42            #define FRAMEWIN_TITLEHEIGHT_DEFAULT 0
     43          #endif
     44          
     45          /* Default for left/right/top/bottom frame size */
     46          #ifndef FRAMEWIN_BORDER_DEFAULT
     47            #define FRAMEWIN_BORDER_DEFAULT 3
     48          #endif
     49          
     50          /* Default for inner frame size */
     51          #ifndef FRAMEWIN_IBORDER_DEFAULT
     52            #define FRAMEWIN_IBORDER_DEFAULT 1
     53          #endif
     54          
     55          /* Default font */
     56          #ifndef FRAMEWIN_DEFAULT_FONT
     57            #define FRAMEWIN_DEFAULT_FONT &GUI_Font8_1
     58          #endif
     59          
     60          /* Default barcolor when framewin is active */
     61          #ifndef FRAMEWIN_BARCOLOR_ACTIVE_DEFAULT
     62            #define FRAMEWIN_BARCOLOR_ACTIVE_DEFAULT 0xFF0000
     63          #endif
     64          
     65          /* Default barcolor when framewin is inactive */
     66          #ifndef FRAMEWIN_BARCOLOR_INACTIVE_DEFAULT
     67            #define FRAMEWIN_BARCOLOR_INACTIVE_DEFAULT 0x404040
     68          #endif
     69          
     70          /* Default framecolor */
     71          #ifndef FRAMEWIN_FRAMECOLOR_DEFAULT
     72            #define FRAMEWIN_FRAMECOLOR_DEFAULT 0xAAAAAA
     73          #endif
     74          
     75          /* Default textcolor when framewin is active */
     76          #ifndef FRAMEWIN_TEXTCOLOR0_DEFAULT
     77            #define FRAMEWIN_TEXTCOLOR0_DEFAULT GUI_WHITE
     78          #endif
     79          
     80          /* Default textcolor when framewin is inactive */
     81          #ifndef FRAMEWIN_TEXTCOLOR1_DEFAULT
     82            #define FRAMEWIN_TEXTCOLOR1_DEFAULT GUI_WHITE
     83          #endif
     84          
     85          /*********************************************************************
     86          *
     87          *       public data, defaults (internal use only)
     88          *
     89          **********************************************************************
     90          */
     91          

   \                                 In section .data, align 4
     92          FRAMEWIN_PROPS FRAMEWIN__DefaultProps = {
   \                     FRAMEWIN__DefaultProps:
   \   00000000   0x........         DC32 GUI_Font8_1, 4210752, 16711680, 16777215, 16777215, 12632256
   \              0x00404040   
   \              0x00FF0000   
   \              0x00FFFFFF   
   \              0x00FFFFFF   
   \              0x00C0C0C0   
   \   00000018   0x0000 0x0003      DC16 0, 3, 1
   \              0x0001       
   \   0000001E   0x00 0x00          DC8 0, 0
     93            FRAMEWIN_DEFAULT_FONT,
     94            FRAMEWIN_BARCOLOR_INACTIVE_DEFAULT,
     95            FRAMEWIN_BARCOLOR_ACTIVE_DEFAULT,
     96            FRAMEWIN_TEXTCOLOR0_DEFAULT,
     97            FRAMEWIN_TEXTCOLOR1_DEFAULT,
     98            FRAMEWIN_CLIENTCOLOR_DEFAULT,
     99            FRAMEWIN_TITLEHEIGHT_DEFAULT,
    100            FRAMEWIN_BORDER_DEFAULT,
    101            FRAMEWIN_IBORDER_DEFAULT
    102          };
    103          
    104          /*********************************************************************
    105          *
    106          *       static data
    107          *
    108          **********************************************************************
    109          */
    110          

   \                                 In section .data, align 2
    111          static I16 FRAMEWIN__MinVisibility = 5;
   \                     FRAMEWIN__MinVisibility:
   \   00000000   0x0005             DC16 5
    112          
    113          /*********************************************************************
    114          *
    115          *           Static routines
    116          *
    117          **********************************************************************
    118          */
    119          
    120          /*********************************************************************
    121          *
    122          *       _SetActive
    123          */

   \                                 In section .text, align 2, keep-with-next
    124          static void _SetActive(FRAMEWIN_Handle hObj, int State) {
   \                     _SetActive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    125            FRAMEWIN_Obj* pObj;
    126            pObj = FRAMEWIN_H2P(hObj);
   \   00000006   0x.... 0x....      BL       GUI_ALLOC_h2p
    127            if        (State && !(pObj->Flags & FRAMEWIN_SF_ACTIVE)) {
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD00C             BEQ.N    ??_SetActive_0
   \   0000000E   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   \   00000012   0x070A             LSLS     R2,R1,#+28
   \   00000014   0xD408             BMI.N    ??_SetActive_0
    128              pObj->Flags |= FRAMEWIN_CF_ACTIVE;
   \   00000016   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000001A   0xF8A0 0x105C      STRH     R1,[R0, #+92]
    129              FRAMEWIN_Invalidate(hObj);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000024   0x.... 0x....      B.W      WM_InvalidateWindow
    130            } else if (!State && (pObj->Flags & FRAMEWIN_SF_ACTIVE)) {
   \                     ??_SetActive_0: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD10D             BNE.N    ??_SetActive_1
   \   0000002C   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   \   00000030   0x070A             LSLS     R2,R1,#+28
   \   00000032   0xD509             BPL.N    ??_SetActive_1
    131              pObj->Flags &= ~FRAMEWIN_CF_ACTIVE;
   \   00000034   0xF64F 0x72F7      MOVW     R2,#+65527
   \   00000038   0x4011             ANDS     R1,R2,R1
   \   0000003A   0xF8A0 0x105C      STRH     R1,[R0, #+92]
    132              FRAMEWIN_Invalidate(hObj);
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000044   0x.... 0x....      B.W      WM_InvalidateWindow
    133            }
    134          }
   \                     ??_SetActive_1: (+1)
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    135          
    136          /*********************************************************************
    137          *
    138          *       _OnTouch
    139          */

   \                                 In section .text, align 2, keep-with-next
    140          static void _OnTouch(FRAMEWIN_Handle hWin, FRAMEWIN_Obj* pObj, WM_MESSAGE* pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    141            const GUI_PID_STATE* pState;
    142            pState = (const GUI_PID_STATE*)pMsg->Data.p;
   \   00000006   0x6895             LDR      R5,[R2, #+8]
    143            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD01A             BEQ.N    ??_OnTouch_0
    144              if (pState->Pressed) {
   \   0000000C   0x7A28             LDRB     R0,[R5, #+8]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD017             BEQ.N    ??_OnTouch_0
    145                if (!(pObj->Flags & FRAMEWIN_SF_ACTIVE)) {
   \   00000012   0xF896 0x005C      LDRB     R0,[R6, #+92]
   \   00000016   0x0700             LSLS     R0,R0,#+28
   \   00000018   0xD402             BMI.N    ??_OnTouch_1
    146                  WM_SetFocus(hWin);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       WM_SetFocus
    147                }
    148                WM_BringToTop(hWin);
   \                     ??_OnTouch_1: (+1)
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       WM_BringToTop
    149                if (pObj->Flags & FRAMEWIN_SF_MOVEABLE) {
   \   00000026   0xF896 0x005C      LDRB     R0,[R6, #+92]
   \   0000002A   0x06C0             LSLS     R0,R0,#+27
   \   0000002C   0xD509             BPL.N    ??_OnTouch_0
    150                  WM_SetCaptureMove(hWin, pState, FRAMEWIN__MinVisibility);
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable2
   \   00000032   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000003E   0x.... 0x....      B.W      WM_SetCaptureMove
    151                }
    152              }
    153            }
    154          }
   \                     ??_OnTouch_0: (+1)
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    155          
    156          /*********************************************************************
    157          *
    158          *       _Paint  (Frame)
    159          *
    160          */

   \                                 In section .text, align 2, keep-with-next
    161          static void _Paint(FRAMEWIN_Obj* pObj) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x4604             MOV      R4,R0
    162            WM_HWIN hWin = WM_GetActiveWindow();
   \   00000008   0x.... 0x....      BL       WM_GetActiveWindow
   \   0000000C   0x4606             MOV      R6,R0
    163            const char* pText = NULL;
   \   0000000E   0xF04F 0x0800      MOV      R8,#+0
    164            int xsize = WM_GetWindowSizeX(hWin);
   \   00000012   0x.... 0x....      BL       WM_GetWindowSizeX
   \   00000016   0x4605             MOV      R5,R0
    165            int ysize = WM_GetWindowSizeY(hWin);
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0x.... 0x....      BL       WM_GetWindowSizeY
   \   0000001E   0x4606             MOV      R6,R0
    166            int BorderSize = pObj->Props.BorderSize;
   \   00000020   0xF104 0x0728      ADD      R7,R4,#+40
   \   00000024   0xF9B7 0x001A      LDRSH    R0,[R7, #+26]
   \   00000028   0x9007             STR      R0,[SP, #+28]
    167            int y0, Index;
    168            POSITIONS Pos;
    169            GUI_RECT r, rText;
    170          
    171            /* Perform computations */
    172            FRAMEWIN__CalcPositions(pObj, &Pos);
   \   0000002A   0xA900             ADD      R1,SP,#+0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       FRAMEWIN__CalcPositions
    173            Index = (pObj->Flags & FRAMEWIN_SF_ACTIVE) ? 1 : 0;
   \   00000032   0x8EB8             LDRH     R0,[R7, #+52]
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x08C0             LSRS     R0,R0,#+3
   \   00000038   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000003C   0x9008             STR      R0,[SP, #+32]
    174          
    175            if (pObj->hText) {
   \   0000003E   0xF9B7 0x0028      LDRSH    R0,[R7, #+40]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??_Paint_0
    176              pText = (const char*) GUI_ALLOC_h2p(pObj->hText);
   \   00000046   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000004A   0x4680             MOV      R8,R0
    177            }
    178            r.x0 = Pos.rClient.x0;
   \                     ??_Paint_0: (+1)
   \   0000004C   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000050   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    179            r.x1 = Pos.rClient.x1;
   \   00000054   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000058   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    180            r.y0 = Pos.rTitleText.y0;
   \   0000005C   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   00000060   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    181            r.y1 = Pos.rTitleText.y1;
   \   00000064   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   00000068   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    182            Pos.rTitleText.y0++;
   \   0000006C   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    183            Pos.rTitleText.x0++;
   \   00000076   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    184            Pos.rTitleText.x1--;
   \   00000080   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    185            GUI_SetFont(pObj->Props.pFont);
   \   0000008A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008C   0x.... 0x....      BL       GUI_SetFont
    186            GUI__CalcTextRect(pText, &Pos.rTitleText, &rText, pObj->TextAlign);
   \   00000090   0xF9B7 0x3032      LDRSH    R3,[R7, #+50]
   \   00000094   0xAA09             ADD      R2,SP,#+36
   \   00000096   0xA903             ADD      R1,SP,#+12
   \   00000098   0x4640             MOV      R0,R8
   \   0000009A   0x.... 0x....      BL       GUI__CalcTextRect
    187            y0 = Pos.TitleHeight + BorderSize;
   \   0000009E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   000000A2   0x9907             LDR      R1,[SP, #+28]
   \   000000A4   0xEB01 0x0900      ADD      R9,R1,R0
    188          
    189            /* Perform drawing operations */
    190            WM_ITERATE_START(NULL) {
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x.... 0x....      BL       WM__InitIVRSearch
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD04A             BEQ.N    ??_Paint_1
    191              /* Draw Title */
    192              LCD_SetBkColor(pObj->Props.aBarColor[Index]);
   \                     ??_Paint_2: (+1)
   \   000000B2   0x9808             LDR      R0,[SP, #+32]
   \   000000B4   0xEB04 0x0A80      ADD      R10,R4,R0, LSL #+2
   \   000000B8   0xF8DA 0x002C      LDR      R0,[R10, #+44]
   \   000000BC   0x.... 0x....      BL       LCD_SetBkColor
    193              LCD_SetColor(pObj->Props.aTextColor[Index]);
   \   000000C0   0xF8DA 0x0034      LDR      R0,[R10, #+52]
   \   000000C4   0x.... 0x....      BL       LCD_SetColor
    194              WIDGET__FillStringInRect(pText, &r, &Pos.rTitleText, &rText);
   \   000000C8   0xAB09             ADD      R3,SP,#+36
   \   000000CA   0xAA03             ADD      R2,SP,#+12
   \   000000CC   0xA905             ADD      R1,SP,#+20
   \   000000CE   0x4640             MOV      R0,R8
   \   000000D0   0x.... 0x....      BL       WIDGET__FillStringInRect
    195              /* Draw Frame */
    196              LCD_SetColor(FRAMEWIN_FRAMECOLOR_DEFAULT);
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable2_1  ;; 0xaaaaaa
   \   000000D8   0x.... 0x....      BL       LCD_SetColor
    197              GUI_FillRect(0, 0, xsize-1, BorderSize-1);
   \   000000DC   0xF1A5 0x0A01      SUB      R10,R5,#+1
   \   000000E0   0x9807             LDR      R0,[SP, #+28]
   \   000000E2   0x1E43             SUBS     R3,R0,#+1
   \   000000E4   0x4652             MOV      R2,R10
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x4608             MOV      R0,R1
   \   000000EA   0x.... 0x....      BL       GUI_FillRect
    198          	  GUI_FillRect(0, 0, Pos.rClient.x0-1, ysize-1);
   \   000000EE   0xF1A6 0x0B01      SUB      R11,R6,#+1
   \   000000F2   0x465B             MOV      R3,R11
   \   000000F4   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   000000F8   0x1E42             SUBS     R2,R0,#+1
   \   000000FA   0x2100             MOVS     R1,#+0
   \   000000FC   0x4608             MOV      R0,R1
   \   000000FE   0x.... 0x....      BL       GUI_FillRect
    199          	  GUI_FillRect(Pos.rClient.x1+1, 0, xsize-1, ysize-1);
   \   00000102   0x465B             MOV      R3,R11
   \   00000104   0x4652             MOV      R2,R10
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000010C   0x1C40             ADDS     R0,R0,#+1
   \   0000010E   0x.... 0x....      BL       GUI_FillRect
    200              GUI_FillRect(0, Pos.rClient.y1+1, xsize-1, ysize-1);
   \   00000112   0x465B             MOV      R3,R11
   \   00000114   0x4652             MOV      R2,R10
   \   00000116   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   0000011A   0x1C41             ADDS     R1,R0,#+1
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x.... 0x....      BL       GUI_FillRect
    201              GUI_FillRect(0, y0, xsize - 1, y0 + pObj->Props.IBorderSize - 1);
   \   00000122   0xF9B7 0x001C      LDRSH    R0,[R7, #+28]
   \   00000126   0x4448             ADD      R0,R0,R9
   \   00000128   0x1E43             SUBS     R3,R0,#+1
   \   0000012A   0x4652             MOV      R2,R10
   \   0000012C   0x4649             MOV      R1,R9
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x.... 0x....      BL       GUI_FillRect
    202              /* Draw the 3D effect (if configured) */
    203              if (pObj->Props.BorderSize >= 2) {
   \   00000134   0xF9B7 0x001A      LDRSH    R0,[R7, #+26]
   \   00000138   0x2802             CMP      R0,#+2
   \   0000013A   0xDB01             BLT.N    ??_Paint_3
    204                WIDGET_EFFECT_3D_DrawUp();  /* pObj->Widget.pEffect->pfDrawUp(); */
   \   0000013C   0x.... 0x....      BL       WIDGET_EFFECT_3D_DrawUp
    205              }
    206          
    207            } WM_ITERATE_END();
   \                     ??_Paint_3: (+1)
   \   00000140   0x.... 0x....      BL       WM__GetNextIVR
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD1B4             BNE.N    ??_Paint_2
    208          
    209          
    210          }
   \                     ??_Paint_1: (+1)
   \   00000148   0xB00B             ADD      SP,SP,#+44
   \   0000014A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    211          
    212          /*********************************************************************
    213          *
    214          *       _OnChildHasFocus
    215          *
    216          * Function:
    217          *   A child has received or lost the focus.
    218          *   The basic idea is to make sure the framewindow is active if a
    219          *   descendant has the focus.
    220          *   If the focus travels from one desc. to an other, there is no need
    221          *   to make the framewindow inactive and active again.
    222          *   Avoiding this complicates the code a litlle, but avoids flicker
    223          *   and waste of CPU load.
    224          *   
    225          */

   \                                 In section .text, align 2, keep-with-next
    226          static void _OnChildHasFocus(FRAMEWIN_Handle hWin, FRAMEWIN_Obj* pObj, WM_MESSAGE *pMsg) {
   \                     _OnChildHasFocus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    227            if (pMsg->Data.p) {
   \   00000006   0x6896             LDR      R6,[R2, #+8]
   \   00000008   0x2E00             CMP      R6,#+0
   \   0000000A   0xD019             BEQ.N    ??_OnChildHasFocus_0
    228              const WM_NOTIFY_CHILD_HAS_FOCUS_INFO * pInfo = (const WM_NOTIFY_CHILD_HAS_FOCUS_INFO *)pMsg->Data.p;
    229              int IsDesc = WM__IsAncestorOrSelf(pInfo->hNew, hWin);
    230              if (IsDesc) {                         /* A child has received the focus, Framewindow needs to be activated */
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   00000012   0x.... 0x....      BL       WM__IsAncestorOrSelf
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??_OnChildHasFocus_1
    231                _SetActive(hWin, 1);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000022   0x....             B.N      _SetActive
    232              } else {                  /* A child has lost the focus, we need to deactivate */
    233                _SetActive(hWin, 0);
   \                     ??_OnChildHasFocus_1: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _SetActive
    234                /* Remember the child which had the focus so we can reactive this child */
    235                if (WM__IsAncestor(pInfo->hOld, hWin)) {
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000032   0x.... 0x....      BL       WM__IsAncestor
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??_OnChildHasFocus_0
    236                  pObj->hFocussedChild = pInfo->hOld;
   \   0000003A   0x8830             LDRH     R0,[R6, #+0]
   \   0000003C   0xF8A5 0x005E      STRH     R0,[R5, #+94]
    237                }
    238              }
    239            }
    240          }
   \                     ??_OnChildHasFocus_0: (+1)
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    241          
    242          /*********************************************************************
    243          *
    244          *       Framewin Callback
    245          */

   \                                 In section .text, align 2, keep-with-next
    246          static void _FRAMEWIN_Callback (WM_MESSAGE *pMsg) {
   \                     _FRAMEWIN_Callback: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4604             MOV      R4,R0
    247            FRAMEWIN_Handle hWin = (FRAMEWIN_Handle)(pMsg->hWin);
   \   00000008   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    248            FRAMEWIN_Obj* pObj = FRAMEWIN_H2P(hWin);
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000012   0x4607             MOV      R7,R0
    249            GUI_RECT* pRect = (GUI_RECT*)(pMsg->Data.p);
   \   00000014   0xF8D4 0x8008      LDR      R8,[R4, #+8]
    250            POSITIONS Pos;
    251            GUI_HOOK* pHook;
    252            /* Call hook functions */
    253            for (pHook = pObj->pFirstHook; pHook; pHook = pHook->pNext) {
   \   00000018   0xF107 0x064C      ADD      R6,R7,#+76
   \   0000001C   0xF8D6 0x9018      LDR      R9,[R6, #+24]
   \   00000020   0xE001             B.N      ??_FRAMEWIN_Callback_0
   \                     ??_FRAMEWIN_Callback_1: (+1)
   \   00000022   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \                     ??_FRAMEWIN_Callback_0: (+1)
   \   00000026   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002A   0xD006             BEQ.N    ??_FRAMEWIN_Callback_2
    254              int r;
    255              r = (*pHook->pHookFunc)(pMsg);
    256              if (r) {
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xF8D9 0x1004      LDR      R1,[R9, #+4]
   \   00000032   0x4788             BLX      R1
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD0F4             BEQ.N    ??_FRAMEWIN_Callback_1
    257                return;   /* Message handled */
   \   00000038   0xE083             B.N      ??_FRAMEWIN_Callback_3
    258              }
    259            }
    260            switch (pMsg->MsgId) {
   \                     ??_FRAMEWIN_Callback_2: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x280B             CMP      R0,#+11
   \   0000003E   0xD073             BEQ.N    ??_FRAMEWIN_Callback_4
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD01B             BEQ.N    ??_FRAMEWIN_Callback_5
   \   00000044   0x280D             CMP      R0,#+13
   \   00000046   0xD05B             BEQ.N    ??_FRAMEWIN_Callback_6
   \   00000048   0x280F             CMP      R0,#+15
   \   0000004A   0xD013             BEQ.N    ??_FRAMEWIN_Callback_7
   \   0000004C   0x2814             CMP      R0,#+20
   \   0000004E   0xD01B             BEQ.N    ??_FRAMEWIN_Callback_8
   \   00000050   0x2817             CMP      R0,#+23
   \   00000052   0xD023             BEQ.N    ??_FRAMEWIN_Callback_9
   \   00000054   0x281F             CMP      R0,#+31
   \   00000056   0xD034             BEQ.N    ??_FRAMEWIN_Callback_10
   \   00000058   0x2821             CMP      R0,#+33
   \   0000005A   0xD05F             BEQ.N    ??_FRAMEWIN_Callback_11
   \   0000005C   0x2826             CMP      R0,#+38
   \   0000005E   0xD021             BEQ.N    ??_FRAMEWIN_Callback_12
   \   00000060   0x282A             CMP      R0,#+42
   \   00000062   0xD165             BNE.N    ??_FRAMEWIN_Callback_13
    261            case WM_HANDLE_DIALOG_STATUS:
    262              if (pMsg->Data.p) {                           /* set pointer to Dialog status */
   \   00000064   0x68A0             LDR      R0,[R4, #+8]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??_FRAMEWIN_Callback_14
    263                pObj->pDialogStatus = (WM_DIALOG_STATUS*)pMsg->Data.p;
   \   0000006A   0x6170             STR      R0,[R6, #+20]
   \   0000006C   0xE069             B.N      ??_FRAMEWIN_Callback_3
    264              } else {                                      /* return pointer to Dialog status */
    265                pMsg->Data.p = pObj->pDialogStatus;      
   \                     ??_FRAMEWIN_Callback_14: (+1)
   \   0000006E   0x6970             LDR      R0,[R6, #+20]
   \   00000070   0x60A0             STR      R0,[R4, #+8]
    266              }
    267              return;
   \   00000072   0xE066             B.N      ??_FRAMEWIN_Callback_3
    268            case WM_PAINT:
    269              _Paint(pObj);
   \                     ??_FRAMEWIN_Callback_7: (+1)
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x.... 0x....      BL       _Paint
    270              break;
   \   0000007A   0xE059             B.N      ??_FRAMEWIN_Callback_13
    271            case WM_TOUCH:
    272              _OnTouch(hWin, pObj, pMsg);
   \                     ??_FRAMEWIN_Callback_5: (+1)
   \   0000007C   0x4622             MOV      R2,R4
   \   0000007E   0x4639             MOV      R1,R7
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0x.... 0x....      BL       _OnTouch
    273              return;                       /* Return here ... Message handled */
   \   00000086   0xE05C             B.N      ??_FRAMEWIN_Callback_3
    274            case WM_GET_INSIDE_RECT:
    275              FRAMEWIN__CalcPositions(pObj, &Pos);
   \                     ??_FRAMEWIN_Callback_8: (+1)
   \   00000088   0xA903             ADD      R1,SP,#+12
   \   0000008A   0x4638             MOV      R0,R7
   \   0000008C   0x.... 0x....      BL       FRAMEWIN__CalcPositions
    276          		*pRect = Pos.rClient;
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0xA904             ADD      R1,SP,#+16
   \   00000094   0x2208             MOVS     R2,#+8
   \   00000096   0x.... 0x....      BL       __aeabi_memcpy
    277              return;                       /* Return here ... Message handled */
   \   0000009A   0xE052             B.N      ??_FRAMEWIN_Callback_3
    278            case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
    279              pMsg->Data.v = (int)pObj->hClient;
   \                     ??_FRAMEWIN_Callback_9: (+1)
   \   0000009C   0xF9B7 0x004C      LDRSH    R0,[R7, #+76]
   \   000000A0   0x60A0             STR      R0,[R4, #+8]
    280              return;                       /* Return here ... Message handled */
   \   000000A2   0xE04E             B.N      ??_FRAMEWIN_Callback_3
    281            case WM_NOTIFY_PARENT:
    282              if (pMsg->Data.v == WM_NOTIFICATION_RELEASED) {
   \                     ??_FRAMEWIN_Callback_12: (+1)
   \   000000A4   0x68A0             LDR      R0,[R4, #+8]
   \   000000A6   0x2802             CMP      R0,#+2
   \   000000A8   0xD14B             BNE.N    ??_FRAMEWIN_Callback_3
    283                WM_MESSAGE Msg;
    284                Msg.hWinSrc = hWin;
   \   000000AA   0xF8AD 0x5006      STRH     R5,[SP, #+6]
    285                Msg.Data    = pMsg->Data;
   \   000000AE   0x68A0             LDR      R0,[R4, #+8]
   \   000000B0   0x9002             STR      R0,[SP, #+8]
    286                Msg.MsgId   = WM_NOTIFY_PARENT_REFLECTION;
   \   000000B2   0x2027             MOVS     R0,#+39
   \   000000B4   0x9000             STR      R0,[SP, #+0]
    287                WM_SendMessage(pMsg->hWinSrc, &Msg);
   \   000000B6   0xA900             ADD      R1,SP,#+0
   \   000000B8   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   000000BC   0x.... 0x....      BL       WM_SendMessage
    288              }
    289              return;
   \   000000C0   0xE03F             B.N      ??_FRAMEWIN_Callback_3
    290            case WM_SET_FOCUS:                 /* We have received or lost focus */
    291              if (pMsg->Data.v == 1) {
   \                     ??_FRAMEWIN_Callback_10: (+1)
   \   000000C2   0x68A0             LDR      R0,[R4, #+8]
   \   000000C4   0x2801             CMP      R0,#+1
   \   000000C6   0xD116             BNE.N    ??_FRAMEWIN_Callback_15
    292                if (WM_IsWindow(pObj->hFocussedChild)) {
   \   000000C8   0xF9B6 0x0012      LDRSH    R0,[R6, #+18]
   \   000000CC   0x.... 0x....      BL       WM_IsWindow
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD004             BEQ.N    ??_FRAMEWIN_Callback_16
    293                  WM_SetFocus(pObj->hFocussedChild);
   \   000000D4   0xF9B6 0x0012      LDRSH    R0,[R6, #+18]
   \   000000D8   0x.... 0x....      BL       WM_SetFocus
   \   000000DC   0xE004             B.N      ??_FRAMEWIN_Callback_17
    294                } else {
    295                  pObj->hFocussedChild = WM_SetFocusOnNextChild(pObj->hClient);
   \                     ??_FRAMEWIN_Callback_16: (+1)
   \   000000DE   0xF9B7 0x004C      LDRSH    R0,[R7, #+76]
   \   000000E2   0x.... 0x....      BL       WM_SetFocusOnNextChild
   \   000000E6   0x8270             STRH     R0,[R6, #+18]
    296                }
    297                FRAMEWIN_SetActive(hWin, 1);
   \                     ??_FRAMEWIN_Callback_17: (+1)
   \   000000E8   0x2101             MOVS     R1,#+1
   \   000000EA   0x4628             MOV      R0,R5
   \   000000EC   0x.... 0x....      BL       FRAMEWIN_SetActive
    298                pMsg->Data.v = 0;              /* Focus could be accepted */
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x60A0             STR      R0,[R4, #+8]
   \   000000F4   0xE025             B.N      ??_FRAMEWIN_Callback_3
    299              } else {
    300                FRAMEWIN_SetActive(hWin, 0);
   \                     ??_FRAMEWIN_Callback_15: (+1)
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       FRAMEWIN_SetActive
    301              }
    302              return;
   \   000000FE   0xE020             B.N      ??_FRAMEWIN_Callback_3
    303            case WM_TOUCH_CHILD:
    304              /* If a child of this framewindow has been touched and the frame window was not active,
    305                 the framewindow will receive the focus.
    306               */
    307              if (!(pObj->Flags & FRAMEWIN_SF_ACTIVE)) {
   \                     ??_FRAMEWIN_Callback_6: (+1)
   \   00000100   0x7C30             LDRB     R0,[R6, #+16]
   \   00000102   0x0700             LSLS     R0,R0,#+28
   \   00000104   0xD414             BMI.N    ??_FRAMEWIN_Callback_13
    308                const WM_MESSAGE * pMsgOrg;
    309                const GUI_PID_STATE * pState;
    310                pMsgOrg = (const WM_MESSAGE*)pMsg->Data.p;      /* The original touch message */
    311                pState = (const GUI_PID_STATE*)pMsgOrg->Data.p;
   \   00000106   0x68A0             LDR      R0,[R4, #+8]
   \   00000108   0x6880             LDR      R0,[R0, #+8]
    312                if (pState) {          /* Message may not have a valid pointer (moved out) ! */
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD010             BEQ.N    ??_FRAMEWIN_Callback_13
    313                  if (pState->Pressed) {
   \   0000010E   0x7A00             LDRB     R0,[R0, #+8]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD00D             BEQ.N    ??_FRAMEWIN_Callback_13
    314                    WM_SetFocus(hWin);
   \   00000114   0x4628             MOV      R0,R5
   \   00000116   0x.... 0x....      BL       WM_SetFocus
   \   0000011A   0xE009             B.N      ??_FRAMEWIN_Callback_13
    315                  }
    316                }
    317              }
    318              break;
    319            case WM_NOTIFY_CHILD_HAS_FOCUS:
    320              _OnChildHasFocus(hWin, pObj, pMsg);
   \                     ??_FRAMEWIN_Callback_11: (+1)
   \   0000011C   0x4622             MOV      R2,R4
   \   0000011E   0x4639             MOV      R1,R7
   \   00000120   0x4628             MOV      R0,R5
   \   00000122   0x.... 0x....      BL       _OnChildHasFocus
    321              break;
   \   00000126   0xE003             B.N      ??_FRAMEWIN_Callback_13
    322            case WM_DELETE:
    323              GUI_DEBUG_LOG("FRAMEWIN: _FRAMEWIN_Callback(WM_DELETE)\n");
    324              GUI_ALLOC_FreePtr(&pObj->hText);
   \                     ??_FRAMEWIN_Callback_4: (+1)
   \   00000128   0xF107 0x0050      ADD      R0,R7,#+80
   \   0000012C   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    325              break;
    326            }
    327            /* Let widget handle the standard messages */
    328            if (WIDGET_HandleActive(hWin, pMsg) == 0) {
   \                     ??_FRAMEWIN_Callback_13: (+1)
   \   00000130   0x4621             MOV      R1,R4
   \   00000132   0x4628             MOV      R0,R5
   \   00000134   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD002             BEQ.N    ??_FRAMEWIN_Callback_3
    329              return;
    330            }
    331            WM_DefaultProc(pMsg);
   \   0000013C   0x4620             MOV      R0,R4
   \   0000013E   0x.... 0x....      BL       WM_DefaultProc
    332          }
   \                     ??_FRAMEWIN_Callback_3: (+1)
   \   00000142   0xB009             ADD      SP,SP,#+36
   \   00000144   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    333          
    334          /*********************************************************************
    335          *
    336          *       Client Callback
    337          */

   \                                 In section .text, align 2, keep-with-next
    338          static void FRAMEWIN__cbClient(WM_MESSAGE* pMsg) {
   \                     FRAMEWIN__cbClient: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4605             MOV      R5,R0
    339            WM_HWIN hWin    = pMsg->hWin;
   \   00000008   0xF9B5 0x4004      LDRSH    R4,[R5, #+4]
    340            WM_HWIN hParent = WM_GetParent(pMsg->hWin);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       WM_GetParent
   \   00000012   0x4680             MOV      R8,R0
    341            FRAMEWIN_Obj* pObj = FRAMEWIN_H2P(hParent);
   \   00000014   0x.... 0x....      BL       GUI_ALLOC_h2p
    342            WM_CALLBACK* cb = pObj->cb;
   \   00000018   0xF100 0x073C      ADD      R7,R0,#+60
   \   0000001C   0x68FE             LDR      R6,[R7, #+12]
    343            switch (pMsg->MsgId) {
   \   0000001E   0x6829             LDR      R1,[R5, #+0]
   \   00000020   0x290E             CMP      R1,#+14
   \   00000022   0xD039             BEQ.N    ??FRAMEWIN__cbClient_0
   \   00000024   0x290F             CMP      R1,#+15
   \   00000026   0xD00C             BEQ.N    ??FRAMEWIN__cbClient_1
   \   00000028   0x2914             CMP      R1,#+20
   \   0000002A   0xD044             BEQ.N    ??FRAMEWIN__cbClient_2
   \   0000002C   0x2915             CMP      R1,#+21
   \   0000002E   0xD042             BEQ.N    ??FRAMEWIN__cbClient_2
   \   00000030   0x2917             CMP      R1,#+23
   \   00000032   0xD040             BEQ.N    ??FRAMEWIN__cbClient_2
   \   00000034   0x291F             CMP      R1,#+31
   \   00000036   0xD017             BEQ.N    ??FRAMEWIN__cbClient_3
   \   00000038   0x2920             CMP      R1,#+32
   \   0000003A   0xD028             BEQ.N    ??FRAMEWIN__cbClient_4
   \   0000003C   0x2922             CMP      R1,#+34
   \   0000003E   0xD037             BEQ.N    ??FRAMEWIN__cbClient_5
   \   00000040   0xE03D             B.N      ??FRAMEWIN__cbClient_6
    344            case WM_PAINT:
    345              if (pObj->Props.ClientColor != GUI_INVALID_COLOR) {
   \                     ??FRAMEWIN__cbClient_1: (+1)
   \   00000042   0x6BC0             LDR      R0,[R0, #+60]
   \   00000044   0xF06F 0x4170      MVN      R1,#-268435456
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD003             BEQ.N    ??FRAMEWIN__cbClient_7
    346                LCD_SetBkColor(pObj->Props.ClientColor);
   \   0000004C   0x.... 0x....      BL       LCD_SetBkColor
    347                GUI_Clear();
   \   00000050   0x.... 0x....      BL       GUI_Clear
    348              }
    349              /* Give the user callback  a chance to draw.
    350               * Note that we can not run into the bottom part, as this passes the parents handle
    351               */
    352              if (cb) {
   \                     ??FRAMEWIN__cbClient_7: (+1)
   \   00000054   0x0030             MOVS     R0,R6
   \   00000056   0xD03C             BEQ.N    ??FRAMEWIN__cbClient_8
    353          	    WM_MESSAGE Msg;
    354                Msg      = *pMsg;
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0xCD0E             LDM      R5!,{R1-R3}
   \   0000005C   0xC00E             STM      R0!,{R1-R3}
    355                Msg.hWin = hWin;
   \   0000005E   0xF8AD 0x4004      STRH     R4,[SP, #+4]
    356                (*cb)(&Msg);
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x47B0             BLX      R6
    357              }
    358              return;
   \   00000066   0xE034             B.N      ??FRAMEWIN__cbClient_8
    359            case WM_SET_FOCUS:
    360              if (pMsg->Data.v) {     /* Focus received */
   \                     ??FRAMEWIN__cbClient_3: (+1)
   \   00000068   0x68A8             LDR      R0,[R5, #+8]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD031             BEQ.N    ??FRAMEWIN__cbClient_8
    361                if (pObj->hFocussedChild && (pObj->hFocussedChild != hWin)) {
   \   0000006E   0xF9B7 0x0022      LDRSH    R0,[R7, #+34]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD004             BEQ.N    ??FRAMEWIN__cbClient_9
   \   00000076   0x42A0             CMP      R0,R4
   \   00000078   0xD002             BEQ.N    ??FRAMEWIN__cbClient_9
    362                  WM_SetFocus(pObj->hFocussedChild);
   \   0000007A   0x.... 0x....      BL       WM_SetFocus
   \   0000007E   0xE003             B.N      ??FRAMEWIN__cbClient_10
    363                } else {
    364                  pObj->hFocussedChild = WM_SetFocusOnNextChild(hWin);
   \                     ??FRAMEWIN__cbClient_9: (+1)
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       WM_SetFocusOnNextChild
   \   00000086   0x8478             STRH     R0,[R7, #+34]
    365                }
    366                pMsg->Data.v = 0;     /* Focus change accepted */
   \                     ??FRAMEWIN__cbClient_10: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x60A8             STR      R0,[R5, #+8]
    367              }
    368              return;
   \   0000008C   0xE021             B.N      ??FRAMEWIN__cbClient_8
    369            case WM_GET_ACCEPT_FOCUS:
    370              WIDGET_HandleActive(hParent, pMsg);
   \                     ??FRAMEWIN__cbClient_4: (+1)
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       WIDGET_HandleActive
    371              return;
   \   00000096   0xE01C             B.N      ??FRAMEWIN__cbClient_8
    372            case WM_KEY:
    373              if (((const WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt > 0) {
   \                     ??FRAMEWIN__cbClient_0: (+1)
   \   00000098   0x68A8             LDR      R0,[R5, #+8]
   \   0000009A   0x6841             LDR      R1,[R0, #+4]
   \   0000009C   0x2901             CMP      R1,#+1
   \   0000009E   0xDB0E             BLT.N    ??FRAMEWIN__cbClient_6
    374                int Key = ((const WM_KEY_INFO*)(pMsg->Data.p))->Key;
    375                switch (Key) {
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x2809             CMP      R0,#+9
   \   000000A4   0xD10B             BNE.N    ??FRAMEWIN__cbClient_6
    376                case GUI_KEY_TAB:
    377                  pObj->hFocussedChild = WM_SetFocusOnNextChild(hWin);
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       WM_SetFocusOnNextChild
   \   000000AC   0x8478             STRH     R0,[R7, #+34]
    378                  return;
   \   000000AE   0xE010             B.N      ??FRAMEWIN__cbClient_8
    379                }
    380              }
    381              break;	                       /* Send to parent by not doing anything */
    382            case WM_GET_BKCOLOR:
    383              pMsg->Data.Color = pObj->Props.ClientColor;
   \                     ??FRAMEWIN__cbClient_5: (+1)
   \   000000B0   0x6BC0             LDR      R0,[R0, #+60]
   \   000000B2   0x60A8             STR      R0,[R5, #+8]
    384              return;                       /* Message handled */
   \   000000B4   0xE00D             B.N      ??FRAMEWIN__cbClient_8
    385            case WM_GET_INSIDE_RECT:        /* This should not be passed to parent ... (We do not want parents coordinates)*/
    386            case WM_GET_ID:                 /* This should not be passed to parent ... (Possible recursion problem)*/
    387            case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
    388              WM_DefaultProc(pMsg);
   \                     ??FRAMEWIN__cbClient_2: (+1)
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x.... 0x....      BL       WM_DefaultProc
    389              return;                       /* We are done ! */
   \   000000BC   0xE009             B.N      ??FRAMEWIN__cbClient_8
    390            }
    391            /* Call user callback. Note that the user callback gets the handle of the Framewindow itself, NOT the Client. */
    392            if (cb) {
   \                     ??FRAMEWIN__cbClient_6: (+1)
   \   000000BE   0x0030             MOVS     R0,R6
   \   000000C0   0xD004             BEQ.N    ??FRAMEWIN__cbClient_11
    393              pMsg->hWin = hParent;
   \   000000C2   0xF8A5 0x8004      STRH     R8,[R5, #+4]
    394              (*cb)(pMsg);
   \   000000C6   0x4628             MOV      R0,R5
   \   000000C8   0x47B0             BLX      R6
   \   000000CA   0xE002             B.N      ??FRAMEWIN__cbClient_8
    395            } else {
    396              WM_DefaultProc(pMsg);
   \                     ??FRAMEWIN__cbClient_11: (+1)
   \   000000CC   0x4628             MOV      R0,R5
   \   000000CE   0x.... 0x....      BL       WM_DefaultProc
    397            }
    398          }
   \                     ??FRAMEWIN__cbClient_8: (+1)
   \   000000D2   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
    399          
    400          /*********************************************************************
    401          *
    402          *        Exported module-internal routines:
    403          *
    404          **********************************************************************
    405          */
    406          /*********************************************************************
    407          *
    408          *       FRAMEWIN__CalcTitleHeight
    409          */

   \                                 In section .text, align 2, keep-with-next
    410          int FRAMEWIN__CalcTitleHeight(FRAMEWIN_Obj* pObj) {
   \                     FRAMEWIN__CalcTitleHeight: (+1)
   \   00000000   0x4601             MOV      R1,R0
    411            int r = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    412            if (pObj->Widget.State & FRAMEWIN_SF_TITLEVIS) {
   \   00000004   0xF891 0x2026      LDRB     R2,[R1, #+38]
   \   00000008   0x0692             LSLS     R2,R2,#+26
   \   0000000A   0xD400             BMI.N    ??FRAMEWIN__CalcTitleHeight_0
   \   0000000C   0x4770             BX       LR
    413              r = pObj->Props.TitleHeight;
   \                     ??FRAMEWIN__CalcTitleHeight_0: (+1)
   \   0000000E   0xB580             PUSH     {R7,LR}
   \   00000010   0xF9B1 0x0040      LDRSH    R0,[R1, #+64]
    414              if (r == 0) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD103             BNE.N    ??FRAMEWIN__CalcTitleHeight_1
    415                r = 2 + GUI_GetYSizeOfFont(pObj->Props.pFont);
   \   00000018   0x6A88             LDR      R0,[R1, #+40]
   \   0000001A   0x.... 0x....      BL       GUI_GetYSizeOfFont
   \   0000001E   0x1C80             ADDS     R0,R0,#+2
    416              }
    417            }
    418            return r;
   \                     ??FRAMEWIN__CalcTitleHeight_1: (+1)
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    419          }
    420          
    421          /*********************************************************************
    422          *
    423          *       FRAMEWIN__CalcPositions
    424          */

   \                                 In section .text, align 2, keep-with-next
    425          void FRAMEWIN__CalcPositions(FRAMEWIN_Obj* pObj, POSITIONS* pPos) {
   \                     FRAMEWIN__CalcPositions: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    426            WM_HWIN hChild;
    427            WM_Obj* pChild;
    428            int TitleHeight;
    429            int MenuHeight = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    430            int IBorderSize = 0;
   \   0000000A   0x46BA             MOV      R10,R7
    431            int BorderSize;
    432            int xsize, ysize;
    433            int x0, x1, y0;
    434            BorderSize = pObj->Props.BorderSize;
   \   0000000C   0xF9B4 0x6042      LDRSH    R6,[R4, #+66]
    435            xsize = WM__GetWindowSizeX(&pObj->Widget.Win);
   \   00000010   0x.... 0x....      BL       WM__GetWindowSizeX
   \   00000014   0x4680             MOV      R8,R0
    436            ysize = WM__GetWindowSizeY(&pObj->Widget.Win);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       WM__GetWindowSizeY
   \   0000001C   0x4681             MOV      R9,R0
    437            if (pObj->Widget.State & FRAMEWIN_SF_TITLEVIS) {
   \   0000001E   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \   00000022   0x0680             LSLS     R0,R0,#+26
   \   00000024   0xD501             BPL.N    ??FRAMEWIN__CalcPositions_0
    438              IBorderSize = pObj->Props.IBorderSize;
   \   00000026   0xF9B4 0xA044      LDRSH    R10,[R4, #+68]
    439            }
    440            TitleHeight = FRAMEWIN__CalcTitleHeight(pObj);
   \                     ??FRAMEWIN__CalcPositions_0: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       FRAMEWIN__CalcTitleHeight
   \   00000030   0x4683             MOV      R11,R0
    441            if (pObj->hMenu) {
   \   00000032   0xF9B4 0x004E      LDRSH    R0,[R4, #+78]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??FRAMEWIN__CalcPositions_1
    442              MenuHeight = WM_GetWindowSizeY(pObj->hMenu);
   \   0000003A   0x.... 0x....      BL       WM_GetWindowSizeY
   \   0000003E   0x4607             MOV      R7,R0
    443            }
    444            pPos->TitleHeight = TitleHeight;
   \                     ??FRAMEWIN__CalcPositions_1: (+1)
   \   00000040   0xF8A5 0xB000      STRH     R11,[R5, #+0]
    445            pPos->MenuHeight  = MenuHeight;
   \   00000044   0x806F             STRH     R7,[R5, #+2]
    446            /* Set object properties accordingly */
    447            pPos->rClient.x0  =         BorderSize;
   \   00000046   0x80AE             STRH     R6,[R5, #+4]
    448            pPos->rClient.x1  = xsize - BorderSize - 1;
   \   00000048   0xEBA8 0x0006      SUB      R0,R8,R6
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0x8128             STRH     R0,[R5, #+8]
    449            pPos->rClient.y0  =         BorderSize + IBorderSize + TitleHeight + MenuHeight;
   \   00000050   0xEB0A 0x0106      ADD      R1,R10,R6
   \   00000054   0x4459             ADD      R1,R11,R1
   \   00000056   0x1879             ADDS     R1,R7,R1
   \   00000058   0x80E9             STRH     R1,[R5, #+6]
    450            pPos->rClient.y1  = ysize - BorderSize - 1;
   \   0000005A   0xEBA9 0x0106      SUB      R1,R9,R6
   \   0000005E   0x1E49             SUBS     R1,R1,#+1
   \   00000060   0x8169             STRH     R1,[R5, #+10]
    451            /* Calculate title rect */
    452            pPos->rTitleText.x0 =         BorderSize;
   \   00000062   0x81AE             STRH     R6,[R5, #+12]
    453            pPos->rTitleText.x1 = xsize - BorderSize - 1;
   \   00000064   0x8228             STRH     R0,[R5, #+16]
    454            pPos->rTitleText.y0 =         BorderSize;
   \   00000066   0x81EE             STRH     R6,[R5, #+14]
    455            pPos->rTitleText.y1 =         BorderSize + TitleHeight - 1;
   \   00000068   0xEB0B 0x0006      ADD      R0,R11,R6
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0x8268             STRH     R0,[R5, #+18]
    456            /* Iterate over all children */
    457            for (hChild = pObj->Widget.Win.hFirstChild; hChild; hChild = pChild->hNext) {
   \   00000070   0xF9B4 0x0018      LDRSH    R0,[R4, #+24]
   \   00000074   0xE007             B.N      ??FRAMEWIN__CalcPositions_2
    458              pChild = WM_H2P(hChild);
    459              x0 = pChild->Rect.x0 - pObj->Widget.Win.Rect.x0;
    460              x1 = pChild->Rect.x1 - pObj->Widget.Win.Rect.x0;
    461              y0 = pChild->Rect.y0 - pObj->Widget.Win.Rect.y0;
    462              if (y0 == BorderSize) {
    463                if (pChild->Status & WM_SF_ANCHOR_RIGHT) {
    464                  if (x0 <= pPos->rTitleText.x1) {
    465                    pPos->rTitleText.x1 = x0 - 1;
    466                  }
    467                } else {
    468                  if (x1 >= pPos->rTitleText.x0) {
   \                     ??FRAMEWIN__CalcPositions_3: (+1)
   \   00000076   0xF9B5 0x200C      LDRSH    R2,[R5, #+12]
   \   0000007A   0x4291             CMP      R1,R2
   \   0000007C   0xDB01             BLT.N    ??FRAMEWIN__CalcPositions_4
    469                    pPos->rTitleText.x0 = x1 + 1;
   \   0000007E   0x1C49             ADDS     R1,R1,#+1
   \   00000080   0x81A9             STRH     R1,[R5, #+12]
    470                  }
    471                }
   \                     ??FRAMEWIN__CalcPositions_4: (+1)
   \   00000082   0xF9B0 0x001A      LDRSH    R0,[R0, #+26]
   \                     ??FRAMEWIN__CalcPositions_2: (+1)
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD01A             BEQ.N    ??FRAMEWIN__CalcPositions_5
   \   0000008A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000008E   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   00000092   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   00000096   0x1A52             SUBS     R2,R2,R1
   \   00000098   0xF9B0 0x3004      LDRSH    R3,[R0, #+4]
   \   0000009C   0x1A59             SUBS     R1,R3,R1
   \   0000009E   0xF9B0 0x3002      LDRSH    R3,[R0, #+2]
   \   000000A2   0xF9B4 0x7002      LDRSH    R7,[R4, #+2]
   \   000000A6   0x1BDB             SUBS     R3,R3,R7
   \   000000A8   0x42B3             CMP      R3,R6
   \   000000AA   0xD1EA             BNE.N    ??FRAMEWIN__CalcPositions_4
   \   000000AC   0x7F03             LDRB     R3,[R0, #+28]
   \   000000AE   0x061B             LSLS     R3,R3,#+24
   \   000000B0   0xD5E1             BPL.N    ??FRAMEWIN__CalcPositions_3
   \   000000B2   0xF9B5 0x1010      LDRSH    R1,[R5, #+16]
   \   000000B6   0x4291             CMP      R1,R2
   \   000000B8   0xDBE3             BLT.N    ??FRAMEWIN__CalcPositions_4
   \   000000BA   0x1E51             SUBS     R1,R2,#+1
   \   000000BC   0x8229             STRH     R1,[R5, #+16]
   \   000000BE   0xE7E0             B.N      ??FRAMEWIN__CalcPositions_4
    472              }
    473            }
    474          }
   \                     ??FRAMEWIN__CalcPositions_5: (+1)
   \   000000C0   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    475          
    476          /*********************************************************************
    477          *
    478          *       FRAMEWIN__UpdatePositions
    479          */

   \                                 In section .text, align 2, keep-with-next
    480          void FRAMEWIN__UpdatePositions(FRAMEWIN_Obj* pObj) {
   \                     FRAMEWIN__UpdatePositions: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4604             MOV      R4,R0
    481            /* Move client window accordingly */
    482            if (pObj->hClient || pObj->hMenu) {
   \   00000006   0xF9B4 0x004C      LDRSH    R0,[R4, #+76]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE.N    ??FRAMEWIN__UpdatePositions_0
   \   0000000E   0xF9B4 0x004E      LDRSH    R0,[R4, #+78]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD02A             BEQ.N    ??FRAMEWIN__UpdatePositions_1
    483              POSITIONS Pos;
    484              FRAMEWIN__CalcPositions(pObj, &Pos);
   \                     ??FRAMEWIN__UpdatePositions_0: (+1)
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       FRAMEWIN__CalcPositions
    485              if (pObj->hClient) {
   \   0000001E   0xF9B4 0x004C      LDRSH    R0,[R4, #+76]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD015             BEQ.N    ??FRAMEWIN__UpdatePositions_2
    486                WM_MoveChildTo(pObj->hClient, Pos.rClient.x0, Pos.rClient.y0);
   \   00000026   0xF9BD 0x2006      LDRSH    R2,[SP, #+6]
   \   0000002A   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   0000002E   0x.... 0x....      BL       WM_MoveChildTo
    487                WM_SetSize(pObj->hClient, 
    488                           Pos.rClient.x1 - Pos.rClient.x0 + 1, 
    489                           Pos.rClient.y1 - Pos.rClient.y0 + 1);
   \   00000032   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   00000036   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   0000003A   0x1A40             SUBS     R0,R0,R1
   \   0000003C   0x1C42             ADDS     R2,R0,#+1
   \   0000003E   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   00000042   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   00000046   0x1A40             SUBS     R0,R0,R1
   \   00000048   0x1C41             ADDS     R1,R0,#+1
   \   0000004A   0xF9B4 0x004C      LDRSH    R0,[R4, #+76]
   \   0000004E   0x.... 0x....      BL       WM_SetSize
    490              }
    491              if (pObj->hMenu) {
   \                     ??FRAMEWIN__UpdatePositions_2: (+1)
   \   00000052   0xF9B4 0x004E      LDRSH    R0,[R4, #+78]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD008             BEQ.N    ??FRAMEWIN__UpdatePositions_1
    492                WM_MoveChildTo(pObj->hMenu, Pos.rClient.x0, Pos.rClient.y0 - Pos.MenuHeight);
   \   0000005A   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \   0000005E   0xF9BD 0x2002      LDRSH    R2,[SP, #+2]
   \   00000062   0x1A8A             SUBS     R2,R1,R2
   \   00000064   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   00000068   0x.... 0x....      BL       WM_MoveChildTo
    493              }
    494            }
    495          }
   \                     ??FRAMEWIN__UpdatePositions_1: (+1)
   \   0000006C   0xB006             ADD      SP,SP,#+24
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    496          
    497          /*********************************************************************
    498          *
    499          *        Exported API routines:  Create
    500          *
    501          **********************************************************************
    502          */
    503          /*********************************************************************
    504          *
    505          *       FRAMEWIN_CreateEx
    506          */

   \                                 In section .text, align 2, keep-with-next
    507          FRAMEWIN_Handle FRAMEWIN_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    508                                            int WinFlags, int ExFlags, int Id, const char* pTitle, WM_CALLBACK* cb)
    509          {
   \                     FRAMEWIN_CreateEx: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    510            FRAMEWIN_Handle hObj;
    511            /* Create the window */
    512            WinFlags |= WM_CF_LATE_CLIP;    /* Always use late clipping since widget is optimized for it. */
   \   00000004   0x9C0F             LDR      R4,[SP, #+60]
   \   00000006   0xF444 0x5480      ORR      R4,R4,#0x1000
    513            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, _FRAMEWIN_Callback,
    514                                          sizeof(FRAMEWIN_Obj) - sizeof(WM_Obj));
   \   0000000A   0x2548             MOVS     R5,#+72
   \   0000000C   0x9503             STR      R5,[SP, #+12]
   \   0000000E   0x....             LDR.N    R5,??DataTable2_2
   \   00000010   0x9502             STR      R5,[SP, #+8]
   \   00000012   0x4625             MOV      R5,R4
   \   00000014   0xB2AD             UXTH     R5,R5
   \   00000016   0x9501             STR      R5,[SP, #+4]
   \   00000018   0xF9BD 0x5038      LDRSH    R5,[SP, #+56]
   \   0000001C   0x9500             STR      R5,[SP, #+0]
   \   0000001E   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   00000022   0x0005             MOVS     R5,R0
    515            if (hObj) {
   \   00000024   0xD03E             BEQ.N    ??FRAMEWIN_CreateEx_0
    516              FRAMEWIN_Obj* pObj;
    517              POSITIONS Pos;
    518              GUI_LOCK();
    519              pObj = FRAMEWIN_H2P(hObj);
   \   00000026   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000002A   0x4607             MOV      R7,R0
    520              /* init widget specific variables */
    521              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE | FRAMEWIN_SF_TITLEVIS);
   \   0000002C   0x2230             MOVS     R2,#+48
   \   0000002E   0x9911             LDR      R1,[SP, #+68]
   \   00000030   0x.... 0x....      BL       WIDGET__Init
    522              /* init member variables */
    523              pObj->Props = FRAMEWIN__DefaultProps;
   \   00000034   0xF107 0x0028      ADD      R0,R7,#+40
   \   00000038   0x....             LDR.N    R1,??DataTable2_3
   \   0000003A   0x2220             MOVS     R2,#+32
   \   0000003C   0x.... 0x....      BL       __aeabi_memcpy4
    524              pObj->TextAlign      = GUI_TA_LEFT;
   \   00000040   0xF107 0x0648      ADD      R6,R7,#+72
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x8270             STRH     R0,[R6, #+18]
    525              pObj->cb             = cb;
   \   00000048   0x9813             LDR      R0,[SP, #+76]
   \   0000004A   0x64B8             STR      R0,[R7, #+72]
    526              pObj->Flags          = ExFlags;
   \   0000004C   0x9810             LDR      R0,[SP, #+64]
   \   0000004E   0x82B0             STRH     R0,[R6, #+20]
    527              pObj->hFocussedChild = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x82F0             STRH     R0,[R6, #+22]
    528              pObj->hMenu          = 0;
   \   00000054   0x80F0             STRH     R0,[R6, #+6]
    529              pObj->pFirstHook     = NULL;
   \   00000056   0x61F0             STR      R0,[R6, #+28]
    530              FRAMEWIN__CalcPositions(pObj, &Pos);
   \   00000058   0xA904             ADD      R1,SP,#+16
   \   0000005A   0x4638             MOV      R0,R7
   \   0000005C   0x.... 0x....      BL       FRAMEWIN__CalcPositions
    531              pObj->hClient = WM_CreateWindowAsChild(Pos.rClient.x0,Pos.rClient.y0,
    532                                                     Pos.rClient.x1 - Pos.rClient.x0 +1,
    533                                                     Pos.rClient.y1 - Pos.rClient.y0 +1,
    534                                                     hObj, 
    535                                                     WM_CF_ANCHOR_RIGHT | WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_TOP | WM_CF_ANCHOR_BOTTOM | WM_CF_SHOW | WM_CF_LATE_CLIP, 
    536                                                     FRAMEWIN__cbClient, 0);
   \   00000060   0xF9BD 0x0014      LDRSH    R0,[SP, #+20]
   \   00000064   0xF9BD 0x1016      LDRSH    R1,[SP, #+22]
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x9203             STR      R2,[SP, #+12]
   \   0000006C   0x....             LDR.N    R2,??DataTable2_4
   \   0000006E   0x9202             STR      R2,[SP, #+8]
   \   00000070   0xF241 0x7282      MOVW     R2,#+6018
   \   00000074   0x9201             STR      R2,[SP, #+4]
   \   00000076   0x9500             STR      R5,[SP, #+0]
   \   00000078   0xF9BD 0x201A      LDRSH    R2,[SP, #+26]
   \   0000007C   0x1A52             SUBS     R2,R2,R1
   \   0000007E   0x1C53             ADDS     R3,R2,#+1
   \   00000080   0xF9BD 0x2018      LDRSH    R2,[SP, #+24]
   \   00000084   0x1A12             SUBS     R2,R2,R0
   \   00000086   0x1C52             ADDS     R2,R2,#+1
   \   00000088   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000008C   0x80B0             STRH     R0,[R6, #+4]
    537              /* Normally we disable memory devices for the frame window:
    538               * The frame window does not flicker, and not using memory devices is usually faster.
    539               * You can still use memory by explicitly specifying the flag
    540               */
    541              if ((WinFlags & (WM_CF_MEMDEV | (WM_CF_MEMDEV_ON_REDRAW))) == 0) {
   \   0000008E   0xF242 0x0004      MOVW     R0,#+8196
   \   00000092   0x4204             TST      R4,R0
   \   00000094   0xD102             BNE.N    ??FRAMEWIN_CreateEx_1
    542                WM_DisableMemdev(hObj);
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x.... 0x....      BL       WM_DisableMemdev
    543              }
    544              FRAMEWIN_SetText(hObj, pTitle);
   \                     ??FRAMEWIN_CreateEx_1: (+1)
   \   0000009C   0x9912             LDR      R1,[SP, #+72]
   \   0000009E   0x4628             MOV      R0,R5
   \   000000A0   0x.... 0x....      BL       FRAMEWIN_SetText
    545              GUI_UNLOCK();
    546            }
    547            return hObj;
   \                     ??FRAMEWIN_CreateEx_0: (+1)
   \   000000A4   0x4628             MOV      R0,R5
   \   000000A6   0xB009             ADD      SP,SP,#+36
   \   000000A8   0xBDF0             POP      {R4-R7,PC}       ;; return
    548          }
    549          
    550          /*********************************************************************
    551          *
    552          *        Exported routines:  Set Properties
    553          *
    554          **********************************************************************
    555          */
    556          /*********************************************************************
    557          *
    558          *       FRAMEWIN_SetText
    559          */

   \                                 In section .text, align 2, keep-with-next
    560          void FRAMEWIN_SetText(FRAMEWIN_Handle hObj, const char* s) {
   \                     FRAMEWIN_SetText: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    561            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??FRAMEWIN_SetText_0
    562              FRAMEWIN_Obj* pObj;
    563              GUI_LOCK();
    564              pObj = FRAMEWIN_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    565              if (GUI__SetText(&pObj->hText, s)) {
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x3050             ADDS     R0,R0,#+80
   \   00000012   0x.... 0x....      BL       GUI__SetText
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??FRAMEWIN_SetText_0
    566                FRAMEWIN_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    567              }
    568              GUI_UNLOCK();
    569            }
    570          }
   \                     ??FRAMEWIN_SetText_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    571          
    572          /*********************************************************************
    573          *
    574          *       FRAMEWIN_SetTextAlign
    575          */

   \                                 In section .text, align 2, keep-with-next
    576          void FRAMEWIN_SetTextAlign(FRAMEWIN_Handle hObj, int Align) {
   \                     FRAMEWIN_SetTextAlign: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    577            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??FRAMEWIN_SetTextAlign_0
    578              FRAMEWIN_Obj* pObj;
    579              GUI_LOCK();
    580              pObj = FRAMEWIN_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    581              if (pObj->TextAlign != Align) {
   \   0000000E   0xF9B0 0x105A      LDRSH    R1,[R0, #+90]
   \   00000012   0x42A9             CMP      R1,R5
   \   00000014   0xD006             BEQ.N    ??FRAMEWIN_SetTextAlign_0
    582                pObj->TextAlign = Align;
   \   00000016   0xF8A0 0x505A      STRH     R5,[R0, #+90]
    583                FRAMEWIN_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    584              }
    585              GUI_UNLOCK();
    586            }
    587          }
   \                     ??FRAMEWIN_SetTextAlign_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    588          
    589          /*********************************************************************
    590          *
    591          *       FRAMEWIN_SetMoveable
    592          */

   \                                 In section .text, align 2, keep-with-next
    593          void FRAMEWIN_SetMoveable(FRAMEWIN_Handle hObj, int State) {
   \                     FRAMEWIN_SetMoveable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    594            if (hObj) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00F             BEQ.N    ??FRAMEWIN_SetMoveable_0
    595              FRAMEWIN_Obj* pObj;
    596              GUI_LOCK();
    597              pObj = FRAMEWIN_H2P(hObj);
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_h2p
    598              if (State) {
   \   0000000C   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD004             BEQ.N    ??FRAMEWIN_SetMoveable_1
    599                pObj->Flags |= FRAMEWIN_CF_MOVEABLE;
   \   00000014   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000018   0xF8A0 0x105C      STRH     R1,[R0, #+92]
   \   0000001C   0xBD10             POP      {R4,PC}
    600              } else {
    601                pObj->Flags &= ~FRAMEWIN_CF_MOVEABLE;
   \                     ??FRAMEWIN_SetMoveable_1: (+1)
   \   0000001E   0xF64F 0x72EF      MOVW     R2,#+65519
   \   00000022   0x4011             ANDS     R1,R2,R1
   \   00000024   0xF8A0 0x105C      STRH     R1,[R0, #+92]
    602              }
    603              GUI_UNLOCK();
    604            }
    605          }
   \                     ??FRAMEWIN_SetMoveable_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    606          
    607          /*********************************************************************
    608          *
    609          *       FRAMEWIN_SetActive
    610          */

   \                                 In section .text, align 2, keep-with-next
    611          void FRAMEWIN_SetActive(FRAMEWIN_Handle hObj, int State) {
    612            if (hObj) {
   \                     FRAMEWIN_SetActive: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??FRAMEWIN_SetActive_0
    613              WM_LOCK();
    614              _SetActive(hObj, State);
   \   00000004   0x....             B.N      _SetActive
    615              WM_UNLOCK();
    616            }
    617          }
   \                     ??FRAMEWIN_SetActive_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     FRAMEWIN__MinVisibility

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x00AAAAAA         DC32     0xaaaaaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     _FRAMEWIN_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     FRAMEWIN__DefaultProps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     FRAMEWIN__cbClient
    618          
    619          #else
    620            void WIDGET_FrameWin(void) {} /* avoid empty object files */
    621          #endif /* GUI_WINSUPPORT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   FRAMEWIN_CreateEx
        56   -> FRAMEWIN_SetText
        56   -> FRAMEWIN__CalcPositions
        56   -> GUI_ALLOC_h2p
        56   -> WIDGET__Init
        56   -> WM_CreateWindowAsChild
        56   -> WM_DisableMemdev
        56   -> __aeabi_memcpy4
       0   FRAMEWIN_SetActive
         0   -> _SetActive
       8   FRAMEWIN_SetMoveable
         8   -> GUI_ALLOC_h2p
      16   FRAMEWIN_SetText
        16   -> GUI_ALLOC_h2p
        16   -> GUI__SetText
         0   -> WM_InvalidateWindow
      16   FRAMEWIN_SetTextAlign
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      40   FRAMEWIN__CalcPositions
        40   -> FRAMEWIN__CalcTitleHeight
        40   -> GUI_ALLOC_h2p
        40   -> WM_GetWindowSizeY
        40   -> WM__GetWindowSizeX
        40   -> WM__GetWindowSizeY
       8   FRAMEWIN__CalcTitleHeight
         8   -> GUI_GetYSizeOfFont
      32   FRAMEWIN__UpdatePositions
        32   -> FRAMEWIN__CalcPositions
        32   -> WM_MoveChildTo
        32   -> WM_SetSize
      40   FRAMEWIN__cbClient
        40   -- Indirect call
        40   -> GUI_ALLOC_h2p
        40   -> GUI_Clear
        40   -> LCD_SetBkColor
        40   -> WIDGET_HandleActive
        40   -> WM_DefaultProc
        40   -> WM_GetParent
        40   -> WM_SetFocus
        40   -> WM_SetFocusOnNextChild
      64   _FRAMEWIN_Callback
        64   -- Indirect call
        64   -> FRAMEWIN_SetActive
        64   -> FRAMEWIN__CalcPositions
        64   -> GUI_ALLOC_FreePtr
        64   -> GUI_ALLOC_h2p
        64   -> WIDGET_HandleActive
        64   -> WM_DefaultProc
        64   -> WM_IsWindow
        64   -> WM_SendMessage
        64   -> WM_SetFocus
        64   -> WM_SetFocusOnNextChild
        64   -> _OnChildHasFocus
        64   -> _OnTouch
        64   -> _Paint
        64   -> __aeabi_memcpy
      16   _OnChildHasFocus
        16   -> WM__IsAncestor
        16   -> WM__IsAncestorOrSelf
         0   -> _SetActive
        16   -> _SetActive
      16   _OnTouch
        16   -> WM_BringToTop
         0   -> WM_SetCaptureMove
        16   -> WM_SetFocus
      80   _Paint
        80   -> FRAMEWIN__CalcPositions
        80   -> GUI_ALLOC_h2p
        80   -> GUI_FillRect
        80   -> GUI_SetFont
        80   -> GUI__CalcTextRect
        80   -> LCD_SetBkColor
        80   -> LCD_SetColor
        80   -> WIDGET_EFFECT_3D_DrawUp
        80   -> WIDGET__FillStringInRect
        80   -> WM_GetActiveWindow
        80   -> WM_GetWindowSizeX
        80   -> WM_GetWindowSizeY
        80   -> WM__GetNextIVR
        80   -> WM__InitIVRSearch
      16   _SetActive
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
     170  FRAMEWIN_CreateEx
       8  FRAMEWIN_SetActive
      42  FRAMEWIN_SetMoveable
      38  FRAMEWIN_SetText
      38  FRAMEWIN_SetTextAlign
     196  FRAMEWIN__CalcPositions
      34  FRAMEWIN__CalcTitleHeight
      32  FRAMEWIN__DefaultProps
       2  FRAMEWIN__MinVisibility
     112  FRAMEWIN__UpdatePositions
     214  FRAMEWIN__cbClient
     328  _FRAMEWIN_Callback
      66  _OnChildHasFocus
      68  _OnTouch
     334  _Paint
      74  _SetActive

 
    34 bytes in section .data
 1 742 bytes in section .text
 
 1 742 bytes of CODE memory
    34 bytes of DATA memory

Errors: none
Warnings: none
