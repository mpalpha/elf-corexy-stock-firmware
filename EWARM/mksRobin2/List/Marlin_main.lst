###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        25/Feb/2020  18:23:05
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\..\Middlewares\GUI\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/List\Marlin_main.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\EWARM\mksRobin2/Obj\Marlin_main.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * About Marlin
     25           *
     26           * This firmware is a mashup between Sprinter and grbl.
     27           *  - https://github.com/kliment/Sprinter
     28           *  - https://github.com/simen/grbl/tree
     29           */
     30          
     31          /**
     32           * -----------------
     33           * G-Codes in Marlin
     34           * -----------------
     35           *
     36           * Helpful G-code references:
     37           *  - http://linuxcnc.org/handbook/gcode/g-code.html
     38           *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
     39           *
     40           * Help to document Marlin's G-codes online:
     41           *  - http://reprap.org/wiki/G-code
     42           *  - https://github.com/MarlinFirmware/MarlinDocumentation
     43           *
     44           * -----------------
     45           *
     46           * "G" Codes
     47           *
     48           * G0   -> G1
     49           * G1   - Coordinated Movement X Y Z E
     50           * G2   - CW ARC
     51           * G3   - CCW ARC
     52           * G4   - Dwell S<seconds> or P<milliseconds>
     53           * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
     54           * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
     55           * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
     56           * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
     57           * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
     58           * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
     59           * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
     60           * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
     61           * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
     62           * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
     63           * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
     64           * G28  - Home one or more axes
     65           * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
     66           * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
     67           * G31  - Dock sled (Z_PROBE_SLED only)
     68           * G32  - Undock sled (Z_PROBE_SLED only)
     69           * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
     70           * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
     71           * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
     72           * G90  - Use Absolute Coordinates
     73           * G91  - Use Relative Coordinates
     74           * G92  - Set current position to coordinates given
     75           *
     76           * "M" Codes
     77           *
     78           * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
     79           * M1   -> M0
     80           * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
     81           * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
     82           * M5   - Turn laser/spindle off
     83           * M17  - Enable/Power all stepper motors
     84           * M18  - Disable all stepper motors; same as M84
     85           * M20  - List SD card. (Requires SDSUPPORT)
     86           * M21  - Init SD card. (Requires SDSUPPORT)
     87           * M22  - Release SD card. (Requires SDSUPPORT)
     88           * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
     89           * M24  - Start/resume SD print. (Requires SDSUPPORT)
     90           * M25  - Pause SD print. (Requires SDSUPPORT)
     91           * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
     92           * M27  - Report SD print status. (Requires SDSUPPORT)
     93           * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
     94           * M29  - Stop SD write. (Requires SDSUPPORT)
     95           * M30  - Delete file from SD: "M30 /path/file.gco"
     96           * M31  - Report time since last M109 or SD card start to serial.
     97           * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
     98           *        Use P to run other files as sub-programs: "M32 P !filename#"
     99           *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
    100           * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
    101           * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
    102           * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
    103           * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
    104           * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
    105           * M75  - Start the print job timer.
    106           * M76  - Pause the print job timer.
    107           * M77  - Stop the print job timer.
    108           * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
    109           * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
    110           * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
    111           * M82  - Set E codes absolute (default).
    112           * M83  - Set E codes relative while in Absolute (G90) mode.
    113           * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
    114           *        duration after which steppers should turn off. S0 disables the timeout.
    115           * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
    116           * M92  - Set planner.axis_steps_per_mm for one or more axes.
    117           * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
    118           * M104 - Set extruder target temp.
    119           * M105 - Report current temperatures.
    120           * M106 - Set print fan speed.
    121           * M107 - Print fan off.
    122           * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
    123           * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
    124           *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
    125           *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
    126           * M110 - Set the current line number. (Used by host printing)
    127           * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
    128           * M112 - Emergency stop.
    129           * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
    130           * M114 - Report current position.
    131           * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
    132           * M117 - Display a message on the controller screen. (Requires an LCD)
    133           * M118 - Display a message in the host console.
    134           * M119 - Report endstops status.
    135           * M120 - Enable endstops detection.
    136           * M121 - Disable endstops detection.
    137           * M122 - Debug stepper (Requires HAVE_TMC2130)
    138           * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
    139           * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
    140           * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
    141           * M128 - EtoP Open. (Requires BARICUDA)
    142           * M129 - EtoP Closed. (Requires BARICUDA)
    143           * M140 - Set bed target temp. S<temp>
    144           * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
    145           * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
    146           * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
    147           * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
    148           * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
    149           * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
    150           * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
    151           * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
    152           *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
    153           * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
    154           * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
    155           * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
    156           * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
    157           * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
    158           * M205 - Set advanced settings. Current units apply:
    159                      S<print> T<travel> minimum speeds
    160                      B<minimum segment time>
    161                      X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
    162           * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    163           * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
    164           * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
    165           * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
    166                    Every normal extrude-only move will be classified as retract depending on the direction.
    167           * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
    168           * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
    169           * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
    170           * M221 - Set Flow Percentage: "M221 S<percent>"
    171           * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
    172           * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
    173           * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
    174           * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
    175           * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
    176           * M280 - Set servo position absolute: "M280 P<index> S<angle|¬µs>". (Requires servos)
    177           * M290 - Babystepping (Requires BABYSTEPPING)
    178           * M300 - Play beep sound S<frequency Hz> P<duration ms>
    179           * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
    180           * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
    181           * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
    182           * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
    183           * M350 - Set microstepping mode. (Requires digital microstepping pins.)
    184           * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
    185           * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
    186           * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
    187           * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
    188           * M400 - Finish all moves.
    189           * M401 - Lower Z probe. (Requires a probe)
    190           * M402 - Raise Z probe. (Requires a probe)
    191           * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
    192           * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
    193           * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
    194           * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
    195           * M410 - Quickstop. Abort all planned moves.
    196           * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
    197           * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
    198           * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    199           * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
    200           * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
    201           * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
    202           * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
    203           * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
    204           * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
    205           * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
    206           * M666 - Set delta endstop adjustment. (Requires DELTA)
    207           * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
    208           * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
    209           * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
    210           * M860 - Report the position of position encoder modules.
    211           * M861 - Report the status of position encoder modules.
    212           * M862 - Perform an axis continuity test for position encoder modules.
    213           * M863 - Perform steps-per-mm calibration for position encoder modules.
    214           * M864 - Change position encoder module I2C address.
    215           * M865 - Check position encoder module firmware version.
    216           * M866 - Report or reset position encoder module error count.
    217           * M867 - Enable/disable or toggle error correction for position encoder modules.
    218           * M868 - Report or set position encoder module error correction threshold.
    219           * M869 - Report position encoder module error.
    220           * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
    221           * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    222           * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
    223           * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
    224           * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
    225           * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
    226           * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    227           * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    228           * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
    229           * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
    230           *
    231           * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
    232           * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
    233           * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
    234           * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
    235           * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
    236           *
    237           * ************ Custom codes - This can change to suit future G-code regulations
    238           * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
    239           * M998	- Stop SD print. (Requires SDSUPPORT)
    240           * M999 - Restart after being stopped by error
    241           *
    242           * "T" Codes
    243           *
    244           * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
    245           *
    246           */
    247          
    248          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
   \                     _Z6strchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strrchr(char *, int)
   \                     _Z7strrchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strrchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
   \                     _Z6strstrPcPKc: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

  #define UNUSED(x) ((void)(x))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Inc\mks_cfg.h",609  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\Marlin_export.h")

   \                                 In section .text, align 2
   \   __interwork __softfp void serial_echopair_P(char const *, bool)
   \                     _Z17serial_echopair_PPKcb: (+1)
   \   00000000   0x.... 0x....      B.W      _Z17serial_echopair_PPKci

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial3

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \   00000000   0x4801             LDR.N    R0,??IsRunning_0
   \   00000002   0x7900             LDRB     R0,[R0, #+4]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??IsRunning_0:
   \   00000008   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsStopped()
   \                     _Z9IsStoppedv: (+1)
   \   00000000   0x4802             LDR.N    R0,??IsStopped_0
   \   00000002   0x7900             LDRB     R0,[R0, #+4]
   \   00000004   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??IsStopped_0:
   \   0000000C   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4
   \   __interwork __softfp void refresh_cmd_timeout()
   \                     _Z19refresh_cmd_timeoutv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       HAL_GetTick
   \   00000006   0x4901             LDR.N    R1,??refresh_cmd_timeout_0
   \   00000008   0x65C8             STR      R0,[R1, #+92]
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   \                     ??refresh_cmd_timeout_0:
   \   0000000C   0x........         DC32     axis_homed

   \                                 In section .text, align 4
   \   __interwork __softfp void set_current_from_destination()
   \                     _Z28set_current_from_destinationv: (+1)
   \   00000000   0x4803             LDR.N    R0,??set_current_from_destination_0
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF100 0x0118      ADD      R1,R0,#+24
   \   00000008   0x3008             ADDS     R0,R0,#+8
   \   0000000A   0x.... 0x....      B.W      memcpy
   \   0000000E   0xBF00             Nop      
   \                     ??set_current_from_destination_0:
   \   00000010   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4
   \   __interwork __softfp void set_destination_from_current()
   \                     _Z28set_destination_from_currentv: (+1)
   \   00000000   0x4803             LDR.N    R0,??set_destination_from_current_0
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF100 0x0108      ADD      R1,R0,#+8
   \   00000008   0x3018             ADDS     R0,R0,#+24
   \   0000000A   0x.... 0x....      B.W      memcpy
   \   0000000E   0xBF00             Nop      
   \                     ??set_destination_from_current_0:
   \   00000010   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_IS_KINEMATIC(float const &, float const &)
   \                     _Z34position_is_reachable_IS_KINEMATICRKfS0_: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4857             LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0
   \   0000000A   0xF9B0 0x1058      LDRSH    R1,[R0, #+88]
   \   0000000E   0x078A             LSLS     R2,R1,#+30
   \   00000010   0xD54E             BPL.N    ??position_is_reachable_IS_KINEMATIC_1
   \   00000012   0xF8D0 0x8054      LDR      R8,[R0, #+84]
   \   00000016   0xF04F 0x0902      MOV      R9,#+2
   \   0000001A   0xF04F 0x567E      MOV      R6,#+1065353216
   \   0000001E   0x4637             MOV      R7,R6
   \   00000020   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_2
   \                     ??position_is_reachable_IS_KINEMATIC_3: (+1)
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x4641             MOV      R1,R8
   \   00000026   0x.... 0x....      BL       __aeabi_fmul
   \   0000002A   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_2: (+1)
   \   0000002C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000030   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_4
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x4641             MOV      R1,R8
   \   00000036   0x.... 0x....      BL       __aeabi_fmul
   \   0000003A   0x4607             MOV      R7,R0
   \                     ??position_is_reachable_IS_KINEMATIC_4: (+1)
   \   0000003C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000040   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_3
   \   00000042   0xF8D5 0x8000      LDR      R8,[R5, #+0]
   \   00000046   0xF04F 0x0902      MOV      R9,#+2
   \   0000004A   0x4635             MOV      R5,R6
   \   0000004C   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_5
   \                     ??position_is_reachable_IS_KINEMATIC_6: (+1)
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0x4641             MOV      R1,R8
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_5: (+1)
   \   00000058   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000005C   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_7
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x4641             MOV      R1,R8
   \   00000062   0x.... 0x....      BL       __aeabi_fmul
   \   00000066   0x4605             MOV      R5,R0
   \                     ??position_is_reachable_IS_KINEMATIC_7: (+1)
   \   00000068   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000006C   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_6
   \   0000006E   0x6824             LDR      R4,[R4, #+0]
   \   00000070   0xF04F 0x0802      MOV      R8,#+2
   \   00000074   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_8
   \                     ??position_is_reachable_IS_KINEMATIC_9: (+1)
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x4621             MOV      R1,R4
   \   0000007A   0x.... 0x....      BL       __aeabi_fmul
   \   0000007E   0x4604             MOV      R4,R0
   \                     ??position_is_reachable_IS_KINEMATIC_8: (+1)
   \   00000080   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000084   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_10
   \   00000086   0x4630             MOV      R0,R6
   \   00000088   0x4621             MOV      R1,R4
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4606             MOV      R6,R0
   \                     ??position_is_reachable_IS_KINEMATIC_10: (+1)
   \   00000090   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000094   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_9
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x4631             MOV      R1,R6
   \   0000009A   0x.... 0x....      BL       __aeabi_fadd
   \   0000009E   0x4601             MOV      R1,R0
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000A6   0xD801             BHI.N    ??position_is_reachable_IS_KINEMATIC_11
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE05A             B.N      ??position_is_reachable_IS_KINEMATIC_12
   \                     ??position_is_reachable_IS_KINEMATIC_11: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE058             B.N      ??position_is_reachable_IS_KINEMATIC_12
   \                     ??position_is_reachable_IS_KINEMATIC_1: (+1)
   \   000000B0   0xF44F 0x7040      MOV      R0,#+768
   \   000000B4   0x4201             TST      R1,R0
   \   000000B6   0xD054             BEQ.N    ??position_is_reachable_IS_KINEMATIC_12
   \   000000B8   0xF8DF 0x80B0      LDR.W    R8,??position_is_reachable_IS_KINEMATIC_0+0x4  ;; 0x43960000
   \   000000BC   0xF04F 0x0902      MOV      R9,#+2
   \   000000C0   0xF04F 0x567E      MOV      R6,#+1065353216
   \   000000C4   0x4637             MOV      R7,R6
   \   000000C6   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_13
   \                     ??position_is_reachable_IS_KINEMATIC_14: (+1)
   \   000000C8   0x4640             MOV      R0,R8
   \   000000CA   0x4641             MOV      R1,R8
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_13: (+1)
   \   000000D2   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000D6   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_15
   \   000000D8   0x4638             MOV      R0,R7
   \   000000DA   0x4641             MOV      R1,R8
   \   000000DC   0x.... 0x....      BL       __aeabi_fmul
   \   000000E0   0x4607             MOV      R7,R0
   \                     ??position_is_reachable_IS_KINEMATIC_15: (+1)
   \   000000E2   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000E6   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_14
   \   000000E8   0x6829             LDR      R1,[R5, #+0]
   \   000000EA   0x4821             LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0x8  ;; 0xc2c80000
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x4680             MOV      R8,R0
   \   000000F2   0xF04F 0x0902      MOV      R9,#+2
   \   000000F6   0x4635             MOV      R5,R6
   \   000000F8   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_16
   \                     ??position_is_reachable_IS_KINEMATIC_17: (+1)
   \   000000FA   0x4640             MOV      R0,R8
   \   000000FC   0x4641             MOV      R1,R8
   \   000000FE   0x.... 0x....      BL       __aeabi_fmul
   \   00000102   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_16: (+1)
   \   00000104   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000108   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_18
   \   0000010A   0x4628             MOV      R0,R5
   \   0000010C   0x4641             MOV      R1,R8
   \   0000010E   0x.... 0x....      BL       __aeabi_fmul
   \   00000112   0x4605             MOV      R5,R0
   \                     ??position_is_reachable_IS_KINEMATIC_18: (+1)
   \   00000114   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000118   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_17
   \   0000011A   0x6821             LDR      R1,[R4, #+0]
   \   0000011C   0x4815             LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0xC  ;; 0x42600000
   \   0000011E   0x.... 0x....      BL       __aeabi_fadd
   \   00000122   0x4604             MOV      R4,R0
   \   00000124   0xF04F 0x0802      MOV      R8,#+2
   \   00000128   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_19
   \                     ??position_is_reachable_IS_KINEMATIC_20: (+1)
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x4621             MOV      R1,R4
   \   0000012E   0x.... 0x....      BL       __aeabi_fmul
   \   00000132   0x4604             MOV      R4,R0
   \                     ??position_is_reachable_IS_KINEMATIC_19: (+1)
   \   00000134   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000138   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_21
   \   0000013A   0x4630             MOV      R0,R6
   \   0000013C   0x4621             MOV      R1,R4
   \   0000013E   0x.... 0x....      BL       __aeabi_fmul
   \   00000142   0x4606             MOV      R6,R0
   \                     ??position_is_reachable_IS_KINEMATIC_21: (+1)
   \   00000144   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000148   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_20
   \   0000014A   0x4628             MOV      R0,R5
   \   0000014C   0x4631             MOV      R1,R6
   \   0000014E   0x.... 0x....      BL       __aeabi_fadd
   \   00000152   0x4601             MOV      R1,R0
   \   00000154   0x4638             MOV      R0,R7
   \   00000156   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000015A   0xD801             BHI.N    ??position_is_reachable_IS_KINEMATIC_22
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xE000             B.N      ??position_is_reachable_IS_KINEMATIC_12
   \                     ??position_is_reachable_IS_KINEMATIC_22: (+1)
   \   00000160   0x2000             MOVS     R0,#+0

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin.h",538  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
   \                     ??position_is_reachable_IS_KINEMATIC_12: (+1)
   \   00000162   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \   00000166   0xBF00             Nop      
   \                     ??position_is_reachable_IS_KINEMATIC_0:
   \   00000168   0x........         DC32     mksCfg
   \   0000016C   0x43960000         DC32     0x43960000
   \   00000170   0xC2C80000         DC32     0xc2c80000
   \   00000174   0x42600000         DC32     0x42600000

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
   \                     _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00F             BEQ.N    ??position_is_reachable_by_probe_IS_KINEMATIC_0
   \   0000000E   0x4E09             LDR.N    R6,??position_is_reachable_by_probe_IS_KINEMATIC_1
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6EF1             LDR      R1,[R6, #+108]
   \   00000014   0x.... 0x....      BL       __aeabi_fsub
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x6F31             LDR      R1,[R6, #+112]
   \   0000001E   0x.... 0x....      BL       __aeabi_fsub
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   0000002C   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??position_is_reachable_by_probe_IS_KINEMATIC_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \   00000032   0xBF00             Nop      
   \                     ??position_is_reachable_by_probe_IS_KINEMATIC_1:
   \   00000034   0x........         DC32     mksCfg

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_IS_CARTESIAN(float const &, float const &)
   \                     _Z34position_is_reachable_IS_CARTESIANRKfS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x468B             MOV      R11,R1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       __aeabi_f2d
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0xF8DF 0x8094      LDR.W    R8,??position_is_reachable_IS_CARTESIAN_0  ;; 0xd2f1a9fc
   \   00000014   0xF8DF 0x9094      LDR.W    R9,??position_is_reachable_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
   \   00000018   0xF8DF 0xA094      LDR.W    R10,??position_is_reachable_IS_CARTESIAN_0+0x8
   \   0000001C   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4642             MOV      R2,R8
   \   00000026   0x464B             MOV      R3,R9
   \   00000028   0x.... 0x....      BL       __aeabi_dadd
   \   0000002C   0x4602             MOV      R2,R0
   \   0000002E   0x460B             MOV      R3,R1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000038   0xD832             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   0000003A   0x4646             MOV      R6,R8
   \   0000003C   0x4F1D             LDR.N    R7,??position_is_reachable_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
   \   0000003E   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4632             MOV      R2,R6
   \   00000048   0x463B             MOV      R3,R7
   \   0000004A   0x.... 0x....      BL       __aeabi_dadd
   \   0000004E   0x4622             MOV      R2,R4
   \   00000050   0x462B             MOV      R3,R5
   \   00000052   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000056   0xD823             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   00000058   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x4604             MOV      R4,R0
   \   00000062   0x460D             MOV      R5,R1
   \   00000064   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000068   0x.... 0x....      BL       __aeabi_f2d
   \   0000006C   0x4642             MOV      R2,R8
   \   0000006E   0x464B             MOV      R3,R9
   \   00000070   0x.... 0x....      BL       __aeabi_dadd
   \   00000074   0x4602             MOV      R2,R0
   \   00000076   0x460B             MOV      R3,R1
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x4629             MOV      R1,R5
   \   0000007C   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000080   0xD80E             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   00000082   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000086   0x.... 0x....      BL       __aeabi_f2d
   \   0000008A   0x4632             MOV      R2,R6
   \   0000008C   0x463B             MOV      R3,R7
   \   0000008E   0x.... 0x....      BL       __aeabi_dadd
   \   00000092   0x4622             MOV      R2,R4
   \   00000094   0x462B             MOV      R3,R5
   \   00000096   0x.... 0x....      BL       __aeabi_cdrcmple
   \   0000009A   0xD801             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE000             B.N      ??position_is_reachable_IS_CARTESIAN_2
   \                     ??position_is_reachable_IS_CARTESIAN_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??position_is_reachable_IS_CARTESIAN_2: (+1)
   \   000000A2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   000000A6   0xBF00             Nop      
   \                     ??position_is_reachable_IS_CARTESIAN_0:
   \   000000A8   0xD2F1A9FC         DC32     0xd2f1a9fc
   \   000000AC   0xBF50624D         DC32     0xbf50624d
   \   000000B0   0x........         DC32     mksCfg
   \   000000B4   0x3F50624D         DC32     0x3f50624d

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
   \                     _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x468B             MOV      R11,R1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       __aeabi_f2d
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0xF8DF 0x8094      LDR.W    R8,??position_is_reachable_by_probe_IS_CARTESIAN_0  ;; 0xd2f1a9fc
   \   00000014   0xF8DF 0x9094      LDR.W    R9,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
   \   00000018   0xF8DF 0xA094      LDR.W    R10,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x8
   \   0000001C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4642             MOV      R2,R8
   \   00000026   0x464B             MOV      R3,R9
   \   00000028   0x.... 0x....      BL       __aeabi_dadd
   \   0000002C   0x4602             MOV      R2,R0
   \   0000002E   0x460B             MOV      R3,R1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000038   0xD832             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   0000003A   0x4646             MOV      R6,R8
   \   0000003C   0x4F1D             LDR.N    R7,??position_is_reachable_by_probe_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
   \   0000003E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4632             MOV      R2,R6
   \   00000048   0x463B             MOV      R3,R7
   \   0000004A   0x.... 0x....      BL       __aeabi_dadd
   \   0000004E   0x4622             MOV      R2,R4
   \   00000050   0x462B             MOV      R3,R5
   \   00000052   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000056   0xD823             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   00000058   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x4604             MOV      R4,R0
   \   00000062   0x460D             MOV      R5,R1
   \   00000064   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \   00000068   0x.... 0x....      BL       __aeabi_f2d
   \   0000006C   0x4642             MOV      R2,R8
   \   0000006E   0x464B             MOV      R3,R9
   \   00000070   0x.... 0x....      BL       __aeabi_dadd
   \   00000074   0x4602             MOV      R2,R0
   \   00000076   0x460B             MOV      R3,R1
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x4629             MOV      R1,R5
   \   0000007C   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000080   0xD80E             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   00000082   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000086   0x.... 0x....      BL       __aeabi_f2d
   \   0000008A   0x4632             MOV      R2,R6
   \   0000008C   0x463B             MOV      R3,R7
   \   0000008E   0x.... 0x....      BL       __aeabi_dadd
   \   00000092   0x4622             MOV      R2,R4
   \   00000094   0x462B             MOV      R3,R5
   \   00000096   0x.... 0x....      BL       __aeabi_cdrcmple
   \   0000009A   0xD801             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE000             B.N      ??position_is_reachable_by_probe_IS_CARTESIAN_2
   \                     ??position_is_reachable_by_probe_IS_CARTESIAN_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??position_is_reachable_by_probe_IS_CARTESIAN_2: (+1)
   \   000000A2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   000000A6   0xBF00             Nop      
   \                     ??position_is_reachable_by_probe_IS_CARTESIAN_0:
   \   000000A8   0xD2F1A9FC         DC32     0xd2f1a9fc
   \   000000AC   0xBF50624D         DC32     0xbf50624d
   \   000000B0   0x........         DC32     mksTmp
   \   000000B4   0x3F50624D         DC32     0x3f50624d
    249          
    250          #include "ultralcd.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_update()
   \                     _Z10lcd_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_init()
   \                     _Z8lcd_initv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool lcd_hasstatus()
   \                     _Z13lcd_hasstatusv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setstatus(char const *, bool)
   \                     _Z13lcd_setstatusPKcb: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setstatusPGM(char const *, int8_t)
   \                     _Z16lcd_setstatusPGMPKca: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setalertstatusPGM(char const *)
   \                     _Z21lcd_setalertstatusPGMPKc: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_reset_alert_level()
   \                     _Z21lcd_reset_alert_levelv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_refresh()
   \                     _Z11lcd_refreshv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    251          #include "planner.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::refresh_e_factor(uint8_t)
   \                     _ZN7Planner16refresh_e_factorEh: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x480C             LDR.N    R0,??refresh_e_factor_0
   \   00000006   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2d
   \   0000000E   0x4A0B             LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
   \   00000010   0x4B0B             LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
   \   00000012   0x.... 0x....      BL       __aeabi_dmul
   \   00000016   0x4604             MOV      R4,R0
   \   00000018   0x460D             MOV      R5,R1
   \   0000001A   0x480A             LDR.N    R0,??refresh_e_factor_0+0xC
   \   0000001C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x.... 0x....      BL       __aeabi_d2f
   \   00000030   0x4905             LDR.N    R1,??refresh_e_factor_0+0x10
   \   00000032   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??refresh_e_factor_0:
   \   00000038   0x........         DC32     _ZN7Planner15flow_percentageE
   \   0000003C   0x47AE147B         DC32     0x47ae147b
   \   00000040   0x3F847AE1         DC32     0x3f847ae1
   \   00000044   0x........         DC32     _ZN7Planner21volumetric_multiplierE
   \   00000048   0x........         DC32     _ZN7Planner8e_factorE

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_filament_size(uint8_t, float const &)
   \                     _ZN7Planner17set_filament_sizeEhRKf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4A09             LDR.N    R2,??set_filament_size_0
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x4619             MOV      R1,R3
   \   0000000E   0xE008             B.N      ??set_filament_size_1
   \                     ??set_filament_size_2: (+1)
   \   00000010   0xF852 0x0023      LDR      R0,[R2, R3, LSL #+2]
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000018   0xD102             BNE.N    ??set_filament_size_3
   \   0000001A   0x4804             LDR.N    R0,??set_filament_size_0+0x4  ;; 0x40400000
   \   0000001C   0xF842 0x0023      STR      R0,[R2, R3, LSL #+2]
   \                     ??set_filament_size_3: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \                     ??set_filament_size_1: (+1)
   \   00000022   0x2B02             CMP      R3,#+2
   \   00000024   0xD3F4             BCC.N    ??set_filament_size_2
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
   \                     ??set_filament_size_0:
   \   00000028   0x........         DC32     _ZN7Planner13filament_sizeE
   \   0000002C   0x40400000         DC32     0x40400000

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::force_fade_recalc()
   \                     _ZN7Planner17force_fade_recalcEv: (+1)
   \   00000000   0x4801             LDR.N    R0,??force_fade_recalc_0  ;; 0xc479fff0
   \   00000002   0x4902             LDR.N    R1,??force_fade_recalc_0+0x4
   \   00000004   0x6008             STR      R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??force_fade_recalc_0:
   \   00000008   0xC479FFF0         DC32     0xc479fff0
   \   0000000C   0x........         DC32     _ZN7Planner11last_fade_zE

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_z_fade_height(float const &)
   \                     _ZN7Planner17set_z_fade_heightERKf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4A10             LDR.N    R2,??set_z_fade_height_6
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000000C   0xD201             BCS.N    ??set_z_fade_height_7
   \   0000000E   0x6010             STR      R0,[R2, #+0]
   \   00000010   0xE001             B.N      ??set_z_fade_height_8
   \                     ??set_z_fade_height_7: (+1)
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x6010             STR      R0,[R2, #+0]
   \                     ??set_z_fade_height_8: (+1)
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x490C             LDR.N    R1,??set_z_fade_height_6+0x4  ;; 0xb58637bd
   \   0000001C   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000020   0xD807             BHI.N    ??set_z_fade_height_9
   \   00000022   0x490B             LDR.N    R1,??set_z_fade_height_6+0x8  ;; 0x358637be
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000028   0xD203             BCS.N    ??set_z_fade_height_9
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4909             LDR.N    R1,??set_z_fade_height_6+0xC
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE006             B.N      ??set_z_fade_height_10
   \                     ??set_z_fade_height_9: (+1)
   \   00000032   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000036   0x4611             MOV      R1,R2
   \   00000038   0x.... 0x....      BL       __aeabi_fdiv
   \   0000003C   0x4905             LDR.N    R1,??set_z_fade_height_6+0xC
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \                     ??set_z_fade_height_10: (+1)
   \   00000040   0xE8BD 0x4001      POP      {R0,LR}
   \   00000044   0x.... 0x....      B.W      _ZN7Planner17force_fade_recalcEv
   \                     ??set_z_fade_height_6:
   \   00000048   0x........         DC32     _ZN7Planner13z_fade_heightE
   \   0000004C   0xB58637BD         DC32     0xb58637bd
   \   00000050   0x358637BE         DC32     0x358637be
   \   00000054   0x........         DC32     _ZN7Planner21inverse_z_fade_heightE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::leveling_active_at_z(float const &)
   \                     _ZN7Planner20leveling_active_at_zERKf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x4807             LDR.N    R0,??leveling_active_at_z_0
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000010   0xD004             BEQ.N    ??leveling_active_at_z_1
   \   00000012   0x6810             LDR      R0,[R2, #+0]
   \   00000014   0x4619             MOV      R1,R3
   \   00000016   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000001A   0xD201             BCS.N    ??leveling_active_at_z_2
   \                     ??leveling_active_at_z_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD02             POP      {R1,PC}
   \                     ??leveling_active_at_z_2: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD02             POP      {R1,PC}          ;; return
   \                     ??leveling_active_at_z_0:
   \   00000024   0x........         DC32     _ZN7Planner13z_fade_heightE

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::apply_leveling(float (&)[3])
   \                     _ZN7Planner14apply_levelingERA3_f: (+1)
   \   00000000   0xF100 0x0208      ADD      R2,R0,#+8
   \   00000004   0x1D01             ADDS     R1,R0,#+4
   \   00000006   0x.... 0x....      B.W      _ZN7Planner14apply_levelingERfS0_S0_

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
   \                     _ZN7Planner11buffer_lineEfffRKfS1_h: (+1)
   \   00000000   0xB537             PUSH     {R0-R2,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0x9D08             LDR      R5,[SP, #+32]
   \   00000008   0x480C             LDR.N    R0,??buffer_line_0
   \   0000000A   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   0000000E   0x222E             MOVS     R2,#+46
   \   00000010   0x4211             TST      R1,R2
   \   00000012   0xD008             BEQ.N    ??buffer_line_1
   \   00000014   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD104             BNE.N    ??buffer_line_1
   \   0000001C   0xAA04             ADD      R2,SP,#+16
   \   0000001E   0xA903             ADD      R1,SP,#+12
   \   00000020   0xA802             ADD      R0,SP,#+8
   \   00000022   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \                     ??buffer_line_1: (+1)
   \   00000026   0x9809             LDR      R0,[SP, #+36]
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x9500             STR      R5,[SP, #+0]
   \   0000002C   0x4623             MOV      R3,R4
   \   0000002E   0xAA04             ADD      R2,SP,#+16
   \   00000030   0xA903             ADD      R1,SP,#+12
   \   00000032   0xA802             ADD      R0,SP,#+8
   \   00000034   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \   00000038   0xB005             ADD      SP,SP,#+20
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??buffer_line_0:
   \   0000003C   0x........         DC32     mksCfg

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
   \                     _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x6861             LDR      R1,[R4, #+4]
   \   00000012   0x6041             STR      R1,[R0, #+4]
   \   00000014   0x68A1             LDR      R1,[R4, #+8]
   \   00000016   0x6081             STR      R1,[R0, #+8]
   \   00000018   0x4F24             LDR.N    R7,??buffer_line_kinematic_0
   \   0000001A   0xF897 0x0040      LDRB     R0,[R7, #+64]
   \   0000001E   0x212E             MOVS     R1,#+46
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD002             BEQ.N    ??buffer_line_kinematic_1
   \   00000024   0xA802             ADD      R0,SP,#+8
   \   00000026   0x.... 0x....      BL       _ZN7Planner14apply_levelingERA3_f
   \                     ??buffer_line_kinematic_1: (+1)
   \   0000002A   0xF107 0x0040      ADD      R0,R7,#+64
   \   0000002E   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \   00000032   0xF240 0x3102      MOVW     R1,#+770
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD02C             BEQ.N    ??buffer_line_kinematic_2
   \   0000003A   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003E   0xA802             ADD      R0,SP,#+8
   \   00000040   0xD102             BNE.N    ??buffer_line_kinematic_3
   \   00000042   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   00000046   0xE001             B.N      ??buffer_line_kinematic_4
   \                     ??buffer_line_kinematic_3: (+1)
   \   00000048   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   \                     ??buffer_line_kinematic_4: (+1)
   \   0000004C   0x4918             LDR.N    R1,??buffer_line_kinematic_0+0x4
   \   0000004E   0xF891 0x0148      LDRB     R0,[R1, #+328]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD111             BNE.N    ??buffer_line_kinematic_5
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0xF8D1 0x1298      LDR      R1,[R1, #+664]
   \   0000005C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000060   0xD20B             BCS.N    ??buffer_line_kinematic_5
   \   00000062   0x68E1             LDR      R1,[R4, #+12]
   \   00000064   0x4813             LDR.N    R0,??buffer_line_kinematic_0+0x8
   \   00000066   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0x.... 0x....      BL       __aeabi_fmul
   \   00000070   0x.... 0x....      BL       lroundf
   \   00000074   0x4910             LDR.N    R1,??buffer_line_kinematic_0+0xC
   \   00000076   0x60C8             STR      R0,[R1, #+12]
   \   00000078   0xE015             B.N      ??buffer_line_kinematic_6
   \                     ??buffer_line_kinematic_5: (+1)
   \   0000007A   0x4810             LDR.N    R0,??buffer_line_kinematic_0+0x10
   \   0000007C   0x9601             STR      R6,[SP, #+4]
   \   0000007E   0x9500             STR      R5,[SP, #+0]
   \   00000080   0xF104 0x030C      ADD      R3,R4,#+12
   \   00000084   0xF100 0x0258      ADD      R2,R0,#+88
   \   00000088   0xF100 0x0154      ADD      R1,R0,#+84
   \   0000008C   0x3050             ADDS     R0,R0,#+80
   \   0000008E   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \   00000092   0xE008             B.N      ??buffer_line_kinematic_6
   \                     ??buffer_line_kinematic_2: (+1)
   \   00000094   0x9601             STR      R6,[SP, #+4]
   \   00000096   0x9500             STR      R5,[SP, #+0]
   \   00000098   0xF104 0x030C      ADD      R3,R4,#+12
   \   0000009C   0xAA04             ADD      R2,SP,#+16
   \   0000009E   0xA903             ADD      R1,SP,#+12
   \   000000A0   0xA802             ADD      R0,SP,#+8
   \   000000A2   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \                     ??buffer_line_kinematic_6: (+1)
   \   000000A6   0xB005             ADD      SP,SP,#+20
   \   000000A8   0xBDF0             POP      {R4-R7,PC}       ;; return
   \   000000AA   0xBF00             Nop      
   \                     ??buffer_line_kinematic_0:
   \   000000AC   0x........         DC32     mksCfg
   \   000000B0   0x........         DC32     gCfgItems
   \   000000B4   0x........         DC32     _ZN7Planner17axis_steps_per_mmE
   \   000000B8   0x........         DC32     _ZN7Planner8positionE
   \   000000BC   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_position_mm(float, float, float, float const &)
   \                     _ZN7Planner15set_position_mmEfffRKf: (+1)
   \   00000000   0xB517             PUSH     {R0-R2,R4,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0x480B             LDR.N    R0,??set_position_mm_0
   \   00000008   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   0000000C   0x222E             MOVS     R2,#+46
   \   0000000E   0x4211             TST      R1,R2
   \   00000010   0xD008             BEQ.N    ??set_position_mm_1
   \   00000012   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD104             BNE.N    ??set_position_mm_1
   \   0000001A   0xAA03             ADD      R2,SP,#+12
   \   0000001C   0xA902             ADD      R1,SP,#+8
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \                     ??set_position_mm_1: (+1)
   \   00000024   0x4623             MOV      R3,R4
   \   00000026   0xAA03             ADD      R2,SP,#+12
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   \   00000030   0xBD1F             POP      {R0-R4,PC}       ;; return
   \   00000032   0xBF00             Nop      
   \                     ??set_position_mm_0:
   \   00000034   0x........         DC32     mksCfg

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::set_e_position_mm(float const &)
   \                     _ZN7Planner17set_e_position_mmERKf: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x.... 0x....      B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??blocks_queued_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4904             LDR.N    R1,??blocks_queued_0+0x4
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD001             BEQ.N    ??blocks_queued_1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??blocks_queued_0:
   \   00000014   0x........         DC32     _ZN7Planner17block_buffer_headE
   \   00000018   0x........         DC32     _ZN7Planner17block_buffer_tailE

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless
    252          #include "stepper.h"

   \                                 In section .text, align 2
   \   __interwork __softfp float Stepper::get_axis_position_degrees(AxisEnum)
   \                     _ZN7Stepper25get_axis_position_degreesE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN7Stepper20get_axis_position_mmE8AxisEnum

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::set_homing_flag_z(bool)
   \                     _ZN7Stepper17set_homing_flag_zEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??set_homing_flag_z_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??set_homing_flag_z_0:
   \   00000008   0x........         DC32     _ZN7Stepper17performing_homingE

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::set_z_lock(bool)
   \                     _ZN7Stepper10set_z_lockEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??set_z_lock_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??set_z_lock_0:
   \   00000008   0x........         DC32     _ZN7Stepper14locked_z_motorE

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::set_z2_lock(bool)
   \                     _ZN7Stepper11set_z2_lockEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??set_z2_lock_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??set_z2_lock_0:
   \   00000008   0x........         DC32     _ZN7Stepper15locked_z2_motorE
    253          #include "endstops.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_globally(bool)
   \                     _ZN8Endstops15enable_globallyEb: (+1)
   \   00000000   0x4902             LDR.N    R1,??enable_globally_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4902             LDR.N    R1,??enable_globally_0+0x4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??enable_globally_0:
   \   0000000C   0x........         DC32     _ZN8Endstops7enabledE
   \   00000010   0x........         DC32     _ZN8Endstops16enabled_globallyE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable(bool)
   \                     _ZN8Endstops6enableEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??enable_0:
   \   00000008   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::not_homing()
   \                     _ZN8Endstops10not_homingEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??not_homing_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4902             LDR.N    R1,??not_homing_0+0x4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??not_homing_0:
   \   0000000C   0x........         DC32     _ZN8Endstops16enabled_globallyE
   \   00000010   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::hit_on_purpose()
   \                     _ZN8Endstops14hit_on_purposeEv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??hit_on_purpose_0
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??hit_on_purpose_0:
   \   00000008   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_z_probe(bool)
   \                     _ZN8Endstops14enable_z_probeEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_z_probe_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??enable_z_probe_0:
   \   00000008   0x........         DC32     _ZN8Endstops15z_probe_enabledE
    254          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
   \                     _ZN11Temperature16tooColdToExtrudeEh: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x480B             LDR.N    R0,??tooColdToExtrude_0
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??tooColdToExtrude_1
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??tooColdToExtrude_1: (+1)
   \   00000010   0x4809             LDR.N    R0,??tooColdToExtrude_0+0x4
   \   00000012   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       __aeabi_i2f
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x460D             MOV      R5,R1
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002A   0xD201             BCS.N    ??tooColdToExtrude_2
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??tooColdToExtrude_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??tooColdToExtrude_0:
   \   00000034   0x........         DC32     _ZN11Temperature18allow_cold_extrudeE
   \   00000038   0x........         DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \   00000000   0x4901             LDR.N    R1,??degHotend_0
   \   00000002   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??degHotend_0:
   \   00000008   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degBed()
   \                     _ZN11Temperature6degBedEv: (+1)
   \   00000000   0x4801             LDR.N    R0,??degBed_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??degBed_0:
   \   00000008   0x........         DC32     _ZN11Temperature23current_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4902             LDR.N    R1,??degTargetHotend_0
   \   00000002   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000006   0x.... 0x....      B.W      __aeabi_i2f
   \   0000000A   0xBF00             Nop      
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetBed()
   \                     _ZN11Temperature12degTargetBedEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??degTargetBed_0
   \   00000002   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000006   0x.... 0x....      B.W      __aeabi_i2f
   \   0000000A   0xBF00             Nop      
   \                     ??degTargetBed_0:
   \   0000000C   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000004   0x.... 0x....      BL       __aeabi_f2iz
   \   00000008   0x4903             LDR.N    R1,??setTargetHotend_0
   \   0000000A   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \   00000018   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4809             LDR.N    R0,??setTargetBed_0
   \   00000006   0xF9B0 0x5032      LDRSH    R5,[R0, #+50]
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       __aeabi_i2f
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000018   0xD202             BCS.N    ??setTargetBed_1
   \   0000001A   0x.... 0x....      BL       __aeabi_f2iz
   \   0000001E   0x4605             MOV      R5,R0
   \                     ??setTargetBed_1: (+1)
   \   00000020   0x4803             LDR.N    R0,??setTargetBed_0+0x4
   \   00000022   0x8005             STRH     R5,[R0, #+0]

          target_temperature_bed =
                                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000024   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000028   0x.... 0x....      B.W      _ZN11Temperature18start_watching_bedEv
   \                     ??setTargetBed_0:
   \   0000002C   0x........         DC32     mksCfg
   \   00000030   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
   \                     _ZN11Temperature15isCoolingHotendEh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4807             LDR.N    R0,??isCoolingHotend_0
   \   00000006   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2f
   \   0000000E   0x4906             LDR.N    R1,??isCoolingHotend_0+0x4
   \   00000010   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000018   0xD201             BCS.N    ??isCoolingHotend_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD10             POP      {R4,PC}
   \                     ??isCoolingHotend_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   \   00000022   0xBF00             Nop      
   \                     ??isCoolingHotend_0:
   \   00000024   0x........         DC32     _ZN11Temperature18target_temperatureE
   \   00000028   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::isCoolingBed()
   \                     _ZN11Temperature12isCoolingBedEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4807             LDR.N    R0,??isCoolingBed_0
   \   00000004   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       __aeabi_i2f
   \   0000000C   0x4905             LDR.N    R1,??isCoolingBed_0+0x4
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000014   0xD201             BCS.N    ??isCoolingBed_1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD02             POP      {R1,PC}
   \                     ??isCoolingBed_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??isCoolingBed_0:
   \   00000020   0x........         DC32     _ZN11Temperature22target_temperature_bedE
   \   00000024   0x........         DC32     _ZN11Temperature23current_temperature_bedE

   \                                 In section .text, align 2
   \   __interwork __softfp void Temperature::updatePID()
   \                     _ZN11Temperature9updatePIDEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::set_auto_report_interval(uint8_t)
   \                     _ZN11Temperature24set_auto_report_intervalEh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x2C3D             CMP      R4,#+61
   \   00000006   0xDB00             BLT.N    ??set_auto_report_interval_0
   \   00000008   0x243C             MOVS     R4,#+60
   \                     ??set_auto_report_interval_0: (+1)
   \   0000000A   0x4805             LDR.N    R0,??set_auto_report_interval_1
   \   0000000C   0x7004             STRB     R4,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0xF44F 0x717A      MOV      R1,#+1000
   \   00000016   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000001A   0x4902             LDR.N    R1,??set_auto_report_interval_1+0x4
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??set_auto_report_interval_1:
   \   00000020   0x........         DC32     _ZN11Temperature25auto_report_temp_intervalE
   \   00000024   0x........         DC32     _ZN11Temperature19next_temp_report_msE
    255          #include "cardreader.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 524 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\SdFatConfig.h")

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::isFileOpen()
   \                     _ZN10CardReader10isFileOpenEv: (+1)
   \   00000000   0xF8D0 0x0200      LDR      R0,[R0, #+512]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??isFileOpen_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??isFileOpen_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::eof()
   \                     _ZN10CardReader3eofEv: (+1)
   \   00000000   0xF8D0 0x1460      LDR      R1,[R0, #+1120]
   \   00000004   0xF8D0 0x045C      LDR      R0,[R0, #+1116]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t CardReader::get()
   \                     _ZN10CardReader3getEv: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xAB01             ADD      R3,SP,#+4
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      BL       f_read
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??get_0
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000001A   0xE005             B.N      ??get_1
   \                     ??get_0: (+1)
   \   0000001C   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000020   0x9901             LDR      R1,[SP, #+4]
   \   00000022   0x1808             ADDS     R0,R1,R0
   \   00000024   0xF8C4 0x0460      STR      R0,[R4, #+1120]
   \                     ??get_1: (+1)
   \   00000028   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void CardReader::setIndex(long)
   \                     _ZN10CardReader8setIndexEl: (+1)
   \   00000000   0xF8C0 0x1460      STR      R1,[R0, #+1120]
   \   00000004   0x.... 0x....      B.W      f_lseek
    256          #include "configuration_store.h"
    257          #include "language.h"
    258          //#include "pins_arduino.h"
    259          #include "math.h"
    260          #include "nozzle.h"
    261          #include "duration_t.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp duration_t::duration_t(uint32_t const &)
   \                     _ZN10duration_tC1ERKj: (+1)
   \   00000000   0x6809             LDR      R1,[R1, #+0]
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t duration_t::year() const
   \                     _ZNK10duration_t4yearEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \   00000006   0xF240 0x116D      MOVW     R1,#+365
   \   0000000A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t duration_t::day() const
   \                     _ZNK10duration_t3dayEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \   00000006   0x2118             MOVS     R1,#+24
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xB280             UXTH     R0,R0
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::hour() const
   \                     _ZNK10duration_t4hourEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \   00000006   0x213C             MOVS     R1,#+60
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::minute() const
   \                     _ZNK10duration_t6minuteEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \   00000006   0x213C             MOVS     R1,#+60
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::second() const
   \                     _ZNK10duration_t6secondEv: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void duration_t::toString(char *) const
   \                     _ZNK10duration_t8toStringEPc: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x.... 0x....      BL       _ZNK10duration_t4yearEv
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0x4638             MOV      R0,R7
   \   00000012   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \   00000016   0xF240 0x116D      MOVW     R1,#+365
   \   0000001A   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000001E   0xF240 0x126D      MOVW     R2,#+365
   \   00000022   0xFB02 0x0611      MLS      R6,R2,R1,R0
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \   0000002C   0x2118             MOVS     R1,#+24
   \   0000002E   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000032   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000036   0xEBA0 0x08C2      SUB      R8,R0,R2, LSL #+3
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \   00000040   0xF04F 0x093C      MOV      R9,#+60
   \   00000044   0x4649             MOV      R1,R9
   \   00000046   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000004A   0xFB09 0x0A11      MLS      R10,R9,R1,R0
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \   00000054   0x4649             MOV      R1,R9
   \   00000056   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000005A   0xFB09 0x0211      MLS      R2,R9,R1,R0
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD00B             BEQ.N    ??toString_0
   \   00000062   0x9202             STR      R2,[SP, #+8]
   \   00000064   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \   00000068   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000006C   0x4633             MOV      R3,R6
   \   0000006E   0x462A             MOV      R2,R5
   \   00000070   0x4918             LDR.N    R1,??toString_1
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       sprintf
   \   00000078   0xE029             B.N      ??toString_2
   \                     ??toString_0: (+1)
   \   0000007A   0x2E00             CMP      R6,#+0
   \   0000007C   0xD009             BEQ.N    ??toString_3
   \   0000007E   0x9201             STR      R2,[SP, #+4]
   \   00000080   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000084   0x4643             MOV      R3,R8
   \   00000086   0x4632             MOV      R2,R6
   \   00000088   0x4913             LDR.N    R1,??toString_1+0x4
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       sprintf
   \   00000090   0xE01D             B.N      ??toString_2
   \                     ??toString_3: (+1)
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD007             BEQ.N    ??toString_4
   \   00000098   0x9200             STR      R2,[SP, #+0]
   \   0000009A   0x4653             MOV      R3,R10
   \   0000009C   0x4642             MOV      R2,R8
   \   0000009E   0x490F             LDR.N    R1,??toString_1+0x8
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       sprintf
   \   000000A6   0xE012             B.N      ??toString_2
   \                     ??toString_4: (+1)
   \   000000A8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000AC   0xD008             BEQ.N    ??toString_5
   \   000000AE   0x4613             MOV      R3,R2
   \   000000B0   0x4652             MOV      R2,R10
   \   000000B2   0x490B             LDR.N    R1,??toString_1+0xC
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xB004             ADD      SP,SP,#+16
   \   000000B8   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000BC   0x.... 0x....      B.W      sprintf
   \                     ??toString_5: (+1)
   \   000000C0   0x4908             LDR.N    R1,??toString_1+0x10
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0xB004             ADD      SP,SP,#+16
   \   000000C6   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000CA   0x.... 0x....      B.W      sprintf
   \                     ??toString_2: (+1)
   \   000000CE   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \   000000D2   0xBF00             Nop      
   \                     ??toString_1:
   \   000000D4   0x........         DC32     _ZZNK10duration_t8toStringEPcEs
   \   000000D8   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_0
   \   000000DC   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_1
   \   000000E0   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_2
   \   000000E4   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_3
    262          //#include "types.h"
    263          #include "tim.h"
    264          #include "gcode.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::seen(char)
   \                     _ZN11GCodeParser4seenEc: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x291A             CMP      R1,#+26
   \   00000008   0xD301             BCC.N    ??seen_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
   \                     ??seen_0: (+1)
   \   0000000E   0x10C8             ASRS     R0,R1,#+3
   \   00000010   0x4A0A             LDR.N    R2,??seen_1
   \   00000012   0x5C80             LDRB     R0,[R0, R2]
   \   00000014   0xF001 0x0207      AND      R2,R1,#0x7
   \   00000018   0x40D0             LSRS     R0,R0,R2
   \   0000001A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001E   0xD00B             BEQ.N    ??seen_2
   \   00000020   0x4A07             LDR.N    R2,??seen_1+0x4
   \   00000022   0x5C89             LDRB     R1,[R1, R2]
   \   00000024   0x4A07             LDR.N    R2,??seen_1+0x8
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD004             BEQ.N    ??seen_3
   \   0000002A   0x4B07             LDR.N    R3,??seen_1+0xC
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0x18C9             ADDS     R1,R1,R3
   \   00000030   0x6011             STR      R1,[R2, #+0]
   \   00000032   0x4770             BX       LR
   \                     ??seen_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6011             STR      R1,[R2, #+0]
   \                     ??seen_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??seen_1:
   \   0000003C   0x........         DC32     _ZN11GCodeParser8codebitsE
   \   00000040   0x........         DC32     _ZN11GCodeParser5paramE
   \   00000044   0x........         DC32     _ZN11GCodeParser9value_ptrE
   \   00000048   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::has_value()
   \                     _ZN11GCodeParser9has_valueEv: (+1)
   \   00000000   0x4803             LDR.N    R0,??has_value_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??has_value_1
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??has_value_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   \                     ??has_value_0:
   \   00000010   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::seenval(char)
   \                     _ZN11GCodeParser7seenvalEc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD003             BEQ.N    ??seenval_0
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      _ZN11GCodeParser9has_valueEv
   \                     ??seenval_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp float GCodeParser::value_float()
   \                     _ZN11GCodeParser11value_floatEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4A12             LDR.N    R2,??value_float_0
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01D             BEQ.N    ??value_float_1
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xE000             B.N      ??value_float_2
   \                     ??value_float_3: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??value_float_2: (+1)
   \   00000010   0xF994 0x5000      LDRSB    R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD001             BEQ.N    ??value_float_4
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xD106             BNE.N    ??value_float_5
   \                     ??value_float_4: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      BL       strtod
   \   00000022   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??value_float_5: (+1)
   \   0000002A   0x2D45             CMP      R5,#+69
   \   0000002C   0xD001             BEQ.N    ??value_float_6
   \   0000002E   0x2D65             CMP      R5,#+101
   \   00000030   0xD1ED             BNE.N    ??value_float_3
   \                     ??value_float_6: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x6810             LDR      R0,[R2, #+0]
   \   0000003A   0x.... 0x....      BL       strtod
   \   0000003E   0x.... 0x....      BL       __aeabi_d2f
   \   00000042   0x7025             STRB     R5,[R4, #+0]
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??value_float_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \   0000004A   0xBF00             Nop      
   \                     ??value_float_0:
   \   0000004C   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp int32_t GCodeParser::value_long()
   \                     _ZN11GCodeParser10value_longEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??value_long_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??value_long_1
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      B.W      strtol
   \                     ??value_long_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??value_long_0:
   \   00000014   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp uint32_t GCodeParser::value_ulong()
   \                     _ZN11GCodeParser11value_ulongEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??value_ulong_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??value_ulong_1
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      B.W      strtoul
   \                     ??value_ulong_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??value_ulong_0:
   \   00000014   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 2
   \   __interwork __softfp millis_t GCodeParser::value_millis()
   \                     _ZN11GCodeParser12value_millisEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_ulongEv

   \                                 In section .text, align 4

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   __interwork __softfp millis_t GCodeParser::value_millis_from_seconds()
   \                     _ZN11GCodeParser25value_millis_from_secondsEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000006   0x4903             LDR.N    R1,??value_millis_from_seconds_0  ;; 0x447a0000
   \   00000008   0x.... 0x....      BL       __aeabi_fmul
   \   0000000C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000010   0x.... 0x....      B.W      __aeabi_f2uiz
   \                     ??value_millis_from_seconds_0:
   \   00000014   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t GCodeParser::value_int()
   \                     _ZN11GCodeParser9value_intEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0xB200             SXTH     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t GCodeParser::value_ushort()
   \                     _ZN11GCodeParser12value_ushortEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t GCodeParser::value_byte()
   \                     _ZN11GCodeParser10value_byteEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD501             BPL.N    ??value_byte_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE007             B.N      ??value_byte_1
   \                     ??value_byte_0: (+1)
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xDD01             BLE.N    ??value_byte_2
   \   00000016   0x20FF             MOVS     R0,#+255
   \   00000018   0xE001             B.N      ??value_byte_1
   \                     ??value_byte_2: (+1)
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \                     ??value_byte_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::value_bool()
   \                     _ZN11GCodeParser10value_boolEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser9has_valueEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??value_bool_0
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x43C0             MVNS     R0,R0
   \   00000014   0x0FC0             LSRS     R0,R0,#+31
   \   00000016   0xBD02             POP      {R1,PC}
   \                     ??value_bool_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_linear_units()
   \                     _ZN11GCodeParser18value_linear_unitsEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_axis_units(AxisEnum)
   \                     _ZN11GCodeParser16value_axis_unitsE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_per_axis_unit(AxisEnum)
   \                     _ZN11GCodeParser19value_per_axis_unitE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_celsius()
   \                     _ZN11GCodeParser13value_celsiusEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_feedrate()
   \                     _ZN11GCodeParser14value_feedrateEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser18value_linear_unitsEv

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::boolval(char)
   \                     _ZN11GCodeParser7boolvalEc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??boolval_0
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x.... 0x....      B.W      _ZN11GCodeParser10value_boolEv
   \                     ??boolval_0: (+1)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      _ZN11GCodeParser4seenEc

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t GCodeParser::byteval(char, uint8_t)
   \                     _ZN11GCodeParser7bytevalEch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??byteval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??byteval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t GCodeParser::intval(char, int16_t)
   \                     _ZN11GCodeParser6intvalEcs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??intval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??intval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t GCodeParser::ushortval(char, uint16_t)
   \                     _ZN11GCodeParser9ushortvalEct: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??ushortval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser12value_ushortEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??ushortval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::linearval(char, float)
   \                     _ZN11GCodeParser9linearvalEcf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??linearval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??linearval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::celsiusval(char, float)
   \                     _ZN11GCodeParser10celsiusvalEcf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??celsiusval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??celsiusval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    265          
    266          #include "least_squares_fit.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void incremental_LSF_reset(linear_fit_data *)
   \                     _Z21incremental_LSF_resetP15linear_fit_data: (+1)
   \   00000000   0x223C             MOVS     R2,#+60
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      B.W      memset

   \                                 In section .text, align 2
   \   __interwork __softfp void incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
   \                     _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x6829             LDR      R1,[R5, #+0]
   \   0000000E   0x6838             LDR      R0,[R7, #+0]
   \   00000010   0x.... 0x....      BL       __aeabi_fadd
   \   00000014   0x6028             STR      R0,[R5, #+0]
   \   00000016   0x6869             LDR      R1,[R5, #+4]
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_fadd
   \   0000001E   0x6068             STR      R0,[R5, #+4]
   \   00000020   0x68A9             LDR      R1,[R5, #+8]
   \   00000022   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000026   0x.... 0x....      BL       __aeabi_fadd
   \   0000002A   0x60A8             STR      R0,[R5, #+8]
   \   0000002C   0xF8D7 0xB000      LDR      R11,[R7, #+0]
   \   00000030   0xF04F 0x0902      MOV      R9,#+2
   \   00000034   0xF04F 0x547E      MOV      R4,#+1065353216
   \   00000038   0x46A2             MOV      R10,R4
   \   0000003A   0xE004             B.N      ??incremental_LSF_0
   \                     ??incremental_LSF_1: (+1)
   \   0000003C   0x4658             MOV      R0,R11
   \   0000003E   0x4659             MOV      R1,R11
   \   00000040   0x.... 0x....      BL       __aeabi_fmul
   \   00000044   0x4683             MOV      R11,R0
   \                     ??incremental_LSF_0: (+1)
   \   00000046   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000004A   0xD504             BPL.N    ??incremental_LSF_2
   \   0000004C   0x4650             MOV      R0,R10
   \   0000004E   0x4659             MOV      R1,R11
   \   00000050   0x.... 0x....      BL       __aeabi_fmul
   \   00000054   0x4682             MOV      R10,R0
   \                     ??incremental_LSF_2: (+1)
   \   00000056   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000005A   0xD1EF             BNE.N    ??incremental_LSF_1
   \   0000005C   0x68E8             LDR      R0,[R5, #+12]
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x.... 0x....      BL       __aeabi_fadd
   \   00000064   0x60E8             STR      R0,[R5, #+12]
   \   00000066   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \   0000006A   0xF04F 0x0902      MOV      R9,#+2
   \   0000006E   0x46A2             MOV      R10,R4
   \   00000070   0xE004             B.N      ??incremental_LSF_3
   \                     ??incremental_LSF_4: (+1)
   \   00000072   0x4658             MOV      R0,R11
   \   00000074   0x4659             MOV      R1,R11
   \   00000076   0x.... 0x....      BL       __aeabi_fmul
   \   0000007A   0x4683             MOV      R11,R0
   \                     ??incremental_LSF_3: (+1)
   \   0000007C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000080   0xD504             BPL.N    ??incremental_LSF_5
   \   00000082   0x4650             MOV      R0,R10
   \   00000084   0x4659             MOV      R1,R11
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x4682             MOV      R10,R0
   \                     ??incremental_LSF_5: (+1)
   \   0000008C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000090   0xD1EF             BNE.N    ??incremental_LSF_4
   \   00000092   0x6928             LDR      R0,[R5, #+16]
   \   00000094   0x4651             MOV      R1,R10
   \   00000096   0x.... 0x....      BL       __aeabi_fadd
   \   0000009A   0x6128             STR      R0,[R5, #+16]
   \   0000009C   0xF8D8 0xA000      LDR      R10,[R8, #+0]
   \   000000A0   0xF04F 0x0902      MOV      R9,#+2
   \   000000A4   0xE004             B.N      ??incremental_LSF_6
   \                     ??incremental_LSF_7: (+1)
   \   000000A6   0x4650             MOV      R0,R10
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fmul
   \   000000AE   0x4682             MOV      R10,R0
   \                     ??incremental_LSF_6: (+1)
   \   000000B0   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000B4   0xD504             BPL.N    ??incremental_LSF_8
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x4651             MOV      R1,R10
   \   000000BA   0x.... 0x....      BL       __aeabi_fmul
   \   000000BE   0x4604             MOV      R4,R0
   \                     ??incremental_LSF_8: (+1)
   \   000000C0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000C4   0xD1EF             BNE.N    ??incremental_LSF_7
   \   000000C6   0x6968             LDR      R0,[R5, #+20]
   \   000000C8   0x4621             MOV      R1,R4
   \   000000CA   0x.... 0x....      BL       __aeabi_fadd
   \   000000CE   0x6168             STR      R0,[R5, #+20]
   \   000000D0   0x6839             LDR      R1,[R7, #+0]
   \   000000D2   0x6830             LDR      R0,[R6, #+0]
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x69A9             LDR      R1,[R5, #+24]
   \   000000DA   0x.... 0x....      BL       __aeabi_fadd
   \   000000DE   0x61A8             STR      R0,[R5, #+24]
   \   000000E0   0x6839             LDR      R1,[R7, #+0]
   \   000000E2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x69E9             LDR      R1,[R5, #+28]
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x61E8             STR      R0,[R5, #+28]
   \   000000F2   0x6831             LDR      R1,[R6, #+0]
   \   000000F4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000F8   0x.... 0x....      BL       __aeabi_fmul
   \   000000FC   0x6A29             LDR      R1,[R5, #+32]
   \   000000FE   0x.... 0x....      BL       __aeabi_fadd
   \   00000102   0x6228             STR      R0,[R5, #+32]
   \   00000104   0x6A68             LDR      R0,[R5, #+36]
   \   00000106   0x6839             LDR      R1,[R7, #+0]
   \   00000108   0xF021 0x4100      BIC      R1,R1,#0x80000000
   \   0000010C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000110   0xD202             BCS.N    ??incremental_LSF_9
   \   00000112   0x6838             LDR      R0,[R7, #+0]
   \   00000114   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \                     ??incremental_LSF_9: (+1)
   \   00000118   0x6268             STR      R0,[R5, #+36]
   \   0000011A   0x6AA8             LDR      R0,[R5, #+40]
   \   0000011C   0x6831             LDR      R1,[R6, #+0]
   \   0000011E   0xF021 0x4100      BIC      R1,R1,#0x80000000
   \   00000122   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000126   0xD202             BCS.N    ??incremental_LSF_10
   \   00000128   0x6830             LDR      R0,[R6, #+0]
   \   0000012A   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \                     ??incremental_LSF_10: (+1)
   \   0000012E   0x62A8             STR      R0,[R5, #+40]
   \   00000130   0x6BA9             LDR      R1,[R5, #+56]
   \   00000132   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000136   0x.... 0x....      BL       __aeabi_fadd
   \   0000013A   0x63A8             STR      R0,[R5, #+56]
   \   0000013C   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    267          #include "ubl.h"

          	cx = (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
          	   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",182  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					cx = (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",184  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					cy = (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",195  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					cy = (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",197  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					px= (x - (MESH_MIN_X_IS_KINEMATIC) + (MESH_X_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  					  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",208  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					px= (x - (MESH_MIN_X_IS_Cartesian) + (MESH_X_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",210  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_KINEMATIC) + (MESH_Y_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",219  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_Cartesian) + (MESH_Y_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\ubl.h",221  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_xpos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_xposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4F4A             LDR.N    R7,??mesh_index_to_xpos_0
   \   00000008   0xF897 0x6060      LDRB     R6,[R7, #+96]
   \   0000000C   0xF107 0x0008      ADD      R0,R7,#+8
   \   00000010   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   00000014   0xF240 0x3202      MOVW     R2,#+770
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD02B             BEQ.N    ??mesh_index_to_xpos_1
   \   0000001C   0x42B5             CMP      R5,R6
   \   0000001E   0xD203             BCS.N    ??mesh_index_to_xpos_2
   \   00000020   0x4844             LDR.N    R0,??mesh_index_to_xpos_0+0x4
   \   00000022   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000026   0xE081             B.N      ??mesh_index_to_xpos_3
   \                     ??mesh_index_to_xpos_2: (+1)
   \   00000028   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000030   0x4682             MOV      R10,R0
   \   00000032   0x4C41             LDR.N    R4,??mesh_index_to_xpos_0+0x8
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fadd
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       __aeabi_ui2f
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x4651             MOV      R1,R10
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x.... 0x....      BL       __aeabi_fsub
   \   00000054   0x4604             MOV      R4,R0
   \   00000056   0x1E70             SUBS     R0,R6,#+1
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000070   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_xpos_1: (+1)
   \   00000074   0x42B5             CMP      R5,R6
   \   00000076   0xD203             BCS.N    ??mesh_index_to_xpos_4
   \   00000078   0x482E             LDR.N    R0,??mesh_index_to_xpos_0+0x4
   \   0000007A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000007E   0xE055             B.N      ??mesh_index_to_xpos_3
   \                     ??mesh_index_to_xpos_4: (+1)
   \   00000080   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   00000084   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   00000094   0x.... 0x....      BL       __aeabi_ui2f
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_fadd
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0xF107 0x0060      ADD      R0,R7,#+96
   \   000000AE   0xF8D0 0xB00C      LDR      R11,[R0, #+12]
   \   000000B2   0x68B8             LDR      R0,[R7, #+8]
   \   000000B4   0x4659             MOV      R1,R11
   \   000000B6   0x.... 0x....      BL       __aeabi_fadd
   \   000000BA   0x4607             MOV      R7,R0
   \   000000BC   0x4621             MOV      R1,R4
   \   000000BE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C2   0xD201             BCS.N    ??mesh_index_to_xpos_5
   \   000000C4   0x9400             STR      R4,[SP, #+0]
   \   000000C6   0xE000             B.N      ??mesh_index_to_xpos_6
   \                     ??mesh_index_to_xpos_5: (+1)
   \   000000C8   0x9700             STR      R7,[SP, #+0]
   \                     ??mesh_index_to_xpos_6: (+1)
   \   000000CA   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CE   0x4649             MOV      R1,R9
   \   000000D0   0x.... 0x....      BL       __aeabi_fmul
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x.... 0x....      BL       __aeabi_fsub
   \   000000DA   0x4681             MOV      R9,R0
   \   000000DC   0x4640             MOV      R0,R8
   \   000000DE   0x4659             MOV      R1,R11
   \   000000E0   0x.... 0x....      BL       __aeabi_fadd
   \   000000E4   0x4601             MOV      R1,R0
   \   000000E6   0x4648             MOV      R0,R9
   \   000000E8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EC   0xD300             BCC.N    ??mesh_index_to_xpos_7
   \   000000EE   0x4689             MOV      R9,R1
   \                     ??mesh_index_to_xpos_7: (+1)
   \   000000F0   0x4638             MOV      R0,R7
   \   000000F2   0x4621             MOV      R1,R4
   \   000000F4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F8   0xD300             BCC.N    ??mesh_index_to_xpos_8
   \   000000FA   0x463C             MOV      R4,R7
   \                     ??mesh_index_to_xpos_8: (+1)
   \   000000FC   0x4628             MOV      R0,R5
   \   000000FE   0x.... 0x....      BL       __aeabi_ui2f
   \   00000102   0x4605             MOV      R5,R0
   \   00000104   0x4648             MOV      R0,R9
   \   00000106   0x4621             MOV      R1,R4
   \   00000108   0x.... 0x....      BL       __aeabi_fsub
   \   0000010C   0x4604             MOV      R4,R0
   \   0000010E   0x1E70             SUBS     R0,R6,#+1
   \   00000110   0x.... 0x....      BL       __aeabi_i2f
   \   00000114   0x4601             MOV      R1,R0
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       __aeabi_fdiv
   \   0000011C   0x4629             MOV      R1,R5
   \   0000011E   0x.... 0x....      BL       __aeabi_fmul
   \   00000122   0x9900             LDR      R1,[SP, #+0]
   \   00000124   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000128   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_xpos_3: (+1)
   \   0000012C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??mesh_index_to_xpos_0:
   \   00000130   0x........         DC32     mksCfg
   \   00000134   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_xposE
   \   00000138   0x........         DC32     mksTmp

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_ypos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_yposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4F49             LDR.N    R7,??mesh_index_to_ypos_0
   \   00000008   0xF897 0x6061      LDRB     R6,[R7, #+97]
   \   0000000C   0xF107 0x000C      ADD      R0,R7,#+12
   \   00000010   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   00000014   0xF240 0x3202      MOVW     R2,#+770
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD02B             BEQ.N    ??mesh_index_to_ypos_1
   \   0000001C   0x42B5             CMP      R5,R6
   \   0000001E   0xD203             BCS.N    ??mesh_index_to_ypos_2
   \   00000020   0x4843             LDR.N    R0,??mesh_index_to_ypos_0+0x4
   \   00000022   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000026   0xE07F             B.N      ??mesh_index_to_ypos_3
   \                     ??mesh_index_to_ypos_2: (+1)
   \   00000028   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000030   0x4682             MOV      R10,R0
   \   00000032   0x4C40             LDR.N    R4,??mesh_index_to_ypos_0+0x8
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fadd
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       __aeabi_ui2f
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x68E0             LDR      R0,[R4, #+12]
   \   00000048   0x4651             MOV      R1,R10
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x.... 0x....      BL       __aeabi_fsub
   \   00000054   0x4604             MOV      R4,R0
   \   00000056   0x1E70             SUBS     R0,R6,#+1
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000070   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_ypos_1: (+1)
   \   00000074   0x42B5             CMP      R5,R6
   \   00000076   0xD203             BCS.N    ??mesh_index_to_ypos_4
   \   00000078   0x482D             LDR.N    R0,??mesh_index_to_ypos_0+0x4
   \   0000007A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000007E   0xE053             B.N      ??mesh_index_to_ypos_3
   \                     ??mesh_index_to_ypos_4: (+1)
   \   00000080   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   00000084   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   00000094   0x.... 0x....      BL       __aeabi_ui2f
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_fadd
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0xF8D7 0xB070      LDR      R11,[R7, #+112]
   \   000000AE   0x68F8             LDR      R0,[R7, #+12]
   \   000000B0   0x4659             MOV      R1,R11
   \   000000B2   0x.... 0x....      BL       __aeabi_fadd
   \   000000B6   0x4607             MOV      R7,R0
   \   000000B8   0x4621             MOV      R1,R4
   \   000000BA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BE   0xD201             BCS.N    ??mesh_index_to_ypos_5
   \   000000C0   0x9400             STR      R4,[SP, #+0]
   \   000000C2   0xE000             B.N      ??mesh_index_to_ypos_6
   \                     ??mesh_index_to_ypos_5: (+1)
   \   000000C4   0x9700             STR      R7,[SP, #+0]
   \                     ??mesh_index_to_ypos_6: (+1)
   \   000000C6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CA   0x4649             MOV      R1,R9
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4651             MOV      R1,R10
   \   000000D2   0x.... 0x....      BL       __aeabi_fsub
   \   000000D6   0x4681             MOV      R9,R0
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x4659             MOV      R1,R11
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x4601             MOV      R1,R0
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E8   0xD300             BCC.N    ??mesh_index_to_ypos_7
   \   000000EA   0x4689             MOV      R9,R1
   \                     ??mesh_index_to_ypos_7: (+1)
   \   000000EC   0x4638             MOV      R0,R7
   \   000000EE   0x4621             MOV      R1,R4
   \   000000F0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F4   0xD300             BCC.N    ??mesh_index_to_ypos_8
   \   000000F6   0x463C             MOV      R4,R7
   \                     ??mesh_index_to_ypos_8: (+1)
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       __aeabi_ui2f
   \   000000FE   0x4605             MOV      R5,R0
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x4621             MOV      R1,R4
   \   00000104   0x.... 0x....      BL       __aeabi_fsub
   \   00000108   0x4604             MOV      R4,R0
   \   0000010A   0x1E70             SUBS     R0,R6,#+1
   \   0000010C   0x.... 0x....      BL       __aeabi_i2f
   \   00000110   0x4601             MOV      R1,R0
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       __aeabi_fdiv
   \   00000118   0x4629             MOV      R1,R5
   \   0000011A   0x.... 0x....      BL       __aeabi_fmul
   \   0000011E   0x9900             LDR      R1,[SP, #+0]
   \   00000120   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000124   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_ypos_3: (+1)
   \   00000128   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??mesh_index_to_ypos_0:
   \   0000012C   0x........         DC32     mksCfg
   \   00000130   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_yposE
   \   00000134   0x........         DC32     mksTmp

   \                                 In section .text, align 4
   \   __interwork __softfp bool unified_bed_leveling::mesh_is_valid()
   \                     _ZN20unified_bed_leveling13mesh_is_validEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4A1D             LDR.N    R2,??mesh_is_valid_0
   \   00000004   0x6853             LDR      R3,[R2, #+4]
   \   00000006   0x6814             LDR      R4,[R2, #+0]
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000010   0xD129             BNE.N    ??mesh_is_valid_1
   \   00000012   0x4618             MOV      R0,R3
   \   00000014   0x6891             LDR      R1,[R2, #+8]
   \   00000016   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000001A   0xD124             BNE.N    ??mesh_is_valid_1
   \   0000001C   0x6B53             LDR      R3,[R2, #+52]
   \   0000001E   0x6B15             LDR      R5,[R2, #+48]
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x4619             MOV      R1,R3
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000028   0xD11D             BNE.N    ??mesh_is_valid_1
   \   0000002A   0x4618             MOV      R0,R3
   \   0000002C   0x6B91             LDR      R1,[R2, #+56]
   \   0000002E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000032   0xD118             BNE.N    ??mesh_is_valid_1
   \   00000034   0x6E53             LDR      R3,[R2, #+100]
   \   00000036   0x6E16             LDR      R6,[R2, #+96]
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x4619             MOV      R1,R3
   \   0000003C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000040   0xD111             BNE.N    ??mesh_is_valid_1
   \   00000042   0x4618             MOV      R0,R3
   \   00000044   0x6E91             LDR      R1,[R2, #+104]
   \   00000046   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000004A   0xD10C             BNE.N    ??mesh_is_valid_1
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000054   0xD107             BNE.N    ??mesh_is_valid_1
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000005C   0xD103             BNE.N    ??mesh_is_valid_1
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000064   0xD006             BEQ.N    ??mesh_is_valid_2
   \                     ??mesh_is_valid_1: (+1)
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       __iar_FDtest
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xD001             BEQ.N    ??mesh_is_valid_2
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xBD70             POP      {R4-R6,PC}
   \                     ??mesh_is_valid_2: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??mesh_is_valid_0:
   \   00000078   0x........         DC32     _ZN20unified_bed_leveling8z_valuesE

   \                                 In section .text, align 2
   \   __interwork __softfp void gcode_G29_UBL()
   \                     _Z13gcode_G29_UBLv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN20unified_bed_leveling13gcode_G29_UBLEv
    268          
    269          #include "mks_cfg.h"
    270          #include "mks_reprint.h"
    271          
    272          #if 1
    273          
    274          #include "wifi_module.h"
    275          
    276          #include "gui.h"
    277          
    278          #include "draw_ready_print.h"
    279          
    280          #include "draw_ui.h"

    #define FILAMENT_CHANGE_TEXT_EN				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_en.h",135  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_EN"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_CN            "Ëß£Èô§ÁªëÂÆö?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_s_cn.h",218  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_CN"
          (declared at line 213)

    #define FILAMENT_CHANGE_TEXT_T_CN				"ÂæÖÊâìÂç∞Ê©üÊö´ÂÅúÂêé,\nË´ãÊåâ<ÈÄ≤Êñô>Êàñ<ÈÄÄÊñô>"
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_t_cn.h",127  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_T_CN"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_RU				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_ru.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_RU"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_RU            "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_ru.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_RU"
          (declared at line 225)

    #define FILAMENT_CHANGE_TEXT_FR				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_fr.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_FR"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_FR        "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_fr.h",233  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_FR"
          (declared at line 229)

    #define FILAMENT_CHANGE_TEXT_SP				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_sp.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_SP"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_IT				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_it.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_IT"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_IT                "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Language_it.h",229  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_IT"
          (declared at line 224)

  #define FILAMENT_CHANGE_TEXT_JP				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Multi_language.h",652  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_JP"
          (declared at line 645)

  #define FILAMENT_CHANGE_TEXT_GN				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\Multi_language\Multi_language.h",860  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_GN"
          (declared at line 854)

  #define Simple_Dec"ºı…Ÿ"
                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\draw_ui.h",492  Warning[Pe1649]: 
          white space is required between the macro name "Simple_Dec" and its
          replacement text

  #define Simple_Speed "ÀŸ∂»"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\draw_ui.h",547  Warning[Pe047]: 
          incompatible redefinition of macro "Simple_Speed" (declared at line
          544)

  #define Complex_Speed "ÀŸ∂»"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\User\ui\draw_ui.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "Complex_Speed" (declared at line
          545)
    281          #include "wifi_module.h"
    282          #include "draw_printing.h"
    283          #include "draw_pause_ui.h"
    284          #include "sdio_sdcard.h"

  #define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",152  Warning[Pe047]: 
          incompatible redefinition of macro "IS_NVIC_PRIORITY_GROUP"
          (declared at line 277 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SYSTICK_CLK_SOURCE" (declared
          at line 296 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define SDIO_INIT_CLK_DIV        0x166//0xB2 		//SDIO≥ı ºªØ∆µ¬ £¨◊Ó¥Û400Kh  
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",36  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_INIT_CLK_DIV" (declared at
          line 479 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SDIO_TRANSFER_CLK_DIV    0x07//0x02//0x01		//SDIO¥´ ‰∆µ¬ £¨◊Ó¥Û24Mhz(4bit)°£∏√÷µÃ´–°ø…ƒ‹ª·µº÷¬∂¡–¥Œƒº˛≥ˆ¥Ì 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",37  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_TRANSFER_CLK_DIV" (declared
          at line 482 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SD_CMD_GO_IDLE_STATE                       ((u8)0)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IDLE_STATE" (declared
          at line 304 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_OP_COND                        ((u8)1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",171  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_OP_COND" (declared
          at line 305 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ALL_SEND_CID                        ((u8)2)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",172  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ALL_SEND_CID" (declared
          at line 306 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_REL_ADDR                        ((u8)3) /*!< SDIO_SEND_REL_ADDR for SD Card */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_REL_ADDR" (declared
          at line 307 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_DSR                             ((u8)4)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_DSR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_SEN_OP_COND                    ((u8)5)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",175  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_SEN_OP_COND"
          (declared at line 309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SWITCH                           ((u8)6)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",176  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SWITCH" (declared at
          line 311 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEL_DESEL_CARD                      ((u8)7)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",177  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEL_DESEL_CARD" (declared
          at line 312 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SEND_EXT_CSD                     ((u8)8)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",178  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SEND_EXT_CSD"
          (declared at line 313 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CSD                            ((u8)9)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",179  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CSD" (declared at
          line 315 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CID                            ((u8)10)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",180  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CID" (declared at
          line 316 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_DAT_UNTIL_STOP                 ((u8)11) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",181  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_DAT_UNTIL_STOP"
          (declared at line 317 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_STOP_TRANSMISSION                   ((u8)12)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_STOP_TRANSMISSION"
          (declared at line 318 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_STATUS                         ((u8)13)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",183  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_STATUS" (declared at
          line 319 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_READ                     ((u8)14)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",184  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_READ"
          (declared at line 320 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_INACTIVE_STATE                   ((u8)15)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_INACTIVE_STATE"
          (declared at line 321 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCKLEN                        ((u8)16)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",186  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCKLEN" (declared
          at line 322 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_SINGLE_BLOCK                   ((u8)17)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",187  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_SINGLE_BLOCK"
          (declared at line 325 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_MULT_BLOCK                     ((u8)18)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",188  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_MULT_BLOCK"
          (declared at line 327 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_WRITE                    ((u8)19)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",189  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_WRITE"
          (declared at line 329 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_DAT_UNTIL_STOP                ((u8)20) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",190  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_DAT_UNTIL_STOP"
          (declared at line 330 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCK_COUNT                     ((u8)23) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",191  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCK_COUNT"
          (declared at line 331 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_SINGLE_BLOCK                  ((u8)24)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",192  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_SINGLE_BLOCK"
          (declared at line 332 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_MULT_BLOCK                    ((u8)25)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",193  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_MULT_BLOCK"
          (declared at line 334 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CID                            ((u8)26)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CID" (declared at
          line 335 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CSD                            ((u8)27)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",195  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CSD" (declared at
          line 336 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_WRITE_PROT                      ((u8)28)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",196  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_WRITE_PROT" (declared
          at line 337 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_CLR_WRITE_PROT                      ((u8)29)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_CLR_WRITE_PROT" (declared
          at line 338 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_WRITE_PROT                     ((u8)30)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",198  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_WRITE_PROT"
          (declared at line 339 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_START                  ((u8)32) /*!< To set the address of the first write
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",199  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_START"
          (declared at line 340 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_END                    ((u8)33) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",201  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_END"
          (declared at line 341 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_START                     ((u8)35) /*!< To set the address of the first write block to be erased.
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",203  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_START"
          (declared at line 342 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_END                       ((u8)36) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",206  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_END" (declared
          at line 344 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE                               ((u8)38)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE" (declared at line
          346 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_FAST_IO                             ((u8)39) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",210  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_FAST_IO" (declared at
          line 347 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_IRQ_STATE                        ((u8)40) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",211  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IRQ_STATE" (declared
          at line 348 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_LOCK_UNLOCK                         ((u8)42)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_LOCK_UNLOCK" (declared at
          line 349 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_CMD                             ((u8)55)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",213  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_CMD" (declared at
          line 351 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GEN_CMD                             ((u8)56)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",214  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GEN_CMD" (declared at
          line 353 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_NO_CMD                              ((u8)64)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",215  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_NO_CMD" (declared at line
          355 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_SD_SET_BUSWIDTH                 ((u8)6)  /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_SD_SET_BUSWIDTH"
          (declared at line 361 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_STAUS                        ((u8)13) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",222  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_STAUS" (declared
          at line 2841 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS        ((u8)22) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",223  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS" (declared at line 364 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_OP_COND                      ((u8)41) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",224  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_OP_COND" (declared
          at line 366 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CLR_CARD_DETECT          ((u8)42) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",225  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SET_CLR_CARD_DETECT" (declared at line 368 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SEND_SCR                     ((u8)51) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",226  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SEND_SCR"
          (declared at line 369 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_DIRECT                      ((u8)52) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",227  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_DIRECT" (declared
          at line 370 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_EXTENDED                    ((u8)53) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",228  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_EXTENDED"
          (declared at line 371 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MKB                      ((u8)43) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",234  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MKB" (declared
          at line 377 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MID                      ((u8)44) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",235  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MID" (declared
          at line 378 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RN1                  ((u8)45) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",236  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RN1"
          (declared at line 379 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RN2                  ((u8)46) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",237  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RN2"
          (declared at line 380 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RES2                 ((u8)47) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",238  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RES2"
          (declared at line 381 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RES1                 ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RES1"
          (declared at line 382 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK   ((u8)18) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",240  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK" (declared at line 383 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK  ((u8)25) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",241  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK" (declared at line 384 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_ERASE                 ((u8)38) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",242  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_ERASE"
          (declared at line 385 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_CHANGE_SECURE_AREA           ((u8)49) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",243  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_CHANGE_SECURE_AREA"
          (declared at line 386 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MKB             ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",244  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_WRITE_MKB"
          (declared at line 387 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define NULL 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "NULL" (declared at line 22 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench
          7.0\arm\inc\c\stdio.h")

  #define SD_OCR_CID_CSD_OVERWRIETE       ((u32)0x00010000)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",278  Warning[Pe047]: 
          incompatible redefinition of macro "SD_OCR_CID_CSD_OVERWRIETE"
          (declared at line 2840 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define SD_DATATIMEOUT                  ((u32)0x000FFFFF)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\sdio_sdcard.h",310  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DATATIMEOUT" (declared at
          line 78 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Inc\bsp_driver_sd.h")
    285          #include "ili9320.h"
    286          

   \                                 In section .bss, align 1
    287          volatile uint8_t temper_error_flg = 0;
   \                     temper_error_flg:
   \   00000000                      DS8 1
    288          volatile uint8_t temper_error_type = 0;
   \                     temper_error_type:
   \   00000001                      DS8 1
    289          
    290          volatile uint8_t mks_heating_busy = 0;
    291          
    292          extern void PowerOff_Filament_Check();
    293          extern void display_temper_error();
    294          extern void Close_machine_display();
    295          
    296          extern uint8_t IsChooseAutoShutdown;
    297          
    298          extern uint8_t temperature_change_frequency;
    299          
    300          static uint32_t temperature_change_frequency_cnt = 0;
    301          static uint32_t After_finish_print_time = 0;
    302          
    303          uint8_t filament_loading_time_flg;
    304          uint32_t filament_loading_time_cnt;
    305          uint8_t filament_loading_completed;
    306          uint8_t filament_unloading_time_flg;
    307          uint32_t filament_unloading_time_cnt;
    308          uint8_t filament_unloading_completed;
    309          
    310          uint8_t filament_heat_completed_load;
    311          uint8_t filament_heat_completed_unload;
    312          
    313          extern uint32_t filament_rate;
    314          
    315          
    316          volatile uint32_t TimeIncrease;
    317          uint8_t volatile printing_rate_update_flag;
    318          uint8_t preview_no_display;
    319          extern PRINT_TIME  print_time;
    320          
    321          extern uint8_t from_flash_pic;
    322          
    323          volatile uint8_t loop_start=0;
    324          #endif
    325          
    326          
    327          #if 0
    328          #if HAS_ABL
    329            #include "vector_3.h"
    330            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
    331              #include "least_squares_fit.h"
    332            #endif
    333          #elif ENABLED(MESH_BED_LEVELING)
    334            #include "mesh_bed_leveling.h"
    335          #endif
    336          #endif
    337          #include "vector_3.h"
    338          //#include "qr_solve.h"
    339          #include "mesh_bed_leveling.h"

  	#define MESH_X_DIST_IS_KINEMATIC ((MESH_MAX_X_IS_KINEMATIC - (MESH_MIN_X_IS_KINEMATIC)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",41  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_KINEMATIC"
          (declared at line 74 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_KINEMATIC ((MESH_MAX_Y_IS_KINEMATIC - (MESH_MIN_Y_IS_KINEMATIC)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",42  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_KINEMATIC"
          (declared at line 75 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_X_DIST_IS_Cartesian ((MESH_MAX_X_IS_Cartesian - (MESH_MIN_X_IS_Cartesian)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",43  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_Cartesian"
          (declared at line 76 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_Cartesian ((MESH_MAX_Y_IS_Cartesian - (MESH_MIN_Y_IS_Cartesian)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",44  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_Cartesian"
          (declared at line 77 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_N
          ano_code\Middlewares\Third_Party\Marlin\ubl.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
   \                     _ZN17mesh_bed_leveling5set_zEaaRKf: (+1)
   \   00000000   0xEB00 0x0340      ADD      R3,R0,R0, LSL #+1
   \   00000004   0x4803             LDR.N    R0,??set_z_0
   \   00000006   0xEB00 0x1003      ADD      R0,R0,R3, LSL #+4
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   \   00000010   0x4770             BX       LR               ;; return
   \   00000012   0xBF00             Nop      
   \                     ??set_z_0:
   \   00000014   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
   \                     _ZN17mesh_bed_leveling6zigzagEaRaS0_: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x4B0C             LDR.N    R3,??zigzag_0
   \   00000004   0xF893 0x4060      LDRB     R4,[R3, #+96]
   \   00000008   0xFB90 0xF5F4      SDIV     R5,R0,R4
   \   0000000C   0xFB04 0x0415      MLS      R4,R4,R5,R0
   \   00000010   0x700C             STRB     R4,[R1, #+0]
   \   00000012   0xF893 0x4060      LDRB     R4,[R3, #+96]
   \   00000016   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   0000001A   0x7010             STRB     R0,[R2, #+0]
   \   0000001C   0x7810             LDRB     R0,[R2, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD505             BPL.N    ??zigzag_1
   \   00000022   0xF993 0x0060      LDRSB    R0,[R3, #+96]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x780A             LDRB     R2,[R1, #+0]
   \   0000002A   0x1A80             SUBS     R0,R0,R2
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   \                     ??zigzag_1: (+1)
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return
   \   00000032   0xBF00             Nop      
   \                     ??zigzag_0:
   \   00000034   0x........         DC32     mksCfg

   \                                 In section .text, align 2
   \   __interwork __softfp void mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
   \                     _ZN17mesh_bed_leveling12set_zigzag_zEaRKf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000000C   0x.... 0x....      BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
   \   00000010   0x4622             MOV      R2,R4
   \   00000012   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   00000016   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \   0000001A   0x.... 0x....      BL       _ZN17mesh_bed_leveling5set_zEaaRKf
   \   0000001E   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_xERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E55             LDR.N    R6,??cell_index_x_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??cell_index_x_1

  				cx= (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",83  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x813C      LDR.W    R8,??cell_index_x_0+0x4
   \   00000026   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493C             LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05C             B.N      ??cell_index_x_2

  				cx= (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",87  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_x_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF106 0x0060      ADD      R0,R6,#+96
   \   000000A6   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
   \   000000AA   0x68B0             LDR      R0,[R6, #+8]
   \   000000AC   0x4651             MOV      R1,R10
   \   000000AE   0x.... 0x....      BL       __aeabi_fadd
   \   000000B2   0x4605             MOV      R5,R0
   \   000000B4   0x4641             MOV      R1,R8
   \   000000B6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BA   0xD202             BCS.N    ??cell_index_x_3
   \   000000BC   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000C0   0xE000             B.N      ??cell_index_x_4
   \                     ??cell_index_x_3: (+1)
   \   000000C2   0x9500             STR      R5,[SP, #+0]
   \                     ??cell_index_x_4: (+1)
   \   000000C4   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C8   0x4659             MOV      R1,R11
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x4639             MOV      R1,R7
   \   000000D0   0x.... 0x....      BL       __aeabi_fsub
   \   000000D4   0x4607             MOV      R7,R0
   \   000000D6   0x4648             MOV      R0,R9
   \   000000D8   0x4651             MOV      R1,R10
   \   000000DA   0x.... 0x....      BL       __aeabi_fadd
   \   000000DE   0x4601             MOV      R1,R0
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E6   0xD300             BCC.N    ??cell_index_x_5
   \   000000E8   0x460F             MOV      R7,R1
   \                     ??cell_index_x_5: (+1)
   \   000000EA   0x4628             MOV      R0,R5
   \   000000EC   0x4641             MOV      R1,R8
   \   000000EE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F2   0xD300             BCC.N    ??cell_index_x_6
   \   000000F4   0x46A8             MOV      R8,R5
   \                     ??cell_index_x_6: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x9900             LDR      R1,[SP, #+0]
   \   000000FA   0x.... 0x....      BL       __aeabi_fsub
   \   000000FE   0x.... 0x....      BL       __aeabi_f2d
   \   00000102   0x4604             MOV      R4,R0
   \   00000104   0x460D             MOV      R5,R1
   \   00000106   0x4638             MOV      R0,R7
   \   00000108   0x4641             MOV      R1,R8
   \   0000010A   0x.... 0x....      BL       __aeabi_fsub
   \   0000010E   0x4607             MOV      R7,R0
   \   00000110   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000114   0x1E40             SUBS     R0,R0,#+1
   \   00000116   0x.... 0x....      BL       __aeabi_i2f
   \   0000011A   0x4601             MOV      R1,R0
   \   0000011C   0x4638             MOV      R0,R7
   \   0000011E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000122   0x.... 0x....      BL       __aeabi_f2d
   \   00000126   0x4602             MOV      R2,R0
   \   00000128   0x460B             MOV      R3,R1
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x490D             LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
   \   0000012E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000132   0x4622             MOV      R2,R4
   \   00000134   0x462B             MOV      R3,R5
   \   00000136   0x.... 0x....      BL       __aeabi_dmul
   \   0000013A   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??cell_index_x_2: (+1)
   \   0000013E   0xB240             SXTB     R0,R0
   \   00000140   0x0001             MOVS     R1,R0
   \   00000142   0xD501             BPL.N    ??cell_index_x_7
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xE005             B.N      ??cell_index_x_8
   \                     ??cell_index_x_7: (+1)
   \   00000148   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   0000014C   0x1E93             SUBS     R3,R2,#+2
   \   0000014E   0x428B             CMP      R3,R1
   \   00000150   0xDA00             BGE.N    ??cell_index_x_8
   \   00000152   0x1E90             SUBS     R0,R2,#+2
   \                     ??cell_index_x_8: (+1)
   \   00000154   0xB240             SXTB     R0,R0
   \   00000156   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   0000015A   0xBF00             Nop      
   \                     ??cell_index_x_0:
   \   0000015C   0x........         DC32     mksCfg
   \   00000160   0x........         DC32     mksTmp
   \   00000164   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_yERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E54             LDR.N    R6,??cell_index_y_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??cell_index_y_1

  				cy= (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",95  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x8138      LDR.W    R8,??cell_index_y_0+0x4
   \   00000026   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493B             LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05A             B.N      ??cell_index_y_2

  				cy= (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",97  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_y_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF8D6 0xA070      LDR      R10,[R6, #+112]
   \   000000A6   0x68F0             LDR      R0,[R6, #+12]
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fadd
   \   000000AE   0x4605             MOV      R5,R0
   \   000000B0   0x4641             MOV      R1,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B6   0xD202             BCS.N    ??cell_index_y_3
   \   000000B8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000BC   0xE000             B.N      ??cell_index_y_4
   \                     ??cell_index_y_3: (+1)
   \   000000BE   0x9500             STR      R5,[SP, #+0]
   \                     ??cell_index_y_4: (+1)
   \   000000C0   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C4   0x4659             MOV      R1,R11
   \   000000C6   0x.... 0x....      BL       __aeabi_fmul
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x.... 0x....      BL       __aeabi_fsub
   \   000000D0   0x4607             MOV      R7,R0
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x.... 0x....      BL       __aeabi_fadd
   \   000000DA   0x4601             MOV      R1,R0
   \   000000DC   0x4638             MOV      R0,R7
   \   000000DE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E2   0xD300             BCC.N    ??cell_index_y_5
   \   000000E4   0x460F             MOV      R7,R1
   \                     ??cell_index_y_5: (+1)
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0x4641             MOV      R1,R8
   \   000000EA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EE   0xD300             BCC.N    ??cell_index_y_6
   \   000000F0   0x46A8             MOV      R8,R5
   \                     ??cell_index_y_6: (+1)
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x9900             LDR      R1,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       __aeabi_fsub
   \   000000FA   0x.... 0x....      BL       __aeabi_f2d
   \   000000FE   0x4604             MOV      R4,R0
   \   00000100   0x460D             MOV      R5,R1
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x4641             MOV      R1,R8
   \   00000106   0x.... 0x....      BL       __aeabi_fsub
   \   0000010A   0x4607             MOV      R7,R0
   \   0000010C   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000110   0x1E40             SUBS     R0,R0,#+1
   \   00000112   0x.... 0x....      BL       __aeabi_i2f
   \   00000116   0x4601             MOV      R1,R0
   \   00000118   0x4638             MOV      R0,R7
   \   0000011A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000011E   0x.... 0x....      BL       __aeabi_f2d
   \   00000122   0x4602             MOV      R2,R0
   \   00000124   0x460B             MOV      R3,R1
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x490D             LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
   \   0000012A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000012E   0x4622             MOV      R2,R4
   \   00000130   0x462B             MOV      R3,R5
   \   00000132   0x.... 0x....      BL       __aeabi_dmul
   \   00000136   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??cell_index_y_2: (+1)
   \   0000013A   0xB240             SXTB     R0,R0
   \   0000013C   0x0001             MOVS     R1,R0
   \   0000013E   0xD501             BPL.N    ??cell_index_y_7
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xE005             B.N      ??cell_index_y_8
   \                     ??cell_index_y_7: (+1)
   \   00000144   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   00000148   0x1E93             SUBS     R3,R2,#+2
   \   0000014A   0x428B             CMP      R3,R1
   \   0000014C   0xDA00             BGE.N    ??cell_index_y_8
   \   0000014E   0x1E90             SUBS     R0,R2,#+2
   \                     ??cell_index_y_8: (+1)
   \   00000150   0xB240             SXTB     R0,R0
   \   00000152   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   00000156   0xBF00             Nop      
   \                     ??cell_index_y_0:
   \   00000158   0x........         DC32     mksCfg
   \   0000015C   0x........         DC32     mksTmp
   \   00000160   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::probe_index_x(float const &)
   \                     _ZN17mesh_bed_leveling13probe_index_xERKf: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4E6A             LDR.N    R6,??probe_index_x_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD03A             BEQ.N    ??probe_index_x_1

  				px = (x - (MESH_MIN_X_IS_KINEMATIC) + 0.5 * (MESH_X_DIST_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",105  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      BL       __aeabi_i2f
   \   0000002C   0x4605             MOV      R5,R0
   \   0000002E   0x4C61             LDR.N    R4,??probe_index_x_0+0x4
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x4680             MOV      R8,R0
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x.... 0x....      BL       __aeabi_fsub
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4604             MOV      R4,R0
   \   00000054   0x460D             MOV      R5,R1
   \   00000056   0x6838             LDR      R0,[R7, #+0]
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0x4680             MOV      R8,R0
   \   00000064   0x4689             MOV      R9,R1
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x4953             LDR.N    R1,??probe_index_x_0+0x8  ;; 0x3fe00000
   \   0000006A   0x4622             MOV      R2,R4
   \   0000006C   0x462B             MOV      R3,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_dmul
   \   00000072   0x4642             MOV      R2,R8
   \   00000074   0x464B             MOV      R3,R9
   \   00000076   0x.... 0x....      BL       __aeabi_dadd
   \   0000007A   0x4680             MOV      R8,R0
   \   0000007C   0x4689             MOV      R9,R1
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x494E             LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
   \   00000082   0x4622             MOV      R2,R4
   \   00000084   0x462B             MOV      R3,R5
   \   00000086   0x.... 0x....      BL       __aeabi_ddiv
   \   0000008A   0x4642             MOV      R2,R8
   \   0000008C   0x464B             MOV      R3,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_dmul
   \   00000092   0x.... 0x....      BL       __aeabi_d2iz
   \   00000096   0xE07E             B.N      ??probe_index_x_2

  				px = (x - (MESH_MIN_X_IS_Cartesian) + 0.5 * (MESH_X_DIST_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",107  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??probe_index_x_1: (+1)
   \   00000098   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   0000009C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   000000A0   0x4641             MOV      R1,R8
   \   000000A2   0x.... 0x....      BL       __aeabi_fmul
   \   000000A6   0x4682             MOV      R10,R0
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x4649             MOV      R1,R9
   \   000000B0   0x.... 0x....      BL       __aeabi_fadd
   \   000000B4   0x4604             MOV      R4,R0
   \   000000B6   0xF106 0x0060      ADD      R0,R6,#+96
   \   000000BA   0xF8D0 0xB00C      LDR      R11,[R0, #+12]
   \   000000BE   0x68B0             LDR      R0,[R6, #+8]
   \   000000C0   0x4659             MOV      R1,R11
   \   000000C2   0x.... 0x....      BL       __aeabi_fadd
   \   000000C6   0x4605             MOV      R5,R0
   \   000000C8   0x4621             MOV      R1,R4
   \   000000CA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000CE   0xD201             BCS.N    ??probe_index_x_3
   \   000000D0   0x9402             STR      R4,[SP, #+8]
   \   000000D2   0xE000             B.N      ??probe_index_x_4
   \                     ??probe_index_x_3: (+1)
   \   000000D4   0x9502             STR      R5,[SP, #+8]
   \                     ??probe_index_x_4: (+1)
   \   000000D6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000DA   0x4651             MOV      R1,R10
   \   000000DC   0x.... 0x....      BL       __aeabi_fmul
   \   000000E0   0x4649             MOV      R1,R9
   \   000000E2   0x.... 0x....      BL       __aeabi_fsub
   \   000000E6   0x4682             MOV      R10,R0
   \   000000E8   0x4640             MOV      R0,R8
   \   000000EA   0x4659             MOV      R1,R11
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x4602             MOV      R2,R0
   \   000000F2   0x4650             MOV      R0,R10
   \   000000F4   0x4611             MOV      R1,R2
   \   000000F6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000FA   0xD201             BCS.N    ??probe_index_x_5
   \   000000FC   0x46D0             MOV      R8,R10
   \   000000FE   0xE000             B.N      ??probe_index_x_6
   \                     ??probe_index_x_5: (+1)
   \   00000100   0x4690             MOV      R8,R2
   \                     ??probe_index_x_6: (+1)
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0x4621             MOV      R1,R4
   \   00000106   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000010A   0xD201             BCS.N    ??probe_index_x_7
   \   0000010C   0x46A1             MOV      R9,R4
   \   0000010E   0xE000             B.N      ??probe_index_x_8
   \                     ??probe_index_x_7: (+1)
   \   00000110   0x46A9             MOV      R9,R5
   \                     ??probe_index_x_8: (+1)
   \   00000112   0x4650             MOV      R0,R10
   \   00000114   0x4611             MOV      R1,R2
   \   00000116   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011A   0xD300             BCC.N    ??probe_index_x_9
   \   0000011C   0x4692             MOV      R10,R2
   \                     ??probe_index_x_9: (+1)
   \   0000011E   0x4628             MOV      R0,R5
   \   00000120   0x4621             MOV      R1,R4
   \   00000122   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000126   0xD300             BCC.N    ??probe_index_x_10
   \   00000128   0x462C             MOV      R4,R5
   \                     ??probe_index_x_10: (+1)
   \   0000012A   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   0000012E   0x1E40             SUBS     R0,R0,#+1
   \   00000130   0x.... 0x....      BL       __aeabi_i2f
   \   00000134   0x4605             MOV      R5,R0
   \   00000136   0x6838             LDR      R0,[R7, #+0]
   \   00000138   0x9902             LDR      R1,[SP, #+8]
   \   0000013A   0x.... 0x....      BL       __aeabi_fsub
   \   0000013E   0x.... 0x....      BL       __aeabi_f2d
   \   00000142   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000146   0x4640             MOV      R0,R8
   \   00000148   0x4649             MOV      R1,R9
   \   0000014A   0x.... 0x....      BL       __aeabi_fsub
   \   0000014E   0x4629             MOV      R1,R5
   \   00000150   0x.... 0x....      BL       __aeabi_fdiv
   \   00000154   0x.... 0x....      BL       __aeabi_f2d
   \   00000158   0x2200             MOVS     R2,#+0
   \   0000015A   0x4B17             LDR.N    R3,??probe_index_x_0+0x8  ;; 0x3fe00000
   \   0000015C   0x.... 0x....      BL       __aeabi_dmul
   \   00000160   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000164   0x.... 0x....      BL       __aeabi_dadd
   \   00000168   0x4680             MOV      R8,R0
   \   0000016A   0x4689             MOV      R9,R1
   \   0000016C   0x4650             MOV      R0,R10
   \   0000016E   0x4621             MOV      R1,R4
   \   00000170   0x.... 0x....      BL       __aeabi_fsub
   \   00000174   0x4629             MOV      R1,R5
   \   00000176   0x.... 0x....      BL       __aeabi_fdiv
   \   0000017A   0x.... 0x....      BL       __aeabi_f2d
   \   0000017E   0x4602             MOV      R2,R0
   \   00000180   0x460B             MOV      R3,R1
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x490D             LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
   \   00000186   0x.... 0x....      BL       __aeabi_ddiv
   \   0000018A   0x4642             MOV      R2,R8
   \   0000018C   0x464B             MOV      R3,R9
   \   0000018E   0x.... 0x....      BL       __aeabi_dmul
   \   00000192   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??probe_index_x_2: (+1)
   \   00000196   0xB240             SXTB     R0,R0
   \   00000198   0x0001             MOVS     R1,R0
   \   0000019A   0xD404             BMI.N    ??probe_index_x_11
   \   0000019C   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   000001A0   0x1E52             SUBS     R2,R2,#+1
   \   000001A2   0x428A             CMP      R2,R1
   \   000001A4   0xDA01             BGE.N    ??probe_index_x_12
   \                     ??probe_index_x_11: (+1)
   \   000001A6   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??probe_index_x_12: (+1)
   \   000001AA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \   000001AE   0xBF00             Nop      
   \                     ??probe_index_x_0:
   \   000001B0   0x........         DC32     mksCfg
   \   000001B4   0x........         DC32     mksTmp
   \   000001B8   0x3FE00000         DC32     0x3fe00000
   \   000001BC   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::probe_index_y(float const &)
   \                     _ZN17mesh_bed_leveling13probe_index_yERKf: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4E69             LDR.N    R6,??probe_index_y_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF9B0 0x104C      LDRSH    R1,[R0, #+76]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4291             CMP      R1,R2
   \   00000020   0xD13A             BNE.N    ??probe_index_y_1

        	py = (y - (MESH_MIN_Y_IS_KINEMATIC) + 0.5 * (MESH_Y_DIST_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
        	   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",115  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      BL       __aeabi_i2f
   \   0000002C   0x4605             MOV      R5,R0
   \   0000002E   0x4C60             LDR.N    R4,??probe_index_y_0+0x4
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x4680             MOV      R8,R0
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x.... 0x....      BL       __aeabi_fsub
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4604             MOV      R4,R0
   \   00000054   0x460D             MOV      R5,R1
   \   00000056   0x6838             LDR      R0,[R7, #+0]
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0x4680             MOV      R8,R0
   \   00000064   0x4689             MOV      R9,R1
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x4952             LDR.N    R1,??probe_index_y_0+0x8  ;; 0x3fe00000
   \   0000006A   0x4622             MOV      R2,R4
   \   0000006C   0x462B             MOV      R3,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_dmul
   \   00000072   0x4642             MOV      R2,R8
   \   00000074   0x464B             MOV      R3,R9
   \   00000076   0x.... 0x....      BL       __aeabi_dadd
   \   0000007A   0x4680             MOV      R8,R0
   \   0000007C   0x4689             MOV      R9,R1
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x494D             LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
   \   00000082   0x4622             MOV      R2,R4
   \   00000084   0x462B             MOV      R3,R5
   \   00000086   0x.... 0x....      BL       __aeabi_ddiv
   \   0000008A   0x4642             MOV      R2,R8
   \   0000008C   0x464B             MOV      R3,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_dmul
   \   00000092   0x.... 0x....      BL       __aeabi_d2iz
   \   00000096   0xE07C             B.N      ??probe_index_y_2

  				py = (y - (MESH_MIN_Y_IS_Cartesian) + 0.5 * (MESH_Y_DIST_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",117  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??probe_index_y_1: (+1)
   \   00000098   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   0000009C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   000000A0   0x4641             MOV      R1,R8
   \   000000A2   0x.... 0x....      BL       __aeabi_fmul
   \   000000A6   0x4682             MOV      R10,R0
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x4649             MOV      R1,R9
   \   000000B0   0x.... 0x....      BL       __aeabi_fadd
   \   000000B4   0x4604             MOV      R4,R0
   \   000000B6   0xF8D6 0xB070      LDR      R11,[R6, #+112]
   \   000000BA   0x68F0             LDR      R0,[R6, #+12]
   \   000000BC   0x4659             MOV      R1,R11
   \   000000BE   0x.... 0x....      BL       __aeabi_fadd
   \   000000C2   0x4605             MOV      R5,R0
   \   000000C4   0x4621             MOV      R1,R4
   \   000000C6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000CA   0xD201             BCS.N    ??probe_index_y_3
   \   000000CC   0x9402             STR      R4,[SP, #+8]
   \   000000CE   0xE000             B.N      ??probe_index_y_4
   \                     ??probe_index_y_3: (+1)
   \   000000D0   0x9502             STR      R5,[SP, #+8]
   \                     ??probe_index_y_4: (+1)
   \   000000D2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000D6   0x4651             MOV      R1,R10
   \   000000D8   0x.... 0x....      BL       __aeabi_fmul
   \   000000DC   0x4649             MOV      R1,R9
   \   000000DE   0x.... 0x....      BL       __aeabi_fsub
   \   000000E2   0x4682             MOV      R10,R0
   \   000000E4   0x4640             MOV      R0,R8
   \   000000E6   0x4659             MOV      R1,R11
   \   000000E8   0x.... 0x....      BL       __aeabi_fadd
   \   000000EC   0x4602             MOV      R2,R0
   \   000000EE   0x4650             MOV      R0,R10
   \   000000F0   0x4611             MOV      R1,R2
   \   000000F2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F6   0xD201             BCS.N    ??probe_index_y_5
   \   000000F8   0x46D0             MOV      R8,R10
   \   000000FA   0xE000             B.N      ??probe_index_y_6
   \                     ??probe_index_y_5: (+1)
   \   000000FC   0x4690             MOV      R8,R2
   \                     ??probe_index_y_6: (+1)
   \   000000FE   0x4628             MOV      R0,R5
   \   00000100   0x4621             MOV      R1,R4
   \   00000102   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000106   0xD201             BCS.N    ??probe_index_y_7
   \   00000108   0x46A1             MOV      R9,R4
   \   0000010A   0xE000             B.N      ??probe_index_y_8
   \                     ??probe_index_y_7: (+1)
   \   0000010C   0x46A9             MOV      R9,R5
   \                     ??probe_index_y_8: (+1)
   \   0000010E   0x4650             MOV      R0,R10
   \   00000110   0x4611             MOV      R1,R2
   \   00000112   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000116   0xD300             BCC.N    ??probe_index_y_9
   \   00000118   0x4692             MOV      R10,R2
   \                     ??probe_index_y_9: (+1)
   \   0000011A   0x4628             MOV      R0,R5
   \   0000011C   0x4621             MOV      R1,R4
   \   0000011E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000122   0xD300             BCC.N    ??probe_index_y_10
   \   00000124   0x462C             MOV      R4,R5
   \                     ??probe_index_y_10: (+1)
   \   00000126   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   0000012A   0x1E40             SUBS     R0,R0,#+1
   \   0000012C   0x.... 0x....      BL       __aeabi_i2f
   \   00000130   0x4605             MOV      R5,R0
   \   00000132   0x6838             LDR      R0,[R7, #+0]
   \   00000134   0x9902             LDR      R1,[SP, #+8]
   \   00000136   0x.... 0x....      BL       __aeabi_fsub
   \   0000013A   0x.... 0x....      BL       __aeabi_f2d
   \   0000013E   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000142   0x4640             MOV      R0,R8
   \   00000144   0x4649             MOV      R1,R9
   \   00000146   0x.... 0x....      BL       __aeabi_fsub
   \   0000014A   0x4629             MOV      R1,R5
   \   0000014C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000150   0x.... 0x....      BL       __aeabi_f2d
   \   00000154   0x2200             MOVS     R2,#+0
   \   00000156   0x4B17             LDR.N    R3,??probe_index_y_0+0x8  ;; 0x3fe00000
   \   00000158   0x.... 0x....      BL       __aeabi_dmul
   \   0000015C   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000160   0x.... 0x....      BL       __aeabi_dadd
   \   00000164   0x4680             MOV      R8,R0
   \   00000166   0x4689             MOV      R9,R1
   \   00000168   0x4650             MOV      R0,R10
   \   0000016A   0x4621             MOV      R1,R4
   \   0000016C   0x.... 0x....      BL       __aeabi_fsub
   \   00000170   0x4629             MOV      R1,R5
   \   00000172   0x.... 0x....      BL       __aeabi_fdiv
   \   00000176   0x.... 0x....      BL       __aeabi_f2d
   \   0000017A   0x4602             MOV      R2,R0
   \   0000017C   0x460B             MOV      R3,R1
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x490D             LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
   \   00000182   0x.... 0x....      BL       __aeabi_ddiv
   \   00000186   0x4642             MOV      R2,R8
   \   00000188   0x464B             MOV      R3,R9
   \   0000018A   0x.... 0x....      BL       __aeabi_dmul
   \   0000018E   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??probe_index_y_2: (+1)
   \   00000192   0xB240             SXTB     R0,R0
   \   00000194   0x0001             MOVS     R1,R0
   \   00000196   0xD404             BMI.N    ??probe_index_y_11
   \   00000198   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   0000019C   0x1E52             SUBS     R2,R2,#+1
   \   0000019E   0x428A             CMP      R2,R1
   \   000001A0   0xDA01             BGE.N    ??probe_index_y_12
   \                     ??probe_index_y_11: (+1)
   \   000001A2   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??probe_index_y_12: (+1)
   \   000001A6   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \   000001AA   0xBF00             Nop      
   \                     ??probe_index_y_0:
   \   000001AC   0x........         DC32     mksCfg
   \   000001B0   0x........         DC32     mksTmp
   \   000001B4   0x3FE00000         DC32     0x3fe00000
   \   000001B8   0x3FF00000         DC32     0x3ff00000
    340          
    341          #if ENABLED(BEZIER_CURVE_SUPPORT)
    342            #include "planner_bezier.h"
    343          #endif
    344          
    345          #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
    346            #include "buzzer.h"
    347          #endif
    348          
    349          #if ENABLED(USE_WATCHDOG)
    350            #include "watchdog.h"
    351          #endif
    352          
    353          #if ENABLED(MAX7219_DEBUG)
    354            #include "Max7219_Debug_LEDs.h"
    355          #endif
    356          
    357          #if HAS_COLOR_LEDS
    358            #include "leds.h"
    359          #endif
    360          
    361          #if HAS_SERVOS
    362            #include "servo.h"
    363          #endif
    364          
    365          #if HAS_DIGIPOTSS
    366            #include <SPI.h>
    367          #endif
    368          
    369          #if ENABLED(DAC_STEPPER_CURRENT)
    370            #include "stepper_dac.h"
    371          #endif
    372          
    373          #if ENABLED(EXPERIMENTAL_I2CBUS)
    374            #include "twibus.h"
    375          #endif
    376          
    377          #if ENABLED(I2C_POSITION_ENCODERS)
    378            #include "I2CPositionEncoder.h"
    379          #endif
    380          
    381          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    382            #include "endstop_interrupts.h"
    383          #endif
    384          
    385          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    386            void gcode_M100();
    387            void M100_dump_routine(const char * const title, const char *start, const char *end);
    388          #endif
    389          
    390          #if ENABLED(G26_MESH_VALIDATION)
    391            bool g26_debug_flag; // =false
    392            void gcode_G26();
    393          #endif
    394          
    395          #if ENABLED(SDSUPPORT)

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    396            CardReader card;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable136_3
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       _ZN10CardReaderC1Ev
    397          #endif
    398          
    399          #if ENABLED(EXPERIMENTAL_I2CBUS)
    400            TWIBus i2c;
    401          #endif
    402          
    403          #if ENABLED(G38_PROBE_TARGET)
    404            bool G38_move = false,
    405                 G38_endstop_hit = false;
    406          #endif
    407          
    408          #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
    409            #include "ubl.h"
    410            extern bool defer_return_to_status;
    411            unified_bed_leveling ubl;
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable136_4
   \   00000012   0xF104 0x0084      ADD      R0,R4,#+132
   \   00000016   0x.... 0x....      BL       _ZN20unified_bed_levelingC1Ev
   \   0000001A   0xF605 0x20E8      ADDW     R0,R5,#+2792
   \   0000001E   0x.... 0x....      BL       _ZN9StopwatchC1Ev
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable136_5
   \   00000026   0x6F68             LDR      R0,[R5, #+116]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable136_6  ;; 0x42700000
   \   0000002C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000030   0x6760             STR      R0,[R4, #+116]
   \   00000032   0x69E8             LDR      R0,[R5, #+28]
   \   00000034   0x67E0             STR      R0,[R4, #+124]
   \   00000036   0x.... 0x....      LDR.W    R7,??DataTable136_7  ;; 0x43160000
   \   0000003A   0x46B9             MOV      R9,R7
   \   0000003C   0xF04F 0x0A02      MOV      R10,#+2
   \   00000040   0xF04F 0x567E      MOV      R6,#+1065353216
   \   00000044   0x46B0             MOV      R8,R6
   \   00000046   0xE004             B.N      ??__sti__routine_0
   \                     ??__sti__routine_1: (+1)
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x4649             MOV      R1,R9
   \   0000004C   0x.... 0x....      BL       __aeabi_fmul
   \   00000050   0x4681             MOV      R9,R0
   \                     ??__sti__routine_0: (+1)
   \   00000052   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000056   0xD504             BPL.N    ??__sti__routine_2
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x4649             MOV      R1,R9
   \   0000005C   0x.... 0x....      BL       __aeabi_fmul
   \   00000060   0x4680             MOV      R8,R0
   \                     ??__sti__routine_2: (+1)
   \   00000062   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000066   0xD1EF             BNE.N    ??__sti__routine_1
   \   00000068   0x.... 0x....      LDR.W    R9,??DataTable136_8
   \   0000006C   0xF8C9 0x8034      STR      R8,[R9, #+52]
   \   00000070   0x4641             MOV      R1,R8
   \   00000072   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000076   0x.... 0x....      BL       __aeabi_fmul
   \   0000007A   0xF8C4 0x0080      STR      R0,[R4, #+128]
   \   0000007E   0x2402             MOVS     R4,#+2
   \   00000080   0xE004             B.N      ??__sti__routine_3
   \                     ??__sti__routine_4: (+1)
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0x4639             MOV      R1,R7
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x4607             MOV      R7,R0
   \                     ??__sti__routine_3: (+1)
   \   0000008C   0x07E0             LSLS     R0,R4,#+31
   \   0000008E   0xD504             BPL.N    ??__sti__routine_5
   \   00000090   0x4630             MOV      R0,R6
   \   00000092   0x4639             MOV      R1,R7
   \   00000094   0x.... 0x....      BL       __aeabi_fmul
   \   00000098   0x4606             MOV      R6,R0
   \                     ??__sti__routine_5: (+1)
   \   0000009A   0x0864             LSRS     R4,R4,#+1
   \   0000009C   0xD1F1             BNE.N    ??__sti__routine_4
   \   0000009E   0xF8C9 0x6038      STR      R6,[R9, #+56]
   \   000000A2   0x68A8             LDR      R0,[R5, #+8]
   \   000000A4   0xF8C9 0x0004      STR      R0,[R9, #+4]
   \   000000A8   0x68E8             LDR      R0,[R5, #+12]
   \   000000AA   0xF8C9 0x0008      STR      R0,[R9, #+8]
   \   000000AE   0x6928             LDR      R0,[R5, #+16]
   \   000000B0   0xF8C9 0x000C      STR      R0,[R9, #+12]
   \   000000B4   0x6968             LDR      R0,[R5, #+20]
   \   000000B6   0xF8C9 0x0010      STR      R0,[R9, #+16]
   \   000000BA   0x69A8             LDR      R0,[R5, #+24]
   \   000000BC   0xF8C9 0x0014      STR      R0,[R9, #+20]
   \   000000C0   0x69E8             LDR      R0,[R5, #+28]
   \   000000C2   0xF8C9 0x0018      STR      R0,[R9, #+24]
   \   000000C6   0x6D28             LDR      R0,[R5, #+80]
   \   000000C8   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000000CC   0x6968             LDR      R0,[R5, #+20]
   \   000000CE   0x68A9             LDR      R1,[R5, #+8]
   \   000000D0   0x.... 0x....      BL       __aeabi_fsub
   \   000000D4   0xF8C9 0x0028      STR      R0,[R9, #+40]
   \   000000D8   0x69A8             LDR      R0,[R5, #+24]
   \   000000DA   0x68E9             LDR      R1,[R5, #+12]
   \   000000DC   0x.... 0x....      BL       __aeabi_fsub
   \   000000E0   0xF8C9 0x002C      STR      R0,[R9, #+44]
   \   000000E4   0x69E8             LDR      R0,[R5, #+28]
   \   000000E6   0x6929             LDR      R1,[R5, #+16]
   \   000000E8   0x.... 0x....      BL       __aeabi_fsub
   \   000000EC   0xF8C9 0x0030      STR      R0,[R9, #+48]
   \   000000F0   0x7968             LDRB     R0,[R5, #+5]
   \   000000F2   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000F6   0x79A8             LDRB     R0,[R5, #+6]
   \   000000F8   0xF889 0x0001      STRB     R0,[R9, #+1]
   \   000000FC   0x79E8             LDRB     R0,[R5, #+7]
   \   000000FE   0xF889 0x0002      STRB     R0,[R9, #+2]
   \   00000102   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    412          #endif
    413          
    414          #if ENABLED(CNC_COORDINATE_SYSTEMS)
    415            int8_t active_coordinate_system = -1; // machine space
    416            float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
    417          #endif
    418          
    419          bool Running = true;
    420          
    421          uint8_t marlin_debug_flags = DEBUG_NONE;
    422          
    423          /**
    424           * Cartesian Current Position
    425           *   Used to track the native machine position as moves are queued.
    426           *   Used by 'buffer_line_to_current_position' to do a move after changing it.
    427           *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
    428           */
    429          float current_position[XYZE] = { 0.0 };
    430          
    431          /**
    432           * Cartesian Destination
    433           *   The destination for a move, filled in by G-code movement commands,
    434           *   and expected by functions like 'prepare_move_to_destination'.
    435           *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
    436           */
    437          float destination[XYZE] = { 0.0 };
    438          
    439          /**
    440           * axis_homed
    441           *   Flags that each linear axis was homed.
    442           *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    443           *
    444           * axis_known_position
    445           *   Flags that the position is known in each linear axis. Set when homed.
    446           *   Cleared whenever a stepper powers off, potentially losing its position.
    447           */
    448          bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
    449          
    450          /**
    451           * GCode line number handling. Hosts may opt to include line numbers when
    452           * sending commands to Marlin, and lines will be checked for sequentiality.
    453           * M110 N<int> sets the current line number.
    454           */
    455          static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
    456          
    457          /**
    458           * GCode Command Queue
    459           * A simple ring buffer of BUFSIZE command strings.
    460           *
    461           * Commands are copied into this buffer by the command injectors
    462           * (immediate, serial, sd card) and they are processed sequentially by
    463           * the main loop. The process_next_command function parses the next
    464           * command and hands off execution to individual handler functions.
    465           */
    466          uint8_t commands_in_queue = 0; // Count of commands in the queue
    467          static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
    468                         cmd_queue_index_w = 0; // Ring buffer write position
    469          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    470            char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
    471          #else                                         // This can be collapsed back to the way it was soon.
    472          static char command_queue[BUFSIZE][MAX_CMD_SIZE];
    473          #endif
    474          
    475          /**
    476           * Next Injected Command pointer. NULL if no commands are being injected.
    477           * Used by Marlin internally to ensure that commands initiated from within
    478           * are enqueued ahead of any pending serial or sd card commands.
    479           */
    480          static const char *injected_commands_P = NULL;
    481          
    482          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
    483            TempUnit input_temp_units = TEMPUNIT_C;
    484          #endif
    485          
    486          /**
    487           * Feed rates are often configured with mm/m
    488           * but the planner and stepper like mm/s units.
    489           */
    490           /*
    491          static const float homing_feedrate_mm_s[] PROGMEM = {
    492            #if ENABLED(DELTA)
    493              MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
    494            #else
    495              MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
    496            #endif
    497            MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
    498          };
    499          
    500          FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
    501          */
    502          
    503          float  homing_feedrate_mm_s[4];
    504          
    505          float feedrate_mm_s = MMM_TO_MMS(1500.0);
    506          static float saved_feedrate_mm_s;
    507          int16_t feedrate_percentage = 100, saved_feedrate_percentage;
    508          
    509          // Initialized by settings.load()
    510          bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
    511          
    512          #if HAS_WORKSPACE_OFFSET
    513            #if HAS_POSITION_SHIFT
    514              // The distance that XYZ has been offset by G92. Reset by G28.
    515              float position_shift[XYZ] = { 0 };
    516            #endif
    517            #if HAS_HOME_OFFSET
    518              // This offset is added to the configured home position.
    519              // Set by M206, M428, or menu item. Saved to EEPROM.
    520              float home_offset[XYZ] = { 0 };
    521            #endif
    522            #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
    523              // The above two are combined to save on computes
    524              float workspace_offset[XYZ] = { 0 };
    525            #endif
    526          #endif
    527          
    528          // Software Endstops are based on the configured limits.
    529          /*
    530          float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
    531                soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
    532          */
    533          float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

   \                                 In section .text, align 2, keep-with-next
    534          void soft_endstop_min_init()
    535          {
   \                     _Z21soft_endstop_min_initv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    536              if(MACHINETPYE & IS_KINEMATIC)
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable136_5
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable136_9
   \   0000000E   0xF04F 0x567C      MOV      R6,#+1056964608
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable136_4
   \   00000016   0xF8B4 0x1058      LDRH     R1,[R4, #+88]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD019             BEQ.N    ??soft_endstop_min_init_0
    537              {
    538                  soft_endstop_min[0]= X_MIN_BED_IS_KINEMATIC;
   \   00000022   0xF04F 0x483F      MOV      R8,#-1090519040
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fmul
   \   0000002C   0x6478             STR      R0,[R7, #+68]
    539                  soft_endstop_min[1]= Y_MIN_BED_IS_KINEMATIC;
   \   0000002E   0x69A0             LDR      R0,[R4, #+24]
   \   00000030   0x4641             MOV      R1,R8
   \   00000032   0x.... 0x....      BL       __aeabi_fmul
   \   00000036   0x64B8             STR      R0,[R7, #+72]
    540                  soft_endstop_min[2]= Z_MIN_POS;
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0x64F8             STR      R0,[R7, #+76]
    541          
    542                  soft_endstop_max[0] = X_MAX_BED_IS_KINEMATIC;
   \   0000003C   0x6960             LDR      R0,[R4, #+20]
   \   0000003E   0x4631             MOV      R1,R6
   \   00000040   0x.... 0x....      BL       __aeabi_fmul
   \   00000044   0x6268             STR      R0,[R5, #+36]
    543                  soft_endstop_max[1] = Y_MAX_BED_IS_KINEMATIC;
   \   00000046   0x69A0             LDR      R0,[R4, #+24]
   \   00000048   0x4631             MOV      R1,R6
   \   0000004A   0x.... 0x....      BL       __aeabi_fmul
   \   0000004E   0x62A8             STR      R0,[R5, #+40]
    544                  soft_endstop_max[2] = Z_MAX_POS;
   \   00000050   0x69E0             LDR      R0,[R4, #+28]
   \   00000052   0x62E8             STR      R0,[R5, #+44]
   \   00000054   0xE024             B.N      ??soft_endstop_min_init_1
    545              }
    546              else
    547              {
    548                  soft_endstop_min[0]= X_MIN_BED_IS_CARTESIAN;
   \                     ??soft_endstop_min_init_0: (+1)
   \   00000056   0x4631             MOV      R1,R6
   \   00000058   0x.... 0x....      BL       __aeabi_fmul
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x.... 0x....      BL       __aeabi_fsub
   \   00000062   0x6478             STR      R0,[R7, #+68]
    549                  soft_endstop_min[1]= Y_MIN_BED_IS_CARTESIAN;
   \   00000064   0x69A0             LDR      R0,[R4, #+24]
   \   00000066   0x4631             MOV      R1,R6
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0x4601             MOV      R1,R0
   \   0000006E   0x.... 0x....      BL       __aeabi_fsub
   \   00000072   0x64B8             STR      R0,[R7, #+72]
    550                  soft_endstop_min[2]= Z_MIN_POS;
   \   00000074   0x6920             LDR      R0,[R4, #+16]
   \   00000076   0x64F8             STR      R0,[R7, #+76]
    551          
    552                  soft_endstop_max[0] = X_MAX_BED_IS_CARTESIAN;
   \   00000078   0xF04F 0x4780      MOV      R7,#+1073741824
   \   0000007C   0x6960             LDR      R0,[R4, #+20]
   \   0000007E   0x4631             MOV      R1,R6
   \   00000080   0x.... 0x....      BL       __aeabi_fmul
   \   00000084   0x4639             MOV      R1,R7
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x6268             STR      R0,[R5, #+36]
    553                  soft_endstop_max[1] = Y_MAX_BED_IS_CARTESIAN;
   \   0000008C   0x69A0             LDR      R0,[R4, #+24]
   \   0000008E   0x4631             MOV      R1,R6
   \   00000090   0x.... 0x....      BL       __aeabi_fmul
   \   00000094   0x4639             MOV      R1,R7
   \   00000096   0x.... 0x....      BL       __aeabi_fmul
   \   0000009A   0x62A8             STR      R0,[R5, #+40]
    554                  soft_endstop_max[2] = Z_MAX_POS;
   \   0000009C   0x69E0             LDR      R0,[R4, #+28]
   \   0000009E   0x62E8             STR      R0,[R5, #+44]
    555              }        
    556          }
   \                     ??soft_endstop_min_init_1: (+1)
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    557          
    558          #if HAS_SOFTWARE_ENDSTOPS
    559            bool soft_endstops_enabled = true;
    560            #if 1// IS_KINEMATIC
    561              float soft_endstop_radius, soft_endstop_radius_2;
    562            #endif
    563          #endif
    564          
    565          #if FAN_COUNT > 0
    566            int fanSpeeds[FAN_COUNT] = { 0 };
    567            #if ENABLED(EXTRA_FAN_SPEED)
    568              int16_t old_fanSpeeds[FAN_COUNT],
    569                      new_fanSpeeds[FAN_COUNT];
    570            #endif
    571            #if ENABLED(PROBING_FANS_OFF)
    572              bool fans_paused = false;
    573              int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
    574            #endif
    575          #endif
    576          
    577          // The active extruder (tool). Set with T<extruder> command.
    578          uint8_t active_extruder = 0;
    579          
    580          // Relative Mode. Enable with G91, disable with G90.
    581          static bool relative_mode = false;
    582          
    583          // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
    584          volatile bool wait_for_heatup = true;
    585          
    586          // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
    587          #if HAS_RESUME_CONTINUE
    588            volatile bool wait_for_user = false;
    589          #endif
    590          

   \                                 In section .text, align 4, keep-with-next
    591          const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
   \                     axis_codes:
   \   00000000   0x58 0x59          DC8 88, 89, 90, 69
   \              0x5A 0x45    
    592          
    593          // Number of characters read in the current line of serial input
    594          static int serial_count = 0;
    595          static int wifi_read_count = 0;
    596          
    597          // Inactivity shutdown
    598          millis_t previous_cmd_ms = 0;
    599          static millis_t max_inactive_time = 0;
    600          static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
    601          
    602          // Print Job Timer
    603          #if ENABLED(PRINTCOUNTER)
    604            PrintCounter print_job_timer = PrintCounter();
    605          #else
    606            Stopwatch print_job_timer = Stopwatch();
    607          #endif
    608          
    609          // Buzzer - I2C on the LCD or a BEEPER_PIN
    610          #if ENABLED(LCD_USE_I2C_BUZZER)
    611            #define BUZZ(d,f) lcd_buzz(d, f)
    612          #elif PIN_EXISTS(BEEPER)
    613            Buzzer buzzer;
    614            #define BUZZ(d,f) buzzer.tone(d, f)
    615          #else
    616            #define BUZZ(d,f) NOOP
    617          #endif
    618          
    619          uint8_t target_extruder;
    620          
    621          #if HAS_BED_PROBE
    622            float zprobe_zoffset; // Initialized by settings.load()
    623          #endif
    624          
    625          #if 1//HAS_ABL
    626            float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
    627            #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
    628          #elif defined(XY_PROBE_SPEED)
    629            #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
    630          #else
    631            #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
    632          #endif
    633          
    634          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
    635          /*
    636            #if ENABLED(DELTA)
    637              #define ADJUST_DELTA(V) \
    638                if (planner.leveling_active) { \
    639                  const float zadj = bilinear_z_offset(V); \
    640                  delta[A_AXIS] += zadj; \
    641                  delta[B_AXIS] += zadj; \
    642                  delta[C_AXIS] += zadj; \
    643                }
    644            #else
    645              #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
    646            #endif
    647            */

   \                                 In section .text, align 2, keep-with-next
    648          void  ADJUST_DELTA(const float logical[XYZ])
    649          {
   \                     _Z12ADJUST_DELTAPKf: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    650          	float zadj;
    651          
    652          	if(MACHINETPYE == DELTA)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable137
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable136_5
   \   0000000C   0xF9B2 0x2058      LDRSH    R2,[R2, #+88]
   \   00000010   0x2A02             CMP      R2,#+2
   \   00000012   0xD116             BNE.N    ??ADJUST_DELTA_0
    653          		{
    654                	if (planner.leveling_active) { 
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD01E             BEQ.N    ??ADJUST_DELTA_1
    655                 	 	zadj = bilinear_z_offset(logical); 
   \   00000018   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   0000001C   0x4604             MOV      R4,R0
    656                  	delta[A_AXIS] += zadj; 
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable136_4
   \   00000022   0x6D28             LDR      R0,[R5, #+80]
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0x.... 0x....      BL       __aeabi_fadd
   \   0000002A   0x6528             STR      R0,[R5, #+80]
    657                 		delta[B_AXIS] += zadj; 
   \   0000002C   0x6D68             LDR      R0,[R5, #+84]
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x.... 0x....      BL       __aeabi_fadd
   \   00000034   0x6568             STR      R0,[R5, #+84]
    658                  	delta[C_AXIS] += zadj; 
   \   00000036   0x6DA8             LDR      R0,[R5, #+88]
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x.... 0x....      BL       __aeabi_fadd
   \   0000003E   0x65A8             STR      R0,[R5, #+88]
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
    659                		}
    660          		}
    661          		else
    662          			{
    663          			if (planner.leveling_active) 
   \                     ??ADJUST_DELTA_0: (+1)
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD007             BEQ.N    ??ADJUST_DELTA_1
    664          				 delta[Z_AXIS] += bilinear_z_offset(logical); 
   \   00000046   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   0000004A   0x.... 0x....      LDR.W    R5,??DataTable136_4
   \   0000004E   0x6DA9             LDR      R1,[R5, #+88]
   \   00000050   0x.... 0x....      BL       __aeabi_fadd
   \   00000054   0x65A8             STR      R0,[R5, #+88]
    665          			}
    666          }  
   \                     ??ADJUST_DELTA_1: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    667          //#elif IS_KINEMATIC
    668          //  #define ADJUST_DELTA(V) NOOP
    669          #endif
    670          
    671          #if ENABLED(X_DUAL_ENDSTOPS)
    672            float x_endstop_adj;                // Initialized by settings.load()
    673          #endif
    674          #if ENABLED(Y_DUAL_ENDSTOPS)
    675            float y_endstop_adj;                // Initialized by settings.load()
    676          #endif
    677          #if 1//ENABLED(Z_DUAL_ENDSTOPS)
    678            float z_endstop_adj;                // Initialized by settings.load()
    679          #endif
    680          
    681          // Extruder offsets
    682          #if HOTENDS > 1
    683            float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
    684          #endif
    685          
    686          #if HAS_Z_SERVO_ENDSTOP
    687            const int z_servo_angle[2] = Z_SERVO_ANGLES;
    688          #endif
    689          
    690          #if ENABLED(BARICUDA)
    691            uint8_t baricuda_valve_pressure = 0,
    692                    baricuda_e_to_p_pressure = 0;
    693          #endif
    694          
    695          #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
    696            bool autoretract_enabled,                 // M209 S - Autoretract switch
    697                 retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
    698            float retract_length,                     // M207 S - G10 Retract length
    699                  retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
    700                  retract_zlift,                      // M207 Z - G10 Retract hop size
    701                  retract_recover_length,             // M208 S - G11 Recover length
    702                  retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
    703                  swap_retract_length,                // M207 W - G10 Swap Retract length
    704                  swap_retract_recover_length,        // M208 W - G11 Swap Recover length
    705                  swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
    706            #if EXTRUDERS > 1
    707              bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
    708            #else
    709              constexpr bool retracted_swap[1] = { false };
    710            #endif
    711          #endif // FWRETRACT
    712          
    713          #if HAS_POWER_SWITCH
    714            bool powersupply_on =
    715              #if ENABLED(PS_DEFAULT_OFF)
    716                false
    717              #else
    718                true
    719              #endif
    720            ;
    721          #endif
    722          
    723          #if 1//ENABLED(DELTA)
    724          
    725            float delta[ABC];
    726          
    727            // Initialized by settings.load()
    728            float delta_height,
    729                  delta_endstop_adj[ABC] = { 0 },
    730                  delta_radius,
    731                  delta_tower_angle_trim[ABC],
    732                  delta_tower[ABC][2],
    733                  delta_diagonal_rod,
    734                  delta_calibration_radius,
    735                  delta_diagonal_rod_2_tower[ABC],
    736                  delta_segments_per_second,
    737                  delta_clip_start_height = Z_MAX_POS;
    738          
    739            float delta_safe_distance_from_top();
    740          
    741          #endif
    742          
    743          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
    744            int bilinear_grid_spacing[2], bilinear_start[2];
    745            float bilinear_grid_factor[2],
    746                  //z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
    747                  z_values[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
    748          #endif
    749          
    750          #if 1//IS_SCARA
    751            // Float constants for SCARA calculations

   \                                 In section .rodata, align 4, keep-with-next
    752            const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
   \                     L1:
   \   00000000   0x43160000         DC32 43160000H

   \                                 In section .rodata, align 4, keep-with-next
   \                     L2:
   \   00000000   0x43160000         DC32 43160000H

   \                                 In section .data, align 4
   \                     mks_heating_busy:
   \   00000000   0x00               DC8 0
   \                     marlin_debug_flags:
   \   00000001   0x00               DC8 0
   \                     commands_in_queue:
   \   00000002   0x00               DC8 0
   \                     active_extruder:
   \   00000003   0x00               DC8 0
   \                     wait_for_heatup:
   \   00000004   0x01               DC8 1
   \                     target_extruder:
   \   00000005   0x00               DC8 0
   \                     feedrate_percentage:
   \   00000006   0x0064             DC16 100
   \                     current_position:
   \   00000008   0x00000000         DC32 0H
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     destination:
   \   00000018   0x00000000         DC32 0H
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     homing_feedrate_mm_s:
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     workspace_offset:
   \   00000038   0x00000000         DC32 0H
   \   0000003C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_min:
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta:
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     feedrate_mm_s:
   \   0000005C   0x41C80000         DC32 41C80000H
   \                     position_shift:
   \   00000060   0x00000000         DC32 0H
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     fanSpeeds:
   \   0000006C   0x00000000         DC32 0
   \                     zprobe_zoffset:
   \   00000070   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     xy_probe_feedrate_mm_s:
   \   00000074   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_height:
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_clip_start_height:
   \   0000007C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000080   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     ubl:
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    753                        L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
    754                        L2_2 = sq(float(L2));
    755          
    756            //float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
    757            //      delta[ABC];
    758          #endif
    759          
    760          float cartes[XYZ] = { 0 };
    761          
    762          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    763            bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
    764            float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
    765                  filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
    766            uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
    767            int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
    768                   filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
    769          #endif
    770          
    771          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    772            static bool filament_ran_out = false;
    773          #endif
    774          
    775          #if ENABLED(ADVANCED_PAUSE_FEATURE)
    776            AdvancedPauseMenuResponse advanced_pause_menu_response;
    777          #endif
    778          
    779          #if ENABLED(MIXING_EXTRUDER)
    780            float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
    781            #if MIXING_VIRTUAL_TOOLS > 1
    782              float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
    783            #endif
    784          #endif
    785          
    786          static bool send_ok[BUFSIZE];
    787          
    788          #if HAS_SERVOS
    789            Servo servo[NUM_SERVOS];
    790            #define MOVE_SERVO(I, P) servo[I].move(P)
    791            #if HAS_Z_SERVO_ENDSTOP
    792              #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
    793              #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
    794            #endif
    795          #endif
    796          
    797          #ifdef CHDK
    798            millis_t chdkHigh = 0;
    799            bool chdkActive = false;
    800          #endif
    801          
    802          #if ENABLED(PID_EXTRUSION_SCALING)
    803            int lpq_len = 20;
    804          #endif
    805          
    806          #if ENABLED(HOST_KEEPALIVE_FEATURE)
    807            MarlinBusyState busy_state = NOT_BUSY;
    808            static millis_t next_busy_signal_ms = 0;
    809            uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
    810          #else
    811            #define host_keepalive() NOOP
    812          #endif
    813          
    814          #if ENABLED(I2C_POSITION_ENCODERS)
    815            I2CPositionEncodersMgr I2CPEM;
    816            uint8_t blockBufferIndexRef = 0;
    817            millis_t lastUpdateMillis;
    818          #endif
    819          
    820          #if ENABLED(CNC_WORKSPACE_PLANES)
    821            static WorkspacePlane workspace_plane = PLANE_XY;
    822          #endif
    823          
    824          //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
    825          //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
    826          static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
    827          static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
    828          /*P
    829          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    830            static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    831            static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
    832            typedef void __void_##CONFIG##__
    833          */
    834          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    835          	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    836          	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
    837          

   \                                 In section .text, align 2, keep-with-next
    838          XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
   \                     _Z12base_min_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable136_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    839          XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
   \                     _Z12base_max_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable136_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    840          XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
   \                     _Z13base_home_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable136_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x69C0             LDR      R0,[R0, #+28]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    841          XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
   \                     _Z10max_length8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable136_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6A80             LDR      R0,[R0, #+40]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    842          XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
   \                     _Z12home_bump_mm8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable139
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    843          XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
   \                     _Z8home_dir8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable136_8
   \   00000004   0x5640             LDRSB    R0,[R0, R1]
   \   00000006   0x4770             BX       LR               ;; return
    844          
    845          /**
    846           * ***************************************************************************
    847           * ******************************** FUNCTIONS ********************************
    848           * ***************************************************************************
    849           */
    850          
    851          void stop();
    852          
    853          void get_available_commands();
    854          void process_next_command();
    855          void process_parsed_command();
    856          
    857          void get_cartesian_from_steppers();
    858          void set_current_from_steppers_for_axis(const AxisEnum axis);
    859          
    860          #if ENABLED(ARC_SUPPORT)
    861            void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
    862          #endif
    863          
    864          #if ENABLED(BEZIER_CURVE_SUPPORT)
    865            void plan_cubic_move(const float (&offset)[4]);
    866          #endif
    867          
    868          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
    869          void report_current_position();
    870          void report_current_position_detail();
    871          
    872          #if ENABLED(DEBUG_LEVELING_FEATURE)
    873            void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
    874              serialprintPGM(prefix);
    875              SERIAL_CHAR('(');
    876              SERIAL_ECHO(x);
    877              SERIAL_ECHOPAIR(", ", y);
    878              SERIAL_ECHOPAIR(", ", z);
    879              SERIAL_CHAR(')');
    880              if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
    881            }
    882          
    883            void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
    884              print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
    885            }
    886          
    887            #if 1//HAS_ABL
    888              void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
    889                print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
    890              }
    891            #endif
    892          
    893            #define DEBUG_POS(SUFFIX,VAR) do { \
    894              print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
    895          #endif
    896          
    897          /**
    898           * sync_plan_position
    899           *
    900           * Set the planner/stepper positions directly from current_position with
    901           * no kinematic translation. Used for homing axes and cartesian/core syncing.
    902           */

   \                                 In section .text, align 2, keep-with-next
    903          void sync_plan_position() {
    904            #if ENABLED(DEBUG_LEVELING_FEATURE)
    905              if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
    906            #endif
    907            planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
   \                     _Z18sync_plan_positionv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable136_4
   \   00000004   0xF100 0x0314      ADD      R3,R0,#+20
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x.... 0x....      B.W      _ZN7Planner15set_position_mmEfffRKf
    908          }

   \                                 In section .text, align 4
    909          inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
   \                     _Z20sync_plan_position_ev: (+1)
   \   00000000   0x4801             LDR.N    R0,??sync_plan_position_e_0
   \   00000002   0x.... 0x....      B.W      _ZN7Planner17set_e_position_mmERKf
   \   00000006   0xBF00             Nop      
   \                     ??sync_plan_position_e_0:
   \   00000008   0x........         DC32     mks_heating_busy+0x14
    910          
    911          //#if IS_KINEMATIC
    912          

   \                                 In section .text, align 4
    913            inline void sync_plan_position_kinematic() {
    914              #if ENABLED(DEBUG_LEVELING_FEATURE)
    915                if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
    916              #endif
    917              planner.set_position_mm_kinematic(current_position);
   \                     _Z28sync_plan_position_kinematicv: (+1)
   \   00000000   0x4801             LDR.N    R0,??sync_plan_position_kinematic_0
   \   00000002   0x.... 0x....      B.W      _ZN7Planner25set_position_mm_kinematicERA4_Kf
   \   00000006   0xBF00             Nop      
   \                     ??sync_plan_position_kinematic_0:
   \   00000008   0x........         DC32     mks_heating_busy+0x8
    918            }
    919          //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
    920          
    921          //#else
    922          
    923          //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
    924          
    925          //#endif
    926          

   \                                 In section .text, align 2, keep-with-next
    927          void SYNC_PLAN_POSITION_KINEMATIC()
    928          {
    929          	if(MACHINETPYE & IS_KINEMATIC)
   \                     _Z28SYNC_PLAN_POSITION_KINEMATICv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable136_5
   \   00000004   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000008   0xF240 0x3102      MOVW     R1,#+770
   \   0000000C   0x4208             TST      R0,R1
   \   0000000E   0xD001             BEQ.N    ??SYNC_PLAN_POSITION_KINEMATIC_0
    930          		sync_plan_position_kinematic();
   \   00000010   0x.... 0x....      B.W      _Z28sync_plan_position_kinematicv
    931          	else
    932          		sync_plan_position();
   \                     ??SYNC_PLAN_POSITION_KINEMATIC_0: (+1)
   \   00000014   0x....             B.N      _Z18sync_plan_positionv
    933          }
    934          
    935          #if 0//ENABLED(SDSUPPORT)
    936            #include "SdFatUtil.h"
    937            int freeMemory() { return SdFatUtil::FreeRam(); }
    938          #else
    939          /*
    940          extern "C" {
    941            extern char __bss_end;
    942            extern char __heap_start;
    943            extern void* __brkval;
    944          
    945            int freeMemory() {
    946              int free_memory;
    947              if ((int)__brkval == 0)
    948                free_memory = ((int)&free_memory) - ((int)&__bss_end);
    949              else
    950                free_memory = ((int)&free_memory) - ((int)__brkval);
    951              return free_memory;
    952            }
    953          }
    954          */

   \                                 In section .text, align 2, keep-with-next
    955          	int freeMemory() { return 4396; }	//No free ram management
   \                     _Z10freeMemoryv: (+1)
   \   00000000   0xF241 0x102C      MOVW     R0,#+4396
   \   00000004   0x4770             BX       LR               ;; return
    956          
    957          #endif // !SDSUPPORT
    958          
    959          #if ENABLED(DIGIPOT_I2C)
    960            extern void digipot_i2c_set_current(uint8_t channel, float current);
    961            extern void digipot_i2c_init();
    962          #endif
    963          
    964          /**
    965           * Inject the next "immediate" command, when possible, onto the front of the queue.
    966           * Return true if any immediate commands remain to inject.
    967           */

   \                                 In section .text, align 2, keep-with-next
    968          static bool drain_injected_commands_P() {
   \                     _Z25drain_injected_commands_Pv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    969            if (injected_commands_P != NULL) {
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable139_1
   \   00000008   0x6821             LDR      R1,[R4, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD01C             BEQ.N    ??drain_injected_commands_P_0
    970              size_t i = 0;
   \   0000000E   0x2500             MOVS     R5,#+0
    971              char c, cmd[30];
    972              //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
    973              strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
   \   00000010   0x221D             MOVS     R2,#+29
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       strncpy
    974              cmd[sizeof(cmd) - 1] = '\0';
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x7741             STRB     R1,[R0, #+29]
   \   0000001E   0xE000             B.N      ??drain_injected_commands_P_1
    975              while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
   \                     ??drain_injected_commands_P_2: (+1)
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \                     ??drain_injected_commands_P_1: (+1)
   \   00000022   0x562E             LDRSB    R6,[R5, R0]
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD001             BEQ.N    ??drain_injected_commands_P_3
   \   00000028   0x2E0A             CMP      R6,#+10
   \   0000002A   0xD1F9             BNE.N    ??drain_injected_commands_P_2
    976              cmd[i] = '\0';
   \                     ??drain_injected_commands_P_3: (+1)
   \   0000002C   0x5429             STRB     R1,[R5, R0]
    977              if (enqueue_and_echo_command(cmd))     // success?
   \   0000002E   0x.... 0x....      BL       _Z24enqueue_and_echo_commandPKcb
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD008             BEQ.N    ??drain_injected_commands_P_0
    978                injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD004             BEQ.N    ??drain_injected_commands_P_4
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x1828             ADDS     R0,R5,R0
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x6020             STR      R0,[R4, #+0]
   \   00000042   0xE001             B.N      ??drain_injected_commands_P_0
   \                     ??drain_injected_commands_P_4: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6020             STR      R0,[R4, #+0]
    979            }
    980            return (injected_commands_P != NULL);    // return whether any more remain
   \                     ??drain_injected_commands_P_0: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??drain_injected_commands_P_5
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??drain_injected_commands_P_6
   \                     ??drain_injected_commands_P_5: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??drain_injected_commands_P_6: (+1)
   \   00000054   0xB008             ADD      SP,SP,#+32
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    981          }
    982          
    983          /**
    984           * Record one or many commands to run from program memory.
    985           * Aborts the current queue, if any.
    986           * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
    987           */

   \                                 In section .text, align 2, keep-with-next
    988          void enqueue_and_echo_commands_P(const char * const pgcode) {
    989            injected_commands_P = pgcode;
   \                     _Z27enqueue_and_echo_commands_PPKc: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable139_1
   \   00000004   0x6008             STR      R0,[R1, #+0]
    990            drain_injected_commands_P(); // first command executed asap (when possible)
   \   00000006   0x....             B.N      _Z25drain_injected_commands_Pv
    991          }
    992          
    993          /**
    994           * Clear the Marlin command queue
    995           */

   \                                 In section .text, align 2, keep-with-next
    996          void clear_command_queue() {
    997            cmd_queue_index_r = cmd_queue_index_w;
   \                     _Z19clear_command_queuev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable139_2
   \   00000004   0x7A01             LDRB     R1,[R0, #+8]
   \   00000006   0x71C1             STRB     R1,[R0, #+7]
    998            commands_in_queue = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable136_4
   \   0000000E   0x7088             STRB     R0,[R1, #+2]
    999          }
   \   00000010   0x4770             BX       LR               ;; return
   1000          
   1001          /**
   1002           * Once a new command is in the ring buffer, call this to commit it
   1003           */

   \                                 In section .text, align 4
   1004          inline void _commit_command(bool say_ok) {
   1005            send_ok[cmd_queue_index_w] = say_ok;
   \                     _Z15_commit_commandb: (+1)
   \   00000000   0x4907             LDR.N    R1,??_commit_command_0
   \   00000002   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000004   0x1853             ADDS     R3,R2,R1
   \   00000006   0x7518             STRB     R0,[R3, #+20]
   1006            if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
   \   00000008   0x1C50             ADDS     R0,R2,#+1
   \   0000000A   0x7208             STRB     R0,[R1, #+8]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xDB01             BLT.N    ??_commit_command_1
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7208             STRB     R0,[R1, #+8]
   1007            commands_in_queue++;
   \                     ??_commit_command_1: (+1)
   \   00000016   0x4803             LDR.N    R0,??_commit_command_0+0x4
   \   00000018   0x7881             LDRB     R1,[R0, #+2]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
   1008          }
   \   0000001E   0x4770             BX       LR               ;; return
   \                     ??_commit_command_0:
   \   00000020   0x........         DC32     filament_loading_time_flg
   \   00000024   0x........         DC32     mks_heating_busy
   1009          
   1010          /**
   1011           * Copy a command from RAM into the main command buffer.
   1012           * Return true if the command was successfully added.
   1013           * Return false for a full buffer, or if the 'command' is a comment.
   1014           */

   \                                 In section .text, align 4
   1015          inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
   \                     _Z15_enqueuecommandPKcb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   1016            if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
   \   00000004   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000008   0x293B             CMP      R1,#+59
   \   0000000A   0xD003             BEQ.N    ??_enqueuecommand_0
   \   0000000C   0x490A             LDR.N    R1,??_enqueuecommand_1
   \   0000000E   0x7889             LDRB     R1,[R1, #+2]
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xDB01             BLT.N    ??_enqueuecommand_2
   \                     ??_enqueuecommand_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}
   1017            strcpy(command_queue[cmd_queue_index_w], cmd);
   \                     ??_enqueuecommand_2: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x4808             LDR.N    R0,??_enqueuecommand_1+0x4
   \   0000001C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000001E   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   00000022   0x4807             LDR.N    R0,??_enqueuecommand_1+0x8
   \   00000024   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \   00000028   0x.... 0x....      BL       strcpy
   1018            _commit_command(say_ok);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _Z15_commit_commandb
   1019            return true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   \   00000036   0xBF00             Nop      
   \                     ??_enqueuecommand_1:
   \   00000038   0x........         DC32     mks_heating_busy
   \   0000003C   0x........         DC32     filament_loading_time_flg
   \   00000040   0x........         DC32     command_queue
   1020          }
   1021          
   1022          /**
   1023           * Enqueue with Serial Echo
   1024           */

   \                                 In section .text, align 2, keep-with-next
   1025          bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
   \                     _Z24enqueue_and_echo_commandPKcb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1026            if (_enqueuecommand(cmd, say_ok)) {
   \   00000004   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??enqueue_and_echo_command_0
   1027              SERIAL_ECHO_START();
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable139_3
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1028              SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "enqueueing \\"">`
   \   0000001A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   1029              SERIAL_CHAR('"');
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable139_4
   \   00000022   0x2122             MOVS     R1,#+34
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1030              SERIAL_EOL();
   \   0000002A   0x210A             MOVS     R1,#+10
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1031              return true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD10             POP      {R4,PC}
   1032            }
   1033            return false;
   \                     ??enqueue_and_echo_command_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1034          }
   1035          

   \                                 In section .text, align 2, keep-with-next
   1036          void setup_killpin() {
   1037            #if HAS_KILL
   1038              SET_INPUT_PULLUP(KILL_PIN);
   1039            #endif
   1040          }
   \                     _Z13setup_killpinv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1041          
   1042          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   1043          

   \                                 In section .text, align 2, keep-with-next
   1044            void setup_filrunoutpin() {
   1045              #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
   1046                SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
   1047              #else
   1048                SET_INPUT(FIL_RUNOUT_PIN);
   1049              #endif
   1050            }
   \                     _Z18setup_filrunoutpinv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1051          
   1052          #endif
   1053          

   \                                 In section .text, align 2, keep-with-next
   1054          void setup_powerhold() {
   1055            #if HAS_SUICIDE
   1056              OUT_WRITE(SUICIDE_PIN, HIGH);
   1057            #endif
   1058            #if HAS_POWER_SWITCH
   1059              #if ENABLED(PS_DEFAULT_OFF)
   1060                OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   1061              #else
   1062                OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
   1063              #endif
   1064            #endif
   1065          }
   \                     _Z15setup_powerholdv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1066          

   \                                 In section .text, align 2, keep-with-next
   1067          void suicide() {
   1068            #if HAS_SUICIDE
   1069              OUT_WRITE(SUICIDE_PIN, LOW);
   1070            #endif
   1071          }
   \                     _Z7suicidev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1072          

   \                                 In section .text, align 2, keep-with-next
   1073          void servo_init() {
   1074            #if NUM_SERVOS >= 1 && HAS_SERVO_0
   1075              servo[0].attach(SERVO0_PIN);
   1076              servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
   1077            #endif
   1078            #if NUM_SERVOS >= 2 && HAS_SERVO_1
   1079              servo[1].attach(SERVO1_PIN);
   1080              servo[1].detach();
   1081            #endif
   1082            #if NUM_SERVOS >= 3 && HAS_SERVO_2
   1083              servo[2].attach(SERVO2_PIN);
   1084              servo[2].detach();
   1085            #endif
   1086            #if NUM_SERVOS >= 4 && HAS_SERVO_3
   1087              servo[3].attach(SERVO3_PIN);
   1088              servo[3].detach();
   1089            #endif
   1090          
   1091            #if HAS_Z_SERVO_ENDSTOP
   1092              /**
   1093               * Set position of Z Servo Endstop
   1094               *
   1095               * The servo might be deployed and positioned too low to stow
   1096               * when starting up the machine or rebooting the board.
   1097               * There's no way to know where the nozzle is positioned until
   1098               * homing has been done - no homing with z-probe without init!
   1099               *
   1100               */
   1101              STOW_Z_SERVO();
   1102            #endif
   1103          }
   \                     _Z10servo_initv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1104          
   1105          /**
   1106           * Stepper Reset (RigidBoard, et.al.)
   1107           */
   1108          #if HAS_STEPPER_RESET
   1109            void disableStepperDrivers() {
   1110              OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
   1111            }
   1112            void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
   1113          #endif
   1114          
   1115          #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
   1116          
   1117            void i2c_on_receive(int bytes) { // just echo all bytes received to serial
   1118              i2c.receive(bytes);
   1119            }
   1120          
   1121            void i2c_on_request() {          // just send dummy data for now
   1122              i2c.reply("Hello World!\n");
   1123            }
   1124          
   1125          #endif
   1126          

   \                                 In section .text, align 2, keep-with-next
   1127          void gcode_line_error(const char* err, bool doFlush = true) {
   \                     _Z16gcode_line_errorPKcb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1128            SERIAL_ERROR_START();
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable139_5
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1129            serialprintPGM(err);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1130            SERIAL_ERRORLN(gcode_LastN);
   \   00000014   0x.... 0x....      LDR.W    R4,??DataTable139_4
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable141
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0x6AF1             LDR      R1,[R6, #+44]
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1131            //Serial.println(gcode_N);
   1132            if (doFlush) FlushSerialRequestResend();
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD001             BEQ.N    ??gcode_line_error_0
   \   00000032   0x.... 0x....      BL       _Z24FlushSerialRequestResendv
   1133            serial_count = 0;
   \                     ??gcode_line_error_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6370             STR      R0,[R6, #+52]
   1134          }
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
   1135          
   1136          uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
   1137          
   1138          uint8_t from_wifi_flag = 0; // whether data comes from wifi model
   1139          
   1140          /**
   1141           * Get all commands waiting on the serial port and queue them.
   1142           * Exit when the buffer is full or when no more characters are
   1143           * left on the serial port.
   1144           */

   \                                 In section .text, align 4
   1145          inline void get_serial_commands() {
   \                     _Z19get_serial_commandsv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   1146            static char serial_line_buffer[MAX_CMD_SIZE];
   1147            static bool serial_comment_mode = false;
   1148            static millis_t last_wait_time = 0;
   1149            const millis_t wait_ms = millis();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x4606             MOV      R6,R0
   1150          
   1151            // If the command buffer is empty for too long,
   1152            // send "wait" to indicate Marlin is still waiting.
   1153            #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1154              static millis_t last_command_time = 0;
   1155              const millis_t ms = millis();
   1156              if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
   1157                SERIAL_ECHOLNPGM(MSG_WAIT);
   1158                last_command_time = ms;
   1159              }
   1160            #endif
   1161          #if 1
   1162            
   1163          	  /*5s?°ß?2a2?|®¨?????°ß2°ßoy?Y?°ß°„°ß°ß??a??°ß?D°ß°Èa?°ß2?????®∫??°ß|°ßo1°ß??wifi*/
   1164          	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
   \   0000000A   0x4C77             LDR.N    R4,??get_serial_commands_0
   \   0000000C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF040 0x80A4      BNE.W    ??get_serial_commands_1
   \   00000014   0x4875             LDR.N    R0,??get_serial_commands_0+0x4
   \   00000016   0x.... 0x....      BL       _ZN10USARTClass9availableEv
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF040 0x809E      BNE.W    ??get_serial_commands_1
   \   00000020   0x4873             LDR.N    R0,??get_serial_commands_0+0x8
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x1A71             SUBS     R1,R6,R1
   \   00000026   0xF5B1 0x717A      SUBS     R1,R1,#+1000
   \   0000002A   0xF100 0x8097      BMI.W    ??get_serial_commands_1
   1165          		if(serial_wait_tick <= 5)
   \   0000002E   0x4D71             LDR.N    R5,??get_serial_commands_0+0xC
   \   00000030   0x7A29             LDRB     R1,[R5, #+8]
   \   00000032   0x2906             CMP      R1,#+6
   \   00000034   0xDA01             BGE.N    ??get_serial_commands_2
   1166          	  {
   1167          		  serial_wait_tick ++;
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \   00000038   0x7229             STRB     R1,[R5, #+8]
   1168          	  }
   1169          		last_wait_time = wait_ms;
   \                     ??get_serial_commands_2: (+1)
   \   0000003A   0x6006             STR      R6,[R0, #+0]
   \   0000003C   0xE08E             B.N      ??get_serial_commands_1
   1170          	  }
   1171          #endif
   1172          
   1173            /**
   1174             * Loop while serial characters are incoming and the queue is not full
   1175             */
   1176            int c;
   1177            while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
   1178          
   1179              char serial_char = c;
   1180          	
   1181          	serial_wait_tick = 0;
   1182          	from_wifi_flag = 0;
   1183          
   1184              /**
   1185               * If the character ends the line
   1186               */
   1187              if (serial_char == '\n' || serial_char == '\r') {
   1188          
   1189                serial_comment_mode = false;                      // end of line == end of comment
   1190          
   1191                if (!serial_count) continue;                      // Skip empty lines
   1192          
   1193                serial_line_buffer[serial_count] = 0;             // Terminate string
   1194                serial_count = 0;                                 // Reset buffer
   1195          
   1196                char* command = serial_line_buffer;
   1197          
   1198                while (*command == ' ') command++;                // Skip leading spaces
   \                     ??get_serial_commands_3: (+1)
   \   0000003E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??get_serial_commands_4: (+1)
   \   00000040   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000044   0x2820             CMP      R0,#+32
   \   00000046   0xD0FA             BEQ.N    ??get_serial_commands_3
   1199                char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
   \   00000048   0x284E             CMP      R0,#+78
   \   0000004A   0xD101             BNE.N    ??get_serial_commands_5
   \   0000004C   0x46B9             MOV      R9,R7
   \   0000004E   0xE001             B.N      ??get_serial_commands_6
   \                     ??get_serial_commands_5: (+1)
   \   00000050   0xF04F 0x0900      MOV      R9,#+0
   1200          
   1201                if (npos) {
   \                     ??get_serial_commands_6: (+1)
   \   00000054   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000058   0xD04B             BEQ.N    ??get_serial_commands_7
   1202          
   1203                  bool M110 = strstr_P(command, PSTR("M110")) != NULL;
   \   0000005A   0x4967             LDR.N    R1,??get_serial_commands_0+0x10
   \   0000005C   0x4638             MOV      R0,R7
   \   0000005E   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD002             BEQ.N    ??get_serial_commands_8
   \   00000066   0xF04F 0x0801      MOV      R8,#+1
   \   0000006A   0xE001             B.N      ??get_serial_commands_9
   \                     ??get_serial_commands_8: (+1)
   \   0000006C   0xF04F 0x0800      MOV      R8,#+0
   1204          
   1205                  if (M110) {
   \                     ??get_serial_commands_9: (+1)
   \   00000070   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000074   0xD006             BEQ.N    ??get_serial_commands_10
   1206                    char* n2pos = strchr(command + 4, 'N');
   \   00000076   0x214E             MOVS     R1,#+78
   \   00000078   0x1D38             ADDS     R0,R7,#+4
   \   0000007A   0x.... 0x....      BL       _Z6strchrPci
   1207                    if (n2pos) npos = n2pos;
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD000             BEQ.N    ??get_serial_commands_10
   \   00000082   0x4681             MOV      R9,R0
   1208                  }
   1209          
   1210                  gcode_N = strtol(npos + 1, NULL, 10);
   \                     ??get_serial_commands_10: (+1)
   \   00000084   0x220A             MOVS     R2,#+10
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0xF109 0x0001      ADD      R0,R9,#+1
   \   0000008C   0x.... 0x....      BL       strtol
   \   00000090   0x62A8             STR      R0,[R5, #+40]
   1211          
   1212                  if (gcode_N != gcode_LastN + 1 && !M110) {
   \   00000092   0x6AE9             LDR      R1,[R5, #+44]
   \   00000094   0x1C49             ADDS     R1,R1,#+1
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD008             BEQ.N    ??get_serial_commands_11
   \   0000009A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000009E   0xD105             BNE.N    ??get_serial_commands_11
   1213                    gcode_line_error(PSTR(MSG_ERR_LINE_NO));
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x4856             LDR.N    R0,??get_serial_commands_0+0x14
   \   000000A4   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000A8   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1214                    return;
   1215                  }
   1216          
   1217                  char *apos = strrchr(command, '*');
   \                     ??get_serial_commands_11: (+1)
   \   000000AC   0x212A             MOVS     R1,#+42
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0x.... 0x....      BL       _Z7strrchrPci
   1218                  if (apos) {
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD06D             BEQ.N    ??get_serial_commands_12
   1219                    uint8_t checksum = 0, count = uint8_t(apos - command);
   \   000000B8   0xF04F 0x0800      MOV      R8,#+0
   \   000000BC   0x1BC1             SUBS     R1,R0,R7
   \   000000BE   0xE004             B.N      ??get_serial_commands_13
   1220                    while (count) checksum ^= command[--count];
   \                     ??get_serial_commands_14: (+1)
   \   000000C0   0x1E49             SUBS     R1,R1,#+1
   \   000000C2   0xB2C9             UXTB     R1,R1
   \   000000C4   0x57CA             LDRSB    R2,[R1, R7]
   \   000000C6   0xEA82 0x0808      EOR      R8,R2,R8
   \                     ??get_serial_commands_13: (+1)
   \   000000CA   0xB2C9             UXTB     R1,R1
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xD1F7             BNE.N    ??get_serial_commands_14
   1221                    if (strtol(apos + 1, NULL, 10) != checksum) {
   \   000000D0   0x220A             MOVS     R2,#+10
   \   000000D2   0x2100             MOVS     R1,#+0
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x.... 0x....      BL       strtol
   \   000000DA   0xFA5F 0xF888      UXTB     R8,R8
   \   000000DE   0x4540             CMP      R0,R8
   \   000000E0   0xD005             BEQ.N    ??get_serial_commands_15
   1222                      gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
   \   000000E2   0x2101             MOVS     R1,#+1
   \   000000E4   0x4846             LDR.N    R0,??get_serial_commands_0+0x18
   \   000000E6   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000EA   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1223                      return;
   1224                    }
   1225                  }
   1226                  else {
   1227                    gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
   1228                    return;
   1229                  }
   1230          
   1231                  gcode_LastN = gcode_N;
   \                     ??get_serial_commands_15: (+1)
   \   000000EE   0x6AA8             LDR      R0,[R5, #+40]
   \   000000F0   0x62E8             STR      R0,[R5, #+44]
   1232                }
   1233          
   1234                // Movement commands alert when stopped
   1235                if (IsStopped()) {
   \                     ??get_serial_commands_7: (+1)
   \   000000F2   0x.... 0x....      BL       _Z9IsStoppedv
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD013             BEQ.N    ??get_serial_commands_16
   1236                  char* gpos = strchr(command, 'G');
   \   000000FA   0x2147             MOVS     R1,#+71
   \   000000FC   0x4638             MOV      R0,R7
   \   000000FE   0x.... 0x....      BL       _Z6strchrPci
   1237                  if (gpos) {
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD00D             BEQ.N    ??get_serial_commands_16
   1238                    const int codenum = strtol(gpos + 1, NULL, 10);
   1239                    switch (codenum) {
   \   00000106   0x220A             MOVS     R2,#+10
   \   00000108   0x2100             MOVS     R1,#+0
   \   0000010A   0x1C40             ADDS     R0,R0,#+1
   \   0000010C   0x.... 0x....      BL       strtol
   \   00000110   0x2803             CMP      R0,#+3
   \   00000112   0xD806             BHI.N    ??get_serial_commands_16
   1240                      case 0:
   1241                      case 1:
   1242                      case 2:
   1243                      case 3:
   1244                        SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   00000114   0x483B             LDR.N    R0,??get_serial_commands_0+0x1C
   \   00000116   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1245                        LCD_MESSAGEPGM(MSG_STOPPED);
   \   0000011A   0x2100             MOVS     R1,#+0
   \   0000011C   0x483A             LDR.N    R0,??get_serial_commands_0+0x20
   \   0000011E   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   1246                        break;
   1247                    }
   1248                  }
   1249                }
   1250          
   1251                #if DISABLED(EMERGENCY_PARSER)
   1252                  // If command was e-stop process now
   1253                  if (strcmp(command, "M108") == 0) {
   \                     ??get_serial_commands_16: (+1)
   \   00000122   0x493A             LDR.N    R1,??get_serial_commands_0+0x24
   \   00000124   0x4638             MOV      R0,R7
   \   00000126   0x.... 0x....      BL       strcmp
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD101             BNE.N    ??get_serial_commands_17
   1254                    wait_for_heatup = false;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x7120             STRB     R0,[R4, #+4]
   1255                    #if ENABLED(ULTIPANEL)
   1256                      wait_for_user = false;
   1257                    #endif
   1258                  }
   1259                  if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_serial_commands_17: (+1)
   \   00000132   0x4937             LDR.N    R1,??get_serial_commands_0+0x28
   \   00000134   0x4638             MOV      R0,R7
   \   00000136   0x.... 0x....      BL       strcmp
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD102             BNE.N    ??get_serial_commands_18
   \   0000013E   0x4835             LDR.N    R0,??get_serial_commands_0+0x2C
   \   00000140   0x.... 0x....      BL       _Z4killPKc
   1260                  if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_serial_commands_18: (+1)
   \   00000144   0x4934             LDR.N    R1,??get_serial_commands_0+0x30
   \   00000146   0x4638             MOV      R0,R7
   \   00000148   0x.... 0x....      BL       strcmp
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD101             BNE.N    ??get_serial_commands_19
   \   00000150   0x.... 0x....      BL       _Z17quickstop_stepperv
   1261                #endif
   1262          
   1263                #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1264                  last_command_time = ms;
   1265                #endif
   1266          
   1267                // Add the command to the queue
   1268                _enqueuecommand(serial_line_buffer, true);
   \                     ??get_serial_commands_19: (+1)
   \   00000154   0x2101             MOVS     R1,#+1
   \   00000156   0x4630             MOV      R0,R6
   \   00000158   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_serial_commands_1: (+1)
   \   0000015C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000015E   0x2804             CMP      R0,#+4
   \   00000160   0xDA3F             BGE.N    ??get_serial_commands_20
   \   00000162   0x4E22             LDR.N    R6,??get_serial_commands_0+0x4
   \   00000164   0x4630             MOV      R0,R6
   \   00000166   0x.... 0x....      BL       _ZN10USARTClass4readEv
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD439             BMI.N    ??get_serial_commands_20
   \   0000016E   0xB240             SXTB     R0,R0
   \   00000170   0x4D20             LDR.N    R5,??get_serial_commands_0+0xC
   \   00000172   0x2100             MOVS     R1,#+0
   \   00000174   0x8129             STRH     R1,[R5, #+8]
   \   00000176   0x280A             CMP      R0,#+10
   \   00000178   0xD001             BEQ.N    ??get_serial_commands_21
   \   0000017A   0x280D             CMP      R0,#+13
   \   0000017C   0xD110             BNE.N    ??get_serial_commands_22
   \                     ??get_serial_commands_21: (+1)
   \   0000017E   0x4608             MOV      R0,R1
   \   00000180   0x4926             LDR.N    R1,??get_serial_commands_0+0x34
   \   00000182   0x7008             STRB     R0,[R1, #+0]
   \   00000184   0x6B69             LDR      R1,[R5, #+52]
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD0E8             BEQ.N    ??get_serial_commands_1
   \   0000018A   0x4E25             LDR.N    R6,??get_serial_commands_0+0x38
   \   0000018C   0x5588             STRB     R0,[R1, R6]
   \   0000018E   0x6368             STR      R0,[R5, #+52]
   \   00000190   0x4637             MOV      R7,R6
   \   00000192   0xE755             B.N      ??get_serial_commands_4
   \                     ??get_serial_commands_12: (+1)
   \   00000194   0x2101             MOVS     R1,#+1
   \   00000196   0x4823             LDR.N    R0,??get_serial_commands_0+0x3C
   \   00000198   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   0000019C   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1269              }
   1270              else if (serial_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_serial_commands_22: (+1)
   \   000001A0   0x6B69             LDR      R1,[R5, #+52]
   \   000001A2   0x295F             CMP      R1,#+95
   \   000001A4   0xDADA             BGE.N    ??get_serial_commands_1
   1271                // Keep fetching, but ignore normal characters beyond the max length
   1272                // The command will be injected when EOL is reached
   1273              }
   1274              else if (serial_char == '\\') {  // Handle escapes
   \   000001A6   0x285C             CMP      R0,#+92
   \   000001A8   0xD10E             BNE.N    ??get_serial_commands_23
   1275                if ((c = MYSERIAL.read()) >= 0) {
   \   000001AA   0x4630             MOV      R0,R6
   \   000001AC   0x.... 0x....      BL       _ZN10USARTClass4readEv
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD4D3             BMI.N    ??get_serial_commands_1
   1276                  // if we have one more character, copy it over
   1277                  serial_char = c;
   1278                  if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \   000001B4   0x4919             LDR.N    R1,??get_serial_commands_0+0x34
   \   000001B6   0x7809             LDRB     R1,[R1, #+0]
   \   000001B8   0x2900             CMP      R1,#+0
   \   000001BA   0xD1CF             BNE.N    ??get_serial_commands_1
   \   000001BC   0x6B69             LDR      R1,[R5, #+52]
   \   000001BE   0x4A18             LDR.N    R2,??get_serial_commands_0+0x38
   \   000001C0   0x5488             STRB     R0,[R1, R2]
   \   000001C2   0x1C48             ADDS     R0,R1,#+1
   \   000001C4   0x6368             STR      R0,[R5, #+52]
   \   000001C6   0xE7C9             B.N      ??get_serial_commands_1
   1279                }
   1280                // otherwise do nothing
   1281              }
   1282              else { // it's not a newline, carriage return or escape char
   1283                if (serial_char == ';') serial_comment_mode = true;
   \                     ??get_serial_commands_23: (+1)
   \   000001C8   0x4A14             LDR.N    R2,??get_serial_commands_0+0x34
   \   000001CA   0x283B             CMP      R0,#+59
   \   000001CC   0xD101             BNE.N    ??get_serial_commands_24
   \   000001CE   0x2301             MOVS     R3,#+1
   \   000001D0   0x7013             STRB     R3,[R2, #+0]
   1284                if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \                     ??get_serial_commands_24: (+1)
   \   000001D2   0x7812             LDRB     R2,[R2, #+0]
   \   000001D4   0x2A00             CMP      R2,#+0
   \   000001D6   0xD1C1             BNE.N    ??get_serial_commands_1
   \   000001D8   0x4A11             LDR.N    R2,??get_serial_commands_0+0x38
   \   000001DA   0x5488             STRB     R0,[R1, R2]
   \   000001DC   0x1C48             ADDS     R0,R1,#+1
   \   000001DE   0x6368             STR      R0,[R5, #+52]
   \   000001E0   0xE7BC             B.N      ??get_serial_commands_1
   1285              }
   1286          
   1287            } // queue has space, serial has data
   1288          }
   \                     ??get_serial_commands_20: (+1)
   \   000001E2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \   000001E6   0xBF00             Nop      
   \                     ??get_serial_commands_0:
   \   000001E8   0x........         DC32     mks_heating_busy
   \   000001EC   0x........         DC32     Serial3
   \   000001F0   0x........         DC32     _ZZ19get_serial_commandsvE14last_wait_time
   \   000001F4   0x........         DC32     axis_relative_modes
   \   000001F8   0x........         DC32     _ZZ19get_serial_commandsvEs
   \   000001FC   0x........         DC32     _ZZ19get_serial_commandsvEs_0
   \   00000200   0x........         DC32     _ZZ19get_serial_commandsvEs_1
   \   00000204   0x........         DC32     _ZZ19get_serial_commandsvEs_3
   \   00000208   0x........         DC32     _ZZ19get_serial_commandsvEs_4
   \   0000020C   0x........         DC32     _ZZ19get_serial_commandsvEs_5
   \   00000210   0x........         DC32     _ZZ19get_serial_commandsvEs_6
   \   00000214   0x........         DC32     _ZZ19get_serial_commandsvEs_7
   \   00000218   0x........         DC32     _ZZ19get_serial_commandsvEs_8
   \   0000021C   0x........         DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
   \   00000220   0x........         DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
   \   00000224   0x........         DC32     _ZZ19get_serial_commandsvEs_2
   1289          
   1290          #if ENABLED(SDSUPPORT)
   1291          
   1292          uint8_t sd_read_error_flg=0;
   1293          uint8_t sd_read_cnt=0;
   1294          

   \                                 In section .text, align 2, keep-with-next
   1295          void display_sd_error()
   1296          {
   \                     _Z16display_sd_errorv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   1297            char buf_sd_err[30]={0};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
   1298            
   1299            if(sd_read_error_flg == 1)
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable139_2
   \   00000010   0x7A60             LDRB     R0,[R4, #+9]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD119             BNE.N    ??display_sd_error_0
   1300            {
   1301                GUI_SetBkColor(gCfgItems.background_color);
   \   00000016   0x.... 0x....      LDR.W    R5,??DataTable141_1
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0x.... 0x....      BL       GUI_SetBkColor
   1302                GUI_SetColor(0X0000ff);//   o®¨®¶?°¡?®¨?
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x.... 0x....      BL       GUI_SetColor
   1303                //memset(buf_sd_err,' ',sizeof(buf_sd_err)-1);
   1304                //GUI_DispStringAt(buf_sd_err,250, TITLE_YPOS);
   1305                sprintf(buf_sd_err,"sd:%d",sd_read_cnt);
   \   00000026   0x7AA2             LDRB     R2,[R4, #+10]
   \   00000028   0x.... 0x....      ADR.W    R1,`?<Constant "sd:%d">`
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       sprintf
   1306                GUI_DispStringAt(buf_sd_err,400, TITLE_YPOS);
   \   00000032   0x2205             MOVS     R2,#+5
   \   00000034   0xF44F 0x71C8      MOV      R1,#+400
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       GUI_DispStringAt
   1307                GUI_SetBkColor(gCfgItems.background_color);
   \   0000003E   0x6868             LDR      R0,[R5, #+4]
   \   00000040   0x.... 0x....      BL       GUI_SetBkColor
   1308                GUI_SetColor(gCfgItems.title_color);            
   \   00000044   0x68A8             LDR      R0,[R5, #+8]
   \   00000046   0x.... 0x....      BL       GUI_SetColor
   1309            }
   1310          }
   \                     ??display_sd_error_0: (+1)
   \   0000004A   0xB009             ADD      SP,SP,#+36
   \   0000004C   0xBD30             POP      {R4,R5,PC}       ;; return
   1311          
   1312          
   1313            /**
   1314             * Get commands from the SD Card until the command buffer is full
   1315             * or until the end of the file is reached. The special character '#'
   1316             * can also interrupt buffering.
   1317             */

   \                                 In section .text, align 4
   1318            inline void get_sdcard_commands() {
   \                     _Z19get_sdcard_commandsv: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   1319              static bool stop_buffering = false,
   1320                          sd_comment_mode = false;
   1321          
   1322              if (!card.sdprinting) return;
   \   00000004   0x4C72             LDR.N    R4,??get_sdcard_commands_0
   \   00000006   0xF894 0x0760      LDRB     R0,[R4, #+1888]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xF000 0x80DD      BEQ.W    ??get_sdcard_commands_1
   1323          
   1324              /**
   1325               * '#' stops reading from SD to the buffer prematurely, so procedural
   1326               * macro calls are possible. If it occurs, stop_buffering is triggered
   1327               * and the buffer is run dry; this character _can_ occur in serial com
   1328               * due to checksums, however, no checksums are used in SD printing.
   1329               */
   1330          
   1331              if (commands_in_queue == 0) stop_buffering = false;
   \   00000010   0x4D70             LDR.N    R5,??get_sdcard_commands_0+0x4
   \   00000012   0x78A8             LDRB     R0,[R5, #+2]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??get_sdcard_commands_2
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x496F             LDR.N    R1,??get_sdcard_commands_0+0x8
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   1332          
   1333              uint16_t sd_count = 0;
   \                     ??get_sdcard_commands_2: (+1)
   \   0000001E   0x2600             MOVS     R6,#+0
   1334              bool card_eof = card.eof();
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \   00000026   0x4681             MOV      R9,R0
   \   00000028   0x4F6B             LDR.N    R7,??get_sdcard_commands_0+0x8
   \   0000002A   0xE05C             B.N      ??get_sdcard_commands_3
   1335              while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
   1336                const int16_t n = card.get();
   1337                char sd_char = (char)n;//^0x08;
   1338                card_eof = card.eof();
   1339                if (card_eof || n == -1
   1340                    || sd_char == '\n' || sd_char == '\r'
   1341                    || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
   1342                ) {
   1343                  if (card_eof) {
   1344                    gCfgItems.breakpoint_reprint_flg = 0;
   1345                    gCfgItems.breakpoint_z_pos = 0;
   1346                    gCfgItems.breakpoint_flg=0;
   1347          
   1348                    card.printingHasFinished();
   1349          
   1350                    if (card.sdprinting)
   1351                      sd_count = 0; // If a sub-file was printing, continue from call point
   1352                    else {
   1353                      SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
   1354                      #if ENABLED(PRINTER_EVENT_LEDS)
   1355                        LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
   1356                        leds.set_green();
   1357                        #if HAS_RESUME_CONTINUE
   1358                          enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
   1359                        #else
   1360                          safe_delay(1000);
   1361                        #endif
   1362                        leds.set_off();
   1363                      #endif
   1364                      card.checkautostart(true);
   1365          			
   1366          			#if 1
   1367          			
   1368          			
   1369          			//°‰®∞®™®∫1??®≤?°Í
   1370          			//if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
   1371          			//    Close_machine_display();
   1372          
   1373                      #endif 				
   1374                    }
   1375                  }
   1376                  else if (n == -1) {
   \                     ??get_sdcard_commands_4: (+1)
   \   0000002C   0xF11A 0x0F01      CMN      R10,#+1
   \   00000030   0xD141             BNE.N    ??get_sdcard_commands_5
   1377                    SERIAL_ERROR_START();
   \   00000032   0x486A             LDR.N    R0,??get_sdcard_commands_0+0xC
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1378                    SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
   \   00000038   0x4869             LDR.N    R0,??get_sdcard_commands_0+0x10
   \   0000003A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1379                    //sd_count++;
   1380                    //card.cardOK=false;
   1381                    //commands_in_queue+=1;
   1382                    //sdpos_bak=card.sdpos;
   1383                    //card.sdprinting=false;
   1384                    SD_Init();
   \   0000003E   0x.... 0x....      BL       SD_Init
   1385                    card.initsd();
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN10CardReader6initsdEv
   1386                    if(card.reopenfile(curFileName))
   \   00000048   0x4966             LDR.N    R1,??get_sdcard_commands_0+0x14
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       _ZN10CardReader10reopenfileEPc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD004             BEQ.N    ??get_sdcard_commands_6
   1387                    {
   1388                      card.setIndex(card.sdpos);
   \   00000054   0xF8D4 0x1460      LDR      R1,[R4, #+1120]
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   1389                    }
   1390                    memset(command_queue[cmd_queue_index_w],0,sizeof(command_queue[cmd_queue_index_w]));
   \                     ??get_sdcard_commands_6: (+1)
   \   0000005E   0xF8DF 0xA188      LDR.W    R10,??get_sdcard_commands_0+0x18
   \   00000062   0x2260             MOVS     R2,#+96
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xF89A 0x0008      LDRB     R0,[R10, #+8]
   \   0000006A   0xEB00 0x0340      ADD      R3,R0,R0, LSL #+1
   \   0000006E   0x485F             LDR.N    R0,??get_sdcard_commands_0+0x1C
   \   00000070   0xEB00 0x1043      ADD      R0,R0,R3, LSL #+5
   \   00000074   0x.... 0x....      BL       memset
   1391                    //GUI_TOUCH_Exec(); 	  
   1392                    //GUI_Exec();
   1393                    	  #if 1
   1394          		  thermalManager.manage_heater();
   \   00000078   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   1395          		  
   1396          		  display_temper_error();
   \   0000007C   0x.... 0x....      BL       _Z20display_temper_errorv
   1397          		  
   1398          		  //wifi_looping();
   1399          		  
   1400          		  if(wifi_link_state != WIFI_TRANS_FILE)
   \   00000080   0x485B             LDR.N    R0,??get_sdcard_commands_0+0x20
   \   00000082   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000086   0x2810             CMP      R0,#+16
   \   00000088   0xD001             BEQ.N    ??get_sdcard_commands_7
   1401          		  {
   1402          			  GUI_RefreshPage();
   \   0000008A   0x.... 0x....      BL       GUI_RefreshPage
   1403          		  }
   1404          		  #if defined(TFT70)
   1405          		  disp_pre_gcode(3,40);
   1406          		  #elif defined(TFT35)
   1407          		  //#if defined(MKS_ROBIN2)
   1408          		  if(preview_no_display != 1)
   \                     ??get_sdcard_commands_7: (+1)
   \   0000008E   0xF89A 0x0005      LDRB     R0,[R10, #+5]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD003             BEQ.N    ??get_sdcard_commands_8
   1409          		  {
   1410          			  disp_pre_gcode(2,36);
   \   00000096   0x2124             MOVS     R1,#+36
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x.... 0x....      BL       disp_pre_gcode
   1411          		  }
   1412          		  //#endif
   1413          		  #endif
   1414          		  
   1415          		  GUI_TOUCH_Exec(); 	  
   \                     ??get_sdcard_commands_8: (+1)
   \   0000009E   0x.... 0x....      BL       GUI_TOUCH_Exec
   1416          		  GUI_Exec(); 
   \   000000A2   0x.... 0x....      BL       GUI_Exec
   1417          
   1418          		#endif
   1419          
   1420                    sd_read_error_flg=1;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xF88A 0x0009      STRB     R0,[R10, #+9]
   1421                    sd_read_cnt++;
   \   000000AC   0xF89A 0x000A      LDRB     R0,[R10, #+10]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0xF88A 0x000A      STRB     R0,[R10, #+10]
   1422                  }
   1423                  if (sd_char == '#') stop_buffering = true;
   \                     ??get_sdcard_commands_5: (+1)
   \   000000B6   0xF1B8 0x0F23      CMP      R8,#+35
   \   000000BA   0xD101             BNE.N    ??get_sdcard_commands_9
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x7038             STRB     R0,[R7, #+0]
   1424          
   1425                  sd_comment_mode = false; // for new command
   \                     ??get_sdcard_commands_9: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x494C             LDR.N    R1,??get_sdcard_commands_0+0x24
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   1426          
   1427                  if (!sd_count) continue; // skip empty lines (and comment lines)
   \   000000C6   0xB2B6             UXTH     R6,R6
   \   000000C8   0x2E00             CMP      R6,#+0
   \   000000CA   0xD00C             BEQ.N    ??get_sdcard_commands_3
   1428          
   1429                  command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
   \   000000CC   0x4846             LDR.N    R0,??get_sdcard_commands_0+0x18
   \   000000CE   0x7A00             LDRB     R0,[R0, #+8]
   \   000000D0   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   000000D4   0x4845             LDR.N    R0,??get_sdcard_commands_0+0x1C
   \   000000D6   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0x5431             STRB     R1,[R6, R0]
   1430                  sd_count = 0; // clear sd line buffer
   \   000000DE   0x460E             MOV      R6,R1
   1431          
   1432                  _commit_command(false);
   \   000000E0   0x4608             MOV      R0,R1
   \   000000E2   0x.... 0x....      BL       _Z15_commit_commandb
   \                     ??get_sdcard_commands_3: (+1)
   \   000000E6   0x78A8             LDRB     R0,[R5, #+2]
   \   000000E8   0x2804             CMP      R0,#+4
   \   000000EA   0xDA6E             BGE.N    ??get_sdcard_commands_1
   \   000000EC   0x7838             LDRB     R0,[R7, #+0]
   \   000000EE   0xEA50 0x0009      ORRS     R0,R0,R9
   \   000000F2   0xD16A             BNE.N    ??get_sdcard_commands_1
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0x.... 0x....      BL       _ZN10CardReader3getEv
   \   000000FA   0x4682             MOV      R10,R0
   \   000000FC   0x46D0             MOV      R8,R10
   \   000000FE   0xFA4F 0xF888      SXTB     R8,R8
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \   00000108   0x4681             MOV      R9,R0
   \   0000010A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000010E   0xD112             BNE.N    ??get_sdcard_commands_10
   \   00000110   0xF11A 0x0F01      CMN      R10,#+1
   \   00000114   0xD00F             BEQ.N    ??get_sdcard_commands_10
   \   00000116   0xF1B8 0x0F0A      CMP      R8,#+10
   \   0000011A   0xD00C             BEQ.N    ??get_sdcard_commands_10
   \   0000011C   0xF1B8 0x0F0D      CMP      R8,#+13
   \   00000120   0xD009             BEQ.N    ??get_sdcard_commands_10
   \   00000122   0xF1B8 0x0F23      CMP      R8,#+35
   \   00000126   0xD002             BEQ.N    ??get_sdcard_commands_11
   \   00000128   0xF1B8 0x0F3A      CMP      R8,#+58
   \   0000012C   0xD120             BNE.N    ??get_sdcard_commands_12
   \                     ??get_sdcard_commands_11: (+1)
   \   0000012E   0x4831             LDR.N    R0,??get_sdcard_commands_0+0x24
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD11C             BNE.N    ??get_sdcard_commands_12
   \                     ??get_sdcard_commands_10: (+1)
   \   00000136   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000013A   0xF43F 0xAF77      BEQ.W    ??get_sdcard_commands_4
   \   0000013E   0x482E             LDR.N    R0,??get_sdcard_commands_0+0x28
   \   00000140   0x2100             MOVS     R1,#+0
   \   00000142   0xF880 0x1148      STRB     R1,[R0, #+328]
   \   00000146   0xF8C0 0x1298      STR      R1,[R0, #+664]
   \   0000014A   0xF880 0x1155      STRB     R1,[R0, #+341]
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0x.... 0x....      BL       _ZN10CardReader19printingHasFinishedEv
   \   00000154   0xF894 0x0760      LDRB     R0,[R4, #+1888]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD001             BEQ.N    ??get_sdcard_commands_13
   \   0000015C   0x2600             MOVS     R6,#+0
   \   0000015E   0xE7AA             B.N      ??get_sdcard_commands_5
   \                     ??get_sdcard_commands_13: (+1)
   \   00000160   0x4826             LDR.N    R0,??get_sdcard_commands_0+0x2C
   \   00000162   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000166   0x2101             MOVS     R1,#+1
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0x.... 0x....      BL       _ZN10CardReader14checkautostartEb
   \   0000016E   0xE7A2             B.N      ??get_sdcard_commands_5
   1433                }
   1434                else if (sd_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_sdcard_commands_12: (+1)
   \   00000170   0xB2B6             UXTH     R6,R6
   \   00000172   0x4630             MOV      R0,R6
   \   00000174   0x285F             CMP      R0,#+95
   \   00000176   0xDAB6             BGE.N    ??get_sdcard_commands_3
   1435                  /**
   1436                   * Keep fetching, but ignore normal characters beyond the max length
   1437                   * The command will be injected when EOL is reached
   1438                   */
   1439                }
   1440                else {
   1441                  if (sd_char == ';') sd_comment_mode = true;
   \   00000178   0x491E             LDR.N    R1,??get_sdcard_commands_0+0x24
   \   0000017A   0xF1B8 0x0F3B      CMP      R8,#+59
   \   0000017E   0xD101             BNE.N    ??get_sdcard_commands_14
   \   00000180   0x2201             MOVS     R2,#+1
   \   00000182   0x700A             STRB     R2,[R1, #+0]
   1442                  //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
   1443                  if (!sd_comment_mode) 
   \                     ??get_sdcard_commands_14: (+1)
   \   00000184   0x7809             LDRB     R1,[R1, #+0]
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD1AD             BNE.N    ??get_sdcard_commands_3
   1444                  {
   1445          			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
   \   0000018A   0x4917             LDR.N    R1,??get_sdcard_commands_0+0x18
   \   0000018C   0x7A09             LDRB     R1,[R1, #+8]
   \   0000018E   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000192   0x4916             LDR.N    R1,??get_sdcard_commands_0+0x1C
   \   00000194   0xEB01 0x1142      ADD      R1,R1,R2, LSL #+5
   \   00000198   0xF800 0x8001      STRB     R8,[R0, R1]
   \   0000019C   0x1C76             ADDS     R6,R6,#+1
   1446          			if(sd_char == 0x5a ) //"Z"
   \   0000019E   0xF1B8 0x0F5A      CMP      R8,#+90
   \   000001A2   0xD1A0             BNE.N    ??get_sdcard_commands_3
   1447          			{
   1448          				mksReprint.sdpos = card.getsdpos()-3;	//"°§?2?????"
   \   000001A4   0x4620             MOV      R0,R4
   \   000001A6   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   000001AA   0x1EC0             SUBS     R0,R0,#+3
   \   000001AC   0xF8C4 0x0820      STR      R0,[R4, #+2080]
   1449          				#if 1
   1450          				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bak¶Ã?®®Y??¶Ã?°Í????°‰®∫1®Æ?
   \   000001B0   0xF604 0x0020      ADDW     R0,R4,#+2080
   \   000001B4   0xF8D4 0x1820      LDR      R1,[R4, #+2080]
   \   000001B8   0x6041             STR      R1,[R0, #+4]
   1451          				if(gCfgItems.pwroff_save_mode != 1)//sd?°ß°¿°Í°‰???¶Ã?®∫y?Y
   \   000001BA   0x490F             LDR.N    R1,??get_sdcard_commands_0+0x28
   \   000001BC   0xF891 0x119F      LDRB     R1,[R1, #+415]
   \   000001C0   0x2901             CMP      R1,#+1
   \   000001C2   0xD090             BEQ.N    ??get_sdcard_commands_3
   1452                          #endif
   1453          					mksReprint.refresh = true;
   \   000001C4   0x2101             MOVS     R1,#+1
   \   000001C6   0x7401             STRB     R1,[R0, #+16]
   \   000001C8   0xE78D             B.N      ??get_sdcard_commands_3
   1454          			}
   1455                  }        
   1456                }
   1457              }
   1458            }
   \                     ??get_sdcard_commands_1: (+1)
   \   000001CA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \   000001CE   0xBF00             Nop      
   \                     ??get_sdcard_commands_0:
   \   000001D0   0x........         DC32     card
   \   000001D4   0x........         DC32     mks_heating_busy
   \   000001D8   0x........         DC32     _ZZ19get_sdcard_commandsvE14stop_buffering
   \   000001DC   0x........         DC32     errormagic
   \   000001E0   0x........         DC32     _ZZ19get_sdcard_commandsvEs_0
   \   000001E4   0x........         DC32     curFileName
   \   000001E8   0x........         DC32     filament_loading_time_flg
   \   000001EC   0x........         DC32     command_queue
   \   000001F0   0x........         DC32     wifi_link_state
   \   000001F4   0x........         DC32     _ZZ19get_sdcard_commandsvE15sd_comment_mode
   \   000001F8   0x........         DC32     gCfgItems
   \   000001FC   0x........         DC32     _ZZ19get_sdcard_commandsvEs
   1459          
   1460          #endif // SDSUPPORT
   1461          #if 1

   \                                 In section .text, align 4
   1462          inline void get_wifi_commands() {
   \                     _Z17get_wifi_commandsv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1463            static char wifi_line_buffer[MAX_CMD_SIZE];
   1464            static bool wifi_comment_mode = false;
   1465          
   1466            if(serial_wait_tick > 5)
   \   00000002   0x4C3B             LDR.N    R4,??get_wifi_commands_0
   \   00000004   0x7A20             LDRB     R0,[R4, #+8]
   \   00000006   0x2806             CMP      R0,#+6
   \   00000008   0xDB6E             BLT.N    ??get_wifi_commands_1
   1467            {
   1468            	from_wifi_flag = 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7260             STRB     R0,[R4, #+9]
   \   0000000E   0x4D39             LDR.N    R5,??get_wifi_commands_0+0x4
   \   00000010   0xE039             B.N      ??get_wifi_commands_2
   1469          
   1470          /**
   1471          	   * Loop while serial characters are incoming and the queue is not full
   1472          	   */
   1473          	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
   1474          
   1475          	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
   1476          
   1477          	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
   1478          
   1479          	    /**
   1480          	     * If the character ends the line
   1481          	     */
   1482          	    if (wifi_char == '\n' || wifi_char == '\r') {
   1483          
   1484          	      wifi_comment_mode = false; // end of line == end of comment
   1485          
   1486          	      if (!wifi_read_count) continue; // skip empty lines
   1487          
   1488          	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
   1489          	      wifi_read_count = 0; //reset buffer
   1490          
   1491          	      char* command = wifi_line_buffer;
   1492          
   1493          	      while (*command == ' ') command++; // skip any leading spaces	    
   \                     ??get_wifi_commands_3: (+1)
   \   00000012   0x1C7F             ADDS     R7,R7,#+1
   \                     ??get_wifi_commands_4: (+1)
   \   00000014   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xD0FA             BEQ.N    ??get_wifi_commands_3
   1494          
   1495          	      // Movement commands alert when stopped
   1496          	      if (IsStopped()) {
   \   0000001C   0x.... 0x....      BL       _Z9IsStoppedv
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD013             BEQ.N    ??get_wifi_commands_5
   1497          	        char* gpos = strchr(command, 'G');
   \   00000024   0x2147             MOVS     R1,#+71
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       _Z6strchrPci
   1498          	        if (gpos) {
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00D             BEQ.N    ??get_wifi_commands_5
   1499          	          const int codenum = strtol(gpos + 1, NULL, 10);
   1500          	          switch (codenum) {
   \   00000030   0x220A             MOVS     R2,#+10
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x.... 0x....      BL       strtol
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD806             BHI.N    ??get_wifi_commands_5
   1501          	            case 0:
   1502          	            case 1:
   1503          	            case 2:
   1504          	            case 3:
   1505          	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   0000003E   0x482E             LDR.N    R0,??get_wifi_commands_0+0x8
   \   00000040   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1506          	              LCD_MESSAGEPGM(MSG_STOPPED);
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x482D             LDR.N    R0,??get_wifi_commands_0+0xC
   \   00000048   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   1507          	              break;
   1508          	          }
   1509          	        }
   1510          	      }
   1511          
   1512          	      #if DISABLED(EMERGENCY_PARSER)
   1513          	        // If command was e-stop process now
   1514          	        if (strcmp(command, "M108") == 0) {
   \                     ??get_wifi_commands_5: (+1)
   \   0000004C   0x492C             LDR.N    R1,??get_wifi_commands_0+0x10
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       strcmp
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD101             BNE.N    ??get_wifi_commands_6
   1515          	          wait_for_heatup = false;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7128             STRB     R0,[R5, #+4]
   1516          	          #if ENABLED(ULTIPANEL)
   1517          	            wait_for_user = false;
   1518          	          #endif
   1519          	        }
   1520          	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_wifi_commands_6: (+1)
   \   0000005C   0x4929             LDR.N    R1,??get_wifi_commands_0+0x14
   \   0000005E   0x4638             MOV      R0,R7
   \   00000060   0x.... 0x....      BL       strcmp
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD102             BNE.N    ??get_wifi_commands_7
   \   00000068   0x4827             LDR.N    R0,??get_wifi_commands_0+0x18
   \   0000006A   0x.... 0x....      BL       _Z4killPKc
   1521          	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_wifi_commands_7: (+1)
   \   0000006E   0x4927             LDR.N    R1,??get_wifi_commands_0+0x1C
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0x.... 0x....      BL       strcmp
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD101             BNE.N    ??get_wifi_commands_8
   \   0000007A   0x.... 0x....      BL       _Z17quickstop_stepperv
   1522          	      #endif
   1523          
   1524          	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1525          	        last_command_time = ms;
   1526          	      #endif
   1527          
   1528          	      // Add the command to the queue
   1529          	      _enqueuecommand(wifi_line_buffer, true);
   \                     ??get_wifi_commands_8: (+1)
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x4630             MOV      R0,R6
   \   00000082   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_wifi_commands_2: (+1)
   \   00000086   0x78A8             LDRB     R0,[R5, #+2]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0xDA2F             BGE.N    ??get_wifi_commands_9
   \   0000008C   0x4920             LDR.N    R1,??get_wifi_commands_0+0x20
   \   0000008E   0x6E0A             LDR      R2,[R1, #+96]
   \   00000090   0x6E48             LDR      R0,[R1, #+100]
   \   00000092   0x4282             CMP      R2,R0
   \   00000094   0xD02A             BEQ.N    ??get_wifi_commands_9
   \   00000096   0x5650             LDRSB    R0,[R2, R1]
   \   00000098   0x1C52             ADDS     R2,R2,#+1
   \   0000009A   0x2360             MOVS     R3,#+96
   \   0000009C   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \   000000A0   0xEB03 0x0643      ADD      R6,R3,R3, LSL #+1
   \   000000A4   0xEBA2 0x1246      SUB      R2,R2,R6, LSL #+5
   \   000000A8   0x660A             STR      R2,[R1, #+96]
   \   000000AA   0x280A             CMP      R0,#+10
   \   000000AC   0xD001             BEQ.N    ??get_wifi_commands_10
   \   000000AE   0x280D             CMP      R0,#+13
   \   000000B0   0xD10A             BNE.N    ??get_wifi_commands_11
   \                     ??get_wifi_commands_10: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x4917             LDR.N    R1,??get_wifi_commands_0+0x24
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
   \   000000B8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000BA   0x2900             CMP      R1,#+0
   \   000000BC   0xD0E3             BEQ.N    ??get_wifi_commands_2
   \   000000BE   0x4E16             LDR.N    R6,??get_wifi_commands_0+0x28
   \   000000C0   0x5588             STRB     R0,[R1, R6]
   \   000000C2   0x63A0             STR      R0,[R4, #+56]
   \   000000C4   0x4637             MOV      R7,R6
   \   000000C6   0xE7A5             B.N      ??get_wifi_commands_4
   1530          	    }
   1531          	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_wifi_commands_11: (+1)
   \   000000C8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000CA   0x295F             CMP      R1,#+95
   \   000000CC   0xDADB             BGE.N    ??get_wifi_commands_2
   1532          	      // Keep fetching, but ignore normal characters beyond the max length
   1533          	      // The command will be injected when EOL is reached
   1534          	    }
   1535          		/*
   1536          	    else if (wifi_char == '\\') {  // Handle escapes
   1537          	      if (MYSERIAL.available() > 0) {
   1538          	        // if we have one more character, copy it over
   1539          	        wifi_char = MYSERIAL.read();
   1540          	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   1541          	      }
   1542          	      // otherwise do nothing
   1543          	    }*/
   1544          	    else { // it's not a newline, carriage return or escape char
   1545          	      if (wifi_char == ';') wifi_comment_mode = true;
   \   000000CE   0x4A11             LDR.N    R2,??get_wifi_commands_0+0x24
   \   000000D0   0x283B             CMP      R0,#+59
   \   000000D2   0xD101             BNE.N    ??get_wifi_commands_12
   \   000000D4   0x2301             MOVS     R3,#+1
   \   000000D6   0x7013             STRB     R3,[R2, #+0]
   1546          	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
   \                     ??get_wifi_commands_12: (+1)
   \   000000D8   0x7812             LDRB     R2,[R2, #+0]
   \   000000DA   0x2A00             CMP      R2,#+0
   \   000000DC   0xD1D3             BNE.N    ??get_wifi_commands_2
   \   000000DE   0x4A0E             LDR.N    R2,??get_wifi_commands_0+0x28
   \   000000E0   0x5488             STRB     R0,[R1, R2]
   \   000000E2   0x1C48             ADDS     R0,R1,#+1
   \   000000E4   0x63A0             STR      R0,[R4, #+56]
   \   000000E6   0xE7CE             B.N      ??get_wifi_commands_2
   1547          	    }
   1548          
   1549          	  }
   1550              }// queue has space, serial has data
   1551              else
   1552              {
   1553              	from_wifi_flag = 0;
   \                     ??get_wifi_commands_1: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x7260             STRB     R0,[R4, #+9]
   1554              }
   1555          }
   \                     ??get_wifi_commands_9: (+1)
   \   000000EC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \   000000EE   0xBF00             Nop      
   \                     ??get_wifi_commands_0:
   \   000000F0   0x........         DC32     axis_relative_modes
   \   000000F4   0x........         DC32     mks_heating_busy
   \   000000F8   0x........         DC32     _ZZ17get_wifi_commandsvEs
   \   000000FC   0x........         DC32     _ZZ17get_wifi_commandsvEs_0
   \   00000100   0x........         DC32     _ZZ17get_wifi_commandsvEs_1
   \   00000104   0x........         DC32     _ZZ17get_wifi_commandsvEs_2
   \   00000108   0x........         DC32     _ZZ17get_wifi_commandsvEs_3
   \   0000010C   0x........         DC32     _ZZ17get_wifi_commandsvEs_4
   \   00000110   0x........         DC32     espGcodeFifo
   \   00000114   0x........         DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
   \   00000118   0x........         DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
   1556          #endif
   1557          
   1558          /**
   1559           * Add to the circular command queue the next command from:
   1560           *  - The command-injection queue (injected_commands_P)
   1561           *  - The active serial input (usually USB)
   1562           *  - The SD card file being actively printed
   1563           */

   \                                 In section .text, align 2, keep-with-next
   1564          void get_available_commands() {
   \                     _Z22get_available_commandsv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1565          
   1566            // if any immediate commands remain, don't get other commands yet
   1567            if (drain_injected_commands_P()) return;
   \   00000002   0x.... 0x....      BL       _Z25drain_injected_commands_Pv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD107             BNE.N    ??get_available_commands_0
   1568          
   1569            get_serial_commands();
   \   0000000A   0x.... 0x....      BL       _Z19get_serial_commandsv
   1570            
   1571          #if 1
   1572          	get_wifi_commands();
   \   0000000E   0x.... 0x....      BL       _Z17get_wifi_commandsv
   1573          #endif
   1574          
   1575            #if ENABLED(SDSUPPORT)
   1576              get_sdcard_commands();
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x.... 0x....      B.W      _Z19get_sdcard_commandsv
   \                     ??get_available_commands_0: (+1)
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
   1577            #endif
   1578          }
   1579          
   1580          /**
   1581           * Set target_extruder from the T parameter or the active_extruder
   1582           *
   1583           * Returns TRUE if the target is invalid
   1584           */

   \                                 In section .text, align 2, keep-with-next
   1585          bool get_target_extruder_from_command(const uint16_t code) {
   \                     _Z32get_target_extruder_from_commandt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1586            if (parser.seenval('T')) {
   \   00000004   0x2054             MOVS     R0,#+84
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD023             BEQ.N    ??get_target_extruder_from_command_0
   1587              const int8_t e = parser.value_byte();
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000012   0x4605             MOV      R5,R0
   \   00000014   0xB26D             SXTB     R5,R5
   1588              if (e >= EXTRUDERS) {
   \   00000016   0x2D02             CMP      R5,#+2
   \   00000018   0xDB19             BLT.N    ??get_target_extruder_from_command_1
   1589                SERIAL_ECHO_START();
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable139_3
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1590                SERIAL_CHAR('M');
   \   00000022   0x.... 0x....      LDR.W    R6,??DataTable139_4
   \   00000026   0x214D             MOVS     R1,#+77
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1591                SERIAL_ECHO(code);
   \   0000002E   0x220A             MOVS     R2,#+10
   \   00000030   0x4621             MOV      R1,R4
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       _ZN5Print5printEii
   1592                SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x.... 0x....      ADR.W    R0,`?<Constant " Invalid extruder ">`
   \   0000003E   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000042   0x210A             MOVS     R1,#+10
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1593                return true;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   1594              }
   1595              target_extruder = e;
   \                     ??get_target_extruder_from_command_1: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable136_4
   \   00000052   0x7145             STRB     R5,[R0, #+5]
   \   00000054   0xE003             B.N      ??get_target_extruder_from_command_2
   1596            }
   1597            else
   1598              target_extruder = active_extruder;
   \                     ??get_target_extruder_from_command_0: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable136_4
   \   0000005A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000005C   0x7141             STRB     R1,[R0, #+5]
   1599          
   1600            return false;
   \                     ??get_target_extruder_from_command_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
   1601          }
   1602          
   1603          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   1604            bool extruder_duplication_enabled = false; // Used in Dual X mode 2
   1605          #endif
   1606          
   1607          #if ENABLED(DUAL_X_CARRIAGE)
   1608          
   1609            static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
   1610          
   1611            static float x_home_pos(const int extruder) {
   1612              if (extruder == 0)
   1613                return base_home_pos(X_AXIS);
   1614              else
   1615                /**
   1616                 * In dual carriage mode the extruder offset provides an override of the
   1617                 * second X-carriage position when homed - otherwise X2_HOME_POS is used.
   1618                 * This allows soft recalibration of the second extruder home position
   1619                 * without firmware reflash (through the M218 command).
   1620                 */
   1621                return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
   1622            }
   1623          
   1624            static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
   1625          
   1626            static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
   1627            static bool active_extruder_parked = false;        // used in mode 1 & 2
   1628            static float raised_parked_position[XYZE];         // used in mode 1
   1629            static millis_t delayed_move_time = 0;             // used in mode 1
   1630            static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
   1631            static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
   1632          
   1633          #endif // DUAL_X_CARRIAGE
   1634          
   1635          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
   1636          
   1637            /**
   1638             * Software endstops can be used to monitor the open end of
   1639             * an axis that has a hardware endstop on the other end. Or
   1640             * they can prevent axes from moving past endstops and grinding.
   1641             *
   1642             * To keep doing their job as the coordinate system changes,
   1643             * the software endstop positions must be refreshed to remain
   1644             * at the same positions relative to the machine.
   1645             */

   \                                 In section .text, align 2, keep-with-next
   1646            void update_software_endstops(const AxisEnum axis) {
   \                     _Z24update_software_endstops8AxisEnum: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   1647              #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   1648                workspace_offset[axis] = home_offset[axis] + position_shift[axis];
   \   00000006   0x4637             MOV      R7,R6
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable136_4
   \   0000000C   0xEB04 0x0887      ADD      R8,R4,R7, LSL #+2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable139_2
   \   00000014   0xEB00 0x0087      ADD      R0,R0,R7, LSL #+2
   \   00000018   0x6AC1             LDR      R1,[R0, #+44]
   \   0000001A   0xF8D8 0x0060      LDR      R0,[R8, #+96]
   \   0000001E   0x.... 0x....      BL       __aeabi_fadd
   \   00000022   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1649              #endif
   1650          
   1651              #if ENABLED(DUAL_X_CARRIAGE)
   1652                if (axis == X_AXIS) {
   1653          
   1654                  // In Dual X mode hotend_offset[X] is T1's home position
   1655                  float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
   1656          
   1657                  if (active_extruder != 0) {
   1658                    // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
   1659                    soft_endstop_min[X_AXIS] = X2_MIN_POS;
   1660                    soft_endstop_max[X_AXIS] = dual_max_x;
   1661                  }
   1662                  else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
   1663                    // In Duplication Mode, T0 can move as far left as X_MIN_POS
   1664                    // but not so far to the right that T1 would move past the end
   1665                    soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
   1666                    soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
   1667                  }
   1668                  else {
   1669                    // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
   1670                    soft_endstop_min[axis] = base_min_pos(axis);
   1671                    soft_endstop_max[axis] = base_max_pos(axis);
   1672                  }
   1673                }
   1674          	#else
   1675              if (MACHINETPYE == DELTA)//ENABLED(DELTA)
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable136_9
   \   0000002A   0x.... 0x....      LDR.W    R9,??DataTable136_5
   \   0000002E   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0xD10E             BNE.N    ??update_software_endstops_0
   1676              {
   1677                soft_endstop_min[axis] = base_min_pos(axis);
   \   00000038   0x.... 0x....      BL       _Z12base_min_pos8AxisEnum
   \   0000003C   0xF8C8 0x0044      STR      R0,[R8, #+68]
   1678                soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
   \   00000040   0x2F02             CMP      R7,#+2
   \   00000042   0xD101             BNE.N    ??update_software_endstops_1
   \   00000044   0x6FA0             LDR      R0,[R4, #+120]
   \   00000046   0xE002             B.N      ??update_software_endstops_2
   \                     ??update_software_endstops_1: (+1)
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       _Z12base_max_pos8AxisEnum
   \                     ??update_software_endstops_2: (+1)
   \   0000004E   0xEB05 0x0187      ADD      R1,R5,R7, LSL #+2
   \   00000052   0x6248             STR      R0,[R1, #+36]
   \   00000054   0xE009             B.N      ??update_software_endstops_3
   1679              }
   1680              else
   1681              {
   1682                soft_endstop_min[axis] = base_min_pos(axis);
   \                     ??update_software_endstops_0: (+1)
   \   00000056   0x.... 0x....      BL       _Z12base_min_pos8AxisEnum
   \   0000005A   0xF8C8 0x0044      STR      R0,[R8, #+68]
   1683                soft_endstop_max[axis] = base_max_pos(axis);
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       _Z12base_max_pos8AxisEnum
   \   00000064   0xEB05 0x0187      ADD      R1,R5,R7, LSL #+2
   \   00000068   0x6248             STR      R0,[R1, #+36]
   1684              }
   1685              #endif
   1686          
   1687              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1688                if (DEBUGGING(LEVELING)) {
   1689                  SERIAL_ECHOPAIR("For ", axis_codes[axis]);
   1690                  #if HAS_HOME_OFFSET
   1691                    SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
   1692                  #endif
   1693                  #if HAS_POSITION_SHIFT
   1694                    SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
   1695                  #endif
   1696                  SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
   1697                  SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
   1698                }
   1699              #endif
   1700          
   1701              //#if ENABLED(DELTA)
   1702              if(MACHINETPYE == DELTA)
   \                     ??update_software_endstops_3: (+1)
   \   0000006A   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD153             BNE.N    ??update_software_endstops_4
   1703              {
   1704                switch(axis) {
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD002             BEQ.N    ??update_software_endstops_5
   \   00000076   0x2E02             CMP      R6,#+2
   \   00000078   0xD048             BEQ.N    ??update_software_endstops_6
   \   0000007A   0xD24E             BCS.N    ??update_software_endstops_4
   1705                  case X_AXIS:
   1706                  case Y_AXIS:
   1707                    // Get a minimum radius for clamping
   1708                    soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
   \                     ??update_software_endstops_5: (+1)
   \   0000007C   0x6C61             LDR      R1,[R4, #+68]
   \   0000007E   0x6CA0             LDR      R0,[R4, #+72]
   \   00000080   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000084   0xD300             BCC.N    ??update_software_endstops_7
   \   00000086   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_7: (+1)
   \   00000088   0xF021 0x4000      BIC      R0,R1,#0x80000000
   \   0000008C   0x6A6A             LDR      R2,[R5, #+36]
   \   0000008E   0x4611             MOV      R1,R2
   \   00000090   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000094   0xD207             BCS.N    ??update_software_endstops_8
   \   00000096   0x6C61             LDR      R1,[R4, #+68]
   \   00000098   0x6CA0             LDR      R0,[R4, #+72]
   \   0000009A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000009E   0xD300             BCC.N    ??update_software_endstops_9
   \   000000A0   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_9: (+1)
   \   000000A2   0xF021 0x4200      BIC      R2,R1,#0x80000000
   \                     ??update_software_endstops_8: (+1)
   \   000000A6   0x6AA9             LDR      R1,[R5, #+40]
   \   000000A8   0x4610             MOV      R0,R2
   \   000000AA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000AE   0xD217             BCS.N    ??update_software_endstops_10
   \   000000B0   0x6C61             LDR      R1,[R4, #+68]
   \   000000B2   0x6CA0             LDR      R0,[R4, #+72]
   \   000000B4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B8   0xD300             BCC.N    ??update_software_endstops_11
   \   000000BA   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_11: (+1)
   \   000000BC   0xF021 0x4000      BIC      R0,R1,#0x80000000
   \   000000C0   0x6A69             LDR      R1,[R5, #+36]
   \   000000C2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C6   0xD209             BCS.N    ??update_software_endstops_12
   \   000000C8   0x6C61             LDR      R1,[R4, #+68]
   \   000000CA   0x6CA0             LDR      R0,[R4, #+72]
   \   000000CC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D0   0xD300             BCC.N    ??update_software_endstops_13
   \   000000D2   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_13: (+1)
   \   000000D4   0xF021 0x4000      BIC      R0,R1,#0x80000000
   \   000000D8   0x6568             STR      R0,[R5, #+84]
   \   000000DA   0xE002             B.N      ??update_software_endstops_14
   \                     ??update_software_endstops_12: (+1)
   \   000000DC   0x6569             STR      R1,[R5, #+84]
   \   000000DE   0xE000             B.N      ??update_software_endstops_14
   \                     ??update_software_endstops_10: (+1)
   \   000000E0   0x6569             STR      R1,[R5, #+84]
   1709                    soft_endstop_radius_2 = sq(soft_endstop_radius);
   \                     ??update_software_endstops_14: (+1)
   \   000000E2   0x6D6C             LDR      R4,[R5, #+84]
   \   000000E4   0x2602             MOVS     R6,#+2
   \   000000E6   0xF04F 0x577E      MOV      R7,#+1065353216
   \   000000EA   0xE004             B.N      ??update_software_endstops_15
   \                     ??update_software_endstops_16: (+1)
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x4621             MOV      R1,R4
   \   000000F0   0x.... 0x....      BL       __aeabi_fmul
   \   000000F4   0x4604             MOV      R4,R0
   \                     ??update_software_endstops_15: (+1)
   \   000000F6   0x07F0             LSLS     R0,R6,#+31
   \   000000F8   0xD504             BPL.N    ??update_software_endstops_17
   \   000000FA   0x4638             MOV      R0,R7
   \   000000FC   0x4621             MOV      R1,R4
   \   000000FE   0x.... 0x....      BL       __aeabi_fmul
   \   00000102   0x4607             MOV      R7,R0
   \                     ??update_software_endstops_17: (+1)
   \   00000104   0x0876             LSRS     R6,R6,#+1
   \   00000106   0xD1F1             BNE.N    ??update_software_endstops_16
   \   00000108   0x65AF             STR      R7,[R5, #+88]
   1710                    break;
   \   0000010A   0xE006             B.N      ??update_software_endstops_4
   1711                  case Z_AXIS:
   1712                    delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
   \                     ??update_software_endstops_6: (+1)
   \   0000010C   0x.... 0x....      BL       _Z28delta_safe_distance_from_topv
   \   00000110   0x4601             MOV      R1,R0
   \   00000112   0x6AE8             LDR      R0,[R5, #+44]
   \   00000114   0x.... 0x....      BL       __aeabi_fsub
   \   00000118   0x67E0             STR      R0,[R4, #+124]
   1713                  default: break;
   1714                }
   1715              }
   1716              //#endif
   1717            }
   \                     ??update_software_endstops_4: (+1)
   \   0000011A   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1718          
   1719          #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
   1720          
   1721          #if 1//HAS_M206_COMMAND
   1722            /**
   1723             * Change the home offset for an axis, update the current
   1724             * position and the software endstops to retain the same
   1725             * relative distance to the new home.
   1726             *
   1727             * Since this changes the current_position, code should
   1728             * call sync_plan_position soon after this.
   1729             */

   \                                 In section .text, align 2, keep-with-next
   1730            static void set_home_offset(const AxisEnum axis, const float v) {
   1731          
   1732            	if(MACHINETPYE == DELTA)	return;
   \                     _Z15set_home_offset8AxisEnumf: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable136_5
   \   00000004   0xF9B2 0x2058      LDRSH    R2,[R2, #+88]
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD005             BEQ.N    ??set_home_offset_0
   1733          	
   1734              home_offset[axis] = v;
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable139_2
   \   00000010   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \   00000014   0x62D1             STR      R1,[R2, #+44]
   1735              update_software_endstops(axis);
   \   00000016   0x....             B.N      _Z24update_software_endstops8AxisEnum
   \                     ??set_home_offset_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1736            }
   1737          #endif // HAS_M206_COMMAND
   1738          
   1739          /**
   1740           * Set an axis' current position to its home position (after homing).
   1741           *
   1742           * For Core and Cartesian robots this applies one-to-one when an
   1743           * individual axis has been homed.
   1744           *
   1745           * DELTA should wait until all homing is done before setting the XYZ
   1746           * current_position to home, because homing is a single operation.
   1747           * In the case where the axis positions are already known and previously
   1748           * homed, DELTA could home to X or Y individually by moving either one
   1749           * to the center. However, homing Z always homes XY and Z.
   1750           *
   1751           * SCARA should wait until all XY homing is done before setting the XY
   1752           * current_position to home, because neither X nor Y is at home until
   1753           * both are at home. Z can however be homed individually.
   1754           *
   1755           * Callers must sync the planner position after calling this!
   1756           */

   \                                 In section .text, align 2, keep-with-next
   1757          static void set_axis_is_at_home(const AxisEnum axis) {
   \                     _Z19set_axis_is_at_home8AxisEnum: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4604             MOV      R4,R0
   1758            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1759              if (DEBUGGING(LEVELING)) {
   1760                SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
   1761                SERIAL_CHAR(')');
   1762                SERIAL_EOL();
   1763              }
   1764            #endif
   1765          
   1766            axis_known_position[axis] = axis_homed[axis] = true;
   \   00000008   0x4625             MOV      R5,R4
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable136_9
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x55A8             STRB     R0,[R5, R6]
   \   00000012   0x19A9             ADDS     R1,R5,R6
   \   00000014   0x7108             STRB     R0,[R1, #+4]
   1767          
   1768            #if HAS_POSITION_SHIFT
   1769              position_shift[axis] = 0;
   \   00000016   0x.... 0x....      LDR.W    R7,??DataTable136_4
   \   0000001A   0xEB07 0x0885      ADD      R8,R7,R5, LSL #+2
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF8C8 0x0060      STR      R0,[R8, #+96]
   1770              update_software_endstops(axis);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   1771            #endif
   1772          
   1773            #if ENABLED(DUAL_X_CARRIAGE)
   1774              if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
   1775                current_position[X_AXIS] = x_home_pos(active_extruder);
   1776                return;
   1777              }
   1778            #endif
   1779          
   1780            //#if ENABLED(MORGAN_SCARA)
   1781            if(MACHINETPYE&MORGAN_SCARA)
   \   0000002A   0x.... 0x....      LDR.W    R9,??DataTable136_5
   \   0000002E   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \   00000032   0x05C1             LSLS     R1,R0,#+23
   \   00000034   0xD531             BPL.N    ??set_axis_is_at_home_0
   1782            	{
   1783              /**
   1784               * Morgan SCARA homes XY at the same time
   1785               */
   1786              if (axis == X_AXIS || axis == Y_AXIS) {
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD001             BEQ.N    ??set_axis_is_at_home_1
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD127             BNE.N    ??set_axis_is_at_home_2
   1787          
   1788                float homeposition[XYZ] = {
   \                     ??set_axis_is_at_home_1: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0xF10D 0x0A00      ADD      R10,SP,#+0
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000050   0xF8CA 0x0004      STR      R0,[R10, #+4]
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   0000005A   0xF8CA 0x0008      STR      R0,[R10, #+8]
   1789                  base_home_pos(X_AXIS),
   1790                  base_home_pos(Y_AXIS),
   1791                  base_home_pos(Z_AXIS)
   1792                };
   1793          
   1794                // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
   1795                // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
   1796          
   1797                /**
   1798                 * Get Home position SCARA arm angles using inverse kinematics,
   1799                 * and calculate homing offset using forward kinematics
   1800                 */
   1801                inverse_kinematics_MORGAN_SCARA(homeposition);
   \   0000005E   0xA800             ADD      R0,SP,#+0
   \   00000060   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   1802                forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
   \   00000064   0xF107 0x0154      ADD      R1,R7,#+84
   \   00000068   0xF107 0x0050      ADD      R0,R7,#+80
   \   0000006C   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
   1803          
   1804                // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
   1805                // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
   1806          
   1807                current_position[axis] = cartes[axis];
   \   00000070   0xEB06 0x0685      ADD      R6,R6,R5, LSL #+2
   \   00000074   0x6CB0             LDR      R0,[R6, #+72]
   \   00000076   0xF8C8 0x0008      STR      R0,[R8, #+8]
   1808          
   1809                /**
   1810                 * SCARA home positions are based on configuration since the actual
   1811                 * limits are determined by the inverse kinematic transform.
   1812                 */
   1813                soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       _Z12base_min_pos8AxisEnum
   \   00000080   0xF8C8 0x0044      STR      R0,[R8, #+68]
   1814                soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       _Z12base_max_pos8AxisEnum
   \   0000008A   0x6270             STR      R0,[R6, #+36]
   \   0000008C   0xE018             B.N      ??set_axis_is_at_home_3
   1815              }
   1816              else
   1817          	{
   1818          	    current_position[axis] = base_home_pos(axis);
   \                     ??set_axis_is_at_home_2: (+1)
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000094   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   00000098   0xE012             B.N      ??set_axis_is_at_home_3
   1819          	}		
   1820            	}
   1821            //#elif ENABLED(DELTA)
   1822            else if(MACHINETPYE&DELTA)
   \                     ??set_axis_is_at_home_0: (+1)
   \   0000009A   0x0780             LSLS     R0,R0,#+30
   \   0000009C   0xD50B             BPL.N    ??set_axis_is_at_home_4
   1823            {
   1824              if (axis == Z_AXIS)
   \   0000009E   0x2D02             CMP      R5,#+2
   \   000000A0   0xD103             BNE.N    ??set_axis_is_at_home_5
   1825                current_position[axis] = delta_height;
   \   000000A2   0x6FB8             LDR      R0,[R7, #+120]
   \   000000A4   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   000000A8   0xE00A             B.N      ??set_axis_is_at_home_3
   1826              else
   1827            //#endif
   1828            	{
   1829              	current_position[axis] = base_home_pos(axis);
   \                     ??set_axis_is_at_home_5: (+1)
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   000000B0   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   000000B4   0xE004             B.N      ??set_axis_is_at_home_3
   1830            	}
   1831            }
   1832            else
   1833            {
   1834              	current_position[axis] = base_home_pos(axis);
   \                     ??set_axis_is_at_home_4: (+1)
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   000000BC   0xF8C8 0x0008      STR      R0,[R8, #+8]
   1835            }    
   1836            /**
   1837             * Z Probe Z Homing? Account for the probe's Z offset.
   1838             */
   1839            #if HAS_BED_PROBE //&& Z_HOME_DIR < 0
   1840            if(Z_HOME_DIR < 0)
   \                     ??set_axis_is_at_home_3: (+1)
   \   000000C0   0xF999 0x0007      LDRSB    R0,[R9, #+7]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD512             BPL.N    ??set_axis_is_at_home_6
   1841            {
   1842              if (axis == Z_AXIS) {
   \   000000C8   0x2D02             CMP      R5,#+2
   \   000000CA   0xD110             BNE.N    ??set_axis_is_at_home_6
   1843                #if HOMING_Z_WITH_PROBE
   1844          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   \   000000CC   0xF899 0x0099      LDRB     R0,[R9, #+153]
   \   000000D0   0x2801             CMP      R0,#+1
   \   000000D2   0xD105             BNE.N    ??set_axis_is_at_home_7
   1845          	  {
   1846                  current_position[Z_AXIS] -= zprobe_zoffset;
   \   000000D4   0x6938             LDR      R0,[R7, #+16]
   \   000000D6   0x6F39             LDR      R1,[R7, #+112]
   \   000000D8   0x.... 0x....      BL       __aeabi_fsub
   \   000000DC   0x6138             STR      R0,[R7, #+16]
   \   000000DE   0xE006             B.N      ??set_axis_is_at_home_6
   1847          
   1848                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1849                    if (DEBUGGING(LEVELING)) {
   1850                      SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
   1851                      SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
   1852                    }
   1853                  #endif
   1854          	  }
   1855          	  else
   1856          	  {
   1857          		  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");	  
   \                     ??set_axis_is_at_home_7: (+1)
   \   000000E0   0x7878             LDRB     R0,[R7, #+1]
   \   000000E2   0x0680             LSLS     R0,R0,#+26
   \   000000E4   0xD503             BPL.N    ??set_axis_is_at_home_6
   \   000000E6   0x.... 0x....      ADR.W    R0,`?<Constant "*** Z HOMED TO ENDSTO...">`
   \   000000EA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1858          	  }
   1859                #elif ENABLED(DEBUG_LEVELING_FEATURE)
   1860          
   1861                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
   1862          
   1863                #endif
   1864              }
   1865            }
   1866            #endif
   1867          
   1868            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1869              if (DEBUGGING(LEVELING)) {
   1870                #if HAS_HOME_OFFSET
   1871                  SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
   1872                  SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
   1873                #endif
   1874                DEBUG_POS("", current_position);
   1875                SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
   1876                SERIAL_CHAR(')');
   1877                SERIAL_EOL();
   1878              }
   1879            #endif
   1880          
   1881            #if ENABLED(I2C_POSITION_ENCODERS)
   1882              I2CPEM.homed(axis);
   1883            #endif
   1884          }
   \                     ??set_axis_is_at_home_6: (+1)
   \   000000EE   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   1885          
   1886          /**
   1887           * Some planner shorthand inline functions
   1888           */

   \                                 In section .text, align 4
   1889          inline float get_homing_bump_feedrate(const AxisEnum axis) {
   \                     _Z24get_homing_bump_feedrate8AxisEnum: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   1890            //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   1891          	int  homing_bump_divisor[4];
   1892          	if(MACHINETPYE == DELTA)
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x4912             LDR.N    R1,??get_homing_bump_feedrate_0
   \   0000000A   0xF9B1 0x1058      LDRSH    R1,[R1, #+88]
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD104             BNE.N    ??get_homing_bump_feedrate_1
   1893          	{
   1894          		homing_bump_divisor[0] = 10;
   \   00000012   0x210A             MOVS     R1,#+10
   \   00000014   0x9100             STR      R1,[SP, #+0]
   1895          		homing_bump_divisor[1] = 10;
   \   00000016   0x6041             STR      R1,[R0, #+4]
   1896          		homing_bump_divisor[2] = 10;
   \   00000018   0x6081             STR      R1,[R0, #+8]
   \   0000001A   0xE004             B.N      ??get_homing_bump_feedrate_2
   1897          	}
   1898          	else
   1899          	{
   1900          		homing_bump_divisor[0] = 2;
   \                     ??get_homing_bump_feedrate_1: (+1)
   \   0000001C   0x2102             MOVS     R1,#+2
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   1901          		homing_bump_divisor[1] = 2;
   \   00000020   0x6041             STR      R1,[R0, #+4]
   1902          		homing_bump_divisor[2] = 4;
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0x6081             STR      R1,[R0, #+8]
   1903          	}  
   1904            uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   \                     ??get_homing_bump_feedrate_2: (+1)
   \   00000026   0xF810 0x5024      LDRB     R5,[R0, R4, LSL #+2]
   1905            if (hbd < 1) {
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD106             BNE.N    ??get_homing_bump_feedrate_3
   1906              hbd = 10;
   \   0000002E   0x250A             MOVS     R5,#+10
   1907              SERIAL_ECHO_START();
   \   00000030   0x4809             LDR.N    R0,??get_homing_bump_feedrate_0+0x4
   \   00000032   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1908              SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   \   00000036   0x4809             LDR.N    R0,??get_homing_bump_feedrate_0+0x8
   \   00000038   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1909            }
   1910            //return homing_feedrate(axis) / hbd;
   1911            return homing_feedrate_mm_s[axis] / hbd;
   \                     ??get_homing_bump_feedrate_3: (+1)
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000042   0x4601             MOV      R1,R0
   \   00000044   0x4806             LDR.N    R0,??get_homing_bump_feedrate_0+0xC
   \   00000046   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   0000004A   0x6A80             LDR      R0,[R0, #+40]
   \   0000004C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000050   0xB005             ADD      SP,SP,#+20
   \   00000052   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??get_homing_bump_feedrate_0:
   \   00000054   0x........         DC32     mksCfg
   \   00000058   0x........         DC32     echomagic
   \   0000005C   0x........         DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
   \   00000060   0x........         DC32     mks_heating_busy
   1912          }
   1913          
   1914          /**
   1915           * Move the planner to the current position from wherever it last moved
   1916           * (or from wherever it has been told it is located).
   1917           */

   \                                 In section .text, align 4
   1918          inline void buffer_line_to_current_position() {
   \                     _Z31buffer_line_to_current_positionv: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1919            planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
   \   00000004   0x4806             LDR.N    R0,??buffer_line_to_current_position_0
   \   00000006   0x78C1             LDRB     R1,[R0, #+3]
   \   00000008   0x9101             STR      R1,[SP, #+4]
   \   0000000A   0xF100 0x015C      ADD      R1,R0,#+92
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0xF100 0x0314      ADD      R3,R0,#+20
   \   00000014   0x6902             LDR      R2,[R0, #+16]
   \   00000016   0x68C1             LDR      R1,[R0, #+12]
   \   00000018   0x6880             LDR      R0,[R0, #+8]
   \   0000001A   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   1920          }
   \   0000001E   0xBD07             POP      {R0-R2,PC}       ;; return
   \                     ??buffer_line_to_current_position_0:
   \   00000020   0x........         DC32     mks_heating_busy
   1921          
   1922          /**
   1923           * Move the planner to the position stored in the destination array, which is
   1924           * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
   1925           */

   \                                 In section .text, align 4
   1926          inline void buffer_line_to_destination(const float fr_mm_s) {
   \                     _Z26buffer_line_to_destinationf: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1927            planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
   \   00000004   0x4806             LDR.N    R0,??buffer_line_to_destination_0
   \   00000006   0x78C1             LDRB     R1,[R0, #+3]
   \   00000008   0x9101             STR      R1,[SP, #+4]
   \   0000000A   0xA902             ADD      R1,SP,#+8
   \   0000000C   0x9100             STR      R1,[SP, #+0]
   \   0000000E   0xF100 0x0324      ADD      R3,R0,#+36
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x69C1             LDR      R1,[R0, #+28]
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   1928          }
   \   0000001C   0xBD07             POP      {R0-R2,PC}       ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??buffer_line_to_destination_0:
   \   00000020   0x........         DC32     mks_heating_busy
   1929          
   1930          #if 1//IS_KINEMATIC
   1931            /**
   1932             * Calculate delta, start a line, and set current_position to destination
   1933             */

   \                                 In section .text, align 2, keep-with-next
   1934            void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
   \                     _Z42prepare_uninterpolated_move_to_destinationf: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1935              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1936                if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
   1937              #endif
   1938          
   1939              refresh_cmd_timeout();
   \   00000004   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   1940          
   1941              #if UBL_SEGMENTED
   1942                // ubl segmented line will do z-only moves in single segment
   1943                ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
   1944              #else
   1945                if ( current_position[X_AXIS] == destination[X_AXIS]
   1946                  && current_position[Y_AXIS] == destination[Y_AXIS]
   1947                  && current_position[Z_AXIS] == destination[Z_AXIS]
   1948                  && current_position[E_AXIS] == destination[E_AXIS]
   1949                ) return;
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable136_4
   \   0000000C   0x68A8             LDR      R0,[R5, #+8]
   \   0000000E   0x69A9             LDR      R1,[R5, #+24]
   \   00000010   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000014   0xD10E             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \   00000016   0x68E8             LDR      R0,[R5, #+12]
   \   00000018   0x69E9             LDR      R1,[R5, #+28]
   \   0000001A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000001E   0xD109             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \   00000020   0x6928             LDR      R0,[R5, #+16]
   \   00000022   0x6A29             LDR      R1,[R5, #+32]
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000028   0xD104             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \   0000002A   0x6968             LDR      R0,[R5, #+20]
   \   0000002C   0x6A69             LDR      R1,[R5, #+36]
   \   0000002E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000032   0xD01F             BEQ.N    ??prepare_uninterpolated_move_to_destination_1
   1950          
   1951                planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
   \                     ??prepare_uninterpolated_move_to_destination_0: (+1)
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000003C   0xD100             BNE.N    ??prepare_uninterpolated_move_to_destination_2
   \   0000003E   0x6DEC             LDR      R4,[R5, #+92]
   \                     ??prepare_uninterpolated_move_to_destination_2: (+1)
   \   00000040   0xF9B5 0x0006      LDRSH    R0,[R5, #+6]
   \   00000044   0x.... 0x....      BL       __aeabi_i2f
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0x.... 0x....      BL       __aeabi_fmul
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x.... 0x....      LDR.W    R2,??DataTable145  ;; 0x47ae147b
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable146  ;; 0x3f847ae1
   \   0000005A   0x.... 0x....      BL       __aeabi_dmul
   \   0000005E   0x.... 0x....      BL       __aeabi_d2f
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x78EA             LDRB     R2,[R5, #+3]
   \   00000066   0xA900             ADD      R1,SP,#+0
   \   00000068   0xF105 0x0018      ADD      R0,R5,#+24
   \   0000006C   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
   1952              #endif
   1953          
   1954              set_current_from_destination();
   \   00000070   0x.... 0x....      BL       _Z28set_current_from_destinationv
   1955            }
   \                     ??prepare_uninterpolated_move_to_destination_1: (+1)
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1956          #endif // IS_KINEMATIC
   1957          
   1958          /**
   1959           *  Plan a move to (X, Y, Z) and set the current_position
   1960           *  The final current_position may not be the one that was requested
   1961           */

   \                                 In section .text, align 2, keep-with-next
   1962          void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z19do_blocking_move_toRKfS0_S0_S0_: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x4699             MOV      R9,R3
   1963            const float old_feedrate_mm_s = feedrate_mm_s;
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable136_4
   \   00000010   0x6DEE             LDR      R6,[R5, #+92]
   1964          
   1965            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1966              if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
   1967            #endif
   1968          
   1969            const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
   \   00000012   0xF8D9 0xA000      LDR      R10,[R9, #+0]
   \   00000016   0x4650             MOV      R0,R10
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000001E   0xD101             BNE.N    ??do_blocking_move_to_0
   \   00000020   0xF8D5 0xA030      LDR      R10,[R5, #+48]
   \                     ??do_blocking_move_to_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable136_5
   \   00000028   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD141             BNE.N    ??do_blocking_move_to_1
   1970          
   1971            //#if ENABLED(DELTA)
   1972            if(MACHINETPYE == DELTA)
   1973            {
   1974              if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
   \   00000030   0x4641             MOV      R1,R8
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xF000 0x8096      BEQ.W    ??do_blocking_move_to_2
   1975          
   1976              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \   0000003E   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   00000042   0x4610             MOV      R0,R2
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000004A   0xD001             BEQ.N    ??do_blocking_move_to_3
   \   0000004C   0x65EA             STR      R2,[R5, #+92]
   \   0000004E   0xE001             B.N      ??do_blocking_move_to_4
   \                     ??do_blocking_move_to_3: (+1)
   \   00000050   0x6F68             LDR      R0,[R5, #+116]
   \   00000052   0x65E8             STR      R0,[R5, #+92]
   1977          
   1978              set_destination_from_current();          // sync destination at the start
   \                     ??do_blocking_move_to_4: (+1)
   \   00000054   0x.... 0x....      BL       _Z28set_destination_from_currentv
   1979          
   1980              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1981                if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
   1982              #endif
   1983          
   1984              // when in the danger zone
   1985              if (current_position[Z_AXIS] > delta_clip_start_height) {
   \   00000058   0x6FE8             LDR      R0,[R5, #+124]
   \   0000005A   0x6929             LDR      R1,[R5, #+16]
   \   0000005C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000060   0xD212             BCS.N    ??do_blocking_move_to_5
   1986                if (rz > delta_clip_start_height) {   // staying in the danger zone
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000068   0xD20A             BCS.N    ??do_blocking_move_to_6
   1987                  destination[X_AXIS] = rx;           // move directly (uninterpolated)
   \   0000006A   0x6838             LDR      R0,[R7, #+0]
   \   0000006C   0x61A8             STR      R0,[R5, #+24]
   1988                  destination[Y_AXIS] = ry;
   \   0000006E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000072   0x61E8             STR      R0,[R5, #+28]
   1989                  destination[Z_AXIS] = rz;
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6228             STR      R0,[R5, #+32]
   1990                  prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   0000007E   0x....             B.N      _Z42prepare_uninterpolated_move_to_destinationf
   1991                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1992                    if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
   1993                  #endif
   1994                  return;
   1995                }
   1996                destination[Z_AXIS] = delta_clip_start_height;
   \                     ??do_blocking_move_to_6: (+1)
   \   00000080   0x6228             STR      R0,[R5, #+32]
   1997                prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   1998                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1999                  if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
   2000                #endif
   2001              }
   2002          
   2003              if (rz > current_position[Z_AXIS]) {    // raising?
   \                     ??do_blocking_move_to_5: (+1)
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6928             LDR      R0,[R5, #+16]
   \   0000008C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000090   0xD203             BCS.N    ??do_blocking_move_to_7
   2004                destination[Z_AXIS] = rz;
   \   00000092   0x6229             STR      R1,[R5, #+32]
   2005                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   \   00000094   0x4650             MOV      R0,R10
   \   00000096   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2006                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2007                  if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
   2008                #endif
   2009              }
   2010          
   2011              destination[X_AXIS] = rx;
   \                     ??do_blocking_move_to_7: (+1)
   \   0000009A   0x6838             LDR      R0,[R7, #+0]
   \   0000009C   0x61A8             STR      R0,[R5, #+24]
   2012              destination[Y_AXIS] = ry;
   \   0000009E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000A2   0x61E8             STR      R0,[R5, #+28]
   2013              prepare_move_to_destination();         // set_current_from_destination
   \   000000A4   0x.... 0x....      BL       _Z27prepare_move_to_destinationv
   2014              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2015                if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
   2016              #endif
   2017          
   2018              if (rz < current_position[Z_AXIS]) {    // lowering?
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6929             LDR      R1,[R5, #+16]
   \   000000AC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B0   0xD258             BCS.N    ??do_blocking_move_to_8
   \   000000B2   0xE029             B.N      ??do_blocking_move_to_9
   2019                destination[Z_AXIS] = rz;
   2020                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   2021                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2022                  if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
   2023                #endif
   2024              }
   2025            }
   2026            //#elif IS_SCARA
   2027            else if(MACHINETPYE&IS_SCARA) {
   \                     ??do_blocking_move_to_1: (+1)
   \   000000B4   0xF44F 0x7140      MOV      R1,#+768
   \   000000B8   0x4208             TST      R0,R1
   \   000000BA   0xD02B             BEQ.N    ??do_blocking_move_to_10
   2028          
   2029              if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
   \   000000BC   0x4641             MOV      R1,R8
   \   000000BE   0x4638             MOV      R0,R7
   \   000000C0   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD050             BEQ.N    ??do_blocking_move_to_2
   2030          
   2031              set_destination_from_current();
   \   000000C8   0x.... 0x....      BL       _Z28set_destination_from_currentv
   2032          
   2033              // If Z needs to raise, do it before moving XY
   2034              if (destination[Z_AXIS] < rz) {
   \   000000CC   0x6821             LDR      R1,[R4, #+0]
   \   000000CE   0x6A28             LDR      R0,[R5, #+32]
   \   000000D0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D4   0xD203             BCS.N    ??do_blocking_move_to_11
   2035                destination[Z_AXIS] = rz;
   \   000000D6   0x6229             STR      R1,[R5, #+32]
   2036                prepare_uninterpolated_move_to_destination(z_feedrate);
   \   000000D8   0x4650             MOV      R0,R10
   \   000000DA   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2037              }
   2038          
   2039              destination[X_AXIS] = rx;
   \                     ??do_blocking_move_to_11: (+1)
   \   000000DE   0x6838             LDR      R0,[R7, #+0]
   \   000000E0   0x61A8             STR      R0,[R5, #+24]
   2040              destination[Y_AXIS] = ry;
   \   000000E2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000E6   0x61E8             STR      R0,[R5, #+28]
   2041              prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
   \   000000E8   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   000000EC   0x4610             MOV      R0,R2
   \   000000EE   0x2100             MOVS     R1,#+0
   \   000000F0   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000F4   0xD100             BNE.N    ??do_blocking_move_to_12
   \   000000F6   0x6F6A             LDR      R2,[R5, #+116]
   \                     ??do_blocking_move_to_12: (+1)
   \   000000F8   0x4610             MOV      R0,R2
   \   000000FA   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2042          
   2043              // If Z needs to lower, do it after moving XY
   2044              if (destination[Z_AXIS] > rz) {
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6A29             LDR      R1,[R5, #+32]
   \   00000102   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000106   0xD22D             BCS.N    ??do_blocking_move_to_8
   2045                destination[Z_AXIS] = rz;
   \                     ??do_blocking_move_to_9: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6228             STR      R0,[R5, #+32]
   2046                prepare_uninterpolated_move_to_destination(z_feedrate);
   \   0000010C   0x4650             MOV      R0,R10
   \   0000010E   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   \   00000112   0xE027             B.N      ??do_blocking_move_to_8
   2047              }
   2048            }
   2049            //#else
   2050            else
   2051            {
   2052              // If Z needs to raise, do it before moving XY
   2053              if (current_position[Z_AXIS] < rz) {
   \                     ??do_blocking_move_to_10: (+1)
   \   00000114   0x6928             LDR      R0,[R5, #+16]
   \   00000116   0x6821             LDR      R1,[R4, #+0]
   \   00000118   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011C   0xD205             BCS.N    ??do_blocking_move_to_13
   2054                feedrate_mm_s = z_feedrate;
   \   0000011E   0xF8C5 0xA05C      STR      R10,[R5, #+92]
   2055                current_position[Z_AXIS] = rz;
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6128             STR      R0,[R5, #+16]
   2056                buffer_line_to_current_position();
   \   00000126   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2057              }
   2058          
   2059              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \                     ??do_blocking_move_to_13: (+1)
   \   0000012A   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   0000012E   0x4610             MOV      R0,R2
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000136   0xD001             BEQ.N    ??do_blocking_move_to_14
   \   00000138   0x65EA             STR      R2,[R5, #+92]
   \   0000013A   0xE001             B.N      ??do_blocking_move_to_15
   \                     ??do_blocking_move_to_14: (+1)
   \   0000013C   0x6F68             LDR      R0,[R5, #+116]
   \   0000013E   0x65E8             STR      R0,[R5, #+92]
   2060              current_position[X_AXIS] = rx;
   \                     ??do_blocking_move_to_15: (+1)
   \   00000140   0x6838             LDR      R0,[R7, #+0]
   \   00000142   0x60A8             STR      R0,[R5, #+8]
   2061              current_position[Y_AXIS] = ry;
   \   00000144   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000148   0x60E8             STR      R0,[R5, #+12]
   2062              buffer_line_to_current_position();
   \   0000014A   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2063          
   2064              // If Z needs to lower, do it after moving XY
   2065              if (current_position[Z_AXIS] > rz) {
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0x6929             LDR      R1,[R5, #+16]
   \   00000152   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000156   0xD205             BCS.N    ??do_blocking_move_to_8
   2066                feedrate_mm_s = z_feedrate;
   \   00000158   0xF8C5 0xA05C      STR      R10,[R5, #+92]
   2067                current_position[Z_AXIS] = rz;
   \   0000015C   0x6820             LDR      R0,[R4, #+0]
   \   0000015E   0x6128             STR      R0,[R5, #+16]
   2068                buffer_line_to_current_position();
   \   00000160   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2069              }
   2070            }
   2071            //#endif
   2072          
   2073            stepper.synchronize();
   \                     ??do_blocking_move_to_8: (+1)
   \   00000164   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   2074          
   2075            feedrate_mm_s = old_feedrate_mm_s;
   \   00000168   0x65EE             STR      R6,[R5, #+92]
   2076          
   2077            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2078              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   2079            #endif
   2080          }
   \                     ??do_blocking_move_to_2: (+1)
   \   0000016A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   2081          void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_xRKfS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2082            do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
   \   00000002   0x....             LDR.N    R4,??DataTable136_4
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0xF104 0x0210      ADD      R2,R4,#+16
   \   0000000A   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000000E   0xB001             ADD      SP,SP,#+4
   \   00000010   0xBC10             POP      {R4}
   \   00000012   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2083          }

   \                                 In section .text, align 2, keep-with-next
   2084          void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_zRKfS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2085            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
   \   00000002   0x....             LDR.N    R4,??DataTable136_4
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0x4602             MOV      R2,R0
   \   00000008   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000000C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2086          }

   \                                 In section .text, align 2, keep-with-next
   2087          void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   2088            do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
   \                     _Z22do_blocking_move_to_xyRKfS0_S0_: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable147
   \   00000006   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2089          }
   2090          
   2091          //
   2092          // Prepare to do endstop or probe moves
   2093          // with custom feedrates.
   2094          //
   2095          //  - Save current feedrates
   2096          //  - Reset the rate multiplier
   2097          //  - Reset the command timeout
   2098          //  - Enable the endstops (for endstop moves)
   2099          //

   \                                 In section .text, align 2, keep-with-next
   2100          static void setup_for_endstop_or_probe_move() {
   2101            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2102              if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
   2103            #endif
   2104            saved_feedrate_mm_s = feedrate_mm_s;
   \                     _Z31setup_for_endstop_or_probe_movev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable147_1
   \   00000004   0x....             LDR.N    R1,??DataTable136_4
   \   00000006   0x6DCA             LDR      R2,[R1, #+92]
   \   00000008   0x6042             STR      R2,[R0, #+4]
   2105            saved_feedrate_percentage = feedrate_percentage;
   \   0000000A   0x88CA             LDRH     R2,[R1, #+6]
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   2106            feedrate_percentage = 100;
   \   0000000E   0x2064             MOVS     R0,#+100
   \   00000010   0x80C8             STRH     R0,[R1, #+6]
   2107            refresh_cmd_timeout();
   \   00000012   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2108          }
   2109          

   \                                 In section .text, align 2, keep-with-next
   2110          static void clean_up_after_endstop_or_probe_move() {
   2111            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2112              if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
   2113            #endif
   2114            feedrate_mm_s = saved_feedrate_mm_s;
   \                     _Z36clean_up_after_endstop_or_probe_movev: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable136_4
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable147_1
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0x65C2             STR      R2,[R0, #+92]
   2115            feedrate_percentage = saved_feedrate_percentage;
   \   0000000A   0x8809             LDRH     R1,[R1, #+0]
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
   2116            refresh_cmd_timeout();
   \   0000000E   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2117          }
   2118          
   2119          #if HAS_BED_PROBE
   2120            /**
   2121             * Raise Z to a minimum height to make room for a probe to move
   2122             */

   \                                 In section .text, align 4
   2123            inline void do_probe_raise(const float z_raise) {
   \                     _Z14do_probe_raisef: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   2124              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2125                if (DEBUGGING(LEVELING)) {
   2126                  SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
   2127                  SERIAL_CHAR(')');
   2128                  SERIAL_EOL();
   2129                }
   2130              #endif
   2131          
   2132              float z_dest = z_raise;
   \   00000002   0x9000             STR      R0,[SP, #+0]
   2133              if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
   \   00000004   0x4C0B             LDR.N    R4,??do_probe_raise_0
   \   00000006   0x6F22             LDR      R2,[R4, #+112]
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000010   0xD204             BCS.N    ??do_probe_raise_1
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x4611             MOV      R1,R2
   \   00000016   0x.... 0x....      BL       __aeabi_fsub
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   2134          
   2135              if (z_dest > current_position[Z_AXIS])
   \                     ??do_probe_raise_1: (+1)
   \   0000001C   0x6920             LDR      R0,[R4, #+16]
   \   0000001E   0x9900             LDR      R1,[SP, #+0]
   \   00000020   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000024   0xD205             BCS.N    ??do_probe_raise_2
   2136                do_blocking_move_to_z(z_dest);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0xA901             ADD      R1,SP,#+4
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2137            }
   \                     ??do_probe_raise_2: (+1)
   \   00000032   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \                     ??do_probe_raise_0:
   \   00000034   0x........         DC32     mks_heating_busy
   2138          
   2139          #endif // HAS_BED_PROBE
   2140          
   2141          #if HAS_AXIS_UNHOMED_ERR
   2142          

   \                                 In section .text, align 2, keep-with-next
   2143            bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
   \                     _Z18axis_unhomed_errorbbb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2144              #if ENABLED(HOME_AFTER_DEACTIVATE)
   2145                const bool xx = x && !axis_known_position[X_AXIS],
   2146                           yy = y && !axis_known_position[Y_AXIS],
   2147                           zz = z && !axis_known_position[Z_AXIS];
   2148              #else
   2149                const bool xx = x && !axis_homed[X_AXIS],
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??axis_unhomed_error_0
   \   00000006   0x....             LDR.N    R0,??DataTable136_9
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xF080 0x0401      EOR      R4,R0,#0x1
   \   0000000E   0xE000             B.N      ??axis_unhomed_error_1
   \                     ??axis_unhomed_error_0: (+1)
   \   00000010   0x2400             MOVS     R4,#+0
   2150                           yy = y && !axis_homed[Y_AXIS],
   \                     ??axis_unhomed_error_1: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD004             BEQ.N    ??axis_unhomed_error_2
   \   00000016   0x....             LDR.N    R0,??DataTable136_9
   \   00000018   0x7840             LDRB     R0,[R0, #+1]
   \   0000001A   0xF080 0x0501      EOR      R5,R0,#0x1
   \   0000001E   0xE000             B.N      ??axis_unhomed_error_3
   \                     ??axis_unhomed_error_2: (+1)
   \   00000020   0x2500             MOVS     R5,#+0
   2151                           zz = z && !axis_homed[Z_AXIS];
   \                     ??axis_unhomed_error_3: (+1)
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD004             BEQ.N    ??axis_unhomed_error_4
   \   00000026   0x....             LDR.N    R0,??DataTable136_9
   \   00000028   0x7880             LDRB     R0,[R0, #+2]
   \   0000002A   0xF080 0x0601      EOR      R6,R0,#0x1
   \   0000002E   0xE000             B.N      ??axis_unhomed_error_5
   \                     ??axis_unhomed_error_4: (+1)
   \   00000030   0x2600             MOVS     R6,#+0
   2152              #endif
   2153              if (xx || yy || zz) {
   \                     ??axis_unhomed_error_5: (+1)
   \   00000032   0xEA45 0x0004      ORR      R0,R5,R4
   \   00000036   0x4330             ORRS     R0,R6,R0
   \   00000038   0xD01C             BEQ.N    ??axis_unhomed_error_6
   2154                SERIAL_ECHO_START();
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable139_3
   \   0000003E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2155                SERIAL_ECHOPGM(MSG_HOME " ");
   \   00000042   0x.... 0x....      ADR.W    R0,`?<Constant "Home ">`
   \   00000046   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2156                if (xx) SERIAL_ECHOPGM(MSG_X);
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD002             BEQ.N    ??axis_unhomed_error_7
   \   0000004E   0x....             ADR.N    R0,??DataTable136  ;; "X"
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2157                if (yy) SERIAL_ECHOPGM(MSG_Y);
   \                     ??axis_unhomed_error_7: (+1)
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD002             BEQ.N    ??axis_unhomed_error_8
   \   00000058   0x....             ADR.N    R0,??DataTable136_1  ;; "Y"
   \   0000005A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2158                if (zz) SERIAL_ECHOPGM(MSG_Z);
   \                     ??axis_unhomed_error_8: (+1)
   \   0000005E   0x2E00             CMP      R6,#+0
   \   00000060   0xD002             BEQ.N    ??axis_unhomed_error_9
   \   00000062   0x....             ADR.N    R0,??DataTable136_2  ;; "Z"
   \   00000064   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2159                SERIAL_ECHOLNPGM(" " MSG_FIRST);
   \                     ??axis_unhomed_error_9: (+1)
   \   00000068   0x.... 0x....      ADR.W    R0,`?<Constant " first\\n">`
   \   0000006C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2160          
   2161                #if ENABLED(ULTRA_LCD)
   2162                  lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
   2163                #endif
   2164                return true;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xBD70             POP      {R4-R6,PC}
   2165              }
   2166              return false;
   \                     ??axis_unhomed_error_6: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
   2167            }
   2168          
   2169          #endif // HAS_AXIS_UNHOMED_ERR
   2170          
   2171          #if ENABLED(Z_PROBE_SLED)
   2172          
   2173            #ifndef SLED_DOCKING_OFFSET
   2174              #define SLED_DOCKING_OFFSET 0
   2175            #endif
   2176          
   2177            /**
   2178             * Method to dock/undock a sled designed by Charles Bell.
   2179             *
   2180             * stow[in]     If false, move to MAX_X and engage the solenoid
   2181             *              If true, move to MAX_X and release the solenoid
   2182             */
   2183            static void dock_sled(bool stow) {
   2184              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2185                if (DEBUGGING(LEVELING)) {
   2186                  SERIAL_ECHOPAIR("dock_sled(", stow);
   2187                  SERIAL_CHAR(')');
   2188                  SERIAL_EOL();
   2189                }
   2190              #endif
   2191          
   2192              // Dock sled a bit closer to ensure proper capturing
   2193              do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
   2194          
   2195              #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
   2196                WRITE(SOL1_PIN, !stow); // switch solenoid
   2197              #endif
   2198            }
   2199          
   2200          #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2201          
   2202            FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
   2203              do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
   2204            }
   2205          
   2206            void run_deploy_moves_script() {
   2207              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
   2208                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
   2209                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
   2210                #endif
   2211                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
   2212                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
   2213                #endif
   2214                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
   2215                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
   2216                #endif
   2217                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
   2218                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
   2219                #endif
   2220                const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
   2221                do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
   2222              #endif
   2223              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
   2224                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
   2225                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
   2226                #endif
   2227                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
   2228                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
   2229                #endif
   2230                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
   2231                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
   2232                #endif
   2233                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
   2234                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
   2235                #endif
   2236                const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
   2237                do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
   2238              #endif
   2239              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
   2240                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
   2241                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
   2242                #endif
   2243                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
   2244                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
   2245                #endif
   2246                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
   2247                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
   2248                #endif
   2249                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
   2250                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
   2251                #endif
   2252                const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
   2253                do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
   2254              #endif
   2255              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
   2256                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
   2257                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
   2258                #endif
   2259                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
   2260                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
   2261                #endif
   2262                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
   2263                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
   2264                #endif
   2265                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
   2266                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
   2267                #endif
   2268                const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
   2269                do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
   2270              #endif
   2271              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
   2272                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
   2273                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
   2274                #endif
   2275                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
   2276                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
   2277                #endif
   2278                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
   2279                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
   2280                #endif
   2281                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
   2282                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
   2283                #endif
   2284                const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
   2285                do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
   2286              #endif
   2287            }
   2288          
   2289            void run_stow_moves_script() {
   2290              #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
   2291                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
   2292                  #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
   2293                #endif
   2294                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
   2295                  #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
   2296                #endif
   2297                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
   2298                  #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
   2299                #endif
   2300                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
   2301                  #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
   2302                #endif
   2303                const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
   2304                do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
   2305              #endif
   2306              #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
   2307                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
   2308                  #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
   2309                #endif
   2310                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
   2311                  #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
   2312                #endif
   2313                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
   2314                  #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
   2315                #endif
   2316                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
   2317                  #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
   2318                #endif
   2319                const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
   2320                do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
   2321              #endif
   2322              #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
   2323                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
   2324                  #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
   2325                #endif
   2326                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
   2327                  #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
   2328                #endif
   2329                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
   2330                  #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
   2331                #endif
   2332                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
   2333                  #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
   2334                #endif
   2335                const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
   2336                do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
   2337              #endif
   2338              #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
   2339                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
   2340                  #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
   2341                #endif
   2342                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
   2343                  #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
   2344                #endif
   2345                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
   2346                  #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
   2347                #endif
   2348                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
   2349                  #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
   2350                #endif
   2351                const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
   2352                do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
   2353              #endif
   2354              #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
   2355                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
   2356                  #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
   2357                #endif
   2358                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
   2359                  #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
   2360                #endif
   2361                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
   2362                  #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
   2363                #endif
   2364                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
   2365                  #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
   2366                #endif
   2367                const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
   2368                do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
   2369              #endif
   2370            }
   2371          
   2372          #endif // Z_PROBE_ALLEN_KEY
   2373          
   2374          #if ENABLED(PROBING_FANS_OFF)
   2375          
   2376            void fans_pause(const bool p) {
   2377              if (p != fans_paused) {
   2378                fans_paused = p;
   2379                if (p)
   2380                  for (uint8_t x = 0; x < FAN_COUNT; x++) {
   2381                    paused_fanSpeeds[x] = fanSpeeds[x];
   2382                    fanSpeeds[x] = 0;
   2383                  }
   2384                else
   2385                  for (uint8_t x = 0; x < FAN_COUNT; x++)
   2386                    fanSpeeds[x] = paused_fanSpeeds[x];
   2387              }
   2388            }
   2389          
   2390          #endif // PROBING_FANS_OFF
   2391          
   2392          #if HAS_BED_PROBE
   2393          
   2394            // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
   2395            #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
   2396              #if 1 //ENABLED(Z_MIN_PROBE_ENDSTOP)
   2397                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
   2398              #else
   2399                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
   2400              #endif
   2401            #endif
   2402          
   2403            #if QUIET_PROBING
   2404              void probing_pause(const bool p) {
   2405                #if ENABLED(PROBING_HEATERS_OFF)
   2406                  thermalManager.pause(p);
   2407                #endif
   2408                #if ENABLED(PROBING_FANS_OFF)
   2409                  fans_pause(p);
   2410                #endif
   2411                if (p) safe_delay(
   2412                  #if DELAY_BEFORE_PROBING > 25
   2413                    DELAY_BEFORE_PROBING
   2414                  #else
   2415                    25
   2416                  #endif
   2417                );
   2418              }
   2419            #endif // QUIET_PROBING
   2420          
   2421            //#if ENABLED(BLTOUCH)
   2422          

   \                                 In section .text, align 2, keep-with-next
   2423              void bltouch_command(int angle) {
   2424              #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
   2425                //MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
   2426                int mksAngle;
   2427           	  switch(angle)
   \                     _Z15bltouch_commandi: (+1)
   \   00000000   0x280A             CMP      R0,#+10
   \   00000002   0xD006             BEQ.N    ??bltouch_command_0
   \   00000004   0x283C             CMP      R0,#+60
   \   00000006   0xD00D             BEQ.N    ??bltouch_command_1
   \   00000008   0x285A             CMP      R0,#+90
   \   0000000A   0xD005             BEQ.N    ??bltouch_command_2
   \   0000000C   0x2878             CMP      R0,#+120
   \   0000000E   0xD006             BEQ.N    ??bltouch_command_3
   \   00000010   0xE00B             B.N      ??bltouch_command_4
   2428          	  {
   2429          		 case 10:
   2430          			 mksAngle = 700/2;
   \                     ??bltouch_command_0: (+1)
   \   00000012   0xF44F 0x70AF      MOV      R0,#+350
   2431          			 break;
   \   00000016   0xE00A             B.N      ??bltouch_command_5
   2432          		 case 90:
   2433          			 mksAngle = 1500/2;
   \                     ??bltouch_command_2: (+1)
   \   00000018   0xF240 0x20EE      MOVW     R0,#+750
   2434          			 break;
   \   0000001C   0xE007             B.N      ??bltouch_command_5
   2435          		 case 120:
   2436          			 mksAngle = 1800/2;
   \                     ??bltouch_command_3: (+1)
   \   0000001E   0xF44F 0x7061      MOV      R0,#+900
   2437          			 break;
   \   00000022   0xE004             B.N      ??bltouch_command_5
   2438          		 case 160:
   2439          			 mksAngle = 2200/2;
   2440          			 break;
   2441          		 case 60:
   2442          			 mksAngle = 1200/2;
   \                     ??bltouch_command_1: (+1)
   \   00000024   0xF44F 0x7016      MOV      R0,#+600
   2443          			 break;
   \   00000028   0xE001             B.N      ??bltouch_command_5
   2444          		 default:
   2445          			 mksAngle = 2200/2;
   \                     ??bltouch_command_4: (+1)
   \   0000002A   0xF240 0x404C      MOVW     R0,#+1100
   2446          			 break;
   2447          	  }
   2448                MKS_TOUCH_TIM = mksAngle;	  
   \                     ??bltouch_command_5: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable147_2  ;; 0x40012c34
   \   00000032   0x6008             STR      R0,[R1, #+0]
   2449                safe_delay(BLTOUCH_DELAY);
   \   00000034   0xF240 0x1077      MOVW     R0,#+375
   \   00000038   0x.... 0x....      B.W      _Z10safe_delaym
   2450                #endif
   2451              }
   2452          

   \                                 In section .text, align 2, keep-with-next
   2453              bool set_bltouch_deployed(const bool deploy) {
   \                     _Z20set_bltouch_deployedb: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   2454                if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   \   00000004   0x....             LDR.N    R5,??DataTable136_5
   \   00000006   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD123             BNE.N    ??set_bltouch_deployed_0
   2455          		{
   2456          		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD050             BEQ.N    ??set_bltouch_deployed_1
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable147_3
   \   00000016   0x.... 0x....      LDR.W    R7,??DataTable147_4
   \   0000001A   0x8B79             LDRH     R1,[R7, #+26]
   \   0000001C   0x6B70             LDR      R0,[R6, #+52]
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000022   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD044             BEQ.N    ??set_bltouch_deployed_1
   2457          		  { 	 // If BL-Touch says it's triggered
   2458          		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
   \   0000002A   0x20A0             MOVS     R0,#+160
   \   0000002C   0x.... 0x....      BL       _Z15bltouch_commandi
   2459          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   \   00000030   0x200A             MOVS     R0,#+10
   \   00000032   0x.... 0x....      BL       _Z15bltouch_commandi
   2460          		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
   \   00000036   0x205A             MOVS     R0,#+90
   \   00000038   0x.... 0x....      BL       _Z15bltouch_commandi
   2461          		  safe_delay(1500); 				 // Wait for internal self-test to complete.
   \   0000003C   0xF240 0x50DC      MOVW     R0,#+1500
   \   00000040   0x.... 0x....      BL       _Z10safe_delaym
   2462          											 //  (Measured completion time was 0.65 seconds
   2463          											 //   after reset, deploy, and stow sequence)
   2464          		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   \   00000044   0x8B79             LDRH     R1,[R7, #+26]
   \   00000046   0x6B70             LDR      R0,[R6, #+52]
   \   00000048   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000004C   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD02F             BEQ.N    ??set_bltouch_deployed_1
   \   00000054   0xE024             B.N      ??set_bltouch_deployed_2
   2465          			SERIAL_ERROR_START();
   2466          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   2467          			stop(); 						 // punt!
   2468          		  	}
   2469          			}
   2470          		
   2471          		}
   2472          	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   \                     ??set_bltouch_deployed_0: (+1)
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD12C             BNE.N    ??set_bltouch_deployed_1
   2473          		{
   2474          		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
   \   0000005A   0x2C00             CMP      R4,#+0
   \   0000005C   0xD02A             BEQ.N    ??set_bltouch_deployed_1
   \   0000005E   0x.... 0x....      LDR.W    R6,??DataTable147_3
   \   00000062   0x.... 0x....      LDR.W    R7,??DataTable147_4
   \   00000066   0x8BB9             LDRH     R1,[R7, #+28]
   \   00000068   0x6BB0             LDR      R0,[R6, #+56]
   \   0000006A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000006E   0xF205 0x0539      ADDW     R5,R5,#+57
   \   00000072   0x7929             LDRB     R1,[R5, #+4]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD01D             BEQ.N    ??set_bltouch_deployed_1
   2475          		  { 	 // If BL-Touch says it's triggered
   2476          		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
   \   00000078   0x20A0             MOVS     R0,#+160
   \   0000007A   0x.... 0x....      BL       _Z15bltouch_commandi
   2477          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0x.... 0x....      BL       _Z15bltouch_commandi
   2478          		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
   \   00000084   0x205A             MOVS     R0,#+90
   \   00000086   0x.... 0x....      BL       _Z15bltouch_commandi
   2479          		  safe_delay(1500); 				 // Wait for internal self-test to complete.
   \   0000008A   0xF240 0x50DC      MOVW     R0,#+1500
   \   0000008E   0x.... 0x....      BL       _Z10safe_delaym
   2480          											 //  (Measured completion time was 0.65 seconds
   2481          											 //   after reset, deploy, and stow sequence)
   2482          		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   \   00000092   0x8BB9             LDRH     R1,[R7, #+28]
   \   00000094   0x6BB0             LDR      R0,[R6, #+56]
   \   00000096   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000009A   0x7929             LDRB     R1,[R5, #+4]
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD009             BEQ.N    ??set_bltouch_deployed_1
   2483          			SERIAL_ERROR_START();
   \                     ??set_bltouch_deployed_2: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable139_5
   \   000000A4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2484          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   \   000000A8   0x.... 0x....      ADR.W    R0,`?<Constant "STOP called because o...">`
   \   000000AC   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2485          			stop(); 						 // punt!
   \   000000B0   0x.... 0x....      BL       _Z4stopv
   2486          		  }
   2487          		}
   2488          		}
   2489                //}
   2490          
   2491                bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
   \                     ??set_bltouch_deployed_1: (+1)
   \   000000B4   0x2C00             CMP      R4,#+0
   \   000000B6   0xD001             BEQ.N    ??set_bltouch_deployed_3
   \   000000B8   0x200A             MOVS     R0,#+10
   \   000000BA   0xE000             B.N      ??set_bltouch_deployed_4
   \                     ??set_bltouch_deployed_3: (+1)
   \   000000BC   0x205A             MOVS     R0,#+90
   \                     ??set_bltouch_deployed_4: (+1)
   \   000000BE   0x.... 0x....      BL       _Z15bltouch_commandi
   2492          
   2493                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2494                  if (DEBUGGING(LEVELING)) {
   2495                    SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
   2496                    SERIAL_CHAR(')');
   2497                    SERIAL_EOL();
   2498                  }
   2499                #endif
   2500          
   2501                return false;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2502              }
   2503          
   2504            //#endif // BLTOUCH
   2505          
   2506            // returns false for ok and true for failure

   \                                 In section .text, align 2, keep-with-next
   2507            bool set_probe_deployed(bool deploy) {
   \                     _Z18set_probe_deployedb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   2508          
   2509              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2510                if (DEBUGGING(LEVELING)) {
   2511                  DEBUG_POS("set_probe_deployed", current_position);
   2512                  SERIAL_ECHOLNPAIR("deploy: ", deploy);
   2513                }
   2514              #endif
   2515          
   2516              if (endstops.z_probe_enabled == deploy) return false;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable148
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x42A0             CMP      R0,R4
   \   0000000E   0xD101             BNE.N    ??set_probe_deployed_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01B             B.N      ??set_probe_deployed_1
   2517          
   2518              // Make room for probe
   2519              //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
   2520              do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
   \                     ??set_probe_deployed_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable136_5
   \   00000016   0x6E41             LDR      R1,[R0, #+100]
   \   00000018   0x6E80             LDR      R0,[R0, #+104]
   \   0000001A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000001E   0xD300             BCC.N    ??set_probe_deployed_2
   \   00000020   0x4601             MOV      R1,R0
   \                     ??set_probe_deployed_2: (+1)
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x.... 0x....      BL       _Z14do_probe_raisef
   2521          
   2522              #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
   2523                #if ENABLED(Z_PROBE_SLED)
   2524                  #define _AUE_ARGS true, false, false
   2525                #else
   2526                  #define _AUE_ARGS
   2527                #endif
   2528                if (axis_unhomed_error(_AUE_ARGS)) {
   2529                  SERIAL_ERROR_START();
   2530                  SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
   2531                  stop();
   2532                  return true;
   2533                }
   2534              #endif
   2535          
   2536              const float oldXpos = current_position[X_AXIS],
   \   00000028   0x....             LDR.N    R0,??DataTable136_4
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0x9102             STR      R1,[SP, #+8]
   2537                          oldYpos = current_position[Y_AXIS];
   \   0000002E   0x68C1             LDR      R1,[R0, #+12]
   \   00000030   0x9101             STR      R1,[SP, #+4]
   2538          
   2539              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2540                bool _triggered_bool =false;
   2541          	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2542          		_triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   2543          	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   2544          		_triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   2545          
   2546                // If endstop is already false, the Z probe is deployed
   2547                if (_triggered_bool == deploy) {
   2548                //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
   2549                                                                 // Would a goto be less ugly?
   2550                  //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
   2551                                                                 // for a triggered when stowed manual probe.
   2552          
   2553                  if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
   2554                                                               // otherwise an Allen-Key probe can't be stowed.
   2555              #endif
   2556          
   2557                  #if ENABLED(SOLENOID_PROBE)
   2558          
   2559                    #if HAS_SOLENOID_1
   2560                      WRITE(SOL1_PIN, deploy);
   2561                    #endif
   2562          
   2563                  #elif ENABLED(Z_PROBE_SLED)
   2564          
   2565                    dock_sled(!deploy);
   2566          
   2567                  #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
   2568          
   2569                    MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
   2570          
   2571                  #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2572          
   2573                    deploy ? run_deploy_moves_script() : run_stow_moves_script();
   2574          
   2575                  #endif
   2576          
   2577              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2578                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2579                
   2580          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2581          		  _triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   2582          	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   2583          		  _triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   2584          
   2585                //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
   2586                if (_triggered_bool == deploy) { 
   2587          
   2588                  if (IsRunning()) {
   2589                    SERIAL_ERROR_START();
   2590                    SERIAL_ERRORLNPGM("Z-Probe failed");
   2591                    LCD_ALERTMESSAGEPGM("Err: ZPROBE");
   2592                  }
   2593                  stop();
   2594                  return true;
   2595          
   2596                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2597          
   2598              #endif
   2599          
   2600              do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x9100             STR      R1,[SP, #+0]
   \   00000036   0xAB00             ADD      R3,SP,#+0
   \   00000038   0xF100 0x0210      ADD      R2,R0,#+16
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0xA802             ADD      R0,SP,#+8
   \   00000040   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
   2601              endstops.enable_z_probe(deploy);
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       _ZN8Endstops14enable_z_probeEb
   2602              return false;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??set_probe_deployed_1: (+1)
   \   0000004C   0xB004             ADD      SP,SP,#+16
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   2603            }
   2604          
   2605            /**
   2606             * @brief Used by run_z_probe to do a single Z probe move.
   2607             *
   2608             * @param  z        Z destination
   2609             * @param  fr_mm_s  Feedrate in mm/s
   2610             * @return true to indicate an error
   2611             */

   \                                 In section .text, align 2, keep-with-next
   2612            static bool do_probe_move(const float z, const float fr_mm_m) {
   \                     _Z13do_probe_moveff: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460D             MOV      R5,R1
   2613              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2614                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   2615              #endif
   2616          
   2617              // Deploy BLTouch at the start of any probe
   2618              //#if ENABLED(BLTOUCH)
   2619              if(MKSTOUCH == 1)
   \   00000006   0x....             LDR.N    R4,??DataTable136_5
   \   00000008   0xF894 0x0100      LDRB     R0,[R4, #+256]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD104             BNE.N    ??do_probe_move_0
   2620                {if (set_bltouch_deployed(true)) return true;}
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD123             BNE.N    ??do_probe_move_1
   2621              //#endif
   2622          
   2623              #if QUIET_PROBING
   2624                probing_pause(true);
   2625              #endif
   2626          
   2627              // Move down until probe triggered
   2628              do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
   \                     ??do_probe_move_0: (+1)
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x....             LDR.N    R1,??DataTable136_6  ;; 0x42700000
   \   0000001E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2629             /*
   2630              // Check to see if the probe was triggered
   2631              const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
   2632                #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2633                  Z_MIN
   2634                #else
   2635                  Z_MIN_PROBE
   2636                #endif
   2637              );
   2638              */
   2639                bool probe_triggered;
   2640                if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable150
   \   00000030   0xF894 0x1099      LDRB     R1,[R4, #+153]
   \   00000034   0x2902             CMP      R1,#+2
   \   00000036   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0xD003             BEQ.N    ??do_probe_move_2
   2641                {
   2642                  probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN);
   \   0000003E   0x0880             LSRS     R0,R0,#+2
   \   00000040   0xF000 0x0501      AND      R5,R0,#0x1
   \   00000044   0xE002             B.N      ??do_probe_move_3
   2643                }
   2644                else
   2645                {
   2646                  probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN_PROBE);
   \                     ??do_probe_move_2: (+1)
   \   00000046   0x08C0             LSRS     R0,R0,#+3
   \   00000048   0xF000 0x0501      AND      R5,R0,#0x1
   2647                }
   2648          
   2649              #if QUIET_PROBING
   2650                probing_pause(false);
   2651              #endif
   2652          
   2653              // Retract BLTouch immediately after a probe if it was triggered
   2654              //#if ENABLED(BLTOUCH)
   2655              if(MKSTOUCH == 1)
   \                     ??do_probe_move_3: (+1)
   \   0000004C   0xF894 0x0100      LDRB     R0,[R4, #+256]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD108             BNE.N    ??do_probe_move_4
   2656                {if (probe_triggered && set_bltouch_deployed(false)) return true;}
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD006             BEQ.N    ??do_probe_move_4
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD001             BEQ.N    ??do_probe_move_4
   \                     ??do_probe_move_1: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xBD3E             POP      {R1-R5,PC}
   2657              //#endif
   2658          
   2659              // Clear endstop flags
   2660              endstops.hit_on_purpose();
   \                     ??do_probe_move_4: (+1)
   \   00000066   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   2661          
   2662              // Get Z where the steppers were interrupted
   2663              set_current_from_steppers_for_axis(Z_AXIS);
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   2664          
   2665              // Tell the planner where we actually are
   2666              SYNC_PLAN_POSITION_KINEMATIC();
   \   00000070   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   2667          
   2668              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2669                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
   2670              #endif
   2671          
   2672              return !probe_triggered;
   \   00000074   0xF085 0x0001      EOR      R0,R5,#0x1
   \   00000078   0xBD3E             POP      {R1-R5,PC}       ;; return
   2673            }
   2674          
   2675            /**
   2676             * @details Used by probe_pt to do a single Z probe at the current position.
   2677             *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
   2678             *
   2679             * @return The raw Z position where the probe was triggered
   2680             */

   \                                 In section .text, align 2, keep-with-next
   2681            static float run_z_probe() {
   \                     _Z11run_z_probev: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2682          
   2683              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2684                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   2685              #endif
   2686          
   2687              // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
   2688              refresh_cmd_timeout();
   \   00000004   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   2689          
   2690              // Double-probing does a fast probe followed by a slow probe
   2691              #if MULTIPLE_PROBING == 2
   2692          
   2693                // Do a first probe at the fast speed
   2694                if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
   2695          
   2696                float first_probe_z = current_position[Z_AXIS];
   2697          
   2698                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2699                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
   2700                #endif
   2701          
   2702                // move up to make clearance for the probe
   2703                do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2704          
   2705              #else
   2706          
   2707                // If the nozzle is above the travel height then
   2708                // move down quickly before doing the slow probe
   2709                float z = Z_CLEARANCE_DEPLOY_PROBE;
   \   00000008   0x....             LDR.N    R4,??DataTable136_5
   \   0000000A   0x6E62             LDR      R2,[R4, #+100]
   2710                if (zprobe_zoffset < 0) z -= zprobe_zoffset;
   \   0000000C   0x....             LDR.N    R5,??DataTable136_4
   \   0000000E   0x6F2B             LDR      R3,[R5, #+112]
   \   00000010   0x4618             MOV      R0,R3
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000018   0xD204             BCS.N    ??run_z_probe_0
   \   0000001A   0x4610             MOV      R0,R2
   \   0000001C   0x4619             MOV      R1,R3
   \   0000001E   0x.... 0x....      BL       __aeabi_fsub
   \   00000022   0x4602             MOV      R2,R0
   2711          
   2712                if (z < current_position[Z_AXIS]) {
   \                     ??run_z_probe_0: (+1)
   \   00000024   0x4610             MOV      R0,R2
   \   00000026   0x6929             LDR      R1,[R5, #+16]
   \   00000028   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002C   0xD212             BCS.N    ??run_z_probe_1
   2713          
   2714                  // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
   2715                  if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
   \   0000002E   0x6FA1             LDR      R1,[R4, #+120]
   \   00000030   0x.... 0x....      BL       _Z13do_probe_moveff
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD10D             BNE.N    ??run_z_probe_1
   2716                    do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   \   00000038   0x6929             LDR      R1,[R5, #+16]
   \   0000003A   0x6EA0             LDR      R0,[R4, #+104]
   \   0000003C   0x.... 0x....      BL       __aeabi_fadd
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x6FA0             LDR      R0,[R4, #+120]
   \   00000044   0x....             LDR.N    R1,??DataTable136_6  ;; 0x42700000
   \   00000046   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0xA801             ADD      R0,SP,#+4
   \   00000050   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2717                }
   2718              #endif
   2719          
   2720              #if MULTIPLE_PROBING > 2
   2721                float probes_total = 0;
   2722                for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   2723              #endif
   2724          
   2725                  // move down slowly to find bed
   2726                  if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
   \                     ??run_z_probe_1: (+1)
   \   00000054   0x6FE1             LDR      R1,[R4, #+124]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable151  ;; 0xc1200000
   \   0000005A   0x.... 0x....      BL       _Z13do_probe_moveff
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD002             BEQ.N    ??run_z_probe_2
   \   00000062   0xF06F 0x4000      MVN      R0,#-2147483648
   \   00000066   0xBD3E             POP      {R1-R5,PC}
   2727          
   2728              #if MULTIPLE_PROBING > 2
   2729                  probes_total += current_position[Z_AXIS];
   2730                  if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2731                }
   2732              #endif
   2733          
   2734              #if MULTIPLE_PROBING > 2
   2735          
   2736                // Return the average value of all probes
   2737                return probes_total * (1.0 / (MULTIPLE_PROBING));
   2738          
   2739              #elif MULTIPLE_PROBING == 2
   2740          
   2741                const float z2 = current_position[Z_AXIS];
   2742          
   2743                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2744                  if (DEBUGGING(LEVELING)) {
   2745                    SERIAL_ECHOPAIR("2nd Probe Z:", z2);
   2746                    SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
   2747                  }
   2748                #endif
   2749          
   2750                // Return a weighted average of the fast and slow probes
   2751                return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
   2752          
   2753              #else
   2754          
   2755                // Return the single probe result
   2756                return current_position[Z_AXIS];
   \                     ??run_z_probe_2: (+1)
   \   00000068   0x6928             LDR      R0,[R5, #+16]
   \   0000006A   0xBD3E             POP      {R1-R5,PC}       ;; return
   2757          
   2758              #endif
   2759          
   2760              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2761                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
   2762              #endif
   2763            }
   2764          
   2765            /**
   2766             * - Move to the given XY
   2767             * - Deploy the probe, if not already deployed
   2768             * - Probe the bed, get the Z position
   2769             * - Depending on the 'stow' flag
   2770             *   - Stow the probe, or
   2771             *   - Raise to the BETWEEN height
   2772             * - Return the probed Z position
   2773             */

   \                                 In section .text, align 2, keep-with-next
   2774            float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
   \                     _Z8probe_ptRKfS0_bhb: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x4699             MOV      R9,R3
   2775              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2776                if (DEBUGGING(LEVELING)) {
   2777                  SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
   2778                  SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
   2779                  SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
   2780                  SERIAL_ECHOLNPGM("stow)");
   2781                  DEBUG_POS("", current_position);
   2782                }
   2783              #endif
   2784          
   2785              // TODO: Adapt for SCARA, where the offset rotates
   2786              float nx = rx, ny = ry;
   \   0000000E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000012   0x9002             STR      R0,[SP, #+8]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x9001             STR      R0,[SP, #+4]
   2787              if (probe_relative) {
   \   00000018   0x.... 0x....      LDR.W    R10,??DataTable151_1
   \   0000001C   0xF9BA 0x1058      LDRSH    R1,[R10, #+88]
   \   00000020   0xF240 0x3202      MOVW     R2,#+770
   \   00000024   0x9810             LDR      R0,[SP, #+64]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD025             BEQ.N    ??probe_pt_0
   2788                if(MACHINETPYE & IS_KINEMATIC)
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xD004             BEQ.N    ??probe_pt_1
   2789                {
   2790                  if (!position_is_reachable_by_probe_IS_KINEMATIC(rx, ry)) return NAN;  // The given position is in terms of the probe
   \   00000032   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD104             BNE.N    ??probe_pt_2
   \   0000003A   0xE029             B.N      ??probe_pt_3
   2791                }
   2792                else
   2793                {
   2794                  if (!position_is_reachable_by_probe_IS_CARTESIAN(rx, ry)) return NAN;  // The given position is in terms of the probe
   \                     ??probe_pt_1: (+1)
   \   0000003C   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD025             BEQ.N    ??probe_pt_3
   2795                }
   2796                nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
   \                     ??probe_pt_2: (+1)
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0xF8DA 0x106C      LDR      R1,[R10, #+108]
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x9002             STR      R0,[SP, #+8]
   2797                ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0xF8DA 0x1070      LDR      R1,[R10, #+112]
   \   00000056   0x.... 0x....      BL       __aeabi_fsub
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   2798              }
   2799              else
   2800              {
   2801                  if(MACHINETPYE & IS_KINEMATIC)
   2802                  {
   2803                      if (!position_is_reachable_IS_KINEMATIC(nx, ny)) return NAN;        // The given position is in terms of the nozzle
   2804                  }
   2805                  else
   2806                  {
   2807                      if (!position_is_reachable_IS_CARTESIAN(nx, ny)) return NAN;        // The given position is in terms of the nozzle            
   2808                  }
   2809               }
   2810              //const 
   2811                  float nz;/* =
   2812                #if ENABLED(DELTA)
   2813                  // Move below clip height or xy move will be aborted by do_blocking_move_to
   2814                  min(current_position[Z_AXIS], delta_clip_start_height)
   2815                #else
   2816                  current_position[Z_AXIS]
   2817                #endif
   2818              ;
   2819              */
   2820              if(MACHINETPYE ==  DELTA)
   \                     ??probe_pt_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R5,??DataTable151_2
   \   00000060   0x6928             LDR      R0,[R5, #+16]
   \   00000062   0xF9BA 0x1058      LDRSH    R1,[R10, #+88]
   \   00000066   0x2902             CMP      R1,#+2
   \   00000068   0xD117             BNE.N    ??probe_pt_5
   2821              {
   2822                  nz = min(current_position[Z_AXIS], delta_clip_start_height);
   \   0000006A   0x6FE9             LDR      R1,[R5, #+124]
   \   0000006C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000070   0xD211             BCS.N    ??probe_pt_6
   \   00000072   0x9003             STR      R0,[SP, #+12]
   \   00000074   0xE012             B.N      ??probe_pt_7
   2823              }
   \                     ??probe_pt_0: (+1)
   \   00000076   0x4211             TST      R1,R2
   \   00000078   0xA901             ADD      R1,SP,#+4
   \   0000007A   0xA802             ADD      R0,SP,#+8
   \   0000007C   0xD004             BEQ.N    ??probe_pt_8
   \   0000007E   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD1EA             BNE.N    ??probe_pt_4
   \   00000086   0xE003             B.N      ??probe_pt_3
   \                     ??probe_pt_8: (+1)
   \   00000088   0x.... 0x....      BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD1E5             BNE.N    ??probe_pt_4
   \                     ??probe_pt_3: (+1)
   \   00000090   0xF06F 0x4000      MVN      R0,#-2147483648
   \   00000094   0xE084             B.N      ??probe_pt_9
   \                     ??probe_pt_6: (+1)
   \   00000096   0x9103             STR      R1,[SP, #+12]
   \   00000098   0xE000             B.N      ??probe_pt_7
   2824              else
   2825              {
   2826                  nz = current_position[Z_AXIS];
   \                     ??probe_pt_5: (+1)
   \   0000009A   0x9003             STR      R0,[SP, #+12]
   2827              }
   2828              const float old_feedrate_mm_s = feedrate_mm_s;
   \                     ??probe_pt_7: (+1)
   \   0000009C   0x6DE8             LDR      R0,[R5, #+92]
   \   0000009E   0x9005             STR      R0,[SP, #+20]
   2829              feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
   \   000000A0   0x6F68             LDR      R0,[R5, #+116]
   \   000000A2   0x65E8             STR      R0,[R5, #+92]
   2830          
   2831              // Move the probe to the starting XYZ
   2832              do_blocking_move_to(nx, ny, nz);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0xAB00             ADD      R3,SP,#+0
   \   000000AA   0xAA03             ADD      R2,SP,#+12
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0xA802             ADD      R0,SP,#+8
   \   000000B0   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
   2833          
   2834              float measured_z = NAN;
   \   000000B4   0xF06F 0x4B00      MVN      R11,#-2147483648
   \   000000B8   0x465E             MOV      R6,R11
   2835              if (!DEPLOY_PROBE()) {
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD120             BNE.N    ??probe_pt_10
   2836                measured_z = run_z_probe() + zprobe_zoffset;
   \   000000C4   0x.... 0x....      BL       _Z11run_z_probev
   \   000000C8   0x4601             MOV      R1,R0
   \   000000CA   0x6F28             LDR      R0,[R5, #+112]
   \   000000CC   0x.... 0x....      BL       __aeabi_fadd
   \   000000D0   0x4606             MOV      R6,R0
   2837          
   2838                if (!stow)
   \   000000D2   0x2F00             CMP      R7,#+0
   \   000000D4   0xD111             BNE.N    ??probe_pt_11
   2839                  do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   \   000000D6   0x6929             LDR      R1,[R5, #+16]
   \   000000D8   0xF8DA 0x0068      LDR      R0,[R10, #+104]
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x9004             STR      R0,[SP, #+16]
   \   000000E2   0xF8DA 0x0078      LDR      R0,[R10, #+120]
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable152  ;; 0x42700000
   \   000000EA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000EE   0x9000             STR      R0,[SP, #+0]
   \   000000F0   0xA900             ADD      R1,SP,#+0
   \   000000F2   0xA804             ADD      R0,SP,#+16
   \   000000F4   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   000000F8   0xE005             B.N      ??probe_pt_10
   2840                else
   2841                  if (STOW_PROBE()) measured_z = NAN;
   \                     ??probe_pt_11: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD000             BEQ.N    ??probe_pt_10
   \   00000104   0x465E             MOV      R6,R11
   2842              }
   2843          
   2844              if (verbose_level > 2) {
   \                     ??probe_pt_10: (+1)
   \   00000106   0xF1B9 0x0F03      CMP      R9,#+3
   \   0000010A   0xDB35             BLT.N    ??probe_pt_12
   2845                SERIAL_PROTOCOLPGM("Bed X: ");
   \   0000010C   0x.... 0x....      ADR.W    R0,`?<Constant "Bed X: ">`
   \   00000110   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2846                SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
   \   00000114   0x....             LDR.N    R7,??DataTable139_4
   \   00000116   0x2003             MOVS     R0,#+3
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   0000011E   0x6BA8             LDR      R0,[R5, #+56]
   \   00000120   0x.... 0x....      BL       __aeabi_fadd
   \   00000124   0x.... 0x....      BL       __aeabi_f2d
   \   00000128   0x4602             MOV      R2,R0
   \   0000012A   0x460B             MOV      R3,R1
   \   0000012C   0x4638             MOV      R0,R7
   \   0000012E   0x.... 0x....      BL       _ZN5Print5printEdi
   2847                SERIAL_PROTOCOLPGM(" Y: ");
   \   00000132   0x.... 0x....      ADR.W    R0,`?<Constant " Y: ">`
   \   00000136   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2848                SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
   \   0000013A   0x2003             MOVS     R0,#+3
   \   0000013C   0x9000             STR      R0,[SP, #+0]
   \   0000013E   0x6821             LDR      R1,[R4, #+0]
   \   00000140   0x6BE8             LDR      R0,[R5, #+60]
   \   00000142   0x.... 0x....      BL       __aeabi_fadd
   \   00000146   0x.... 0x....      BL       __aeabi_f2d
   \   0000014A   0x4602             MOV      R2,R0
   \   0000014C   0x460B             MOV      R3,R1
   \   0000014E   0x4638             MOV      R0,R7
   \   00000150   0x.... 0x....      BL       _ZN5Print5printEdi
   2849                SERIAL_PROTOCOLPGM(" Z: ");
   \   00000154   0x.... 0x....      ADR.W    R0,`?<Constant " Z: ">`
   \   00000158   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2850                SERIAL_PROTOCOL_F(measured_z, 3);
   \   0000015C   0x2003             MOVS     R0,#+3
   \   0000015E   0x9000             STR      R0,[SP, #+0]
   \   00000160   0x4630             MOV      R0,R6
   \   00000162   0x.... 0x....      BL       __aeabi_f2d
   \   00000166   0x4602             MOV      R2,R0
   \   00000168   0x460B             MOV      R3,R1
   \   0000016A   0x4638             MOV      R0,R7
   \   0000016C   0x.... 0x....      BL       _ZN5Print5printEdi
   2851                SERIAL_EOL();
   \   00000170   0x210A             MOVS     R1,#+10
   \   00000172   0x4638             MOV      R0,R7
   \   00000174   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2852              }
   2853          
   2854              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2855                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
   2856              #endif
   2857          
   2858              feedrate_mm_s = old_feedrate_mm_s;
   \                     ??probe_pt_12: (+1)
   \   00000178   0x9805             LDR      R0,[SP, #+20]
   \   0000017A   0x65E8             STR      R0,[R5, #+92]
   2859          
   2860              if (isnan(measured_z)) {
   \   0000017C   0x4630             MOV      R0,R6
   \   0000017E   0x.... 0x....      BL       __iar_FDtest
   \   00000182   0x2802             CMP      R0,#+2
   \   00000184   0xD10B             BNE.N    ??probe_pt_13
   2861                LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
   \   00000186   0x2100             MOVS     R1,#+0
   \   00000188   0x.... 0x....      ADR.W    R0,`?<Constant "Probing failed">`
   \   0000018C   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   2862                SERIAL_ERROR_START();
   \   00000190   0x....             LDR.N    R0,??DataTable139_5
   \   00000192   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2863                SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
   \   00000196   0x.... 0x....      ADR.W    R0,`?<Constant "Probing failed\\n">`
   \   0000019A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2864              }
   2865          
   2866              return measured_z;
   \                     ??probe_pt_13: (+1)
   \   0000019E   0x4630             MOV      R0,R6
   \                     ??probe_pt_9: (+1)
   \   000001A0   0xB007             ADD      SP,SP,#+28
   \   000001A2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2867            }
   2868          
   2869          #endif // HAS_BED_PROBE
   2870          
   2871          #if 1//HAS_LEVELING
   2872          

   \                                 In section .text, align 2, keep-with-next
   2873            bool leveling_is_valid() {
   \                     _Z17leveling_is_validv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable151_1
   \   00000004   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD103             BNE.N    ??leveling_is_valid_0
   2874            /*
   2875              return
   2876                #if ENABLED(MESH_BED_LEVELING)
   2877                  mbl.has_mesh
   2878                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2879                  !!bilinear_grid_spacing[X_AXIS]
   2880                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   2881                  true
   2882                #else // 3POINT, LINEAR
   2883                  true
   2884                #endif
   2885              ;
   2886              */
   2887                if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   2888                  return mbl.has_mesh;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable153
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x4770             BX       LR
   2889                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??leveling_is_valid_0: (+1)
   \   00000014   0x2808             CMP      R0,#+8
   \   00000016   0xD106             BNE.N    ??leveling_is_valid_1
   2890                  return !!bilinear_grid_spacing[X_AXIS];
   \   00000018   0x....             LDR.N    R0,??DataTable141
   \   0000001A   0x6900             LDR      R0,[R0, #+16]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x4180             SBCS     R0,R0,R0
   \   00000020   0x43C0             MVNS     R0,R0
   \   00000022   0x0FC0             LSRS     R0,R0,#+31
   \   00000024   0x4770             BX       LR
   2891                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??leveling_is_valid_1: (+1)
   \   00000026   0x2810             CMP      R0,#+16
   \   00000028   0xD101             BNE.N    ??leveling_is_valid_2
   2892                  return true;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x4770             BX       LR
   2893                else
   2894                  return true;
   \                     ??leveling_is_valid_2: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x4770             BX       LR               ;; return
   2895            }
   2896          
   2897            /**
   2898             * Turn bed leveling on or off, fixing the current
   2899             * position as-needed.
   2900             *
   2901             * Disable: Current position = physical position
   2902             *  Enable: Current position = "unleveled" physical position
   2903             */

   \                                 In section .text, align 2, keep-with-next
   2904            void set_bed_leveling_enabled(const bool enable/*=true*/) {
   \                     _Z24set_bed_leveling_enabledb: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4605             MOV      R5,R0
   2905              bool can_change;
   2906          /*
   2907              #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2908                const bool can_change = (!enable || leveling_is_valid());
   2909              #else
   2910                constexpr bool can_change = true;
   2911              #endif
   2912          */
   2913              if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable151_1
   \   0000000C   0xF896 0x7040      LDRB     R7,[R6, #+64]
   \   00000010   0x46B8             MOV      R8,R7
   \   00000012   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000016   0xD106             BNE.N    ??set_bed_leveling_enabled_0
   2914                  can_change = (!enable || leveling_is_valid());
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD002             BEQ.N    ??set_bed_leveling_enabled_1
   \   0000001C   0x.... 0x....      BL       _Z17leveling_is_validv
   \   00000020   0xE002             B.N      ??set_bed_leveling_enabled_2
   \                     ??set_bed_leveling_enabled_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE000             B.N      ??set_bed_leveling_enabled_2
   2915              else
   2916                  can_change = true;
   \                     ??set_bed_leveling_enabled_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   2917                  
   2918              if (can_change && enable != planner.leveling_active) {
   \                     ??set_bed_leveling_enabled_2: (+1)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD060             BEQ.N    ??set_bed_leveling_enabled_3
   \   0000002C   0x.... 0x....      LDR.W    R4,??DataTable153_1
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD05B             BEQ.N    ??set_bed_leveling_enabled_3
   2919          
   2920                //#if ENABLED(MESH_BED_LEVELING)
   2921                if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \   00000036   0xF1B8 0x0F20      CMP      R8,#+32
   \   0000003A   0xD119             BNE.N    ??set_bed_leveling_enabled_4
   2922                {
   2923                  if (!enable)
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD109             BNE.N    ??set_bed_leveling_enabled_5
   2924                    planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   \   00000040   0x.... 0x....      LDR.W    R3,??DataTable151_2
   \   00000044   0xF103 0x0210      ADD      R2,R3,#+16
   \   00000048   0xF103 0x010C      ADD      R1,R3,#+12
   \   0000004C   0xF103 0x0008      ADD      R0,R3,#+8
   \   00000050   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   2925          
   2926                  const bool enabling = enable && leveling_is_valid();
   \                     ??set_bed_leveling_enabled_5: (+1)
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD002             BEQ.N    ??set_bed_leveling_enabled_6
   \   00000058   0x.... 0x....      BL       _Z17leveling_is_validv
   \   0000005C   0xE000             B.N      ??set_bed_leveling_enabled_7
   \                     ??set_bed_leveling_enabled_6: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   2927                  planner.leveling_active = enabling;
   \                     ??set_bed_leveling_enabled_7: (+1)
   \   00000060   0x7020             STRB     R0,[R4, #+0]
   2928                  if (enabling) planner.unapply_leveling(current_position);
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD043             BEQ.N    ??set_bed_leveling_enabled_3
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable154
   \   0000006A   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   \   0000006E   0xE03E             B.N      ??set_bed_leveling_enabled_3
   2929                }
   2930                //#elif ENABLED(AUTO_BED_LEVELING_UBL)
   2931                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??set_bed_leveling_enabled_4: (+1)
   \   00000070   0xF1B8 0x0F10      CMP      R8,#+16
   \   00000074   0xD11A             BNE.N    ??set_bed_leveling_enabled_8
   2932                {
   2933                  //#if PLANNER_LEVELING
   2934                  if(BED_LEVELING_METHOD&ABL_PLANAR)
   \   00000076   0x2106             MOVS     R1,#+6
   \   00000078   0x420F             TST      R7,R1
   \   0000007A   0xD015             BEQ.N    ??set_bed_leveling_enabled_9
   2935                  {
   2936                    if (planner.leveling_active) {                       // leveling from on to off
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable151_2
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD00A             BEQ.N    ??set_bed_leveling_enabled_10
   2937                      // change unleveled current_position to physical current_position without moving steppers.
   2938                      planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   \   00000084   0xF103 0x0210      ADD      R2,R3,#+16
   \   00000088   0xF103 0x010C      ADD      R1,R3,#+12
   \   0000008C   0xF103 0x0008      ADD      R0,R3,#+8
   \   00000090   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   2939                      planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x7020             STRB     R0,[R4, #+0]
   \   00000098   0xE029             B.N      ??set_bed_leveling_enabled_3
   2940                    }
   2941                    else {                                        // leveling from off to on
   2942                      planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
   \                     ??set_bed_leveling_enabled_10: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x7020             STRB     R0,[R4, #+0]
   2943                      // change physical current_position to unleveled current_position without moving steppers.
   2944                      planner.unapply_leveling(current_position);
   \   0000009E   0xF103 0x0008      ADD      R0,R3,#+8
   \   000000A2   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   \   000000A6   0xE022             B.N      ??set_bed_leveling_enabled_3
   2945                    }
   2946                  }
   2947                  //#else
   2948                  else
   2949                    planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
   \                     ??set_bed_leveling_enabled_9: (+1)
   \   000000A8   0x7025             STRB     R5,[R4, #+0]
   \   000000AA   0xE020             B.N      ??set_bed_leveling_enabled_3
   2950                  //#endif
   2951                }
   2952                //#else // ABL
   2953                else
   2954                {
   2955                  //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2956                  if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
   \                     ??set_bed_leveling_enabled_8: (+1)
   \   000000AC   0xF1B8 0x0F08      CMP      R8,#+8
   \   000000B0   0xD107             BNE.N    ??set_bed_leveling_enabled_11
   2957                  {
   2958                    // Force bilinear_z_offset to re-calculate next time
   2959                    const float reset[XYZ] = { -9999.999, -9999.999, 0 };
   \   000000B2   0xA800             ADD      R0,SP,#+0
   \   000000B4   0x.... 0x....      ADR.W    R1,`?<Constant {(-9.9999990233E+3F), (-9.999999023`
   \   000000B8   0xC98C             LDM      R1!,{R2,R3,R7}
   \   000000BA   0xC08C             STM      R0!,{R2,R3,R7}
   2960                    (void)bilinear_z_offset(reset);
   \   000000BC   0xA800             ADD      R0,SP,#+0
   \   000000BE   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   2961                  }
   2962                  //#endif
   2963          
   2964                  // Enable or disable leveling compensation in the planner
   2965                  planner.leveling_active = enable;
   \                     ??set_bed_leveling_enabled_11: (+1)
   \   000000C2   0x7025             STRB     R5,[R4, #+0]
   2966          
   2967                  if (!enable)
   \   000000C4   0x2D00             CMP      R5,#+0
   \   000000C6   0xD10C             BNE.N    ??set_bed_leveling_enabled_12
   2968                      /*
   2969                    // When disabling just get the current position from the steppers.
   2970                    // This will yield the smallest error when first converted back to steps.
   2971                    set_current_from_steppers_for_axis(
   2972                      #if ABL_PLANAR
   2973                        ALL_AXES
   2974                      #else
   2975                        Z_AXIS
   2976                      #endif
   2977                    );
   2978                    */
   2979                  {
   2980                      if(BED_LEVELING_METHOD&ABL_PLANAR)
   \   000000C8   0xF896 0x0040      LDRB     R0,[R6, #+64]
   \   000000CC   0x2106             MOVS     R1,#+6
   \   000000CE   0x4208             TST      R0,R1
   \   000000D0   0xD003             BEQ.N    ??set_bed_leveling_enabled_13
   2981                          set_current_from_steppers_for_axis(ALL_AXES);
   \   000000D2   0x2064             MOVS     R0,#+100
   \   000000D4   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   \   000000D8   0xE007             B.N      ??set_bed_leveling_enabled_14
   2982                      else
   2983                          set_current_from_steppers_for_axis(Z_AXIS);
   \                     ??set_bed_leveling_enabled_13: (+1)
   \   000000DA   0x2002             MOVS     R0,#+2
   \   000000DC   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   \   000000E0   0xE003             B.N      ??set_bed_leveling_enabled_14
   2984                  }
   2985                  else
   2986                    // When enabling, remove compensation from the current position,
   2987                    // so compensation will give the right stepper counts.
   2988                    planner.unapply_leveling(current_position);
   \                     ??set_bed_leveling_enabled_12: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable154
   \   000000E6   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   2989          
   2990                  SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??set_bed_leveling_enabled_14: (+1)
   \   000000EA   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   2991                }
   2992                //#endif // ABL
   2993              }
   2994            }
   \                     ??set_bed_leveling_enabled_3: (+1)
   \   000000EE   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
   2995          
   2996            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   2997          

   \                                 In section .text, align 2, keep-with-next
   2998              void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
   \                     _Z17set_z_fade_heightfb: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x460C             MOV      R4,R1
   2999          
   3000                if (planner.z_fade_height == zfh) return; // do nothing if no change
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable154_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x9903             LDR      R1,[SP, #+12]
   \   0000000E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000012   0xD03A             BEQ.N    ??set_z_fade_height_0
   3001          
   3002                const bool level_active = planner.leveling_active;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable153_1
   \   00000018   0x7806             LDRB     R6,[R0, #+0]
   3003          
   3004                //#if ENABLED(AUTO_BED_LEVELING_UBL)
   3005                if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable151_1
   \   0000001E   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \   00000022   0x2810             CMP      R0,#+16
   \   00000024   0xD104             BNE.N    ??set_z_fade_height_1
   3006                  if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD002             BEQ.N    ??set_z_fade_height_1
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   3007                //#endif
   3008          
   3009                planner.set_z_fade_height(zfh);
   \                     ??set_z_fade_height_1: (+1)
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       _ZN7Planner17set_z_fade_heightERKf
   3010          
   3011                if (level_active) {
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD027             BEQ.N    ??set_z_fade_height_0
   3012                  const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable151_2
   \   0000003E   0x68B0             LDR      R0,[R6, #+8]
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x68F0             LDR      R0,[R6, #+12]
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x6930             LDR      R0,[R6, #+16]
   \   00000048   0x9002             STR      R0,[SP, #+8]
   3013                  //#if ENABLED(AUTO_BED_LEVELING_UBL)
   3014                  if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
   \   0000004A   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \   0000004E   0x2810             CMP      R0,#+16
   \   00000050   0xD103             BNE.N    ??set_z_fade_height_2
   3015                    set_bed_leveling_enabled(true);  // turn back on after changing fade height
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   \   00000058   0xE00B             B.N      ??set_z_fade_height_3
   3016                  //#else
   3017                  else
   3018                  {
   3019                  /*
   3020                    set_current_from_steppers_for_axis(
   3021                      #if ABL_PLANAR
   3022                        ALL_AXES
   3023                      #else
   3024                        Z_AXIS
   3025                      #endif
   3026                    );
   3027                      */
   3028                    if(BED_LEVELING_METHOD&ABL_PLANAR)
   \                     ??set_z_fade_height_2: (+1)
   \   0000005A   0x2106             MOVS     R1,#+6
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD003             BEQ.N    ??set_z_fade_height_4
   3029                    {
   3030                      set_current_from_steppers_for_axis(ALL_AXES);
   \   00000060   0x2064             MOVS     R0,#+100
   \   00000062   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   \   00000066   0xE002             B.N      ??set_z_fade_height_5
   3031                    }
   3032                    else
   3033                    {
   3034                      set_current_from_steppers_for_axis(Z_AXIS);
   \                     ??set_z_fade_height_4: (+1)
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   3035                    }
   3036                      
   3037                    SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??set_z_fade_height_5: (+1)
   \   0000006E   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   3038                  }
   3039                  //#endif
   3040                  if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
   \                     ??set_z_fade_height_3: (+1)
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD009             BEQ.N    ??set_z_fade_height_0
   \   00000076   0x220C             MOVS     R2,#+12
   \   00000078   0xF106 0x0108      ADD      R1,R6,#+8
   \   0000007C   0xA800             ADD      R0,SP,#+0
   \   0000007E   0x.... 0x....      BL       memcmp
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD001             BEQ.N    ??set_z_fade_height_0
   3041                    report_current_position();
   \   00000086   0x.... 0x....      BL       _Z23report_current_positionv
   3042                }
   3043              }
   \                     ??set_z_fade_height_0: (+1)
   \   0000008A   0xBD7F             POP      {R0-R6,PC}       ;; return
   3044          
   3045            #endif // LEVELING_FADE_HEIGHT
   3046          
   3047            /**
   3048             * Reset calibration results to zero.
   3049             */

   \                                 In section .text, align 2, keep-with-next
   3050            void reset_bed_level() {
   \                     _Z15reset_bed_levelv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3051              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3052                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
   3053              #endif
   3054              set_bed_leveling_enabled(false);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   3055              //#if ENABLED(MESH_BED_LEVELING)
   3056              if(BED_LEVELING_METHOD==MESH_BED_LEVELING)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable151_1
   \   0000000C   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x2A20             CMP      R2,#+32
   \   00000014   0xD10A             BNE.N    ??reset_bed_level_0
   3057              {
   3058                if (leveling_is_valid()) {
   \   00000016   0x.... 0x....      BL       _Z17leveling_is_validv
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD037             BEQ.N    ??reset_bed_level_1
   3059                  mbl.reset();
   \   0000001E   0x.... 0x....      BL       _ZN17mesh_bed_leveling5resetEv
   3060                  mbl.has_mesh = false;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable153
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   \   0000002A   0xBD10             POP      {R4,PC}
   3061                }
   3062              }
   3063              //#elif ENABLED(AUTO_BED_LEVELING_UBL)
   3064              else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
   \                     ??reset_bed_level_0: (+1)
   \   0000002C   0x2A10             CMP      R2,#+16
   \   0000002E   0xD103             BNE.N    ??reset_bed_level_2
   3065                ubl.reset();
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      _ZN20unified_bed_leveling5resetEv
   3066              //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   3067              else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
   \                     ??reset_bed_level_2: (+1)
   \   00000038   0x2A08             CMP      R2,#+8
   \   0000003A   0xD11F             BNE.N    ??reset_bed_level_3
   3068              {
   3069                bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
   3070                bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
   \   0000003C   0x....             LDR.N    R1,??DataTable141
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x614A             STR      R2,[R1, #+20]
   \   00000042   0x610A             STR      R2,[R1, #+16]
   \   00000044   0x61CA             STR      R2,[R1, #+28]
   \   00000046   0x618A             STR      R2,[R1, #+24]
   3071                for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   \   00000048   0x4611             MOV      R1,R2
   \   0000004A   0xE011             B.N      ??reset_bed_level_4
   3072                  for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   3073                    z_values[x][y] = NAN;
   \                     ??reset_bed_level_5: (+1)
   \   0000004C   0xEB01 0x0341      ADD      R3,R1,R1, LSL #+1
   \   00000050   0x.... 0x....      LDR.W    R4,??DataTable156
   \   00000054   0xEB04 0x1303      ADD      R3,R4,R3, LSL #+4
   \   00000058   0xF06F 0x4400      MVN      R4,#-2147483648
   \   0000005C   0xF843 0x4022      STR      R4,[R3, R2, LSL #+2]
   \   00000060   0x1C52             ADDS     R2,R2,#+1
   \                     ??reset_bed_level_6: (+1)
   \   00000062   0xF890 0x3061      LDRB     R3,[R0, #+97]
   \   00000066   0xB2D2             UXTB     R2,R2
   \   00000068   0x429A             CMP      R2,R3
   \   0000006A   0xD3EF             BCC.N    ??reset_bed_level_5
   \   0000006C   0x1C49             ADDS     R1,R1,#+1
   \   0000006E   0xB2C9             UXTB     R1,R1
   \                     ??reset_bed_level_4: (+1)
   \   00000070   0xF890 0x2060      LDRB     R2,[R0, #+96]
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xDA0A             BGE.N    ??reset_bed_level_1
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0xE7F2             B.N      ??reset_bed_level_6
   3074              }
   3075              //#elif ABL_PLANAR
   3076              else if(BED_LEVELING_METHOD&ABL_PLANAR)
   \                     ??reset_bed_level_3: (+1)
   \   0000007C   0x2006             MOVS     R0,#+6
   \   0000007E   0x4201             TST      R1,R0
   \   00000080   0xD005             BEQ.N    ??reset_bed_level_1
   3077                planner.bed_level_matrix.set_to_identity();
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable156_1
   \   00000086   0xE8BD 0x4010      POP      {R4,LR}
   \   0000008A   0x.... 0x....      B.W      _ZN10matrix_3x315set_to_identityEv
   3078              //#endif
   3079            }
   \                     ??reset_bed_level_1: (+1)
   \   0000008E   0xBD10             POP      {R4,PC}          ;; return
   3080          
   3081          #endif // HAS_LEVELING
   3082          
   3083          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
   3084          
   3085            /**
   3086             * Enable to produce output in JSON format suitable
   3087             * for SCAD or JavaScript mesh visualizers.
   3088             *
   3089             * Visualize meshes in OpenSCAD using the included script.
   3090             *
   3091             *   buildroot/shared/scripts/MarlinMesh.scad
   3092             */
   3093            //#define SCAD_MESH_OUTPUT
   3094          
   3095            /**
   3096             * Print calibration results for plotting or manual frame adjustment.
   3097             */
   3098            //static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {

   \                                 In section .text, align 2, keep-with-next
   3099              static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, const uint8_t fn) {
   \                     _Z14print_2d_arrayhhhh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x4698             MOV      R8,R3
   3100              #ifndef SCAD_MESH_OUTPUT
   3101                for (uint8_t x = 0; x < sx; x++) {
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable156_2
   \   00000012   0xE00C             B.N      ??print_2d_array_0
   3102                  for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
   \                     ??print_2d_array_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??print_2d_array_2: (+1)
   \   00000016   0xB2FF             UXTB     R7,R7
   \   00000018   0x1900             ADDS     R0,R0,R4
   \   0000001A   0x1C80             ADDS     R0,R0,#+2
   \   0000001C   0x4287             CMP      R7,R0
   \   0000001E   0xDB0A             BLT.N    ??print_2d_array_3
   3103                    SERIAL_PROTOCOLCHAR(' ');
   3104                  SERIAL_PROTOCOL((int)x);
   \   00000020   0x220A             MOVS     R2,#+10
   \   00000022   0x4631             MOV      R1,R6
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       _ZN5Print5printEii
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0xB2F6             UXTB     R6,R6
   \                     ??print_2d_array_0: (+1)
   \   0000002E   0x454E             CMP      R6,R9
   \   00000030   0xDA0A             BGE.N    ??print_2d_array_4
   \   00000032   0x2700             MOVS     R7,#+0
   \   00000034   0xE004             B.N      ??print_2d_array_5
   \                     ??print_2d_array_3: (+1)
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000003E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??print_2d_array_5: (+1)
   \   00000040   0x2E0A             CMP      R6,#+10
   \   00000042   0xDAE7             BGE.N    ??print_2d_array_1
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE7E6             B.N      ??print_2d_array_2
   3105                }
   3106                SERIAL_EOL();
   \                     ??print_2d_array_4: (+1)
   \   00000048   0x210A             MOVS     R1,#+10
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   3107              #endif
   3108              #ifdef SCAD_MESH_OUTPUT
   3109                SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
   3110              #endif
   3111              for (uint8_t y = 0; y < sy; y++) {
   \   00000050   0x2600             MOVS     R6,#+0
   \   00000052   0xE005             B.N      ??print_2d_array_6
   3112                #ifdef SCAD_MESH_OUTPUT
   3113                  SERIAL_PROTOCOLPGM(" [");           // open sub-array
   3114                #else
   3115                  if (y < 10) SERIAL_PROTOCOLCHAR(' ');
   3116                  SERIAL_PROTOCOL((int)y);
   3117                #endif
   3118                for (uint8_t x = 0; x < sx; x++) {
   3119                  SERIAL_PROTOCOLCHAR(' ');
   3120                  //const float offset = fn(x, y);
   3121                  float offset;
   3122          		switch(fn)
   3123          		{
   3124          			case 0:	
   3125          			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   3126          				offset =z_values[x][y];
   3127          			break;
   3128          			case 1:	
   3129          			#if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3130          				offset =z_values_virt[x][y];	
   3131          			#endif
   3132          			break;
   3133          			case 2:	
   3134          				if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   3135                             offset =mbl.z_values[x][y];		
   3136                                    break;
   3137          			default:		break;
   3138          		}        
   3139                  if (!isnan(offset)) {
   3140                    if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
   3141                    SERIAL_PROTOCOL_F(offset, precision);
   3142                  }
   3143                  else {
   3144                    #ifdef SCAD_MESH_OUTPUT
   3145                      for (uint8_t i = 3; i < precision + 3; i++)
   3146                        SERIAL_PROTOCOLCHAR(' ');
   3147                      SERIAL_PROTOCOLPGM("NAN");
   3148                    #else
   3149                      for (uint8_t i = 0; i < precision + 3; i++)
   3150                        SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
   3151                    #endif
   3152                  }
   3153                  #ifdef SCAD_MESH_OUTPUT
   3154                    if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
   3155                  #endif
   3156                }
   3157                #ifdef SCAD_MESH_OUTPUT
   3158                  SERIAL_PROTOCOLCHAR(' ');
   3159                  SERIAL_PROTOCOLCHAR(']');                     // close sub-array
   3160                  if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
   3161                #endif
   3162                SERIAL_EOL();
   \                     ??print_2d_array_7: (+1)
   \   00000054   0x210A             MOVS     R1,#+10
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000005C   0x1C76             ADDS     R6,R6,#+1
   \   0000005E   0xB2F6             UXTB     R6,R6
   \                     ??print_2d_array_6: (+1)
   \   00000060   0x4556             CMP      R6,R10
   \   00000062   0xDA61             BGE.N    ??print_2d_array_8
   \   00000064   0x2E0A             CMP      R6,#+10
   \   00000066   0xDA03             BGE.N    ??print_2d_array_9
   \   00000068   0x2120             MOVS     R1,#+32
   \   0000006A   0x4628             MOV      R0,R5
   \   0000006C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??print_2d_array_9: (+1)
   \   00000070   0x220A             MOVS     R2,#+10
   \   00000072   0x4631             MOV      R1,R6
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       _ZN5Print5printEii
   \   0000007A   0x2700             MOVS     R7,#+0
   \   0000007C   0xE026             B.N      ??print_2d_array_10
   \                     ??print_2d_array_11: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable151_1
   \   00000082   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000086   0x2820             CMP      R0,#+32
   \   00000088   0xD107             BNE.N    ??print_2d_array_12
   \   0000008A   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable156_5
   \   00000092   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000096   0xF850 0xB026      LDR      R11,[R0, R6, LSL #+2]
   \                     ??print_2d_array_12: (+1)
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x.... 0x....      BL       __iar_FDtest
   \   000000A0   0x2802             CMP      R0,#+2
   \   000000A2   0xD02E             BEQ.N    ??print_2d_array_13
   \   000000A4   0x4658             MOV      R0,R11
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000AC   0xD803             BHI.N    ??print_2d_array_14
   \   000000AE   0x212B             MOVS     R1,#+43
   \   000000B0   0x4628             MOV      R0,R5
   \   000000B2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??print_2d_array_14: (+1)
   \   000000B6   0x9400             STR      R4,[SP, #+0]
   \   000000B8   0x4658             MOV      R0,R11
   \   000000BA   0x.... 0x....      BL       __aeabi_f2d
   \   000000BE   0x4602             MOV      R2,R0
   \   000000C0   0x460B             MOV      R3,R1
   \   000000C2   0x4628             MOV      R0,R5
   \   000000C4   0x.... 0x....      BL       _ZN5Print5printEdi
   \                     ??print_2d_array_15: (+1)
   \   000000C8   0x1C7F             ADDS     R7,R7,#+1
   \   000000CA   0xB2FF             UXTB     R7,R7
   \                     ??print_2d_array_10: (+1)
   \   000000CC   0x454F             CMP      R7,R9
   \   000000CE   0xDAC1             BGE.N    ??print_2d_array_7
   \   000000D0   0x2120             MOVS     R1,#+32
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD002             BEQ.N    ??print_2d_array_16
   \   000000DE   0x2802             CMP      R0,#+2
   \   000000E0   0xD0CD             BEQ.N    ??print_2d_array_11
   \   000000E2   0xE7DA             B.N      ??print_2d_array_12
   \                     ??print_2d_array_16: (+1)
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable151_1
   \   000000E8   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000000EC   0x2808             CMP      R0,#+8
   \   000000EE   0xD1D4             BNE.N    ??print_2d_array_12
   \   000000F0   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable156
   \   000000F8   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   000000FC   0xF850 0xB026      LDR      R11,[R0, R6, LSL #+2]
   \   00000100   0xE7CB             B.N      ??print_2d_array_12
   \                     ??print_2d_array_13: (+1)
   \   00000102   0xF04F 0x0B00      MOV      R11,#+0
   \   00000106   0xE005             B.N      ??print_2d_array_17
   \                     ??print_2d_array_18: (+1)
   \   00000108   0x2120             MOVS     R1,#+32
   \                     ??print_2d_array_19: (+1)
   \   0000010A   0x4628             MOV      R0,R5
   \   0000010C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000110   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??print_2d_array_17: (+1)
   \   00000114   0xFA5F 0xFB8B      UXTB     R11,R11
   \   00000118   0x1CE0             ADDS     R0,R4,#+3
   \   0000011A   0x4583             CMP      R11,R0
   \   0000011C   0xDAD4             BGE.N    ??print_2d_array_15
   \   0000011E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000122   0xD0F1             BEQ.N    ??print_2d_array_18
   \   00000124   0x213D             MOVS     R1,#+61
   \   00000126   0xE7F0             B.N      ??print_2d_array_19
   3163              }
   3164              #ifdef SCAD_MESH_OUTPUT
   3165                SERIAL_PROTOCOLPGM("];");                       // close 2D array
   3166              #endif
   3167              SERIAL_EOL();
   \                     ??print_2d_array_8: (+1)
   \   00000128   0x210A             MOVS     R1,#+10
   \   0000012A   0x4628             MOV      R0,R5
   \   0000012C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000130   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   3168            }
   3169          
   3170          #endif
   3171          
   3172          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
   3173          
   3174            /**
   3175             * Extrapolate a single point from its neighbors
   3176             */

   \                                 In section .text, align 2, keep-with-next
   3177            static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   \                     _Z21extrapolate_one_pointhhaa: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4682             MOV      R10,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   3178              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3179                if (DEBUGGING(LEVELING)) {
   3180                  SERIAL_ECHOPGM("Extrapolate [");
   3181                  if (x < 10) SERIAL_CHAR(' ');
   3182                  SERIAL_ECHO((int)x);
   3183                  SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
   3184                  SERIAL_CHAR(' ');
   3185                  if (y < 10) SERIAL_CHAR(' ');
   3186                  SERIAL_ECHO((int)y);
   3187                  SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
   3188                  SERIAL_CHAR(']');
   3189                }
   3190              #endif
   3191              if (!isnan(z_values[x][y])) {
   \   0000000C   0x2530             MOVS     R5,#+48
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable156
   \   00000012   0xFB05 0x600A      MLA      R0,R5,R10,R6
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x464C             MOV      R4,R9
   \   0000001A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001E   0x.... 0x....      BL       __iar_FDtest
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD16E             BNE.N    ??extrapolate_one_point_0
   3192                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3193                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
   3194                #endif
   3195                return;  // Don't overwrite good values.
   3196              }
   3197              SERIAL_EOL();
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable156_2
   \   0000002C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   3198          
   3199              // Get X neighbors, Y neighbors, and XY neighbors
   3200              const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
   \   00000030   0xEB07 0x020A      ADD      R2,R7,R10
   \   00000034   0xB2D2             UXTB     R2,R2
   \   00000036   0xEB08 0x0009      ADD      R0,R8,R9
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x18BB             ADDS     R3,R7,R2
   \   0000003E   0xB2DB             UXTB     R3,R3
   \   00000040   0xEB08 0x0100      ADD      R1,R8,R0
   \   00000044   0xB2C9             UXTB     R1,R1
   3201              float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
   \   00000046   0xFB05 0x6202      MLA      R2,R5,R2,R6
   \   0000004A   0xF852 0x7024      LDR      R7,[R2, R4, LSL #+2]
   \   0000004E   0xFB05 0x6303      MLA      R3,R5,R3,R6
   \   00000052   0xF853 0x5024      LDR      R5,[R3, R4, LSL #+2]
   3202                    b1 = z_values[x ][y1], b2 = z_values[x ][y2],
   \   00000056   0x9E00             LDR      R6,[SP, #+0]
   \   00000058   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000005C   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \   00000060   0xF85C 0x8021      LDR      R8,[R12, R1, LSL #+2]
   3203                    c1 = z_values[x1][y1], c2 = z_values[x2][y2];
   \   00000064   0xF852 0x9020      LDR      R9,[R2, R0, LSL #+2]
   \   00000068   0xF853 0xA021      LDR      R10,[R3, R1, LSL #+2]
   3204          
   3205              // Treat far unprobed points as zero, near as equal to far
   3206              if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       __iar_FDtest
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD100             BNE.N    ??extrapolate_one_point_1
   \   00000076   0x2500             MOVS     R5,#+0
   \                     ??extrapolate_one_point_1: (+1)
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x.... 0x....      BL       __iar_FDtest
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD100             BNE.N    ??extrapolate_one_point_2
   \   00000082   0x462F             MOV      R7,R5
   3207              if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
   \                     ??extrapolate_one_point_2: (+1)
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x.... 0x....      BL       __iar_FDtest
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xD101             BNE.N    ??extrapolate_one_point_3
   \   0000008E   0xF04F 0x0800      MOV      R8,#+0
   \                     ??extrapolate_one_point_3: (+1)
   \   00000092   0x4630             MOV      R0,R6
   \   00000094   0x.... 0x....      BL       __iar_FDtest
   \   00000098   0x2802             CMP      R0,#+2
   \   0000009A   0xD100             BNE.N    ??extrapolate_one_point_4
   \   0000009C   0x4646             MOV      R6,R8
   3208              if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
   \                     ??extrapolate_one_point_4: (+1)
   \   0000009E   0x4650             MOV      R0,R10
   \   000000A0   0x.... 0x....      BL       __iar_FDtest
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD101             BNE.N    ??extrapolate_one_point_5
   \   000000A8   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??extrapolate_one_point_5: (+1)
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0x.... 0x....      BL       __iar_FDtest
   \   000000B2   0x2802             CMP      R0,#+2
   \   000000B4   0xD100             BNE.N    ??extrapolate_one_point_6
   \   000000B6   0x46D1             MOV      R9,R10
   3209          
   3210              const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
   3211          
   3212              // Take the average instead of the median
   3213              z_values[x][y] = (a + b + c) / 3.0;
   \                     ??extrapolate_one_point_6: (+1)
   \   000000B8   0xF04F 0x4B80      MOV      R11,#+1073741824
   \   000000BC   0x4638             MOV      R0,R7
   \   000000BE   0x4659             MOV      R1,R11
   \   000000C0   0x.... 0x....      BL       __aeabi_fmul
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0x.... 0x....      BL       __aeabi_fsub
   \   000000CA   0x4605             MOV      R5,R0
   \   000000CC   0x4630             MOV      R0,R6
   \   000000CE   0x4659             MOV      R1,R11
   \   000000D0   0x.... 0x....      BL       __aeabi_fmul
   \   000000D4   0x4641             MOV      R1,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_fsub
   \   000000DA   0x4629             MOV      R1,R5
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x4605             MOV      R5,R0
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x4659             MOV      R1,R11
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4651             MOV      R1,R10
   \   000000EC   0x.... 0x....      BL       __aeabi_fsub
   \   000000F0   0x4629             MOV      R1,R5
   \   000000F2   0x.... 0x....      BL       __aeabi_fadd
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable157_2  ;; 0x40400000
   \   000000FA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000FE   0x9900             LDR      R1,[SP, #+0]
   \   00000100   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   3214          
   3215              // Median is robust (ignores outliers).
   3216              // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
   3217              //                                : ((c < b) ? b : (a < c) ? a : c);
   3218            }
   \                     ??extrapolate_one_point_0: (+1)
   \   00000104   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   3219          
   3220            //Enable this if your SCARA uses 180¬∞ of total area
   3221            //#define EXTRAPOLATE_FROM_EDGE
   3222          
   3223            #if ENABLED(EXTRAPOLATE_FROM_EDGE)
   3224              #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
   3225                #define HALF_IN_X
   3226              #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
   3227                #define HALF_IN_Y
   3228              #endif
   3229            #endif
   3230          
   3231            /**
   3232             * Fill in the unprobed points (corners of circular print surface)
   3233             * using linear extrapolation, away from the center.
   3234             */

   \                                 In section .text, align 2, keep-with-next
   3235            static void extrapolate_unprobed_bed_level() {
   \                     _Z30extrapolate_unprobed_bed_levelv: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   3236              #ifdef HALF_IN_X
   3237                constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
   3238              #else
   3239                constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable151_1
   \   0000000A   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   0000000E   0x1E4A             SUBS     R2,R1,#+1
   \   00000010   0xEB02 0x72D2      ADD      R2,R2,R2, LSR #+31
   \   00000014   0x1054             ASRS     R4,R2,#+1
   \   00000016   0xB2E4             UXTB     R4,R4
   3240                                  ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
   \   00000018   0x0849             LSRS     R1,R1,#+1
   \   0000001A   0x9103             STR      R1,[SP, #+12]
   3241                                  xlen = ctrx1;
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x9102             STR      R1,[SP, #+8]
   \   00000020   0x3060             ADDS     R0,R0,#+96
   \   00000022   0x7840             LDRB     R0,[R0, #+1]
   \   00000024   0x1E41             SUBS     R1,R0,#+1
   \   00000026   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   0000002A   0x104D             ASRS     R5,R1,#+1
   \   0000002C   0xB2ED             UXTB     R5,R5
   3242              #endif
   3243          
   3244              #ifdef HALF_IN_Y
   3245                constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
   3246              #else
   3247                constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
   3248                                  ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x9001             STR      R0,[SP, #+4]
   3249                                  ylen = ctry1;
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x9000             STR      R0,[SP, #+0]
   3250              #endif
   3251          
   3252              for (uint8_t xo = 0; xo <= xlen; xo++)
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0xE031             B.N      ??extrapolate_unprobed_bed_level_0
   3253                for (uint8_t yo = 0; yo <= ylen; yo++) {
   3254                  uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
   \                     ??extrapolate_unprobed_bed_level_1: (+1)
   \   0000003A   0x9803             LDR      R0,[SP, #+12]
   \   0000003C   0xEB06 0x0800      ADD      R8,R6,R0
   \   00000040   0x9801             LDR      R0,[SP, #+4]
   \   00000042   0xEB07 0x0900      ADD      R9,R7,R0
   3255                  #ifndef HALF_IN_X
   3256                    const uint8_t x1 = ctrx1 - xo;
   3257                  #endif
   3258                  #ifndef HALF_IN_Y
   3259                    const uint8_t y1 = ctry1 - yo;
   \   00000046   0xEBA5 0x0B07      SUB      R11,R5,R7
   3260                    #ifndef HALF_IN_X
   3261                      extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x461A             MOV      R2,R3
   \   0000004E   0x4659             MOV      R1,R11
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x4650             MOV      R0,R10
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3262                    #endif
   3263                    extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
   \   0000005A   0x2301             MOVS     R3,#+1
   \   0000005C   0xF04F 0x32FF      MOV      R2,#-1
   \   00000060   0x4659             MOV      R1,R11
   \   00000062   0xB2C9             UXTB     R1,R1
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3264                  #endif
   3265                  #ifndef HALF_IN_X
   3266                    extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
   \   0000006C   0xF04F 0x33FF      MOV      R3,#-1
   \   00000070   0x2201             MOVS     R2,#+1
   \   00000072   0x4649             MOV      R1,R9
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x4650             MOV      R0,R10
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3267                  #endif
   3268                  extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
   \   0000007E   0xF04F 0x33FF      MOV      R3,#-1
   \   00000082   0x461A             MOV      R2,R3
   \   00000084   0x4649             MOV      R1,R9
   \   00000086   0xB2C9             UXTB     R1,R1
   \   00000088   0x4640             MOV      R0,R8
   \   0000008A   0xB2C0             UXTB     R0,R0
   \   0000008C   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3269                }
   \   00000090   0x1C7F             ADDS     R7,R7,#+1
   \   00000092   0xB2FF             UXTB     R7,R7
   \                     ??extrapolate_unprobed_bed_level_2: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x42B8             CMP      R0,R7
   \   00000098   0xDACF             BGE.N    ??extrapolate_unprobed_bed_level_1
   \   0000009A   0x1C76             ADDS     R6,R6,#+1
   \   0000009C   0xB2F6             UXTB     R6,R6
   \                     ??extrapolate_unprobed_bed_level_0: (+1)
   \   0000009E   0x9802             LDR      R0,[SP, #+8]
   \   000000A0   0x42B0             CMP      R0,R6
   \   000000A2   0xDB03             BLT.N    ??extrapolate_unprobed_bed_level_3
   \   000000A4   0x2700             MOVS     R7,#+0
   \   000000A6   0xEBA4 0x0A06      SUB      R10,R4,R6
   \   000000AA   0xE7F3             B.N      ??extrapolate_unprobed_bed_level_2
   3270          
   3271            }
   \                     ??extrapolate_unprobed_bed_level_3: (+1)
   \   000000AC   0xB005             ADD      SP,SP,#+20
   \   000000AE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3272          

   \                                 In section .text, align 2, keep-with-next
   3273            static void print_bilinear_leveling_grid() {
   \                     _Z28print_bilinear_leveling_gridv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3274              SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
   \   00000002   0x.... 0x....      ADR.W    R0,`?<Constant "Bilinear Leveling Grid:\\n">`
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3275              /*
   3276              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
   3277                [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
   3278              );
   3279              */
   3280              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,0);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable151_1
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2203             MOVS     R2,#+3
   \   00000012   0xF890 0x1061      LDRB     R1,[R0, #+97]
   \   00000016   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   0000001A   0xE8BD 0x5000      POP      {R12,LR}
   \   0000001E   0x....             B.N      _Z14print_2d_arrayhhhh
   3281            }
   3282          
   3283            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3284          
   3285              #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3286              #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3287              #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
   3288              #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
   3289              float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
   3290              int bilinear_grid_spacing_virt[2] = { 0 };
   3291              float bilinear_grid_factor_virt[2] = { 0 };
   3292          
   3293              static void print_bilinear_leveling_grid_virt() {
   3294                SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
   3295                /*
   3296                print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
   3297                  [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
   3298                );
   3299                */
   3300                print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,1);
   3301              }
   3302          
   3303              #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
   3304              float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
   3305                uint8_t ep = 0, ip = 1;
   3306                if (!x || x == ABL_TEMP_POINTS_X - 1) {
   3307                  if (x) {
   3308                    ep = GRID_MAX_POINTS_X - 1;
   3309                    ip = GRID_MAX_POINTS_X - 2;
   3310                  }
   3311                  if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
   3312                    return LINEAR_EXTRAPOLATION(
   3313                      z_values[ep][y - 1],
   3314                      z_values[ip][y - 1]
   3315                    );
   3316                  else
   3317                    return LINEAR_EXTRAPOLATION(
   3318                      bed_level_virt_coord(ep + 1, y),
   3319                      bed_level_virt_coord(ip + 1, y)
   3320                    );
   3321                }
   3322                if (!y || y == ABL_TEMP_POINTS_Y - 1) {
   3323                  if (y) {
   3324                    ep = GRID_MAX_POINTS_Y - 1;
   3325                    ip = GRID_MAX_POINTS_Y - 2;
   3326                  }
   3327                  if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
   3328                    return LINEAR_EXTRAPOLATION(
   3329                      z_values[x - 1][ep],
   3330                      z_values[x - 1][ip]
   3331                    );
   3332                  else
   3333                    return LINEAR_EXTRAPOLATION(
   3334                      bed_level_virt_coord(x, ep + 1),
   3335                      bed_level_virt_coord(x, ip + 1)
   3336                    );
   3337                }
   3338                return z_values[x - 1][y - 1];
   3339              }
   3340          
   3341              static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
   3342                return (
   3343                    p[i-1] * -t * sq(1 - t)
   3344                  + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
   3345                  + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
   3346                  - p[i+2] * sq(t) * (1 - t)
   3347                ) * 0.5;
   3348              }
   3349          
   3350              static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
   3351                float row[4], column[4];
   3352                for (uint8_t i = 0; i < 4; i++) {
   3353                  for (uint8_t j = 0; j < 4; j++) {
   3354                    column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
   3355                  }
   3356                  row[i] = bed_level_virt_cmr(column, 1, ty);
   3357                }
   3358                return bed_level_virt_cmr(row, 1, tx);
   3359              }
   3360          
   3361              void bed_level_virt_interpolate() {
   3362                bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
   3363                bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
   3364                bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
   3365                bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
   3366                for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   3367                  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   3368                    for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
   3369                      for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
   3370                        if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
   3371                          continue;
   3372                        z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
   3373                          bed_level_virt_2cmr(
   3374                            x + 1,
   3375                            y + 1,
   3376                            (float)tx / (BILINEAR_SUBDIVISIONS),
   3377                            (float)ty / (BILINEAR_SUBDIVISIONS)
   3378                          );
   3379                      }
   3380              }
   3381            #endif // ABL_BILINEAR_SUBDIVISION
   3382          
   3383            // Refresh after other values have been updated

   \                                 In section .text, align 2, keep-with-next
   3384            void refresh_bed_level() {
   \                     _Z17refresh_bed_levelv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3385              bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable156_7
   \   00000006   0x6920             LDR      R0,[R4, #+16]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD102             BNE.N    ??refresh_bed_level_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6220             STR      R0,[R4, #+32]
   \   00000010   0xE00B             B.N      ??refresh_bed_level_1
   \                     ??refresh_bed_level_0: (+1)
   \   00000012   0x.... 0x....      BL       __aeabi_i2d
   \   00000016   0x4602             MOV      R2,R0
   \   00000018   0x460B             MOV      R3,R1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable157_3  ;; 0x3ff00000
   \   00000020   0x.... 0x....      BL       __aeabi_ddiv
   \   00000024   0x.... 0x....      BL       __aeabi_d2f
   \   00000028   0x6220             STR      R0,[R4, #+32]
   3386              bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
   \                     ??refresh_bed_level_1: (+1)
   \   0000002A   0x6960             LDR      R0,[R4, #+20]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD102             BNE.N    ??refresh_bed_level_2
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6260             STR      R0,[R4, #+36]
   \   00000034   0xBD10             POP      {R4,PC}
   \                     ??refresh_bed_level_2: (+1)
   \   00000036   0x.... 0x....      BL       __aeabi_i2d
   \   0000003A   0x4602             MOV      R2,R0
   \   0000003C   0x460B             MOV      R3,R1
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable157_3  ;; 0x3ff00000
   \   00000044   0x.... 0x....      BL       __aeabi_ddiv
   \   00000048   0x.... 0x....      BL       __aeabi_d2f
   \   0000004C   0x6260             STR      R0,[R4, #+36]
   3387              #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3388                bed_level_virt_interpolate();
   3389              #endif
   3390            }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   3391          
   3392          #endif // AUTO_BED_LEVELING_BILINEAR
   3393          
   3394          /**
   3395           * Home an individual linear axis
   3396           */

   \                                 In section .text, align 2, keep-with-next
   3397          static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
   \                     _Z14do_homing_move8AxisEnumff: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4617             MOV      R7,R2
   3398          
   3399            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3400              if (DEBUGGING(LEVELING)) {
   3401                SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
   3402                SERIAL_ECHOPAIR(", ", distance);
   3403                SERIAL_ECHOPAIR(", ", fr_mm_s);
   3404                SERIAL_CHAR(')');
   3405                SERIAL_EOL();
   3406              }
   3407            #endif
   3408          
   3409            //#if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
   3410            #if HOMING_Z_WITH_PROBE
   3411              //const 
   3412              bool deploy_bltouch;
   3413            if(MKSTOUCH == 1)
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable151_1
   \   0000000E   0xF895 0x0100      LDRB     R0,[R5, #+256]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD117             BNE.N    ??do_homing_move_0
   3414            {
   3415            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)){	/*--mks cfg--*/
   \   00000016   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD513             BPL.N    ??do_homing_move_0
   \   0000001E   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD10F             BNE.N    ??do_homing_move_0
   3416              deploy_bltouch = (axis == Z_AXIS && distance < 0);
   \   00000026   0xF1B9 0x0F02      CMP      R9,#+2
   \   0000002A   0xD106             BNE.N    ??do_homing_move_1
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000034   0xD201             BCS.N    ??do_homing_move_1
   \   00000036   0x2401             MOVS     R4,#+1
   \   00000038   0xE000             B.N      ??do_homing_move_2
   \                     ??do_homing_move_1: (+1)
   \   0000003A   0x2400             MOVS     R4,#+0
   3417              if (deploy_bltouch) set_bltouch_deployed(true);
   \                     ??do_homing_move_2: (+1)
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD002             BEQ.N    ??do_homing_move_0
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   3418              }
   3419            }
   3420            #endif
   3421          
   3422            #if QUIET_PROBING
   3423              if (axis == Z_AXIS) probing_pause(true);
   3424            #endif
   3425          
   3426            // Tell the planner the axis is at 0
   3427            current_position[axis] = 0;
   \                     ??do_homing_move_0: (+1)
   \   00000046   0x.... 0x....      LDR.W    R6,??DataTable151_2
   \   0000004A   0xEB06 0x0989      ADD      R9,R6,R9, LSL #+2
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF8C9 0x0008      STR      R0,[R9, #+8]
   3428          
   3429            //#if IS_SCARA
   3430            if(MACHINETPYE&IS_SCARA)
   \   00000054   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   00000058   0xF44F 0x7140      MOV      R1,#+768
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD026             BEQ.N    ??do_homing_move_3
   3431            {
   3432              SYNC_PLAN_POSITION_KINEMATIC();
   \   00000060   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   3433              current_position[axis] = distance;
   \   00000064   0xF8C9 0x8008      STR      R8,[R9, #+8]
   3434              if(MACHINETPYE&IS_SCARA)
   \   00000068   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   0000006C   0xF44F 0x7140      MOV      R1,#+768
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000076   0xD002             BEQ.N    ??do_homing_move_4
   3435          		inverse_kinematics_MORGAN_SCARA(current_position);
   \   00000078   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   0000007C   0xE001             B.N      ??do_homing_move_5
   3436          	else
   3437                  inverse_kinematics(current_position);
   \                     ??do_homing_move_4: (+1)
   \   0000007E   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   3438              planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
   \                     ??do_homing_move_5: (+1)
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000008A   0xD001             BEQ.N    ??do_homing_move_6
   \   0000008C   0x9702             STR      R7,[SP, #+8]
   \   0000008E   0xE002             B.N      ??do_homing_move_7
   \                     ??do_homing_move_6: (+1)
   \   00000090   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   00000094   0x9002             STR      R0,[SP, #+8]
   \                     ??do_homing_move_7: (+1)
   \   00000096   0x78F0             LDRB     R0,[R6, #+3]
   \   00000098   0x9001             STR      R0,[SP, #+4]
   \   0000009A   0xA802             ADD      R0,SP,#+8
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0xF106 0x0314      ADD      R3,R6,#+20
   \   000000A2   0x6DB2             LDR      R2,[R6, #+88]
   \   000000A4   0x6D71             LDR      R1,[R6, #+84]
   \   000000A6   0x6D30             LDR      R0,[R6, #+80]
   \   000000A8   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   \   000000AC   0xE018             B.N      ??do_homing_move_8
   3439            }
   3440            //#else
   3441            else
   3442            {
   3443              sync_plan_position();
   \                     ??do_homing_move_3: (+1)
   \   000000AE   0x.... 0x....      BL       _Z18sync_plan_positionv
   3444              current_position[axis] = distance;
   \   000000B2   0xF8C9 0x8008      STR      R8,[R9, #+8]
   3445              planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
   \   000000B6   0x4638             MOV      R0,R7
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000BE   0xD001             BEQ.N    ??do_homing_move_9
   \   000000C0   0x9702             STR      R7,[SP, #+8]
   \   000000C2   0xE002             B.N      ??do_homing_move_10
   \                     ??do_homing_move_9: (+1)
   \   000000C4   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   000000C8   0x9002             STR      R0,[SP, #+8]
   \                     ??do_homing_move_10: (+1)
   \   000000CA   0x78F0             LDRB     R0,[R6, #+3]
   \   000000CC   0x9001             STR      R0,[SP, #+4]
   \   000000CE   0xA802             ADD      R0,SP,#+8
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \   000000D2   0xF106 0x0314      ADD      R3,R6,#+20
   \   000000D6   0x6932             LDR      R2,[R6, #+16]
   \   000000D8   0x68F1             LDR      R1,[R6, #+12]
   \   000000DA   0x68B0             LDR      R0,[R6, #+8]
   \   000000DC   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   3446            }
   3447            //#endif
   3448          
   3449            stepper.synchronize();
   \                     ??do_homing_move_8: (+1)
   \   000000E0   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   3450          
   3451            #if QUIET_PROBING
   3452              if (axis == Z_AXIS) probing_pause(false);
   3453            #endif
   3454          
   3455            #if HOMING_Z_WITH_PROBE //&& ENABLED(BLTOUCH)
   3456            if(MKSTOUCH == 1)
   \   000000E4   0xF895 0x0100      LDRB     R0,[R5, #+256]
   \   000000E8   0x2801             CMP      R0,#+1
   \   000000EA   0xD10D             BNE.N    ??do_homing_move_11
   3457            {
   3458              if((Z_HOME_DIR < 0) &&  (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \   000000EC   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD509             BPL.N    ??do_homing_move_11
   \   000000F4   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD105             BNE.N    ??do_homing_move_11
   3459              {
   3460                  if (deploy_bltouch) set_bltouch_deployed(false);
   \   000000FC   0xB2E4             UXTB     R4,R4
   \   000000FE   0x2C00             CMP      R4,#+0
   \   00000100   0xD002             BEQ.N    ??do_homing_move_11
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   3461              }
   3462            }
   3463            #endif
   3464          
   3465            endstops.hit_on_purpose();
   \                     ??do_homing_move_11: (+1)
   \   00000108   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   3466          
   3467            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3468              if (DEBUGGING(LEVELING)) {
   3469                SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
   3470                SERIAL_CHAR(')');
   3471                SERIAL_EOL();
   3472              }
   3473            #endif
   3474          }
   \   0000010C   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
   3475          
   3476          /**
   3477           * TMC2130 specific sensorless homing using stallGuard2.
   3478           * stallGuard2 only works when in spreadCycle mode.
   3479           * spreadCycle and stealthChop are mutually exclusive.
   3480           */
   3481          #if ENABLED(SENSORLESS_HOMING)
   3482            template<typename TMC>
   3483            void tmc_sensorless_homing(TMC &st, bool enable=true) {
   3484              #if ENABLED(STEALTHCHOP)
   3485                if (enable) {
   3486                  st.coolstep_min_speed(1024UL * 1024UL - 1UL);
   3487                  st.stealthChop(0);
   3488                }
   3489                else {
   3490                  st.coolstep_min_speed(0);
   3491                  st.stealthChop(1);
   3492                }
   3493              #endif
   3494          
   3495              st.diag1_stall(enable ? 1 : 0);
   3496            }
   3497          #endif
   3498          
   3499          /**
   3500           * Home an individual "raw axis" to its endstop.
   3501           * This applies to XYZ on Cartesian and Core robots, and
   3502           * to the individual ABC steppers on DELTA and SCARA.
   3503           *
   3504           * At the end of the procedure the axis is marked as
   3505           * homed and the current position of that axis is updated.
   3506           * Kinematic robots should wait till all axes are homed
   3507           * before updating the current position.
   3508           */
   3509          
   3510          #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
   3511          

   \                                 In section .text, align 2, keep-with-next
   3512          static void homeaxis(const AxisEnum axis) {
   \                     _Z8homeaxis8AxisEnum: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   3513          
   3514          #define CAN_HOME(A) \
   3515              (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
   3516          
   3517            //#if IS_SCARA
   3518            if(MACHINETPYE&IS_SCARA)
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable151_1
   \   0000000A   0xF205 0x0805      ADDW     R8,R5,#+5
   \   0000000E   0x4626             MOV      R6,R4
   \   00000010   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   00000014   0xF44F 0x7140      MOV      R1,#+768
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xD002             BEQ.N    ??homeaxis_0
   3519            {
   3520              // Only Z homing (with probe) is permitted
   3521              if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   \   0000001C   0x2E02             CMP      R6,#+2
   \   0000001E   0xD014             BEQ.N    ??homeaxis_1
   \   00000020   0xE12E             B.N      ??homeaxis_2
   3522            }
   3523            //#else
   3524            else
   3525             {
   3526              if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
   \                     ??homeaxis_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD103             BNE.N    ??homeaxis_3
   \   00000026   0xF995 0x0005      LDRSB    R0,[R5, #+5]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD10D             BNE.N    ??homeaxis_1
   \                     ??homeaxis_3: (+1)
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD103             BNE.N    ??homeaxis_4
   \   00000032   0xF998 0x0001      LDRSB    R0,[R8, #+1]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD107             BNE.N    ??homeaxis_1
   \                     ??homeaxis_4: (+1)
   \   0000003A   0x2E02             CMP      R6,#+2
   \   0000003C   0xF040 0x8120      BNE.W    ??homeaxis_2
   \   00000040   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xF000 0x811B      BEQ.W    ??homeaxis_2
   3527             }
   3528            //#endif
   3529          
   3530            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3531              if (DEBUGGING(LEVELING)) {
   3532                SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
   3533                SERIAL_CHAR(')');
   3534                SERIAL_EOL();
   3535              }
   3536            #endif
   3537          
   3538            const int axis_home_dir =
   3539              #if ENABLED(DUAL_X_CARRIAGE)
   3540                (axis == X_AXIS) ? x_home_dir(active_extruder) :
   3541              #endif
   3542              home_dir(axis);
   \                     ??homeaxis_1: (+1)
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   00000050   0x4607             MOV      R7,R0
   3543          
   3544            // Homing Z towards the bed? Deploy the Z probe or endstop.
   3545            #if HOMING_Z_WITH_PROBE
   3546            
   3547            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \   00000052   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD50B             BPL.N    ??homeaxis_5
   \   0000005A   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD107             BNE.N    ??homeaxis_5
   3548            {
   3549              if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   \   00000062   0x2E02             CMP      R6,#+2
   \   00000064   0xD105             BNE.N    ??homeaxis_5
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xF040 0x8107      BNE.W    ??homeaxis_2
   3550            }
   3551            #endif
   3552          
   3553            // Set flags for X, Y, Z motor locking
   3554            #if ENABLED(X_DUAL_ENDSTOPS)
   3555              if (axis == X_AXIS) stepper.set_homing_flag_x(true);
   3556            #endif
   3557            #if ENABLED(Y_DUAL_ENDSTOPS)
   3558              if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
   3559            #endif
   3560            #if 1//ENABLED(Z_DUAL_ENDSTOPS)
   3561              if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
   \                     ??homeaxis_5: (+1)
   \   00000072   0x2E02             CMP      R6,#+2
   \   00000074   0xD102             BNE.N    ??homeaxis_6
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x.... 0x....      BL       _ZN7Stepper17set_homing_flag_zEb
   3562            #endif
   3563          
   3564            // Disable stealthChop if used. Enable diag1 pin on driver.
   3565            #if ENABLED(SENSORLESS_HOMING)
   3566              #if ENABLED(X_IS_TMC2130)
   3567                if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
   3568              #endif
   3569              #if ENABLED(Y_IS_TMC2130)
   3570                if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
   3571              #endif
   3572            #endif
   3573          
   3574            // Fast move towards endstop until triggered
   3575            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3576              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   3577            #endif
   3578            do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
   \                     ??homeaxis_6: (+1)
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       _Z10max_length8AxisEnum
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x4691             MOV      R9,R2
   \   00000086   0x.... 0x....      BL       __aeabi_f2d
   \   0000008A   0x464A             MOV      R2,R9
   \   0000008C   0x.... 0x....      LDR.W    R3,??DataTable157_4  ;; 0x3ff80000
   \   00000090   0x.... 0x....      BL       __aeabi_dmul
   \   00000094   0x4682             MOV      R10,R0
   \   00000096   0x468B             MOV      R11,R1
   \   00000098   0x4638             MOV      R0,R7
   \   0000009A   0x.... 0x....      BL       __aeabi_i2d
   \   0000009E   0x4652             MOV      R2,R10
   \   000000A0   0x465B             MOV      R3,R11
   \   000000A2   0x.... 0x....      BL       __aeabi_dmul
   \   000000A6   0x.... 0x....      BL       __aeabi_d2f
   \   000000AA   0x4601             MOV      R1,R0
   \   000000AC   0x464A             MOV      R2,R9
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3579          
   3580            // When homing Z with probe respect probe clearance
   3581            /*
   3582            const float bump = axis_home_dir * (
   3583              #if HOMING_Z_WITH_PROBE
   3584                (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
   3585              #endif
   3586              home_bump_mm(axis)
   3587            );
   3588            */
   3589              float bump = 0;
   3590              #if HOMING_Z_WITH_PROBE
   3591                  if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))    /*--mks cfg--*/
   \   000000B4   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD521             BPL.N    ??homeaxis_7
   \   000000BC   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD11D             BNE.N    ??homeaxis_7
   3592                      bump = axis_home_dir*((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
   \   000000C4   0x2E02             CMP      R6,#+2
   \   000000C6   0xD10F             BNE.N    ??homeaxis_8
   \   000000C8   0xF105 0x0058      ADD      R0,R5,#+88
   \   000000CC   0xF8D0 0x9010      LDR      R9,[R0, #+16]
   \   000000D0   0x2002             MOVS     R0,#+2
   \   000000D2   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   000000D6   0x4649             MOV      R1,R9
   \   000000D8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000DC   0xD308             BCC.N    ??homeaxis_9
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   000000E4   0x4681             MOV      R9,R0
   \   000000E6   0xE003             B.N      ??homeaxis_9
   \                     ??homeaxis_8: (+1)
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   000000EE   0x4681             MOV      R9,R0
   \                     ??homeaxis_9: (+1)
   \   000000F0   0x4638             MOV      R0,R7
   \   000000F2   0x.... 0x....      BL       __aeabi_i2f
   \   000000F6   0x4649             MOV      R1,R9
   \   000000F8   0x.... 0x....      BL       __aeabi_fmul
   \   000000FC   0x4681             MOV      R9,R0
   \   000000FE   0xE00A             B.N      ??homeaxis_10
   3593                  else
   3594                      bump = axis_home_dir *home_bump_mm(axis);
   \                     ??homeaxis_7: (+1)
   \   00000100   0x4638             MOV      R0,R7
   \   00000102   0x.... 0x....      BL       __aeabi_i2f
   \   00000106   0x4681             MOV      R9,R0
   \   00000108   0x4620             MOV      R0,R4
   \   0000010A   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   0000010E   0x4649             MOV      R1,R9
   \   00000110   0x.... 0x....      BL       __aeabi_fmul
   \   00000114   0x4681             MOV      R9,R0
   3595              #else
   3596                  bump = axis_home_dir *home_bump_mm(axis);
   3597              #endif
   3598          
   3599            // If a second homing move is configured...
   3600            if (bump) {
   \                     ??homeaxis_10: (+1)
   \   00000116   0x4648             MOV      R0,R9
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000011E   0xD015             BEQ.N    ??homeaxis_11
   3601              // Move away from the endstop by the axis HOME_BUMP_MM
   3602              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3603                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
   3604              #endif
   3605              do_homing_move(axis, -bump);
   \   00000120   0x460A             MOV      R2,R1
   \   00000122   0x4649             MOV      R1,R9
   \   00000124   0xF081 0x4100      EOR      R1,R1,#0x80000000
   \   00000128   0x4620             MOV      R0,R4
   \   0000012A   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3606          
   3607              // Slow move towards endstop until triggered
   3608              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3609                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
   3610              #endif
   3611              do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   \   0000012E   0x4620             MOV      R0,R4
   \   00000130   0x.... 0x....      BL       _Z24get_homing_bump_feedrate8AxisEnum
   \   00000134   0x4602             MOV      R2,R0
   \   00000136   0x4692             MOV      R10,R2
   \   00000138   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000013C   0x4649             MOV      R1,R9
   \   0000013E   0x.... 0x....      BL       __aeabi_fmul
   \   00000142   0x4601             MOV      R1,R0
   \   00000144   0x4652             MOV      R2,R10
   \   00000146   0x4620             MOV      R0,R4
   \   00000148   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3612            }
   3613          
   3614            /**
   3615             * Home axes that have dual endstops... differently
   3616             */
   3617            #if 1//ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   3618              const bool pos_dir = axis_home_dir > 0;
   \                     ??homeaxis_11: (+1)
   \   0000014C   0x2F01             CMP      R7,#+1
   \   0000014E   0xDB01             BLT.N    ??homeaxis_12
   \   00000150   0x2701             MOVS     R7,#+1
   \   00000152   0xE000             B.N      ??homeaxis_13
   \                     ??homeaxis_12: (+1)
   \   00000154   0x2700             MOVS     R7,#+0
   3619              #if ENABLED(X_DUAL_ENDSTOPS)
   3620                if (axis == X_AXIS) {
   3621                  const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
   3622                  const float adj = FABS(x_endstop_adj);
   3623                  if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
   3624                  do_homing_move(axis, pos_dir ? -adj : adj);
   3625                  if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
   3626                  stepper.set_homing_flag_x(false);
   3627                }
   3628              #endif
   3629              #if ENABLED(Y_DUAL_ENDSTOPS)
   3630                if (axis == Y_AXIS) {
   3631                  const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
   3632                  const float adj = FABS(y_endstop_adj);
   3633                  if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
   3634                  do_homing_move(axis, pos_dir ? -adj : adj);
   3635                  if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
   3636                  stepper.set_homing_flag_y(false);
   3637                }
   3638              #endif
   3639              //#if ENABLED(Z_DUAL_ENDSTOPS)
   3640              if(Z_DUAL_ENDSTOPS==1)
   \                     ??homeaxis_13: (+1)
   \   00000156   0xF895 0x0102      LDRB     R0,[R5, #+258]
   \   0000015A   0x2801             CMP      R0,#+1
   \   0000015C   0xD139             BNE.N    ??homeaxis_14
   3641              {
   3642                if (axis == Z_AXIS) {
   \   0000015E   0x2E02             CMP      R6,#+2
   \   00000160   0xD137             BNE.N    ??homeaxis_14
   3643                  const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable157_5
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x2F00             CMP      R7,#+0
   \   0000016A   0xD008             BEQ.N    ??homeaxis_15
   \   0000016C   0x2100             MOVS     R1,#+0
   \   0000016E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000172   0xD202             BCS.N    ??homeaxis_16
   \   00000174   0xF04F 0x0901      MOV      R9,#+1
   \   00000178   0xE009             B.N      ??homeaxis_17
   \                     ??homeaxis_16: (+1)
   \   0000017A   0x4689             MOV      R9,R1
   \   0000017C   0xE007             B.N      ??homeaxis_17
   \                     ??homeaxis_15: (+1)
   \   0000017E   0x2100             MOVS     R1,#+0
   \   00000180   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000184   0xD202             BCS.N    ??homeaxis_18
   \   00000186   0xF04F 0x0901      MOV      R9,#+1
   \   0000018A   0xE000             B.N      ??homeaxis_17
   \                     ??homeaxis_18: (+1)
   \   0000018C   0x4689             MOV      R9,R1
   3644                  const float adj = FABS(z_endstop_adj);
   \                     ??homeaxis_17: (+1)
   \   0000018E   0xF020 0x4A00      BIC      R10,R0,#0x80000000
   3645                  if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
   \   00000192   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000196   0xD003             BEQ.N    ??homeaxis_19
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0x.... 0x....      BL       _ZN7Stepper10set_z_lockEb
   \   0000019E   0xE002             B.N      ??homeaxis_20
   \                     ??homeaxis_19: (+1)
   \   000001A0   0x2001             MOVS     R0,#+1
   \   000001A2   0x.... 0x....      BL       _ZN7Stepper11set_z2_lockEb
   3646                  do_homing_move(axis, pos_dir ? -adj : adj);
   \                     ??homeaxis_20: (+1)
   \   000001A6   0x2F00             CMP      R7,#+0
   \   000001A8   0xD001             BEQ.N    ??homeaxis_21
   \   000001AA   0xF08A 0x4A00      EOR      R10,R10,#0x80000000
   \                     ??homeaxis_21: (+1)
   \   000001AE   0x2200             MOVS     R2,#+0
   \   000001B0   0x4651             MOV      R1,R10
   \   000001B2   0x4620             MOV      R0,R4
   \   000001B4   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3647                  if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
   \   000001B8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001BC   0xD003             BEQ.N    ??homeaxis_22
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x.... 0x....      BL       _ZN7Stepper10set_z_lockEb
   \   000001C4   0xE002             B.N      ??homeaxis_23
   \                     ??homeaxis_22: (+1)
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0x.... 0x....      BL       _ZN7Stepper11set_z2_lockEb
   3648                  stepper.set_homing_flag_z(false);
   \                     ??homeaxis_23: (+1)
   \   000001CC   0x2000             MOVS     R0,#+0
   \   000001CE   0x.... 0x....      BL       _ZN7Stepper17set_homing_flag_zEb
   3649                }
   3650              }
   3651              //#endif
   3652            #endif
   3653          
   3654            //#if IS_SCARA
   3655            if(MACHINETPYE&IS_SCARA)
   \                     ??homeaxis_14: (+1)
   \   000001D2   0xF9B5 0x0058      LDRSH    R0,[R5, #+88]
   \   000001D6   0xF44F 0x7140      MOV      R1,#+768
   \   000001DA   0x4208             TST      R0,R1
   \   000001DC   0xD005             BEQ.N    ??homeaxis_24
   3656            {
   3657              set_axis_is_at_home(axis);
   \   000001DE   0x4620             MOV      R0,R4
   \   000001E0   0x.... 0x....      BL       _Z19set_axis_is_at_home8AxisEnum
   3658              SYNC_PLAN_POSITION_KINEMATIC();
   \   000001E4   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   \   000001E8   0xE03B             B.N      ??homeaxis_25
   3659            }
   3660            //#elif ENABLED(DELTA)
   3661            else if(MACHINETPYE == DELTA) {
   \                     ??homeaxis_24: (+1)
   \   000001EA   0x2802             CMP      R0,#+2
   \   000001EC   0xD12F             BNE.N    ??homeaxis_26
   3662          
   3663              // Delta has already moved all three towers up in G28
   3664              // so here it re-homes each tower in turn.
   3665              // Delta homing treats the axes as normal linear axes.
   3666          
   3667              // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
   3668              if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable157_5
   \   000001F2   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   000001F6   0xF8D0 0xA004      LDR      R10,[R0, #+4]
   \   000001FA   0xF998 0x7002      LDRSB    R7,[R8, #+2]
   \   000001FE   0x4638             MOV      R0,R7
   \   00000200   0x.... 0x....      BL       __aeabi_i2f
   \   00000204   0x4651             MOV      R1,R10
   \   00000206   0x.... 0x....      BL       __aeabi_fmul
   \   0000020A   0x2100             MOVS     R1,#+0
   \   0000020C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000210   0xD827             BHI.N    ??homeaxis_25
   3669                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3670                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
   3671                #endif
   3672                do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
   \   00000212   0x460A             MOV      R2,R1
   \   00000214   0x4691             MOV      R9,R2
   \   00000216   0x4650             MOV      R0,R10
   \   00000218   0x.... 0x....      BL       __aeabi_f2d
   \   0000021C   0x4682             MOV      R10,R0
   \   0000021E   0x468B             MOV      R11,R1
   \   00000220   0x4638             MOV      R0,R7
   \   00000222   0x.... 0x....      BL       __aeabi_i2d
   \   00000226   0x.... 0x....      LDR.W    R2,??DataTable157_6  ;; 0x9999999a
   \   0000022A   0x.... 0x....      LDR.W    R3,??DataTable157_7  ;; 0x3fb99999
   \   0000022E   0x.... 0x....      BL       __aeabi_dmul
   \   00000232   0x4602             MOV      R2,R0
   \   00000234   0x460B             MOV      R3,R1
   \   00000236   0x4650             MOV      R0,R10
   \   00000238   0x4659             MOV      R1,R11
   \   0000023A   0x.... 0x....      BL       __aeabi_dsub
   \   0000023E   0x.... 0x....      BL       __aeabi_d2f
   \   00000242   0x4601             MOV      R1,R0
   \   00000244   0x464A             MOV      R2,R9
   \   00000246   0x4620             MOV      R0,R4
   \   00000248   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   \   0000024C   0xE009             B.N      ??homeaxis_25
   3673              }
   3674            }
   3675            //#else
   3676            else
   3677            {
   3678              // For cartesian/core machines,
   3679              // set the axis to its home position
   3680              set_axis_is_at_home(axis);
   \                     ??homeaxis_26: (+1)
   \   0000024E   0x4620             MOV      R0,R4
   \   00000250   0x.... 0x....      BL       _Z19set_axis_is_at_home8AxisEnum
   3681              sync_plan_position();
   \   00000254   0x.... 0x....      BL       _Z18sync_plan_positionv
   3682          
   3683              destination[axis] = current_position[axis];
   \   00000258   0x....             LDR.N    R0,??DataTable151_2
   \   0000025A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000025E   0x6881             LDR      R1,[R0, #+8]
   \   00000260   0x6181             STR      R1,[R0, #+24]
   3684          
   3685              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3686                if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
   3687              #endif
   3688            }
   3689            //#endif
   3690          
   3691            // Re-enable stealthChop if used. Disable diag1 pin on driver.
   3692            #if ENABLED(SENSORLESS_HOMING)
   3693              #if ENABLED(X_IS_TMC2130)
   3694                if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
   3695              #endif
   3696              #if ENABLED(Y_IS_TMC2130)
   3697                if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
   3698              #endif
   3699            #endif
   3700          
   3701            // Put away the Z probe
   3702            #if HOMING_Z_WITH_PROBE
   3703            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \                     ??homeaxis_25: (+1)
   \   00000262   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   00000266   0x2800             CMP      R0,#+0
   \   00000268   0xD50A             BPL.N    ??homeaxis_2
   \   0000026A   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   0000026E   0x2801             CMP      R0,#+1
   \   00000270   0xD106             BNE.N    ??homeaxis_2
   3704            {    
   3705              if (axis == Z_AXIS && STOW_PROBE()) return;
   \   00000272   0x2E02             CMP      R6,#+2
   \   00000274   0xD104             BNE.N    ??homeaxis_2
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   0000027C   0x.... 0x....      B.W      _Z18set_probe_deployedb
   3706             }
   3707            #endif
   3708          
   3709            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3710              if (DEBUGGING(LEVELING)) {
   3711                SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
   3712                SERIAL_CHAR(')');
   3713                SERIAL_EOL();
   3714              }
   3715            #endif
   3716          } // homeaxis()
   \                     ??homeaxis_2: (+1)
   \   00000280   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   3717          
   3718          #if ENABLED(FWRETRACT)
   3719          
   3720            /**
   3721             * Retract or recover according to firmware settings
   3722             *
   3723             * This function handles retract/recover moves for G10 and G11,
   3724             * plus auto-retract moves sent from G0/G1 when E-only moves are done.
   3725             *
   3726             * To simplify the logic, doubled retract/recover moves are ignored.
   3727             *
   3728             * Note: Z lift is done transparently to the planner. Aborting
   3729             *       a print between G10 and G11 may corrupt the Z position.
   3730             *
   3731             * Note: Auto-retract will apply the set Z hop in addition to any Z hop
   3732             *       included in the G-code. Use M207 Z0 to to prevent double hop.
   3733             */
   3734            void retract(const bool retracting
   3735              #if EXTRUDERS > 1
   3736                , bool swapping = false
   3737              #endif
   3738            ) {
   3739          
   3740              static float hop_amount = 0.0;  // Total amount lifted, for use in recover
   3741          
   3742              // Prevent two retracts or recovers in a row
   3743              if (retracted[active_extruder] == retracting) return;
   3744          
   3745              // Prevent two swap-retract or recovers in a row
   3746              #if EXTRUDERS > 1
   3747                // Allow G10 S1 only after G10
   3748                if (swapping && retracted_swap[active_extruder] == retracting) return;
   3749                // G11 priority to recover the long retract if activated
   3750                if (!retracting) swapping = retracted_swap[active_extruder];
   3751              #else
   3752                const bool swapping = false;
   3753              #endif
   3754          
   3755              /* // debugging
   3756                SERIAL_ECHOLNPAIR("retracting ", retracting);
   3757                SERIAL_ECHOLNPAIR("swapping ", swapping);
   3758                SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
   3759                for (uint8_t i = 0; i < EXTRUDERS; ++i) {
   3760                  SERIAL_ECHOPAIR("retracted[", i);
   3761                  SERIAL_ECHOLNPAIR("] ", retracted[i]);
   3762                  SERIAL_ECHOPAIR("retracted_swap[", i);
   3763                  SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
   3764                }
   3765                SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
   3766                SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
   3767              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
   3768          
   3769              const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
   3770              const float old_feedrate_mm_s = feedrate_mm_s;
   3771          
   3772              // The current position will be the destination for E and Z moves
   3773              set_destination_from_current();
   3774              stepper.synchronize();  // Wait for buffered moves to complete
   3775          
   3776              const float renormalize = 1.0 / planner.e_factor[active_extruder];
   3777          
   3778              if (retracting) {
   3779                // Retract by moving from a faux E position back to the current E position
   3780                feedrate_mm_s = retract_feedrate_mm_s;
   3781                current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
   3782                sync_plan_position_e();
   3783                prepare_move_to_destination();
   3784          
   3785                // Is a Z hop set, and has the hop not yet been done?
   3786                if (has_zhop && !hop_amount) {
   3787                  hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
   3788                  feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
   3789                  current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
   3790                  SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
   3791                  prepare_move_to_destination();                      // Raise up to the old current pos
   3792                  feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
   3793                }
   3794              }
   3795              else {
   3796                // If a hop was done and Z hasn't changed, undo the Z hop
   3797                if (hop_amount) {
   3798                  current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
   3799                  SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
   3800                  feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
   3801                  prepare_move_to_destination();                      // Raise up to the old current pos
   3802                  hop_amount = 0.0;                                   // Clear hop
   3803                }
   3804          
   3805                // A retract multiplier has been added here to get faster swap recovery
   3806                feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
   3807          
   3808                const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
   3809                current_position[E_AXIS] -= move_e * renormalize;
   3810                sync_plan_position_e();
   3811                prepare_move_to_destination();                        // Recover E
   3812              }
   3813          
   3814              feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
   3815          
   3816              retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
   3817          
   3818              // If swap retract/recover update the retracted_swap flag too
   3819              #if EXTRUDERS > 1
   3820                if (swapping) retracted_swap[active_extruder] = retracting;
   3821              #endif
   3822          
   3823              /* // debugging
   3824                SERIAL_ECHOLNPAIR("retracting ", retracting);
   3825                SERIAL_ECHOLNPAIR("swapping ", swapping);
   3826                SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
   3827                for (uint8_t i = 0; i < EXTRUDERS; ++i) {
   3828                  SERIAL_ECHOPAIR("retracted[", i);
   3829                  SERIAL_ECHOLNPAIR("] ", retracted[i]);
   3830                  SERIAL_ECHOPAIR("retracted_swap[", i);
   3831                  SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
   3832                }
   3833                SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
   3834                SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
   3835              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
   3836          
   3837            }
   3838          
   3839          #endif // FWRETRACT
   3840          
   3841          #if ENABLED(MIXING_EXTRUDER)
   3842          
   3843            void normalize_mix() {
   3844              float mix_total = 0.0;
   3845              for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
   3846              // Scale all values if they don't add up to ~1.0
   3847              if (!NEAR(mix_total, 1.0)) {
   3848                SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
   3849                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
   3850              }
   3851            }
   3852          
   3853            #if ENABLED(DIRECT_MIXING_IN_G1)
   3854              // Get mixing parameters from the GCode
   3855              // The total "must" be 1.0 (but it will be normalized)
   3856              // If no mix factors are given, the old mix is preserved
   3857              void gcode_get_mix() {
   3858                const char* mixing_codes = "ABCDHI";
   3859                byte mix_bits = 0;
   3860                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
   3861                  if (parser.seenval(mixing_codes[i])) {
   3862                    SBI(mix_bits, i);
   3863                    float v = parser.value_float();
   3864                    NOLESS(v, 0.0);
   3865                    mixing_factor[i] = RECIPROCAL(v);
   3866                  }
   3867                }
   3868                // If any mixing factors were included, clear the rest
   3869                // If none were included, preserve the last mix
   3870                if (mix_bits) {
   3871                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
   3872                    if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
   3873                  normalize_mix();
   3874                }
   3875              }
   3876            #endif
   3877          
   3878          #endif
   3879          
   3880          /**
   3881           * ***************************************************************************
   3882           * ***************************** G-CODE HANDLING *****************************
   3883           * ***************************************************************************
   3884           */
   3885          
   3886          /**
   3887           * Set XYZE destination and feedrate from the current GCode command
   3888           *
   3889           *  - Set destination from included axis codes
   3890           *  - Set to current for missing axis codes
   3891           *  - Set the feedrate, if included
   3892           */

   \                                 In section .text, align 2, keep-with-next
   3893          void gcode_get_destination() {
   \                     _Z21gcode_get_destinationv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   3894            LOOP_XYZE(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE002             B.N      ??gcode_get_destination_0
   3895              if (parser.seen(axis_codes[i])) {
   3896                const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
   3897                //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
   3898                destination[i] = v;
   3899              }
   3900              else
   3901                destination[i] = current_position[i];
   \                     ??gcode_get_destination_1: (+1)
   \   00000006   0x68A8             LDR      R0,[R5, #+8]
   \   00000008   0x61A8             STR      R0,[R5, #+24]
   \                     ??gcode_get_destination_2: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_get_destination_0: (+1)
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xDA1A             BGE.N    ??gcode_get_destination_3
   \   00000010   0x....             LDR.N    R0,??DataTable151_2
   \   00000012   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   00000016   0x.... 0x....      ADR.W    R0,axis_codes
   \   0000001A   0x5620             LDRSB    R0,[R4, R0]
   \   0000001C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD0F0             BEQ.N    ??gcode_get_destination_1
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xB240             SXTB     R0,R0
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable156_7
   \   00000030   0x5C62             LDRB     R2,[R4, R1]
   \   00000032   0x7949             LDRB     R1,[R1, #+5]
   \   00000034   0x4311             ORRS     R1,R1,R2
   \   00000036   0xD001             BEQ.N    ??gcode_get_destination_4
   \   00000038   0x68A9             LDR      R1,[R5, #+8]
   \   0000003A   0xE000             B.N      ??gcode_get_destination_5
   \                     ??gcode_get_destination_4: (+1)
   \   0000003C   0x2100             MOVS     R1,#+0
   \                     ??gcode_get_destination_5: (+1)
   \   0000003E   0x.... 0x....      BL       __aeabi_fadd
   \   00000042   0x61A8             STR      R0,[R5, #+24]
   \   00000044   0xE7E1             B.N      ??gcode_get_destination_2
   3902            }
   3903          
   3904            if (parser.linearval('F') > 0.0)
   \                     ??gcode_get_destination_3: (+1)
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x2046             MOVS     R0,#+70
   \   0000004A   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000054   0xD206             BCS.N    ??gcode_get_destination_6
   3905              feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
   \   00000056   0x.... 0x....      BL       _ZN11GCodeParser14value_feedrateEv
   \   0000005A   0x....             LDR.N    R1,??DataTable152  ;; 0x42700000
   \   0000005C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000060   0x....             LDR.N    R1,??DataTable151_2
   \   00000062   0x65C8             STR      R0,[R1, #+92]
   3906          
   3907            #if ENABLED(PRINTCOUNTER)
   3908              if (!DEBUGGING(DRYRUN))
   3909                print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
   3910            #endif
   3911          
   3912            // Get ABCDHI mixing factors
   3913            #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
   3914              gcode_get_mix();
   3915            #endif
   3916          }
   \                     ??gcode_get_destination_6: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3917          
   3918          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   3919          
   3920            /**
   3921             * Output a "busy" message at regular intervals
   3922             * while the machine is not accepting commands.
   3923             */

   \                                 In section .text, align 2, keep-with-next
   3924            void host_keepalive() {
   \                     _Z14host_keepalivev: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   3925              const millis_t ms = millis();
   \   00000002   0x.... 0x....      BL       HAL_GetTick
   \   00000006   0x4605             MOV      R5,R0
   3926              if (host_keepalive_interval && busy_state != NOT_BUSY) {
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable156_7
   \   0000000C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD029             BEQ.N    ??host_keepalive_0
   \   00000012   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD025             BEQ.N    ??host_keepalive_0
   3927                if (PENDING(ms, next_busy_signal_ms)) return;
   \   0000001A   0x6BE1             LDR      R1,[R4, #+60]
   \   0000001C   0x1A69             SUBS     R1,R5,R1
   \   0000001E   0xD428             BMI.N    ??host_keepalive_1
   3928                switch (busy_state) {
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD006             BEQ.N    ??host_keepalive_2
   \   00000024   0xD31F             BCC.N    ??host_keepalive_0
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD00C             BEQ.N    ??host_keepalive_3
   \   0000002A   0xD302             BCC.N    ??host_keepalive_2
   \   0000002C   0x2804             CMP      R0,#+4
   \   0000002E   0xD012             BEQ.N    ??host_keepalive_4
   \   00000030   0xE019             B.N      ??host_keepalive_0
   3929                  case IN_HANDLER:
   3930                  case IN_PROCESS:
   3931                    SERIAL_ECHO_START();
   \                     ??host_keepalive_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable157_8
   \   00000036   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3932                    SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
   \   0000003A   0x.... 0x....      ADR.W    R0,`?<Constant "busy: processing\\n">`
   \   0000003E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3933                    break;
   \   00000042   0xE010             B.N      ??host_keepalive_0
   3934                  case PAUSED_FOR_USER:
   3935                    SERIAL_ECHO_START();
   \                     ??host_keepalive_3: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable157_8
   \   00000048   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3936                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
   \   0000004C   0x.... 0x....      ADR.W    R0,`?<Constant "busy: paused for user\\n">`
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3937                    break;
   \   00000054   0xE007             B.N      ??host_keepalive_0
   3938                  case PAUSED_FOR_INPUT:
   3939                    SERIAL_ECHO_START();
   \                     ??host_keepalive_4: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable157_8
   \   0000005A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3940                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
   \   0000005E   0x.... 0x....      ADR.W    R0,`?<Constant "busy: paused for input\\n">`
   \   00000062   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3941                    break;
   3942                  default:
   3943                    break;
   3944                }
   3945              }
   3946              next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
   \                     ??host_keepalive_0: (+1)
   \   00000066   0x79E0             LDRB     R0,[R4, #+7]
   \   00000068   0xF44F 0x717A      MOV      R1,#+1000
   \   0000006C   0xFB01 0x5000      MLA      R0,R1,R0,R5
   \   00000070   0x63E0             STR      R0,[R4, #+60]
   3947            }
   \                     ??host_keepalive_1: (+1)
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3948          
   3949          #endif // HOST_KEEPALIVE_FEATURE
   3950          
   3951          
   3952          /**************************************************
   3953           ***************** GCode Handlers *****************
   3954           **************************************************/
   3955          
   3956          #if ENABLED(NO_MOTION_BEFORE_HOMING)
   3957            #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
   3958          #else
   3959            #define G0_G1_CONDITION true
   3960          #endif
   3961          
   3962          /**
   3963           * G0, G1: Coordinated movement of X Y Z E axes
   3964           */

   \                                 In section .text, align 2
   3965          inline void gcode_G0_G1(
   3966            #if 0//IS_SCARA
   3967              bool fast_move=false
   3968            #endif
   3969          ) {
   \                     _Z11gcode_G0_G1v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3970            if (IsRunning() && G0_G1_CONDITION) {
   \   00000002   0x.... 0x....      BL       _Z9IsRunningv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??gcode_G0_G1_0
   3971              gcode_get_destination(); // For X Y Z E F
   \   0000000A   0x.... 0x....      BL       _Z21gcode_get_destinationv
   3972              
   3973             /*    
   3974              if (gCfgItems.breakpoint_reprint_flg == 1) 
   3975              {
   3976                  if ((destination[2] <= gCfgItems.breakpoint_z_pos)&&(card.sdpos >= 5000)) //∂œµ„–¯¥Ú–Ë“™¥Û”⁄5k÷Æ∫Ûµƒƒ⁄»›≤≈ƒ‹Ω¯–––¯¥Ú°£
   3977                  {
   3978                      return;
   3979                  }
   3980              }
   3981              */
   3982              #if ENABLED(FWRETRACT)
   3983                if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
   3984                  // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
   3985                  if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
   3986                    const float echange = destination[E_AXIS] - current_position[E_AXIS];
   3987                    // Is this a retract or recover move?
   3988                    if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
   3989                      current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
   3990                      sync_plan_position_e();                         // AND from the planner
   3991                      return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
   3992                    }
   3993                  }
   3994                }
   3995              #endif // FWRETRACT
   3996          
   3997              #if 0//IS_SCARA
   3998                fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
   3999              #else
   4000                prepare_move_to_destination();
   \   0000000E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000012   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   4001              #endif
   4002          
   4003              #if ENABLED(NANODLP_Z_SYNC)
   4004                #if ENABLED(NANODLP_ALL_AXIS)
   4005                  #define _MOVE_SYNC true                 // For any move wait and output sync message
   4006                #else
   4007                  #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
   4008                #endif
   4009                if (_MOVE_SYNC) {
   4010                  stepper.synchronize();
   4011                  SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4012                }
   4013              #endif
   4014            }
   4015          }
   \                     ??gcode_G0_G1_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   4016          inline void gcode_G0_G1_SCARA(
   4017          	  bool fast_move=false
   4018            )
   4019            {
   \                     _Z17gcode_G0_G1_SCARAb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4020              if (IsRunning() && G0_G1_CONDITION) {
   \   00000004   0x.... 0x....      BL       _Z9IsRunningv
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00C             BEQ.N    ??gcode_G0_G1_SCARA_0
   4021                gcode_get_destination(); // For X Y Z E F
   \   0000000C   0x.... 0x....      BL       _Z21gcode_get_destinationv
   4022          
   4023              #if ENABLED(FWRETRACT)
   4024                  if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
   4025                    // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
   4026                    if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
   4027                      const float echange = destination[E_AXIS] - current_position[E_AXIS];
   4028                      // Is this a retract or recover move?
   4029                      if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
   4030                        current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
   4031                        sync_plan_position_e();                         // AND from the planner
   4032                        return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
   4033                      }
   4034                    }
   4035                  }
   4036              #endif // FWRETRACT
   4037          
   4038              #if 1//IS_SCARA
   4039                  fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD004             BEQ.N    ??gcode_G0_G1_SCARA_1
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      _Z42prepare_uninterpolated_move_to_destinationf
   \                     ??gcode_G0_G1_SCARA_1: (+1)
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   4040              #else
   4041                  prepare_move_to_destination();
   4042              #endif
   4043          
   4044              #if ENABLED(NANODLP_Z_SYNC)
   4045              #if ENABLED(NANODLP_ALL_AXIS)
   4046                  #define _MOVE_SYNC true                 // For any move wait and output sync message
   4047              #else
   4048                  #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
   4049              #endif
   4050                  if (_MOVE_SYNC) {
   4051                    stepper.synchronize();
   4052                    SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4053                  }
   4054              #endif
   4055              }
   4056          }
   \                     ??gcode_G0_G1_SCARA_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   4057          
   4058          /**
   4059           * G2: Clockwise Arc
   4060           * G3: Counterclockwise Arc
   4061           *
   4062           * This command has two forms: IJ-form and R-form.
   4063           *
   4064           *  - I specifies an X offset. J specifies a Y offset.
   4065           *    At least one of the IJ parameters is required.
   4066           *    X and Y can be omitted to do a complete circle.
   4067           *    The given XY is not error-checked. The arc ends
   4068           *     based on the angle of the destination.
   4069           *    Mixing I or J with R will throw an error.
   4070           *
   4071           *  - R specifies the radius. X or Y is required.
   4072           *    Omitting both X and Y will throw an error.
   4073           *    X or Y must differ from the current XY.
   4074           *    Mixing R with I or J will throw an error.
   4075           *
   4076           *  - P specifies the number of full circles to do
   4077           *    before the specified arc move.
   4078           *
   4079           *  Examples:
   4080           *
   4081           *    G2 I10           ; CW circle centered at X+10
   4082           *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
   4083           */
   4084          #if ENABLED(ARC_SUPPORT)
   4085          

   \                                 In section .text, align 4
   4086            inline void gcode_G2_G3(const bool clockwise) {
   \                     _Z11gcode_G2_G3b: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   4087              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   4088                if (axis_unhomed_error()) return;
   4089              #endif
   4090          
   4091              if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xF000 0x8113      BEQ.W    ??gcode_G2_G3_0
   4092          
   4093                #if ENABLED(SF_ARC_FIX)
   4094                  const bool relative_mode_backup = relative_mode;
   4095                  relative_mode = true;
   4096                #endif
   4097          
   4098                gcode_get_destination();
   \   00000010   0x.... 0x....      BL       _Z21gcode_get_destinationv
   4099          
   4100                #if ENABLED(SF_ARC_FIX)
   4101                  relative_mode = relative_mode_backup;
   4102                #endif
   4103          
   4104                float arc_offset[2] = { 0.0, 0.0 };
   \   00000014   0xA804             ADD      R0,SP,#+16
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0xC006             STM      R0!,{R1,R2}
   4105                if (parser.seenval('R')) {
   \   0000001C   0x2052             MOVS     R0,#+82
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xF000 0x80DF      BEQ.W    ??gcode_G2_G3_1
   4106                  const float r = parser.value_linear_units(),
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000002C   0x4604             MOV      R4,R0
   4107                              p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
   \   0000002E   0x4883             LDR.N    R0,??gcode_G2_G3_2
   \   00000030   0x6881             LDR      R1,[R0, #+8]
   \   00000032   0x9101             STR      R1,[SP, #+4]
   \   00000034   0x68C1             LDR      R1,[R0, #+12]
   \   00000036   0x9100             STR      R1,[SP, #+0]
   4108                              p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
   \   00000038   0x6981             LDR      R1,[R0, #+24]
   \   0000003A   0x9103             STR      R1,[SP, #+12]
   \   0000003C   0x69C0             LDR      R0,[R0, #+28]
   \   0000003E   0x9002             STR      R0,[SP, #+8]
   4109                  if (r && (p2 != p1 || q2 != q1)) {
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000048   0xF000 0x80DD      BEQ.W    ??gcode_G2_G3_3
   \   0000004C   0x9803             LDR      R0,[SP, #+12]
   \   0000004E   0x9901             LDR      R1,[SP, #+4]
   \   00000050   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000054   0xD105             BNE.N    ??gcode_G2_G3_4
   \   00000056   0x9802             LDR      R0,[SP, #+8]
   \   00000058   0x9900             LDR      R1,[SP, #+0]
   \   0000005A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000005E   0xF000 0x80D2      BEQ.W    ??gcode_G2_G3_3
   4110                    const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
   \                     ??gcode_G2_G3_4: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000006A   0xD201             BCS.N    ??gcode_G2_G3_5
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE000             B.N      ??gcode_G2_G3_6
   \                     ??gcode_G2_G3_5: (+1)
   \   00000070   0x4608             MOV      R0,R1
   \                     ??gcode_G2_G3_6: (+1)
   \   00000072   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000076   0xF89D 0x1020      LDRB     R1,[SP, #+32]
   \   0000007A   0xEA90 0x0F01      TEQ      R0,R1
   \   0000007E   0xD001             BEQ.N    ??gcode_G2_G3_7
   \   00000080   0x4E6F             LDR.N    R6,??gcode_G2_G3_2+0x4  ;; 0xbf800000
   \   00000082   0xE000             B.N      ??gcode_G2_G3_8
   \                     ??gcode_G2_G3_7: (+1)
   \   00000084   0x463E             MOV      R6,R7
   4111                                dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
   \                     ??gcode_G2_G3_8: (+1)
   \   00000086   0x9803             LDR      R0,[SP, #+12]
   \   00000088   0x9901             LDR      R1,[SP, #+4]
   \   0000008A   0x.... 0x....      BL       __aeabi_fsub
   \   0000008E   0x9007             STR      R0,[SP, #+28]
   \   00000090   0x9802             LDR      R0,[SP, #+8]
   \   00000092   0x9900             LDR      R1,[SP, #+0]
   \   00000094   0x.... 0x....      BL       __aeabi_fsub
   \   00000098   0x9006             STR      R0,[SP, #+24]
   4112                                d = HYPOT(dx, dy),                          // Linear distance between the points
   \   0000009A   0xF8DD 0x801C      LDR      R8,[SP, #+28]
   \   0000009E   0xF04F 0x0902      MOV      R9,#+2
   \   000000A2   0x463D             MOV      R5,R7
   \   000000A4   0xE004             B.N      ??gcode_G2_G3_9
   \                     ??gcode_G2_G3_10: (+1)
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x4641             MOV      R1,R8
   \   000000AA   0x.... 0x....      BL       __aeabi_fmul
   \   000000AE   0x4680             MOV      R8,R0
   \                     ??gcode_G2_G3_9: (+1)
   \   000000B0   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000B4   0xD504             BPL.N    ??gcode_G2_G3_11
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x4641             MOV      R1,R8
   \   000000BA   0x.... 0x....      BL       __aeabi_fmul
   \   000000BE   0x4605             MOV      R5,R0
   \                     ??gcode_G2_G3_11: (+1)
   \   000000C0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000C4   0xD1EF             BNE.N    ??gcode_G2_G3_10
   \   000000C6   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   000000CA   0xF04F 0x0902      MOV      R9,#+2
   \   000000CE   0x46BA             MOV      R10,R7
   \   000000D0   0xE004             B.N      ??gcode_G2_G3_12
   \                     ??gcode_G2_G3_13: (+1)
   \   000000D2   0x4640             MOV      R0,R8
   \   000000D4   0x4641             MOV      R1,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_fmul
   \   000000DA   0x4680             MOV      R8,R0
   \                     ??gcode_G2_G3_12: (+1)
   \   000000DC   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000E0   0xD504             BPL.N    ??gcode_G2_G3_14
   \   000000E2   0x4650             MOV      R0,R10
   \   000000E4   0x4641             MOV      R1,R8
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4682             MOV      R10,R0
   \                     ??gcode_G2_G3_14: (+1)
   \   000000EC   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000F0   0xD1EF             BNE.N    ??gcode_G2_G3_13
   \   000000F2   0x4628             MOV      R0,R5
   \   000000F4   0x4651             MOV      R1,R10
   \   000000F6   0x.... 0x....      BL       __aeabi_fadd
   \   000000FA   0x.... 0x....      BL       sqrtf
   \   000000FE   0x4682             MOV      R10,R0
   4113                                h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
   \   00000100   0x2502             MOVS     R5,#+2
   \   00000102   0xE004             B.N      ??gcode_G2_G3_15
   \                     ??gcode_G2_G3_16: (+1)
   \   00000104   0x4620             MOV      R0,R4
   \   00000106   0x4621             MOV      R1,R4
   \   00000108   0x.... 0x....      BL       __aeabi_fmul
   \   0000010C   0x4604             MOV      R4,R0
   \                     ??gcode_G2_G3_15: (+1)
   \   0000010E   0x07E8             LSLS     R0,R5,#+31
   \   00000110   0xD504             BPL.N    ??gcode_G2_G3_17
   \   00000112   0x4638             MOV      R0,R7
   \   00000114   0x4621             MOV      R1,R4
   \   00000116   0x.... 0x....      BL       __aeabi_fmul
   \   0000011A   0x4607             MOV      R7,R0
   \                     ??gcode_G2_G3_17: (+1)
   \   0000011C   0x086D             LSRS     R5,R5,#+1
   \   0000011E   0xD1F1             BNE.N    ??gcode_G2_G3_16
   \   00000120   0x4650             MOV      R0,R10
   \   00000122   0x.... 0x....      BL       __aeabi_f2d
   \   00000126   0x2200             MOVS     R2,#+0
   \   00000128   0x4B46             LDR.N    R3,??gcode_G2_G3_2+0x8  ;; 0x3fe00000
   \   0000012A   0x.... 0x....      BL       __aeabi_dmul
   \   0000012E   0x4680             MOV      R8,R0
   \   00000130   0x4689             MOV      R9,R1
   \   00000132   0xF04F 0x0B02      MOV      R11,#+2
   \   00000136   0x2400             MOVS     R4,#+0
   \   00000138   0x4D43             LDR.N    R5,??gcode_G2_G3_2+0xC  ;; 0x3ff00000
   \   0000013A   0xE007             B.N      ??gcode_G2_G3_18
   \                     ??gcode_G2_G3_19: (+1)
   \   0000013C   0x4640             MOV      R0,R8
   \   0000013E   0x4649             MOV      R1,R9
   \   00000140   0x4642             MOV      R2,R8
   \   00000142   0x464B             MOV      R3,R9
   \   00000144   0x.... 0x....      BL       __aeabi_dmul
   \   00000148   0x4680             MOV      R8,R0
   \   0000014A   0x4689             MOV      R9,R1
   \                     ??gcode_G2_G3_18: (+1)
   \   0000014C   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   00000150   0xD507             BPL.N    ??gcode_G2_G3_20
   \   00000152   0x4642             MOV      R2,R8
   \   00000154   0x464B             MOV      R3,R9
   \   00000156   0x4620             MOV      R0,R4
   \   00000158   0x4629             MOV      R1,R5
   \   0000015A   0x.... 0x....      BL       __aeabi_dmul
   \   0000015E   0x4604             MOV      R4,R0
   \   00000160   0x460D             MOV      R5,R1
   \                     ??gcode_G2_G3_20: (+1)
   \   00000162   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   00000166   0xD1E9             BNE.N    ??gcode_G2_G3_19
   \   00000168   0x4638             MOV      R0,R7
   \   0000016A   0x.... 0x....      BL       __aeabi_f2d
   \   0000016E   0x4622             MOV      R2,R4
   \   00000170   0x462B             MOV      R3,R5
   \   00000172   0x.... 0x....      BL       __aeabi_dsub
   \   00000176   0x.... 0x....      BL       sqrt
   \   0000017A   0x.... 0x....      BL       __aeabi_d2f
   4114                                mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
   4115                                sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
   4116                                cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
   4117                    arc_offset[0] = cx - p1;
   \   0000017E   0x4631             MOV      R1,R6
   \   00000180   0x.... 0x....      BL       __aeabi_fmul
   \   00000184   0x4604             MOV      R4,R0
   \   00000186   0xF04F 0x557C      MOV      R5,#+1056964608
   \   0000018A   0x9901             LDR      R1,[SP, #+4]
   \   0000018C   0x9803             LDR      R0,[SP, #+12]
   \   0000018E   0x.... 0x....      BL       __aeabi_fadd
   \   00000192   0x4629             MOV      R1,R5
   \   00000194   0x.... 0x....      BL       __aeabi_fmul
   \   00000198   0x4606             MOV      R6,R0
   \   0000019A   0x9806             LDR      R0,[SP, #+24]
   \   0000019C   0x4651             MOV      R1,R10
   \   0000019E   0x.... 0x....      BL       __aeabi_fdiv
   \   000001A2   0x4621             MOV      R1,R4
   \   000001A4   0x.... 0x....      BL       __aeabi_fmul
   \   000001A8   0x4601             MOV      R1,R0
   \   000001AA   0x4630             MOV      R0,R6
   \   000001AC   0x.... 0x....      BL       __aeabi_fsub
   \   000001B0   0x9901             LDR      R1,[SP, #+4]
   \   000001B2   0x.... 0x....      BL       __aeabi_fsub
   \   000001B6   0x9004             STR      R0,[SP, #+16]
   4118                    arc_offset[1] = cy - q1;
   \   000001B8   0x9900             LDR      R1,[SP, #+0]
   \   000001BA   0x9802             LDR      R0,[SP, #+8]
   \   000001BC   0x.... 0x....      BL       __aeabi_fadd
   \   000001C0   0x4629             MOV      R1,R5
   \   000001C2   0x.... 0x....      BL       __aeabi_fmul
   \   000001C6   0x4605             MOV      R5,R0
   \   000001C8   0x9807             LDR      R0,[SP, #+28]
   \   000001CA   0x4651             MOV      R1,R10
   \   000001CC   0x.... 0x....      BL       __aeabi_fdiv
   \   000001D0   0x4621             MOV      R1,R4
   \   000001D2   0x.... 0x....      BL       __aeabi_fmul
   \   000001D6   0x4629             MOV      R1,R5
   \   000001D8   0x.... 0x....      BL       __aeabi_fadd
   \   000001DC   0x9900             LDR      R1,[SP, #+0]
   \   000001DE   0x.... 0x....      BL       __aeabi_fsub
   \   000001E2   0x9005             STR      R0,[SP, #+20]
   \   000001E4   0xE00F             B.N      ??gcode_G2_G3_3
   4119                  }
   4120                }
   4121                else {
   4122                  if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
   \                     ??gcode_G2_G3_1: (+1)
   \   000001E6   0x2049             MOVS     R0,#+73
   \   000001E8   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001EC   0x2800             CMP      R0,#+0
   \   000001EE   0xD002             BEQ.N    ??gcode_G2_G3_21
   \   000001F0   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000001F4   0x9004             STR      R0,[SP, #+16]
   4123                  if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
   \                     ??gcode_G2_G3_21: (+1)
   \   000001F6   0x204A             MOVS     R0,#+74
   \   000001F8   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD002             BEQ.N    ??gcode_G2_G3_3
   \   00000200   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000204   0x9005             STR      R0,[SP, #+20]
   4124                }
   4125          
   4126                if (arc_offset[0] || arc_offset[1]) {
   \                     ??gcode_G2_G3_3: (+1)
   \   00000206   0x9804             LDR      R0,[SP, #+16]
   \   00000208   0x2100             MOVS     R1,#+0
   \   0000020A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000020E   0xD103             BNE.N    ??gcode_G2_G3_22
   \   00000210   0x9805             LDR      R0,[SP, #+20]
   \   00000212   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000216   0xD008             BEQ.N    ??gcode_G2_G3_23
   4127          
   4128                  #if ENABLED(ARC_P_CIRCLES)
   4129                    // P indicates number of circles to do
   4130                    int8_t circles_to_do = parser.byteval('P');
   4131                    if (!WITHIN(circles_to_do, 0, 100)) {
   4132                      SERIAL_ERROR_START();
   4133                      SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
   4134                    }
   4135                    while (circles_to_do--)
   4136                      plan_arc(current_position, arc_offset, clockwise);
   4137                  #endif
   4138          
   4139                  // Send the arc to the planner
   4140                  plan_arc(destination, arc_offset, clockwise);
   \                     ??gcode_G2_G3_22: (+1)
   \   00000218   0xF89D 0x2020      LDRB     R2,[SP, #+32]
   \   0000021C   0xA904             ADD      R1,SP,#+16
   \   0000021E   0x480B             LDR.N    R0,??gcode_G2_G3_2+0x10
   \   00000220   0x.... 0x....      BL       _Z8plan_arcRA4_KfRA2_S_b
   4141                  refresh_cmd_timeout();
   \   00000224   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   \   00000228   0xE005             B.N      ??gcode_G2_G3_0
   4142                }
   4143                else {
   4144                  // Bad arguments
   4145                  SERIAL_ERROR_START();
   \                     ??gcode_G2_G3_23: (+1)
   \   0000022A   0x4809             LDR.N    R0,??gcode_G2_G3_2+0x14
   \   0000022C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4146                  SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
   \   00000230   0x4808             LDR.N    R0,??gcode_G2_G3_2+0x18
   \   00000232   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4147                }
   4148              }
   4149            }
   \                     ??gcode_G2_G3_0: (+1)
   \   00000236   0xB009             ADD      SP,SP,#+36
   \   00000238   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??gcode_G2_G3_2:
   \   0000023C   0x........         DC32     mks_heating_busy
   \   00000240   0xBF800000         DC32     0xbf800000
   \   00000244   0x3FE00000         DC32     0x3fe00000
   \   00000248   0x3FF00000         DC32     0x3ff00000
   \   0000024C   0x........         DC32     mks_heating_busy+0x18
   \   00000250   0x........         DC32     errormagic
   \   00000254   0x........         DC32     _ZZ11gcode_G2_G3bEs
   4150          
   4151          #endif // ARC_SUPPORT
   4152          

   \                                 In section .text, align 2, keep-with-next
   4153          void dwell(millis_t time) {
   \                     _Z5dwellm: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4154            refresh_cmd_timeout();
   \   00000004   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   4155            time += previous_cmd_ms;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable158
   \   0000000C   0x6DC0             LDR      R0,[R0, #+92]
   \   0000000E   0x1904             ADDS     R4,R0,R4
   \   00000010   0xE001             B.N      ??dwell_0
   4156            while (PENDING(millis(), time)) idle();
   \                     ??dwell_1: (+1)
   \   00000012   0x.... 0x....      BL       _Z4idlev
   \                     ??dwell_0: (+1)
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x1B00             SUBS     R0,R0,R4
   \   0000001C   0xD4F9             BMI.N    ??dwell_1
   4157          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   4158          
   4159          /**
   4160           * G4: Dwell S<seconds> or P<milliseconds>
   4161           */

   \                                 In section .text, align 4
   4162          inline void gcode_G4() {
   \                     _Z8gcode_G4v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4163            millis_t dwell_ms = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   4164          
   4165            if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??gcode_G4_0
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser12value_millisEv
   \   00000012   0x4604             MOV      R4,R0
   4166            if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
   \                     ??gcode_G4_0: (+1)
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??gcode_G4_1
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000022   0x4604             MOV      R4,R0
   4167          
   4168            stepper.synchronize();
   \                     ??gcode_G4_1: (+1)
   \   00000024   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4169            #if ENABLED(NANODLP_Z_SYNC)
   4170              SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4171            #endif
   4172          
   4173            if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
   \   00000028   0x.... 0x....      BL       _Z13lcd_hasstatusv
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??gcode_G4_2
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x4804             LDR.N    R0,??gcode_G4_3
   \   00000034   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   4174          
   4175            dwell(dwell_ms);
   \                     ??gcode_G4_2: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003E   0x.... 0x....      B.W      _Z5dwellm
   \   00000042   0xBF00             Nop      
   \                     ??gcode_G4_3:
   \   00000044   0x........         DC32     _ZZ8gcode_G4vEs
   4176          }
   4177          
   4178          #if ENABLED(BEZIER_CURVE_SUPPORT)
   4179          
   4180            /**
   4181             * Parameters interpreted according to:
   4182             * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
   4183             * However I, J omission is not supported at this point; all
   4184             * parameters can be omitted and default to zero.
   4185             */
   4186          
   4187            /**
   4188             * G5: Cubic B-spline
   4189             */
   4190            inline void gcode_G5() {
   4191              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   4192                if (axis_unhomed_error()) return;
   4193              #endif
   4194          
   4195              if (IsRunning()) {
   4196          
   4197                #if ENABLED(CNC_WORKSPACE_PLANES)
   4198                  if (workspace_plane != PLANE_XY) {
   4199                    SERIAL_ERROR_START();
   4200                    SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
   4201                    return;
   4202                  }
   4203                #endif
   4204          
   4205                gcode_get_destination();
   4206          
   4207                const float offset[] = {
   4208                  parser.linearval('I'),
   4209                  parser.linearval('J'),
   4210                  parser.linearval('P'),
   4211                  parser.linearval('Q')
   4212                };
   4213          
   4214                plan_cubic_move(offset);
   4215              }
   4216            }
   4217          
   4218          #endif // BEZIER_CURVE_SUPPORT
   4219          
   4220          #if ENABLED(FWRETRACT)
   4221          
   4222            /**
   4223             * G10 - Retract filament according to settings of M207
   4224             */
   4225            inline void gcode_G10() {
   4226              #if EXTRUDERS > 1
   4227                const bool rs = parser.boolval('S');
   4228                retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
   4229              #endif
   4230              retract(true
   4231                #if EXTRUDERS > 1
   4232                  , rs
   4233                #endif
   4234              );
   4235            }
   4236          
   4237            /**
   4238             * G11 - Recover filament according to settings of M208
   4239             */
   4240            inline void gcode_G11() { retract(false); }
   4241          
   4242          #endif // FWRETRACT
   4243          
   4244          #if ENABLED(NOZZLE_CLEAN_FEATURE)
   4245            /**
   4246             * G12: Clean the nozzle
   4247             */
   4248            inline void gcode_G12() {
   4249              // Don't allow nozzle cleaning without homing first
   4250              if (axis_unhomed_error()) return;
   4251          
   4252              const uint8_t pattern = parser.ushortval('P', 0),
   4253                            strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
   4254                            objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
   4255              const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
   4256          
   4257              Nozzle::clean(pattern, strokes, radius, objects);
   4258            }
   4259          #endif
   4260          
   4261          #if ENABLED(CNC_WORKSPACE_PLANES)
   4262          
   4263            inline void report_workspace_plane() {
   4264              SERIAL_ECHO_START();
   4265              SERIAL_ECHOPGM("Workspace Plane ");
   4266              serialprintPGM(
   4267                workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
   4268                workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
   4269                                              PSTR("XY\n")
   4270              );
   4271            }
   4272          
   4273            inline void set_workspace_plane(const WorkspacePlane plane) {
   4274              workspace_plane = plane;
   4275              if (DEBUGGING(INFO)) report_workspace_plane();
   4276            }
   4277          
   4278            /**
   4279             * G17: Select Plane XY
   4280             * G18: Select Plane ZX
   4281             * G19: Select Plane YZ
   4282             */
   4283            inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
   4284            inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
   4285            inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
   4286          
   4287          #endif // CNC_WORKSPACE_PLANES
   4288          
   4289          #if ENABLED(CNC_COORDINATE_SYSTEMS)
   4290          
   4291            /**
   4292             * Select a coordinate system and update the workspace offset.
   4293             * System index -1 is used to specify machine-native.
   4294             */
   4295            bool select_coordinate_system(const int8_t _new) {
   4296              if (active_coordinate_system == _new) return false;
   4297              float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
   4298              if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
   4299                COPY(old_offset, coordinate_system[active_coordinate_system]);
   4300              if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
   4301                COPY(new_offset, coordinate_system[_new]);
   4302              active_coordinate_system = _new;
   4303              LOOP_XYZ(i) {
   4304                const float diff = new_offset[i] - old_offset[i];
   4305                if (diff) {
   4306                  position_shift[i] += diff;
   4307                  update_software_endstops((AxisEnum)i);
   4308                }
   4309              }
   4310              return true;
   4311            }
   4312          
   4313            /**
   4314             * In CNC G-code G53 is like a modifier
   4315             * It precedes a movement command (or other modifiers) on the same line.
   4316             * This is the first command to use parser.chain() to make this possible.
   4317             */
   4318            inline void gcode_G53() {
   4319              // If this command has more following...
   4320              if (parser.chain()) {
   4321                const int8_t _system = active_coordinate_system;
   4322                active_coordinate_system = -1;
   4323                process_parsed_command();
   4324                active_coordinate_system = _system;
   4325              }
   4326            }
   4327          
   4328            /**
   4329             * G54-G59.3: Select a new workspace
   4330             *
   4331             * A workspace is an XYZ offset to the machine native space.
   4332             * All workspaces default to 0,0,0 at start, or with EEPROM
   4333             * support they may be restored from a previous session.
   4334             *
   4335             * G92 is used to set the current workspace's offset.
   4336             */
   4337            inline void gcode_G54_59(uint8_t subcode=0) {
   4338              const int8_t _space = parser.codenum - 54 + subcode;
   4339              if (select_coordinate_system(_space)) {
   4340                SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
   4341                report_current_position();
   4342              }
   4343            }
   4344            FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
   4345            FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
   4346            FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
   4347            FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
   4348            FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
   4349            FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
   4350          
   4351          #endif
   4352          
   4353          #if ENABLED(INCH_MODE_SUPPORT)
   4354            /**
   4355             * G20: Set input mode to inches
   4356             */
   4357            inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
   4358          
   4359            /**
   4360             * G21: Set input mode to millimeters
   4361             */
   4362            inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
   4363          #endif
   4364          
   4365          #if ENABLED(NOZZLE_PARK_FEATURE)
   4366            /**
   4367             * G27: Park the nozzle
   4368             */
   4369            inline void gcode_G27() {
   4370              // Don't allow nozzle parking without homing first
   4371              if (axis_unhomed_error()) return;
   4372              Nozzle::park(parser.ushortval('P'));
   4373            }
   4374          #endif // NOZZLE_PARK_FEATURE
   4375          
   4376          #if 1//ENABLED(QUICK_HOME)
   4377          

   \                                 In section .text, align 2, keep-with-next
   4378            static void quick_home_xy() {
   \                     _Z13quick_home_xyv: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   4379          
   4380              // Pretend the current position is 0,0
   4381              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable158_1
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x60F0             STR      R0,[R6, #+12]
   \   0000000C   0x60B0             STR      R0,[R6, #+8]
   4382              sync_plan_position();
   \   0000000E   0x.... 0x....      BL       _Z18sync_plan_positionv
   4383          
   4384              const int x_axis_home_dir =
   4385                #if ENABLED(DUAL_X_CARRIAGE)
   4386                  x_home_dir(active_extruder)
   4387                #else
   4388                  home_dir(X_AXIS)
   4389                #endif
   4390              ;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   00000018   0x4681             MOV      R9,R0
   4391          
   4392              const float mlx = max_length(X_AXIS),
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       _Z10max_length8AxisEnum
   \   00000020   0x4680             MOV      R8,R0
   4393                          mly = max_length(Y_AXIS),
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       _Z10max_length8AxisEnum
   \   00000028   0x4607             MOV      R7,R0
   4394                          mlratio = mlx > mly ? mly / mlx : mlx / mly,
   \   0000002A   0x4641             MOV      R1,R8
   \   0000002C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000030   0xD203             BCS.N    ??quick_home_xy_0
   \   00000032   0x.... 0x....      BL       __aeabi_fdiv
   \   00000036   0x4682             MOV      R10,R0
   \   00000038   0xE004             B.N      ??quick_home_xy_1
   \                     ??quick_home_xy_0: (+1)
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x4639             MOV      R1,R7
   \   0000003E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000042   0x4682             MOV      R10,R0
   4395                          fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
   \                     ??quick_home_xy_1: (+1)
   \   00000044   0xF8D6 0xB02C      LDR      R11,[R6, #+44]
   \   00000048   0x6AB0             LDR      R0,[R6, #+40]
   \   0000004A   0x4659             MOV      R1,R11
   \   0000004C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000050   0xD200             BCS.N    ??quick_home_xy_2
   \   00000052   0x4683             MOV      R11,R0
   \                     ??quick_home_xy_2: (+1)
   \   00000054   0x2502             MOVS     R5,#+2
   \   00000056   0xF04F 0x547E      MOV      R4,#+1065353216
   \   0000005A   0xE004             B.N      ??quick_home_xy_3
   \                     ??quick_home_xy_4: (+1)
   \   0000005C   0x4650             MOV      R0,R10
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x.... 0x....      BL       __aeabi_fmul
   \   00000064   0x4682             MOV      R10,R0
   \                     ??quick_home_xy_3: (+1)
   \   00000066   0x07E8             LSLS     R0,R5,#+31
   \   00000068   0xD504             BPL.N    ??quick_home_xy_5
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x4651             MOV      R1,R10
   \   0000006E   0x.... 0x....      BL       __aeabi_fmul
   \   00000072   0x4604             MOV      R4,R0
   \                     ??quick_home_xy_5: (+1)
   \   00000074   0x086D             LSRS     R5,R5,#+1
   \   00000076   0xD1F1             BNE.N    ??quick_home_xy_4
   \   00000078   0x4658             MOV      R0,R11
   \   0000007A   0x.... 0x....      BL       __aeabi_f2d
   \   0000007E   0x4682             MOV      R10,R0
   \   00000080   0x468B             MOV      R11,R1
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       __aeabi_f2d
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x.... 0x....      LDR.W    R3,??DataTable157_3  ;; 0x3ff00000
   \   0000008E   0x.... 0x....      BL       __aeabi_dadd
   \   00000092   0x.... 0x....      BL       sqrt
   \   00000096   0x4652             MOV      R2,R10
   \   00000098   0x465B             MOV      R3,R11
   \   0000009A   0x.... 0x....      BL       __aeabi_dmul
   \   0000009E   0x.... 0x....      BL       __aeabi_d2f
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   4396          
   4397              do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
   \   000000A4   0x2400             MOVS     R4,#+0
   \   000000A6   0x.... 0x....      LDR.W    R5,??DataTable157_4  ;; 0x3ff80000
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0x.... 0x....      BL       __aeabi_f2d
   \   000000B0   0x4622             MOV      R2,R4
   \   000000B2   0x462B             MOV      R3,R5
   \   000000B4   0x.... 0x....      BL       __aeabi_dmul
   \   000000B8   0x4682             MOV      R10,R0
   \   000000BA   0x468B             MOV      R11,R1
   \   000000BC   0x4648             MOV      R0,R9
   \   000000BE   0x.... 0x....      BL       __aeabi_i2d
   \   000000C2   0x4652             MOV      R2,R10
   \   000000C4   0x465B             MOV      R3,R11
   \   000000C6   0x.... 0x....      BL       __aeabi_dmul
   \   000000CA   0x.... 0x....      BL       __aeabi_d2f
   \   000000CE   0x9002             STR      R0,[SP, #+8]
   \   000000D0   0x4638             MOV      R0,R7
   \   000000D2   0x.... 0x....      BL       __aeabi_f2d
   \   000000D6   0x4622             MOV      R2,R4
   \   000000D8   0x462B             MOV      R3,R5
   \   000000DA   0x.... 0x....      BL       __aeabi_dmul
   \   000000DE   0x4604             MOV      R4,R0
   \   000000E0   0x460D             MOV      R5,R1
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   000000E8   0x.... 0x....      BL       __aeabi_i2d
   \   000000EC   0x4622             MOV      R2,R4
   \   000000EE   0x462B             MOV      R3,R5
   \   000000F0   0x.... 0x....      BL       __aeabi_dmul
   \   000000F4   0x.... 0x....      BL       __aeabi_d2f
   \   000000F8   0x9001             STR      R0,[SP, #+4]
   \   000000FA   0xAA00             ADD      R2,SP,#+0
   \   000000FC   0xA901             ADD      R1,SP,#+4
   \   000000FE   0xA802             ADD      R0,SP,#+8
   \   00000100   0x.... 0x....      BL       _Z22do_blocking_move_to_xyRKfS0_S0_
   4398              endstops.hit_on_purpose(); // clear endstop hit flags
   \   00000104   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   4399              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x60F0             STR      R0,[R6, #+12]
   \   0000010C   0x60B0             STR      R0,[R6, #+8]
   4400            }
   \   0000010E   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   4401          
   4402          #endif // QUICK_HOME
   4403          
   4404          #if ENABLED(DEBUG_LEVELING_FEATURE)
   4405          
   4406            void log_machine_info() {
   4407              SERIAL_ECHOPGM("Machine Type: ");
   4408              #if ENABLED(DELTA)
   4409                SERIAL_ECHOLNPGM("Delta");
   4410              #elif IS_SCARA
   4411                SERIAL_ECHOLNPGM("SCARA");
   4412              #elif IS_CORE
   4413                SERIAL_ECHOLNPGM("Core");
   4414              #else
   4415                SERIAL_ECHOLNPGM("Cartesian");
   4416              #endif
   4417          
   4418              SERIAL_ECHOPGM("Probe: ");
   4419              #if ENABLED(PROBE_MANUALLY)
   4420                SERIAL_ECHOLNPGM("PROBE_MANUALLY");
   4421              #elif ENABLED(FIX_MOUNTED_PROBE)
   4422                SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
   4423              #elif ENABLED(BLTOUCH)
   4424                SERIAL_ECHOLNPGM("BLTOUCH");
   4425              #elif HAS_Z_SERVO_ENDSTOP
   4426                SERIAL_ECHOLNPGM("SERVO PROBE");
   4427              #elif ENABLED(Z_PROBE_SLED)
   4428                SERIAL_ECHOLNPGM("Z_PROBE_SLED");
   4429              #elif ENABLED(Z_PROBE_ALLEN_KEY)
   4430                SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
   4431              #else
   4432                SERIAL_ECHOLNPGM("NONE");
   4433              #endif
   4434          
   4435              #if HAS_BED_PROBE
   4436                SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
   4437                SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
   4438                SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
   4439                #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
   4440                  SERIAL_ECHOPGM(" (Right");
   4441                #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
   4442                  SERIAL_ECHOPGM(" (Left");
   4443                #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
   4444                  SERIAL_ECHOPGM(" (Middle");
   4445                #else
   4446                  SERIAL_ECHOPGM(" (Aligned With");
   4447                #endif
   4448                #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
   4449                  SERIAL_ECHOPGM("-Back");
   4450                #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
   4451                  SERIAL_ECHOPGM("-Front");
   4452                #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
   4453                  SERIAL_ECHOPGM("-Center");
   4454                #endif
   4455                if (zprobe_zoffset < 0)
   4456                  SERIAL_ECHOPGM(" & Below");
   4457                else if (zprobe_zoffset > 0)
   4458                  SERIAL_ECHOPGM(" & Above");
   4459                else
   4460                  SERIAL_ECHOPGM(" & Same Z as");
   4461                SERIAL_ECHOLNPGM(" Nozzle)");
   4462              #endif
   4463          
   4464              #if HAS_ABL
   4465                SERIAL_ECHOPGM("Auto Bed Leveling: ");
   4466                #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   4467                  SERIAL_ECHOPGM("LINEAR");
   4468                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4469                  SERIAL_ECHOPGM("BILINEAR");
   4470                #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   4471                  SERIAL_ECHOPGM("3POINT");
   4472                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   4473                  SERIAL_ECHOPGM("UBL");
   4474                #endif
   4475                if (planner.leveling_active) {
   4476                  SERIAL_ECHOLNPGM(" (enabled)");
   4477                  #if ABL_PLANAR
   4478                    const float diff[XYZ] = {
   4479                      stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
   4480                      stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
   4481                      stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
   4482                    };
   4483                    SERIAL_ECHOPGM("ABL Adjustment X");
   4484                    if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
   4485                    SERIAL_ECHO(diff[X_AXIS]);
   4486                    SERIAL_ECHOPGM(" Y");
   4487                    if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
   4488                    SERIAL_ECHO(diff[Y_AXIS]);
   4489                    SERIAL_ECHOPGM(" Z");
   4490                    if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
   4491                    SERIAL_ECHO(diff[Z_AXIS]);
   4492                  #elif ENABLED(AUTO_BED_LEVELING_UBL)
   4493                    SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
   4494                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4495                    SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
   4496                  #endif
   4497                }
   4498                else
   4499                  SERIAL_ECHOLNPGM(" (disabled)");
   4500          
   4501                SERIAL_EOL();
   4502          
   4503              #elif ENABLED(MESH_BED_LEVELING)
   4504          
   4505                SERIAL_ECHOPGM("Mesh Bed Leveling");
   4506                if (planner.leveling_active) {
   4507                  float rz = current_position[Z_AXIS];
   4508                  planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
   4509                  SERIAL_ECHOLNPGM(" (enabled)");
   4510                  SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
   4511                }
   4512                else
   4513                  SERIAL_ECHOPGM(" (disabled)");
   4514          
   4515                SERIAL_EOL();
   4516          
   4517              #endif // MESH_BED_LEVELING
   4518            }
   4519          
   4520          #endif // DEBUG_LEVELING_FEATURE
   4521          
   4522          #if 1//ENABLED(DELTA)
   4523          
   4524            /**
   4525             * A delta can only safely home all axes at the same time
   4526             * This is like quick_home_xy() but for 3 towers.
   4527             */

   \                                 In section .text, align 4
   4528            inline bool home_delta() {
   \                     _Z10home_deltav: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4529              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4530                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
   4531              #endif
   4532              // Init the current position of all carriages to 0,0,0
   4533              ZERO(current_position);
   \   00000002   0x4C20             LDR.N    R4,??home_delta_0
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000000C   0x.... 0x....      BL       memset
   4534              sync_plan_position();
   \   00000010   0x.... 0x....      BL       _Z18sync_plan_positionv
   4535          
   4536              // Move all carriages together linearly until an endstop is hit.
   4537              current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
   \   00000014   0x6FA0             LDR      R0,[R4, #+120]
   \   00000016   0x491C             LDR.N    R1,??home_delta_0+0x4  ;; 0x41200000
   \   00000018   0x.... 0x....      BL       __aeabi_fadd
   \   0000001C   0x6120             STR      R0,[R4, #+16]
   \   0000001E   0x60E0             STR      R0,[R4, #+12]
   \   00000020   0x60A0             STR      R0,[R4, #+8]
   4538              feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
   \   00000022   0x6AA0             LDR      R0,[R4, #+40]
   \   00000024   0x65E0             STR      R0,[R4, #+92]
   4539              buffer_line_to_current_position();
   \   00000026   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   4540              stepper.synchronize();
   \   0000002A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4541          
   4542              // If an endstop was not hit, then damage can occur if homing is continued.
   4543              // This can occur if the delta height not set correctly.
   4544              if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
   \   0000002E   0x4817             LDR.N    R0,??home_delta_0+0x8
   \   00000030   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000034   0x2170             MOVS     R1,#+112
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD10B             BNE.N    ??home_delta_1
   4545                LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x4814             LDR.N    R0,??home_delta_0+0xC
   \   0000003E   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   4546                SERIAL_ERROR_START();
   \   00000042   0x4814             LDR.N    R0,??home_delta_0+0x10
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4547                SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
   \   00000048   0x4813             LDR.N    R0,??home_delta_0+0x14
   \   0000004A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4548                return false;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD10             POP      {R4,PC}
   4549              }
   4550          
   4551              endstops.hit_on_purpose(); // clear endstop hit flags
   \                     ??home_delta_1: (+1)
   \   00000052   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   4552          
   4553              // At least one carriage has reached the top.
   4554              // Now re-home each carriage separately.
   4555              HOMEAXIS(A);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4556              HOMEAXIS(B);
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4557              HOMEAXIS(C);
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4558          
   4559              // Set all carriages to their home positions
   4560              // Do this here all at once for Delta, because
   4561              // XYZ isn't ABC. Applying this per-tower would
   4562              // give the impression that they are the same.
   4563              LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
   \   00000068   0x2400             MOVS     R4,#+0
   \   0000006A   0xE004             B.N      ??home_delta_2
   \                     ??home_delta_3: (+1)
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0xB240             SXTB     R0,R0
   \   00000070   0x.... 0x....      BL       _Z19set_axis_is_at_home8AxisEnum
   \   00000074   0x1C64             ADDS     R4,R4,#+1
   \                     ??home_delta_2: (+1)
   \   00000076   0x2C03             CMP      R4,#+3
   \   00000078   0xDBF8             BLT.N    ??home_delta_3
   4564          
   4565              SYNC_PLAN_POSITION_KINEMATIC();
   \   0000007A   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   4566          
   4567              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4568                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
   4569              #endif
   4570          
   4571              return true;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
   \   00000082   0xBF00             Nop      
   \                     ??home_delta_0:
   \   00000084   0x........         DC32     mks_heating_busy
   \   00000088   0x41200000         DC32     0x41200000
   \   0000008C   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE
   \   00000090   0x........         DC32     _ZZ10home_deltavEs
   \   00000094   0x........         DC32     errormagic
   \   00000098   0x........         DC32     _ZZ10home_deltavEs_0
   4572            }
   4573          
   4574          #endif // DELTA
   4575          
   4576          #if ENABLED(Z_SAFE_HOMING)
   4577          
   4578            inline void home_z_safely() {
   4579          
   4580              // Disallow Z homing if X or Y are unknown
   4581              if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
   4582                LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
   4583                SERIAL_ECHO_START();
   4584                SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
   4585                return;
   4586              }
   4587          
   4588              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4589                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
   4590              #endif
   4591          
   4592              SYNC_PLAN_POSITION_KINEMATIC();
   4593          
   4594              /**
   4595               * Move the Z probe (or just the nozzle) to the safe homing point
   4596               */
   4597              destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
   4598              destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
   4599              destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
   4600          
   4601              #if HOMING_Z_WITH_PROBE
   4602              if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))  /*--mks cfg--*/
   4603              {      
   4604                  destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
   4605                  destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   4606              }
   4607              #endif
   4608          if(MACHINETPYE & IS_KINEMATIC)
   4609          {
   4610              if (position_is_reachable_IS_KINEMATIC(destination[X_AXIS], destination[Y_AXIS])) {
   4611          
   4612                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4613                  if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
   4614                #endif
   4615          
   4616                // This causes the carriage on Dual X to unpark
   4617                #if ENABLED(DUAL_X_CARRIAGE)
   4618                  active_extruder_parked = false;
   4619                #endif
   4620          
   4621                do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
   4622                HOMEAXIS(Z);
   4623              }
   4624              else {
   4625                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   4626                SERIAL_ECHO_START();
   4627                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   4628              }
   4629          }
   4630          else
   4631          {
   4632              if (position_is_reachable_IS_CARTESIAN(destination[X_AXIS], destination[Y_AXIS])) {
   4633          
   4634                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4635                  if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
   4636                #endif
   4637          
   4638                // This causes the carriage on Dual X to unpark
   4639                #if ENABLED(DUAL_X_CARRIAGE)
   4640                  active_extruder_parked = false;
   4641                #endif
   4642          
   4643                do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
   4644                HOMEAXIS(Z);
   4645              }
   4646              else {
   4647                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   4648                SERIAL_ECHO_START();
   4649                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   4650              }    
   4651          }
   4652              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4653                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
   4654              #endif
   4655            }
   4656          
   4657          #endif // Z_SAFE_HOMING
   4658          
   4659          #if ENABLED(PROBE_MANUALLY)
   4660            bool g29_in_progress = false;
   4661          #else
   4662            constexpr bool g29_in_progress = false;
   4663          #endif
   4664          
   4665          /**
   4666           * G28: Home all axes according to settings
   4667           *
   4668           * Parameters
   4669           *
   4670           *  None  Home to all axes with no parameters.
   4671           *        With QUICK_HOME enabled XY will home together, then Z.
   4672           *
   4673           * Cartesian parameters
   4674           *
   4675           *  X   Home to the X endstop
   4676           *  Y   Home to the Y endstop
   4677           *  Z   Home to the Z endstop
   4678           *
   4679           */

   \                                 In section .text, align 4
   4680          inline void gcode_G28(const bool always_home_all) {
   \                     _Z9gcode_G28b: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   4681          
   4682            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4683              if (DEBUGGING(LEVELING)) {
   4684                SERIAL_ECHOLNPGM(">>> gcode_G28");
   4685                log_machine_info();
   4686              }
   4687            #endif
   4688          
   4689            // Wait for planner moves to finish!
   4690            stepper.synchronize();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4691          
   4692            // Cancel the active G29 session
   4693            #if ENABLED(PROBE_MANUALLY)
   4694              g29_in_progress = false;
   4695            #endif
   4696          
   4697            // Disable the leveling matrix before homing
   4698            //#if HAS_LEVELING
   4699            	//const 
   4700            	bool ubl_state_at_entry;
   4701              //#if ENABLED(AUTO_BED_LEVELING_UBL)
   4702              if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \   0000000A   0x4D5E             LDR.N    R5,??gcode_G28_0
   \   0000000C   0xF205 0x003F      ADDW     R0,R5,#+63
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x7840             LDRB     R0,[R0, #+1]
   \   00000014   0x2810             CMP      R0,#+16
   \   00000016   0xD101             BNE.N    ??gcode_G28_1
   4703              {
   4704              	ubl_state_at_entry = planner.leveling_active;
   \   00000018   0x495B             LDR.N    R1,??gcode_G28_0+0x4
   \   0000001A   0x780C             LDRB     R4,[R1, #+0]
   4705              }
   4706              //#endif
   4707              if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??gcode_G28_1: (+1)
   \   0000001C   0x213E             MOVS     R1,#+62
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD002             BEQ.N    ??gcode_G28_2
   4708              {
   4709              	set_bed_leveling_enabled(false);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4710              }
   4711            //#endif
   4712          
   4713            #if ENABLED(CNC_WORKSPACE_PLANES)
   4714              workspace_plane = PLANE_XY;
   4715            #endif
   4716          
   4717            // Always home with tool 0 active
   4718            #if HOTENDS > 1
   4719              const uint8_t old_tool_index = active_extruder;
   \                     ??gcode_G28_2: (+1)
   \   00000028   0x4E58             LDR.N    R6,??gcode_G28_0+0x8
   \   0000002A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000002C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   4720              tool_change(0, 0, true);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x4608             MOV      R0,R1
   \   00000036   0x.... 0x....      BL       _Z11tool_changehfb
   4721            #endif
   4722          
   4723            #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   4724              extruder_duplication_enabled = false;
   4725            #endif
   4726          
   4727            setup_for_endstop_or_probe_move();
   \   0000003A   0x.... 0x....      BL       _Z31setup_for_endstop_or_probe_movev
   4728            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4729              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
   4730            #endif
   4731            endstops.enable(true); // Enable endstops for next homing move
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       _ZN8Endstops6enableEb
   4732          
   4733            //#if ENABLED(DELTA)
   4734            if(MACHINETPYE == DELTA)
   \   00000044   0xF9B5 0x0058      LDRSH    R0,[R5, #+88]
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD102             BNE.N    ??gcode_G28_3
   4735            {
   4736              home_delta();
   \   0000004C   0x.... 0x....      BL       _Z10home_deltav
   4737              UNUSED(always_home_all);
   \   00000050   0xE080             B.N      ??gcode_G28_4
   4738            }
   4739            //#else // NOT DELTA
   4740            else
   4741            {
   4742              const bool homeX = always_home_all || parser.seen('X'),
   \                     ??gcode_G28_3: (+1)
   \   00000052   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000056   0xD104             BNE.N    ??gcode_G28_5
   \   00000058   0x2058             MOVS     R0,#+88
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000005E   0x4683             MOV      R11,R0
   \   00000060   0xE001             B.N      ??gcode_G28_6
   \                     ??gcode_G28_5: (+1)
   \   00000062   0xF04F 0x0B01      MOV      R11,#+1
   4743                         homeY = always_home_all || parser.seen('Y'),
   \                     ??gcode_G28_6: (+1)
   \   00000066   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006A   0xD104             BNE.N    ??gcode_G28_7
   \   0000006C   0x2059             MOVS     R0,#+89
   \   0000006E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000072   0x4607             MOV      R7,R0
   \   00000074   0xE000             B.N      ??gcode_G28_8
   \                     ??gcode_G28_7: (+1)
   \   00000076   0x2701             MOVS     R7,#+1
   4744                         homeZ = always_home_all || parser.seen('Z'),
   \                     ??gcode_G28_8: (+1)
   \   00000078   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000007C   0xD104             BNE.N    ??gcode_G28_9
   \   0000007E   0x205A             MOVS     R0,#+90
   \   00000080   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000084   0x4680             MOV      R8,R0
   \   00000086   0xE001             B.N      ??gcode_G28_10
   \                     ??gcode_G28_9: (+1)
   \   00000088   0xF04F 0x0801      MOV      R8,#+1
   4745                         home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
   \                     ??gcode_G28_10: (+1)
   \   0000008C   0xEA07 0x090B      AND      R9,R7,R11
   \   00000090   0xEA47 0x000B      ORR      R0,R7,R11
   \   00000094   0xEA48 0x0000      ORR      R0,R8,R0
   \   00000098   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000009C   0xEA08 0x0109      AND      R1,R8,R9
   \   000000A0   0xEA41 0x0A00      ORR      R10,R1,R0
   4746          
   4747              set_destination_from_current();
   \   000000A4   0x.... 0x....      BL       _Z28set_destination_from_currentv
   4748          
   4749              //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
   4750          	if(Z_HOME_DIR > 0)
   \   000000A8   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xDB05             BLT.N    ??gcode_G28_11
   4751          	{
   4752                if (home_all || homeZ) {
   \   000000B0   0xEA58 0x000A      ORRS     R0,R8,R10
   \   000000B4   0xD002             BEQ.N    ??gcode_G28_11
   4753                  HOMEAXIS(Z);
   \   000000B6   0x2002             MOVS     R0,#+2
   \   000000B8   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4754                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4755                    if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
   4756                  #endif
   4757                }
   4758          	}
   4759              //#endif
   4760          
   4761              if ((home_all || homeX || homeY) 
   4762                  #if 1
   4763          		&& ((mksReprint.mks_printer_state != MKS_REPRINTING)
   4764          	  	||(mksReprint.mks_printer_state != MKS_REPRINTED))
   4765          	  	#endif
   4766                  )
   \                     ??gcode_G28_11: (+1)
   \   000000BC   0xEA4B 0x0B0A      ORR      R11,R11,R10
   \   000000C0   0xEA57 0x000B      ORRS     R0,R7,R11
   \   000000C4   0xD013             BEQ.N    ??gcode_G28_12
   \   000000C6   0x4832             LDR.N    R0,??gcode_G28_0+0xC
   \   000000C8   0xF890 0x081C      LDRB     R0,[R0, #+2076]
   \   000000CC   0x28AB             CMP      R0,#+171
   \   000000CE   0xD101             BNE.N    ??gcode_G28_13
   \   000000D0   0x28AC             CMP      R0,#+172
   \   000000D2   0xD00C             BEQ.N    ??gcode_G28_12
   4767                {
   4768                // Raise Z before homing any other axes and z is not already high enough (never lower z)
   4769                destination[Z_AXIS] = Z_HOMING_HEIGHT;
   \                     ??gcode_G28_13: (+1)
   \   000000D4   0x492F             LDR.N    R1,??gcode_G28_0+0x10  ;; 0x40a00000
   \   000000D6   0x6231             STR      R1,[R6, #+32]
   4770                if (destination[Z_AXIS] > current_position[Z_AXIS]) {
   \   000000D8   0x6930             LDR      R0,[R6, #+16]
   \   000000DA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000DE   0xD206             BCS.N    ??gcode_G28_12
   4771          
   4772                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4773                    if (DEBUGGING(LEVELING))
   4774                      SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
   4775                  #endif
   4776          
   4777                  do_blocking_move_to_z(destination[Z_AXIS]);
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x9001             STR      R0,[SP, #+4]
   \   000000E4   0xA901             ADD      R1,SP,#+4
   \   000000E6   0xF106 0x0020      ADD      R0,R6,#+32
   \   000000EA   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   4778                }
   4779              }
   4780          
   4781              //#if ENABLED(QUICK_HOME)
   4782          	if(MACHINETPYE&IS_SCARA)
   \                     ??gcode_G28_12: (+1)
   \   000000EE   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   000000F2   0xF44F 0x7140      MOV      R1,#+768
   \   000000F6   0x4208             TST      R0,R1
   \   000000F8   0xD004             BEQ.N    ??gcode_G28_14
   4783          	{
   4784                if (home_all || (homeX && homeY)) quick_home_xy();
   \   000000FA   0xEA59 0x000A      ORRS     R0,R9,R10
   \   000000FE   0xD001             BEQ.N    ??gcode_G28_14
   \   00000100   0x.... 0x....      BL       _Z13quick_home_xyv
   4785          	}
   4786              //#endif
   4787          
   4788              //#if ENABLED(HOME_Y_BEFORE_X)
   4789          	if(MACHINETPYE&IS_SCARA)
   \                     ??gcode_G28_14: (+1)
   \   00000104   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   00000108   0xF44F 0x7140      MOV      R1,#+768
   \   0000010C   0x4208             TST      R0,R1
   \   0000010E   0xD005             BEQ.N    ??gcode_G28_15
   4790          	{
   4791                // Home Y
   4792                if (home_all || homeY) {
   \   00000110   0xEA57 0x000A      ORRS     R0,R7,R10
   \   00000114   0xD002             BEQ.N    ??gcode_G28_15
   4793                  HOMEAXIS(Y);
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4794                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4795                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4796                  #endif
   4797                }
   4798          	}
   4799              //#endif
   4800          
   4801              // Home X
   4802              if (home_all || homeX) {
   \                     ??gcode_G28_15: (+1)
   \   0000011C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000120   0xD002             BEQ.N    ??gcode_G28_16
   4803          
   4804                #if ENABLED(DUAL_X_CARRIAGE)
   4805          
   4806                  // Always home the 2nd (right) extruder first
   4807                  active_extruder = 1;
   4808                  HOMEAXIS(X);
   4809          
   4810                  // Remember this extruder's position for later tool change
   4811                  inactive_extruder_x_pos = current_position[X_AXIS];
   4812          
   4813                  // Home the 1st (left) extruder
   4814                  active_extruder = 0;
   4815                  HOMEAXIS(X);
   4816          
   4817                  // Consider the active extruder to be parked
   4818                  COPY(raised_parked_position, current_position);
   4819                  delayed_move_time = 0;
   4820                  active_extruder_parked = true;
   4821          
   4822                #else
   4823          
   4824                  HOMEAXIS(X);
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4825          
   4826                #endif
   4827          
   4828                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4829                  if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
   4830                #endif
   4831              }
   4832          
   4833              //#if DISABLED(HOME_Y_BEFORE_X)
   4834          	if(!HOME_Y_BEFORE_X)
   \                     ??gcode_G28_16: (+1)
   \   00000128   0xF895 0x003F      LDRB     R0,[R5, #+63]
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD105             BNE.N    ??gcode_G28_17
   4835          	{
   4836                // Home Y
   4837                if (home_all || homeY) {
   \   00000130   0xEA57 0x000A      ORRS     R0,R7,R10
   \   00000134   0xD002             BEQ.N    ??gcode_G28_17
   4838                  HOMEAXIS(Y);
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4839                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4840                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4841                  #endif
   4842                }
   4843          	}
   4844              //#endif
   4845          
   4846              // Home Z last if homing towards the bed
   4847              //#if Z_HOME_DIR < 0
   4848              if(Z_HOME_DIR < 0)
   \                     ??gcode_G28_17: (+1)
   \   0000013C   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD505             BPL.N    ??gcode_G28_18
   4849              {
   4850                if (home_all || homeZ) {
   \   00000144   0xEA58 0x000A      ORRS     R0,R8,R10
   \   00000148   0xD002             BEQ.N    ??gcode_G28_18
   4851                  #if ENABLED(Z_SAFE_HOMING)
   4852                    home_z_safely();
   4853                  #else
   4854                    HOMEAXIS(Z);
   \   0000014A   0x2002             MOVS     R0,#+2
   \   0000014C   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4855                  #endif
   4856                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4857                    if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
   4858                  #endif
   4859                } // home_all || homeZ
   4860              }
   4861              //#endif // Z_HOME_DIR < 0
   4862          
   4863              SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??gcode_G28_18: (+1)
   \   00000150   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   4864          
   4865          	//if(home_all)
   4866          	  //{
   4867          	  	//Z÷·…œ…˝
   4868          		//mks_home_moveZ(5);
   4869          	      //“∆∂ØX,Y
   4870          		//mks_home_moveXY(mksReprint.mks_zero_x,mksReprint.mks_zero_y,mksCfg.homing_feedrate_xy);
   4871          		  //mks_home_moveZ(0);
   4872          		  //SYNC_PLAN_POSITION_KINEMATIC();
   4873          	  //}
   4874          }
   4875            //#endif // !DELTA (gcode_G28)
   4876          
   4877            endstops.not_homing();
   \                     ??gcode_G28_4: (+1)
   \   00000154   0x.... 0x....      BL       _ZN8Endstops10not_homingEv
   4878          
   4879            #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
   4880              // move to a height where we can use the full xy-area
   4881              do_blocking_move_to_z(delta_clip_start_height);
   4882            #endif
   4883          
   4884            //#if ENABLED(AUTO_BED_LEVELING_UBL)
   4885            if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   \   0000015A   0x7840             LDRB     R0,[R0, #+1]
   \   0000015C   0x2810             CMP      R0,#+16
   \   0000015E   0xD103             BNE.N    ??gcode_G28_19
   4886              set_bed_leveling_enabled(ubl_state_at_entry);
   \   00000160   0x4620             MOV      R0,R4
   \   00000162   0xB2C0             UXTB     R0,R0
   \   00000164   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4887            //#endif
   4888          
   4889            clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G28_19: (+1)
   \   00000168   0x.... 0x....      BL       _Z36clean_up_after_endstop_or_probe_movev
   4890          
   4891            // Restore the active tool after homing
   4892            #if HOTENDS > 1
   4893              #if ENABLED(PARKING_EXTRUDER)
   4894                #define NO_FETCH false // fetch the previous toolhead
   4895              #else
   4896                #define NO_FETCH true
   4897              #endif
   4898              tool_change(old_tool_index, 0, NO_FETCH);
   \   0000016C   0x2201             MOVS     R2,#+1
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000174   0x.... 0x....      BL       _Z11tool_changehfb
   4899            #endif
   4900          
   4901            lcd_refresh();
   \   00000178   0x.... 0x....      BL       _Z11lcd_refreshv
   4902          
   4903            report_current_position();
   \   0000017C   0x.... 0x....      BL       _Z23report_current_positionv
   4904          
   4905            #if ENABLED(NANODLP_Z_SYNC)
   4906              #if ENABLED(NANODLP_ALL_AXIS)
   4907                #define _HOME_SYNC true                 // For any axis, output sync text.
   4908              #else
   4909                #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
   4910              #endif
   4911              if (_HOME_SYNC)
   4912                SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4913            #endif
   4914          
   4915            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4916              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
   4917            #endif
   4918          
   4919            
   4920          } // G28
   \   00000180   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??gcode_G28_0:
   \   00000184   0x........         DC32     mksCfg
   \   00000188   0x........         DC32     _ZN7Planner15leveling_activeE
   \   0000018C   0x........         DC32     mks_heating_busy
   \   00000190   0x........         DC32     card
   \   00000194   0x40A00000         DC32     0x40a00000
   4921          

   \                                 In section .text, align 2, keep-with-next
   4922          void home_all_axes() { gcode_G28(true); }
   \                     _Z13home_all_axesv: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _Z9gcode_G28b
   4923          
   4924          #if HAS_PROBING_PROCEDURE
   4925          

   \                                 In section .text, align 2, keep-with-next
   4926            void out_of_range_error(const char* p_edge) {
   \                     _Z18out_of_range_errorPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4927              SERIAL_PROTOCOLPGM("?Probe ");
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "?Probe ">`
   \   00000008   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4928              serialprintPGM(p_edge);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4929              SERIAL_PROTOCOLLNPGM(" position out of range.");
   \   00000012   0x.... 0x....      ADR.W    R0,`?<Constant " position out of range.\\n">`
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   4930            }
   4931          
   4932          #endif
   4933          
   4934          #if 1//ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
   4935          
   4936            #if ENABLED(LCD_BED_LEVELING)
   4937              //extern 
   4938              bool lcd_wait_for_move;
   4939            #else
   4940              constexpr bool lcd_wait_for_move = false;
   4941            #endif
   4942          

   \                                 In section .text, align 4
   4943            inline void _manual_goto_xy(const float &rx, const float &ry) {
   \                     _Z15_manual_goto_xyRKfS0_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   4944          
   4945              //#if MANUAL_PROBE_HEIGHT > 0
   4946              if(MANUAL_PROBE_HEIGHT > 0)
   \   00000008   0x4E13             LDR.N    R6,??_manual_goto_xy_0
   \   0000000A   0x4A14             LDR.N    R2,??_manual_goto_xy_0+0x4
   \   0000000C   0x6E90             LDR      R0,[R2, #+104]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000014   0xD210             BCS.N    ??_manual_goto_xy_1
   4947              {
   4948                const float prev_z = current_position[Z_AXIS];
   \   00000016   0x6930             LDR      R0,[R6, #+16]
   \   00000018   0x9002             STR      R0,[SP, #+8]
   4949                do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0xAB01             ADD      R3,SP,#+4
   \   00000020   0x3268             ADDS     R2,R2,#+104
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
   4950                do_blocking_move_to_z(prev_z);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0xA802             ADD      R0,SP,#+8
   \   00000032   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   00000036   0xE006             B.N      ??_manual_goto_xy_2
   4951              }
   4952              //#else
   4953              else
   4954              {
   4955                do_blocking_move_to_xy(rx, ry);
   \                     ??_manual_goto_xy_1: (+1)
   \   00000038   0x4608             MOV      R0,R1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xAA00             ADD      R2,SP,#+0
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       _Z22do_blocking_move_to_xyRKfS0_S0_
   4956              }
   4957              //#endif
   4958          
   4959              current_position[X_AXIS] = rx;
   \                     ??_manual_goto_xy_2: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x60B0             STR      R0,[R6, #+8]
   4960              current_position[Y_AXIS] = ry;
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x60F0             STR      R0,[R6, #+12]
   4961          
   4962              #if ENABLED(LCD_BED_LEVELING)
   4963                lcd_wait_for_move = false;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x4903             LDR.N    R1,??_manual_goto_xy_0+0x8
   \   00000052   0x7248             STRB     R0,[R1, #+9]
   4964              #endif
   4965            }
   \   00000054   0xBD7F             POP      {R0-R6,PC}       ;; return
   \   00000056   0xBF00             Nop      
   \                     ??_manual_goto_xy_0:
   \   00000058   0x........         DC32     mks_heating_busy
   \   0000005C   0x........         DC32     mksCfg
   \   00000060   0x........         DC32     axis_homed
   4966          
   4967          #endif
   4968          
   4969          #if 1//ENABLED(MESH_BED_LEVELING)
   4970          
   4971            // Save 130 bytes with non-duplication of PSTR

   \                                 In section .text, align 2, keep-with-next
   4972            void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
   \                     _Z16echo_not_enteredv: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,`?<Constant " not entered.\\n">`
   \   00000004   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   4973          

   \                                 In section .text, align 2, keep-with-next
   4974            void mbl_mesh_report() {
   \                     _Z15mbl_mesh_reportv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   4975              //SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
   4976              SERIAL_PROTOCOLPGM("Num X,Y: ");
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "Num X,Y: ">`
   \   00000008   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4977              SERIAL_PROTOCOL((int)GRID_MAX_POINTS_X);
   \   0000000C   0x....             LDR.N    R4,??DataTable156_2
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable160
   \   00000012   0x220A             MOVS     R2,#+10
   \   00000014   0xF895 0x1060      LDRB     R1,[R5, #+96]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN5Print5printEii
   4978              SERIAL_PROTOCOLCHAR(',');
   \   0000001E   0x212C             MOVS     R1,#+44
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   4979              SERIAL_PROTOCOL((int)GRID_MAX_POINTS_Y);
   \   00000026   0xF105 0x0660      ADD      R6,R5,#+96
   \   0000002A   0x220A             MOVS     R2,#+10
   \   0000002C   0x7871             LDRB     R1,[R6, #+1]
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       _ZN5Print5printEii
   4980              SERIAL_EOL();
   \   00000034   0x210A             MOVS     R1,#+10
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   4981              SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
   \   0000003C   0x.... 0x....      ADR.W    R0,`?<Constant "Z offset: ">`
   \   00000040   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable161
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0x460B             MOV      R3,R1
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       _ZN5Print5printEdi
   4982              SERIAL_PROTOCOLLNPGM("\nMeasured points:");
   \   0000005C   0x.... 0x....      ADR.W    R0,`?<Constant "\\nMeasured points:\\n">`
   \   00000060   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4983          	/*
   4984              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
   4985                [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
   4986              );
   4987              */
   4988              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,2);
   \   00000064   0x2302             MOVS     R3,#+2
   \   00000066   0x2205             MOVS     R2,#+5
   \   00000068   0x7871             LDRB     R1,[R6, #+1]
   \   0000006A   0xF895 0x0060      LDRB     R0,[R5, #+96]
   \   0000006E   0xB002             ADD      SP,SP,#+8
   \   00000070   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000074   0x.... 0x....      B.W      _Z14print_2d_arrayhhhh
   4989            }
   4990          
   4991            /**
   4992             * G29: Mesh-based Z probe, probes a grid and produces a
   4993             *      mesh to compensate for variable bed height
   4994             *
   4995             * Parameters With MESH_BED_LEVELING:
   4996             *
   4997             *  S0              Produce a mesh report
   4998             *  S1              Start probing mesh points
   4999             *  S2              Probe the next mesh point
   5000             *  S3 Xn Yn Zn.nn  Manually modify a single point
   5001             *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
   5002             *  S5              Reset and disable mesh
   5003             *
   5004             * The S0 report the points as below
   5005             *
   5006             *  +----> X-axis  1-n
   5007             *  |
   5008             *  |
   5009             *  v Y-axis  1-n
   5010             *
   5011             */
   5012          //  inline void gcode_G29() {

   \                                 In section .text, align 4
   5013          inline void gcode_G29_MESH_BED_LEVELING() {
   \                     _Z27gcode_G29_MESH_BED_LEVELINGv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   5014          
   5015              static int mbl_probe_index = -1;
   5016              #if HAS_SOFTWARE_ENDSTOPS
   5017                static bool enable_soft_endstops;
   5018              #endif
   5019          
   5020              const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2053             MOVS     R0,#+83
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   0000000E   0x4604             MOV      R4,R0
   \   00000010   0xB264             SXTB     R4,R4
   5021              if (!WITHIN(state, 0, 5)) {
   \   00000012   0x2C06             CMP      R4,#+6
   \   00000014   0xD303             BCC.N    ??gcode_G29_MESH_BED_LEVELING_1
   5022                SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
   \   00000016   0x4888             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5023                return;
   \   0000001C   0xE10A             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5024              }
   5025          
   5026              int8_t px, py;
   5027          
   5028              switch (state) {
   \                     ??gcode_G29_MESH_BED_LEVELING_1: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xF200 0x80E5      BHI.W    ??gcode_G29_MESH_BED_LEVELING_4
   \   00000026   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_G29_MESH_BED_LEVELING_0:
   \   0000002A   0x03 0x1C          DC8      0x3,0x1C,0x2B,0x7F
   \              0x2B 0x7F    
   \   0000002E   0xD0 0xE1          DC8      0xD0,0xE1
   5029                case MeshReport:
   5030                  if (leveling_is_valid()) {
   \                     ??gcode_G29_MESH_BED_LEVELING_5: (+1)
   \   00000030   0x.... 0x....      BL       _Z17leveling_is_validv
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD010             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_6
   5031                    SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
   \   00000038   0x4880             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x4
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_7
   \   00000040   0x497F             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x8
   \   00000042   0xE000             B.N      ??gcode_G29_MESH_BED_LEVELING_8
   \                     ??gcode_G29_MESH_BED_LEVELING_7: (+1)
   \   00000044   0x497F             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0xC
   \                     ??gcode_G29_MESH_BED_LEVELING_8: (+1)
   \   00000046   0x4880             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x10
   \   00000048   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   0000004C   0x210A             MOVS     R1,#+10
   \   0000004E   0x487F             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   00000050   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5032                    mbl_mesh_report();
   \   00000054   0x.... 0x....      BL       _Z15mbl_mesh_reportv
   \   00000058   0xE0CA             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5033                  }
   5034                  else
   5035                    SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
   \                     ??gcode_G29_MESH_BED_LEVELING_6: (+1)
   \   0000005A   0x487D             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x18
   \   0000005C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000060   0xE0C6             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5036                  break;
   5037          
   5038                case MeshStart:
   5039                  mbl.reset();
   \                     ??gcode_G29_MESH_BED_LEVELING_9: (+1)
   \   00000062   0x.... 0x....      BL       _ZN17mesh_bed_leveling5resetEv
   5040                  mbl_probe_index = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x497A             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x1C
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   5041                  enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
   \   0000006C   0x487A             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x20
   \   0000006E   0x7A40             LDRB     R0,[R0, #+9]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_10
   \   00000074   0x4879             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x24
   \   00000076   0xE000             B.N      ??gcode_G29_MESH_BED_LEVELING_11
   \                     ??gcode_G29_MESH_BED_LEVELING_10: (+1)
   \   00000078   0x4879             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x28
   \                     ??gcode_G29_MESH_BED_LEVELING_11: (+1)
   \   0000007A   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
   5042                  break;
   \   0000007E   0xE0B7             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5043          
   5044                case MeshNext:
   5045                  if (mbl_probe_index < 0) {
   \                     ??gcode_G29_MESH_BED_LEVELING_12: (+1)
   \   00000080   0x4D74             LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD503             BPL.N    ??gcode_G29_MESH_BED_LEVELING_13
   5046                    SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
   \   00000088   0x4876             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x2C
   \   0000008A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5047                    return;
   \   0000008E   0xE0D1             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5048                  }
   5049                  // For each G29 S2...
   5050                  if (mbl_probe_index == 0) {
   \                     ??gcode_G29_MESH_BED_LEVELING_13: (+1)
   \   00000090   0x4E75             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x30
   \   00000092   0x4F71             LDR.N    R7,??gcode_G29_MESH_BED_LEVELING_2+0x20
   \   00000094   0xD102             BNE.N    ??gcode_G29_MESH_BED_LEVELING_14
   5051                    #if HAS_SOFTWARE_ENDSTOPS
   5052                      // For the initial G29 S2 save software endstop state
   5053                      enable_soft_endstops = soft_endstops_enabled;
   \   00000096   0x7A38             LDRB     R0,[R7, #+8]
   \   00000098   0x7030             STRB     R0,[R6, #+0]
   \   0000009A   0xE006             B.N      ??gcode_G29_MESH_BED_LEVELING_15
   5054                    #endif
   5055                  }
   5056                  else {
   5057                    // For G29 S2 after adjusting Z.
   5058                    mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
   \                     ??gcode_G29_MESH_BED_LEVELING_14: (+1)
   \   0000009C   0x4973             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x34
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   \   000000A0   0xB240             SXTB     R0,R0
   \   000000A2   0x.... 0x....      BL       _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
   5059                    #if HAS_SOFTWARE_ENDSTOPS
   5060                      soft_endstops_enabled = enable_soft_endstops;
   \   000000A6   0x7830             LDRB     R0,[R6, #+0]
   \   000000A8   0x7238             STRB     R0,[R7, #+8]
   5061                    #endif
   5062                  }
   5063                  // If there's another point to sample, move there with optional lift.
   5064                  if (mbl_probe_index < GRID_MAX_POINTS) {
   \                     ??gcode_G29_MESH_BED_LEVELING_15: (+1)
   \   000000AA   0x6828             LDR      R0,[R5, #+0]
   \   000000AC   0x4E70             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
   \   000000AE   0xF106 0x0860      ADD      R8,R6,#+96
   \   000000B2   0xF896 0x1060      LDRB     R1,[R6, #+96]
   \   000000B6   0xF898 0x2001      LDRB     R2,[R8, #+1]
   \   000000BA   0x4351             MULS     R1,R2,R1
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xDA17             BGE.N    ??gcode_G29_MESH_BED_LEVELING_16
   5065                    mbl.zigzag(mbl_probe_index, px, py);
   \   000000C0   0xAA00             ADD      R2,SP,#+0
   \   000000C2   0xF10D 0x0101      ADD      R1,SP,#+1
   \   000000C6   0xB240             SXTB     R0,R0
   \   000000C8   0x.... 0x....      BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
   5066                    _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
   \   000000CC   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   000000D0   0x4968             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x3C
   \   000000D2   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   000000D6   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \   000000DA   0x4A67             LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x40
   \   000000DC   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   000000E0   0x.... 0x....      BL       _Z15_manual_goto_xyRKfS0_
   5067          
   5068                    #if HAS_SOFTWARE_ENDSTOPS
   5069                      // Disable software endstops to allow manual adjustment
   5070                      // If G29 is not completed, they will not be re-enabled
   5071                      soft_endstops_enabled = false;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x7238             STRB     R0,[R7, #+8]
   5072                    #endif
   5073          
   5074                    mbl_probe_index++;
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
   \   000000EC   0x6028             STR      R0,[R5, #+0]
   \   000000EE   0xE07F             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5075                  }
   5076                  else {
   5077                    // One last "return to the bed" (as originally coded) at completion
   5078                    current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
   \                     ??gcode_G29_MESH_BED_LEVELING_16: (+1)
   \   000000F0   0x6930             LDR      R0,[R6, #+16]
   \   000000F2   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \   000000F6   0x.... 0x....      BL       __aeabi_fadd
   \   000000FA   0x4960             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x44
   \   000000FC   0x6108             STR      R0,[R1, #+16]
   5079                    buffer_line_to_current_position();
   \   000000FE   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   5080                    stepper.synchronize();
   \   00000102   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   5081          
   5082                    // After recording the last point, activate home and activate
   5083                    mbl_probe_index = -1;
   \   00000106   0xF04F 0x30FF      MOV      R0,#-1
   \   0000010A   0x6028             STR      R0,[R5, #+0]
   5084                    SERIAL_PROTOCOLLNPGM("Mesh probing done.");
   \   0000010C   0x485C             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x48
   \   0000010E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5085                    BUZZ(100, 659);
   5086                    BUZZ(100, 698);
   5087                    mbl.has_mesh = true;
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x495B             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x4C
   \   00000116   0x7008             STRB     R0,[R1, #+0]
   5088          
   5089                    home_all_axes();
   \   00000118   0x.... 0x....      BL       _Z13home_all_axesv
   5090                    set_bed_leveling_enabled(true);
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5091          
   5092                    #if ENABLED(MESH_G28_REST_ORIGIN)
   5093                      current_position[Z_AXIS] = Z_MIN_POS;
   5094                      set_destination_from_current();
   5095                      buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
   5096                      stepper.synchronize();
   5097                    #endif
   5098          
   5099                    #if ENABLED(LCD_BED_LEVELING)
   5100                      lcd_wait_for_move = false;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x7278             STRB     R0,[R7, #+9]
   \   00000126   0xE063             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5101                    #endif
   5102                  }
   5103                  break;
   5104          
   5105                case MeshSet:
   5106                  if (parser.seenval('X')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_17: (+1)
   \   00000128   0x2058             MOVS     R0,#+88
   \   0000012A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD01E             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_18
   5107                    px = parser.value_int() - 1;
   \   00000132   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000136   0x1E40             SUBS     R0,R0,#+1
   \   00000138   0xF88D 0x0001      STRB     R0,[SP, #+1]
   5108                    if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
   \   0000013C   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD405             BMI.N    ??gcode_G29_MESH_BED_LEVELING_19
   \   00000144   0x4E4A             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
   \   00000146   0xF896 0x1060      LDRB     R1,[R6, #+96]
   \   0000014A   0x1E49             SUBS     R1,R1,#+1
   \   0000014C   0x4281             CMP      R1,R0
   \   0000014E   0xDA03             BGE.N    ??gcode_G29_MESH_BED_LEVELING_20
   5109                      SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
   \                     ??gcode_G29_MESH_BED_LEVELING_19: (+1)
   \   00000150   0x484D             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x50
   \   00000152   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5110                      return;
   \   00000156   0xE06D             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5111                    }
   5112                  }
   5113                  else {
   5114                    SERIAL_CHAR('X'); echo_not_entered();
   5115                    return;
   5116                  }
   5117          
   5118                  if (parser.seenval('Y')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_20: (+1)
   \   00000158   0x2059             MOVS     R0,#+89
   \   0000015A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD10D             BNE.N    ??gcode_G29_MESH_BED_LEVELING_21
   5119                    py = parser.value_int() - 1;
   5120                    if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
   5121                      SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
   5122                      return;
   5123                    }
   5124                  }
   5125                  else {
   5126                    SERIAL_CHAR('Y'); echo_not_entered();
   \   00000162   0x2159             MOVS     R1,#+89
   \   00000164   0x4839             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   00000166   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000016A   0x.... 0x....      BL       _Z16echo_not_enteredv
   5127                    return;
   \   0000016E   0xE061             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5128                  }
   \                     ??gcode_G29_MESH_BED_LEVELING_18: (+1)
   \   00000170   0x2158             MOVS     R1,#+88
   \   00000172   0x4836             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   00000174   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000178   0x.... 0x....      BL       _Z16echo_not_enteredv
   \   0000017C   0xE05A             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   \                     ??gcode_G29_MESH_BED_LEVELING_21: (+1)
   \   0000017E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000182   0x1E40             SUBS     R0,R0,#+1
   \   00000184   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000188   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD405             BMI.N    ??gcode_G29_MESH_BED_LEVELING_22
   \   00000190   0xF106 0x0160      ADD      R1,R6,#+96
   \   00000194   0x7849             LDRB     R1,[R1, #+1]
   \   00000196   0x1E49             SUBS     R1,R1,#+1
   \   00000198   0x4281             CMP      R1,R0
   \   0000019A   0xDA03             BGE.N    ??gcode_G29_MESH_BED_LEVELING_23
   \                     ??gcode_G29_MESH_BED_LEVELING_22: (+1)
   \   0000019C   0x483B             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x54
   \   0000019E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000001A2   0xE047             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5129          
   5130                  if (parser.seenval('Z'))
   \                     ??gcode_G29_MESH_BED_LEVELING_23: (+1)
   \   000001A4   0x205A             MOVS     R0,#+90
   \   000001A6   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD017             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
   5131                    mbl.z_values[px][py] = parser.value_linear_units();
   \   000001AE   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000001B2   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   000001B6   0xF99D 0x2001      LDRSB    R2,[SP, #+1]
   \   000001BA   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \   000001BE   0x4A34             LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x58
   \   000001C0   0xEB02 0x1203      ADD      R2,R2,R3, LSL #+4
   \   000001C4   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   5132                  else {
   5133                    SERIAL_CHAR('Z'); echo_not_entered();
   5134                    return;
   5135                  }
   5136                  break;
   \   000001C8   0xE012             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5137          
   5138                case MeshSetZOffset:
   5139                  if (parser.seenval('Z'))
   \                     ??gcode_G29_MESH_BED_LEVELING_25: (+1)
   \   000001CA   0x205A             MOVS     R0,#+90
   \   000001CC   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD004             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
   5140                    mbl.z_offset = parser.value_linear_units();
   \   000001D4   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000001D8   0x492E             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x5C
   \   000001DA   0x6008             STR      R0,[R1, #+0]
   5141                  else {
   5142                    SERIAL_CHAR('Z'); echo_not_entered();
   5143                    return;
   5144                  }
   5145                  break;
   \   000001DC   0xE008             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   \                     ??gcode_G29_MESH_BED_LEVELING_24: (+1)
   \   000001DE   0x215A             MOVS     R1,#+90
   \   000001E0   0x481A             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   000001E2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000001E6   0x.... 0x....      BL       _Z16echo_not_enteredv
   \   000001EA   0xE023             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5146          
   5147                case MeshReset:
   5148                  reset_bed_level();
   \                     ??gcode_G29_MESH_BED_LEVELING_26: (+1)
   \   000001EC   0x.... 0x....      BL       _Z15reset_bed_levelv
   5149                  break;
   5150          
   5151              } // switch(state)
   5152          
   5153              if (state == MeshStart || state == MeshNext) {
   \                     ??gcode_G29_MESH_BED_LEVELING_4: (+1)
   \   000001F0   0x2C01             CMP      R4,#+1
   \   000001F2   0xD001             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_27
   \   000001F4   0x2C02             CMP      R4,#+2
   \   000001F6   0xD11B             BNE.N    ??gcode_G29_MESH_BED_LEVELING_28
   5154                SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
   \                     ??gcode_G29_MESH_BED_LEVELING_27: (+1)
   \   000001F8   0x4E1D             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
   \   000001FA   0xF106 0x0860      ADD      R8,R6,#+96
   \   000001FE   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000202   0xF898 0x1001      LDRB     R1,[R8, #+1]
   \   00000206   0x4341             MULS     R1,R1,R0
   \   00000208   0x4D12             LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
   \   0000020A   0x6828             LDR      R0,[R5, #+0]
   \   0000020C   0x4288             CMP      R0,R1
   \   0000020E   0xDA00             BGE.N    ??gcode_G29_MESH_BED_LEVELING_29
   \   00000210   0x4601             MOV      R1,R0
   \                     ??gcode_G29_MESH_BED_LEVELING_29: (+1)
   \   00000212   0x4821             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x60
   \   00000214   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   5155                SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
   \   00000218   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   0000021C   0xF898 0x1001      LDRB     R1,[R8, #+1]
   \   00000220   0x4341             MULS     R1,R1,R0
   \   00000222   0x481E             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x64
   \   00000224   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000228   0x210A             MOVS     R1,#+10
   \   0000022A   0x4808             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   0000022C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5156              }
   5157          
   5158              report_current_position();
   \                     ??gcode_G29_MESH_BED_LEVELING_28: (+1)
   \   00000230   0x.... 0x....      BL       _Z23report_current_positionv
   5159            }
   \                     ??gcode_G29_MESH_BED_LEVELING_3: (+1)
   \   00000234   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   \                     ??gcode_G29_MESH_BED_LEVELING_2:
   \   00000238   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
   \   0000023C   0x........         DC32     _ZN7Planner15leveling_activeE
   \   00000240   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
   \   00000244   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
   \   00000248   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
   \   0000024C   0x........         DC32     Serial3
   \   00000250   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
   \   00000254   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
   \   00000258   0x........         DC32     axis_homed
   \   0000025C   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
   \   00000260   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
   \   00000264   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
   \   00000268   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
   \   0000026C   0x........         DC32     mks_heating_busy+0x10
   \   00000270   0x........         DC32     mksCfg
   \   00000274   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \   00000278   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \   0000027C   0x........         DC32     mks_heating_busy
   \   00000280   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
   \   00000284   0x........         DC32     _ZN17mesh_bed_leveling8has_meshE
   \   00000288   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
   \   0000028C   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
   \   00000290   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE
   \   00000294   0x........         DC32     _ZN17mesh_bed_leveling8z_offsetE
   \   00000298   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
   \   0000029C   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
   5160          #endif
   5161          //#if 1
   5162          //#elif OLDSCHOOL_ABL
   5163          
   5164            #if 1//ABL_GRID
   5165              #if ENABLED(PROBE_Y_FIRST)
   5166                #define PR_OUTER_VAR xCount
   5167                #define PR_OUTER_END abl_grid_points_x
   5168                #define PR_INNER_VAR yCount
   5169                #define PR_INNER_END abl_grid_points_y
   5170              #else
   5171                #define PR_OUTER_VAR yCount
   5172                #define PR_OUTER_END abl_grid_points_y
   5173                #define PR_INNER_VAR xCount
   5174                #define PR_INNER_END abl_grid_points_x
   5175              #endif
   5176            #endif
   5177          
   5178            /**
   5179             * G29: Detailed Z probe, probes the bed at 3 or more points.
   5180             *      Will fail if the printer has not been homed with G28.
   5181             *
   5182             * Enhanced G29 Auto Bed Leveling Probe Routine
   5183             *
   5184             *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
   5185             *     or alter the bed level data. Useful to check the topology
   5186             *     after a first run of G29.
   5187             *
   5188             *  J  Jettison current bed leveling data
   5189             *
   5190             *  V  Set the verbose level (0-4). Example: "G29 V3"
   5191             *
   5192             * Parameters With LINEAR leveling only:
   5193             *
   5194             *  P  Set the size of the grid that will be probed (P x P points).
   5195             *     Example: "G29 P4"
   5196             *
   5197             *  X  Set the X size of the grid that will be probed (X x Y points).
   5198             *     Example: "G29 X7 Y5"
   5199             *
   5200             *  Y  Set the Y size of the grid that will be probed (X x Y points).
   5201             *
   5202             *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
   5203             *     This is useful for manual bed leveling and finding flaws in the bed (to
   5204             *     assist with part placement).
   5205             *     Not supported by non-linear delta printer bed leveling.
   5206             *
   5207             * Parameters With LINEAR and BILINEAR leveling only:
   5208             *
   5209             *  S  Set the XY travel speed between probe points (in units/min)
   5210             *
   5211             *  F  Set the Front limit of the probing grid
   5212             *  B  Set the Back limit of the probing grid
   5213             *  L  Set the Left limit of the probing grid
   5214             *  R  Set the Right limit of the probing grid
   5215             *
   5216             * Parameters with DEBUG_LEVELING_FEATURE only:
   5217             *
   5218             *  C  Make a totally fake grid with no actual probing.
   5219             *     For use in testing when no probing is possible.
   5220             *
   5221             * Parameters with BILINEAR leveling only:
   5222             *
   5223             *  Z  Supply an additional Z probe offset
   5224             *
   5225             * Extra parameters with PROBE_MANUALLY:
   5226             *
   5227             *  To do manual probing simply repeat G29 until the procedure is complete.
   5228             *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
   5229             *
   5230             *  Q  Query leveling and G29 state
   5231             *
   5232             *  A  Abort current leveling procedure
   5233             *
   5234             * Extra parameters with BILINEAR only:
   5235             *
   5236             *  W  Write a mesh point. (If G29 is idle.)
   5237             *  I  X index for mesh point
   5238             *  J  Y index for mesh point
   5239             *  X  X for mesh point, overrides I
   5240             *  Y  Y for mesh point, overrides J
   5241             *  Z  Z for mesh point. Otherwise, raw current Z.
   5242             *
   5243             * Without PROBE_MANUALLY:
   5244             *
   5245             *  E  By default G29 will engage the Z probe, test the bed, then disengage.
   5246             *     Include "E" to engage/disengage the Z probe for each sample.
   5247             *     There's no extra effect if you have a fixed Z probe.
   5248             *
   5249             */

   \                                 In section .text, align 4
   5250            inline void gcode_G29() {
   \                     _Z9gcode_G29v: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xF5AD 0x7D4B      SUB      SP,SP,#+812
   5251          
   5252              // G29 Q is also available if debugging
   5253              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5254                const bool query = parser.seen('Q');
   5255                const uint8_t old_debug_flags = marlin_debug_flags;
   5256                if (query) marlin_debug_flags |= DEBUG_LEVELING;
   5257                if (DEBUGGING(LEVELING)) {
   5258                  DEBUG_POS(">>> G29", current_position);
   5259                  log_machine_info();
   5260                }
   5261                marlin_debug_flags = old_debug_flags;
   5262                #if DISABLED(PROBE_MANUALLY)
   5263                  if (query) return;
   5264                #endif
   5265              #endif
   5266          
   5267              #if ENABLED(PROBE_MANUALLY)
   5268                const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
   5269              #endif
   5270          
   5271              #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
   5272                const bool faux = parser.boolval('C');
   5273              #elif ENABLED(PROBE_MANUALLY)
   5274                const bool faux = no_action;
   5275              #else
   5276                bool constexpr faux = false;
   5277              #endif
   5278          
   5279              // Don't allow auto-leveling without homing first
   5280              if (axis_unhomed_error()) return;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4611             MOV      R1,R2
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       _Z18axis_unhomed_errorbbb
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xF040 0x8673      BNE.W    ??gcode_G29_0
   5281          
   5282              // Define local vars 'static' for manual probing, 'auto' otherwise
   5283              #if ENABLED(PROBE_MANUALLY)
   5284                #define ABL_VAR static
   5285              #else
   5286                #define ABL_VAR
   5287              #endif
   5288          
   5289              ABL_VAR int verbose_level=0;
   5290              ABL_VAR float xProbe=0, yProbe=0, measured_z=0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x900E             STR      R0,[SP, #+56]
   \   0000001C   0x900D             STR      R0,[SP, #+52]
   \   0000001E   0x9009             STR      R0,[SP, #+36]
   5291              ABL_VAR bool dryrun=false, abl_should_enable=false;
   5292          
   5293              //#if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
   5294                ABL_VAR int abl_probe_index=0;
   \   00000020   0x4606             MOV      R6,R0
   5295              //#endif
   5296          
   5297              #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
   5298                ABL_VAR bool enable_soft_endstops = true;
   5299              #endif
   5300          
   5301              #if 1//ABL_GRID
   5302          
   5303                #if ENABLED(PROBE_MANUALLY)
   5304                  ABL_VAR uint8_t PR_OUTER_VAR;
   5305                  ABL_VAR  int8_t PR_INNER_VAR;
   5306                #endif
   5307          
   5308                ABL_VAR int left_probe_bed_position=0, right_probe_bed_position=0, front_probe_bed_position=0, back_probe_bed_position=0;
   \   00000022   0x9005             STR      R0,[SP, #+20]
   \   00000024   0x9002             STR      R0,[SP, #+8]
   5309                ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
   \   00000026   0x9012             STR      R0,[SP, #+72]
   \   00000028   0x9007             STR      R0,[SP, #+28]
   \   0000002A   0xF8DF 0x0CDC      LDR.W    R0,??gcode_G29_1
   \   0000002E   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   00000032   0x900C             STR      R0,[SP, #+48]
   5310          
   5311                //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5312                  ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
   5313                                  abl_grid_points_y = GRID_MAX_POINTS_Y;
   \   00000034   0xF8DF 0x1CD4      LDR.W    R1,??gcode_G29_1+0x4
   \   00000038   0x9108             STR      R1,[SP, #+32]
   \   0000003A   0x7849             LDRB     R1,[R1, #+1]
   \   0000003C   0x9104             STR      R1,[SP, #+16]
   5314                  ABL_VAR bool do_topography_map=0;
   \   0000003E   0x4632             MOV      R2,R6
   \   00000040   0xF88D 0x200C      STRB     R2,[SP, #+12]
   5315                //#else // Bilinear
   5316                //  uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
   5317                //                    abl_grid_points_y = GRID_MAX_POINTS_Y;
   5318                //#endif
   5319          
   5320                //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5321                  ABL_VAR int abl2;
   5322                //#elif ENABLED(PROBE_MANUALLY) // Bilinear
   5323                //  int constexpr abl2 = GRID_MAX_POINTS;
   5324                //#endif
   5325                if(! (BED_LEVELING_METHOD&ABL_PLANAR)) abl2 = GRID_MAX_POINTS;
   \   00000044   0x4348             MULS     R0,R1,R0
   \   00000046   0xF8DF 0x1CC0      LDR.W    R1,??gcode_G29_1
   \   0000004A   0xF891 0x1040      LDRB     R1,[R1, #+64]
   \   0000004E   0x2206             MOVS     R2,#+6
   \   00000050   0x4211             TST      R1,R2
   \   00000052   0xD100             BNE.N    ??gcode_G29_2
   \   00000054   0x9011             STR      R0,[SP, #+68]
   5326          
   5327                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5328          
   5329                  ABL_VAR float zoffset;
   5330          
   5331                //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5332          
   5333                  ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
   5334          
   5335                  ABL_VAR float *eqnAMatrix=NULL,//[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
   5336                                *eqnBVector=NULL,//[GRID_MAX_POINTS],     // "B" vector of Z points
   5337                                mean;
   5338          		eqnAMatrix = (float *)malloc((GRID_MAX_POINTS * 3 + 1) * sizeof(float));
   \                     ??gcode_G29_2: (+1)
   \   00000056   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x0080             LSLS     R0,R0,#+2
   \   0000005E   0x.... 0x....      BL       malloc
   \   00000062   0x900B             STR      R0,[SP, #+44]
   5339          		if(eqnAMatrix == NULL)
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD107             BNE.N    ??gcode_G29_3
   5340          			{
   5341          			Running = false;
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0xF8DF 0x1CA4      LDR.W    R1,??gcode_G29_1+0x8
   \   0000006E   0x7108             STRB     R0,[R1, #+4]
   5342          			kill("malloc eqnAMatrix err!");
   \   00000070   0xF8DF 0x0CA0      LDR.W    R0,??gcode_G29_1+0xC
   \   00000074   0x.... 0x....      BL       _Z4killPKc
   5343          			}
   5344          		for(int i=0;i<GRID_MAX_POINTS * 3 + 1;i++)
   \                     ??gcode_G29_3: (+1)
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0xE004             B.N      ??gcode_G29_4
   5345                      *(eqnAMatrix+i) = 0.0;
   \                     ??gcode_G29_5: (+1)
   \   0000007C   0x4631             MOV      R1,R6
   \   0000007E   0x9A0B             LDR      R2,[SP, #+44]
   \   00000080   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \                     ??gcode_G29_4: (+1)
   \   00000086   0xF8DF 0x1C80      LDR.W    R1,??gcode_G29_1
   \   0000008A   0xF891 0x1060      LDRB     R1,[R1, #+96]
   \   0000008E   0x9A08             LDR      R2,[SP, #+32]
   \   00000090   0x7852             LDRB     R2,[R2, #+1]
   \   00000092   0x4351             MULS     R1,R2,R1
   \   00000094   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000098   0x1C52             ADDS     R2,R2,#+1
   \   0000009A   0x4290             CMP      R0,R2
   \   0000009C   0xDBEE             BLT.N    ??gcode_G29_5
   5346          
   5347          		
   5348          		eqnBVector = (float *)malloc((GRID_MAX_POINTS + 1) * sizeof(float));
   \   0000009E   0x1C48             ADDS     R0,R1,#+1
   \   000000A0   0x0080             LSLS     R0,R0,#+2
   \   000000A2   0x.... 0x....      BL       malloc
   \   000000A6   0x9010             STR      R0,[SP, #+64]
   5349          		if(eqnBVector == NULL)
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD107             BNE.N    ??gcode_G29_6
   5350          		{
   5351          			Running = false;
   \   000000AC   0x4630             MOV      R0,R6
   \   000000AE   0xF8DF 0x1C60      LDR.W    R1,??gcode_G29_1+0x8
   \   000000B2   0x7108             STRB     R0,[R1, #+4]
   5352          			kill("malloc eqnBVector err!");
   \   000000B4   0xF8DF 0x0C60      LDR.W    R0,??gcode_G29_1+0x10
   \   000000B8   0x.... 0x....      BL       _Z4killPKc
   5353          		}
   5354          		for(int i=0;i<GRID_MAX_POINTS + 1;i++) 	*(eqnBVector+i) = 0.0;        
   \                     ??gcode_G29_6: (+1)
   \   000000BC   0x4630             MOV      R0,R6
   \   000000BE   0xE004             B.N      ??gcode_G29_7
   \                     ??gcode_G29_8: (+1)
   \   000000C0   0x4631             MOV      R1,R6
   \   000000C2   0x9A10             LDR      R2,[SP, #+64]
   \   000000C4   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \                     ??gcode_G29_7: (+1)
   \   000000CA   0xF8DF 0x1C3C      LDR.W    R1,??gcode_G29_1
   \   000000CE   0xF891 0x1060      LDRB     R1,[R1, #+96]
   \   000000D2   0x9A08             LDR      R2,[SP, #+32]
   \   000000D4   0x7852             LDRB     R2,[R2, #+1]
   \   000000D6   0x4351             MULS     R1,R2,R1
   \   000000D8   0x1C49             ADDS     R1,R1,#+1
   \   000000DA   0x4288             CMP      R0,R1
   \   000000DC   0xDBF0             BLT.N    ??gcode_G29_8
   5355                //#endif
   5356          
   5357             // #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5358          
   5359                #if ENABLED(PROBE_MANUALLY)
   5360                  int constexpr abl2 = 3; // used to show total points
   5361                #endif
   5362          
   5363                // Probe at 3 arbitrary points
   5364                ABL_VAR vector_3 points[3] = {
   \   000000DE   0x4633             MOV      R3,R6
   \   000000E0   0x9808             LDR      R0,[SP, #+32]
   \   000000E2   0x6C02             LDR      R2,[R0, #+64]
   \   000000E4   0x6BC1             LDR      R1,[R0, #+60]
   \   000000E6   0xA816             ADD      R0,SP,#+88
   \   000000E8   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   000000EC   0x4633             MOV      R3,R6
   \   000000EE   0x9808             LDR      R0,[SP, #+32]
   \   000000F0   0x6C82             LDR      R2,[R0, #+72]
   \   000000F2   0x6C41             LDR      R1,[R0, #+68]
   \   000000F4   0xA819             ADD      R0,SP,#+100
   \   000000F6   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   000000FA   0x4633             MOV      R3,R6
   \   000000FC   0x9808             LDR      R0,[SP, #+32]
   \   000000FE   0x6D02             LDR      R2,[R0, #+80]
   \   00000100   0x6CC1             LDR      R1,[R0, #+76]
   \   00000102   0xA81C             ADD      R0,SP,#+112
   \   00000104   0x.... 0x....      BL       _ZN8vector_3C1Efff
   5365                  vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
   5366                  vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
   5367                  vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
   5368                };
   5369          
   5370             // #endif // AUTO_BED_LEVELING_3POINT
   5371          
   5372              //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5373              struct linear_fit_data lsf_results;
   5374              if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_LINEAR)
   \   00000108   0xF8DF 0x0BFC      LDR.W    R0,??gcode_G29_1
   \   0000010C   0xF890 0x4040      LDRB     R4,[R0, #+64]
   \   00000110   0xF014 0x0504      ANDS     R5,R4,#0x4
   \   00000114   0xD002             BEQ.N    ??gcode_G29_9
   5375              {
   5376                incremental_LSF_reset(&lsf_results);
   \   00000116   0xA82B             ADD      R0,SP,#+172
   \   00000118   0x.... 0x....      BL       _Z21incremental_LSF_resetP15linear_fit_data
   5377              }
   5378              //#endif
   5379          
   5380              /**
   5381               * On the initial G29 fetch command parameters.
   5382               */
   5383              if (!g29_in_progress) {
   5384          #if 0
   5385                #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
   5386                  abl_probe_index = -1;
   5387                #endif
   5388          #else
   5389                if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   \                     ??gcode_G29_9: (+1)
   \   0000011C   0x2D00             CMP      R5,#+0
   \   0000011E   0xD001             BEQ.N    ??gcode_G29_10
   5390                   abl_probe_index = -1;
   \   00000120   0xF04F 0x36FF      MOV      R6,#-1
   \                     ??gcode_G29_10: (+1)
   \   00000124   0xF8DF 0x0BF4      LDR.W    R0,??gcode_G29_1+0x14
   \   00000128   0xF890 0x9000      LDRB     R9,[R0, #+0]
   5391          #endif
   5392                abl_should_enable = planner.leveling_active;
   5393          
   5394                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5395                if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
   \   0000012C   0x2C08             CMP      R4,#+8
   \   0000012E   0xF040 0x80CD      BNE.W    ??gcode_G29_11
   5396          
   5397                  if (parser.seen('W')) {
   \   00000132   0x2057             MOVS     R0,#+87
   \   00000134   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xF000 0x80C7      BEQ.W    ??gcode_G29_11
   5398                    if (!leveling_is_valid()) {
   \   0000013E   0x.... 0x....      BL       _Z17leveling_is_validv
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD109             BNE.N    ??gcode_G29_12
   5399                      SERIAL_ERROR_START();
   \   00000146   0xF8DF 0x0BD8      LDR.W    R0,??gcode_G29_1+0x18
   \   0000014A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5400                      SERIAL_ERRORLNPGM("No bilinear grid");
   \   0000014E   0xF8DF 0x0BD4      LDR.W    R0,??gcode_G29_1+0x1C
   \   00000152   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5401                      return;
   \   00000156   0xF000 0xBDD2      B.W      ??gcode_G29_0
   5402                    }
   5403          
   5404                    const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
   \                     ??gcode_G29_12: (+1)
   \   0000015A   0xF8DF 0x4BCC      LDR.W    R4,??gcode_G29_1+0x20
   \   0000015E   0x205A             MOVS     R0,#+90
   \   00000160   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD006             BEQ.N    ??gcode_G29_13
   \   00000168   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000016C   0x6C21             LDR      R1,[R4, #+64]
   \   0000016E   0x.... 0x....      BL       __aeabi_fsub
   \   00000172   0x4605             MOV      R5,R0
   \   00000174   0xE000             B.N      ??gcode_G29_14
   \                     ??gcode_G29_13: (+1)
   \   00000176   0x6925             LDR      R5,[R4, #+16]
   5405                    if (!WITHIN(rz, -10, 10)) {
   \                     ??gcode_G29_14: (+1)
   \   00000178   0x4628             MOV      R0,R5
   \   0000017A   0xF8DF 0x1BB0      LDR.W    R1,??gcode_G29_1+0x24  ;; 0xc1200000
   \   0000017E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000182   0xD804             BHI.N    ??gcode_G29_15
   \   00000184   0xF8DF 0x1BA8      LDR.W    R1,??gcode_G29_1+0x28  ;; 0x41200001
   \   00000188   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000018C   0xD309             BCC.N    ??gcode_G29_16
   5406                      SERIAL_ERROR_START();
   \                     ??gcode_G29_15: (+1)
   \   0000018E   0xF8DF 0x0B90      LDR.W    R0,??gcode_G29_1+0x18
   \   00000192   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5407                      SERIAL_ERRORLNPGM("Bad Z value");
   \   00000196   0xF8DF 0x0B9C      LDR.W    R0,??gcode_G29_1+0x2C
   \   0000019A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5408                      return;
   \   0000019E   0xF000 0xBDAE      B.W      ??gcode_G29_0
   5409                    }
   5410          
   5411                    const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
   \                     ??gcode_G29_16: (+1)
   \   000001A2   0xF06F 0x4600      MVN      R6,#-2147483648
   \   000001A6   0x4631             MOV      R1,R6
   \   000001A8   0x2058             MOVS     R0,#+88
   \   000001AA   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   000001AE   0x6BA1             LDR      R1,[R4, #+56]
   \   000001B0   0x.... 0x....      BL       __aeabi_fsub
   \   000001B4   0x4680             MOV      R8,R0
   5412                                ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
   \   000001B6   0x4631             MOV      R1,R6
   \   000001B8   0x2059             MOVS     R0,#+89
   \   000001BA   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   000001BE   0x6BE1             LDR      R1,[R4, #+60]
   \   000001C0   0x.... 0x....      BL       __aeabi_fsub
   \   000001C4   0x4606             MOV      R6,R0
   5413                    int8_t i = parser.byteval('I', -1),
   \   000001C6   0x21FF             MOVS     R1,#+255
   \   000001C8   0x2049             MOVS     R0,#+73
   \   000001CA   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   000001CE   0x4607             MOV      R7,R0
   \   000001D0   0xB27F             SXTB     R7,R7
   5414                           j = parser.byteval('J', -1);
   \   000001D2   0x21FF             MOVS     R1,#+255
   \   000001D4   0x204A             MOVS     R0,#+74
   \   000001D6   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   000001DA   0x4604             MOV      R4,R0
   \   000001DC   0xB264             SXTB     R4,R4
   5415          
   5416                    if (!isnan(rx) && !isnan(ry)) {
   \   000001DE   0x4640             MOV      R0,R8
   \   000001E0   0x.... 0x....      BL       __iar_FDtest
   \   000001E4   0x2802             CMP      R0,#+2
   \   000001E6   0xD048             BEQ.N    ??gcode_G29_17
   \   000001E8   0x4630             MOV      R0,R6
   \   000001EA   0x.... 0x....      BL       __iar_FDtest
   \   000001EE   0x2802             CMP      R0,#+2
   \   000001F0   0xD043             BEQ.N    ??gcode_G29_17
   5417                      // Get nearest i / j from rx / ry
   5418                      i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000001F2   0xF8DF 0x4B1C      LDR.W    R4,??gcode_G29_1+0x8
   \   000001F6   0x69A0             LDR      R0,[R4, #+24]
   \   000001F8   0x.... 0x....      BL       __aeabi_i2f
   \   000001FC   0x4601             MOV      R1,R0
   \   000001FE   0x4640             MOV      R0,R8
   \   00000200   0x.... 0x....      BL       __aeabi_fsub
   \   00000204   0x.... 0x....      BL       __aeabi_f2d
   \   00000208   0x2200             MOVS     R2,#+0
   \   0000020A   0x4613             MOV      R3,R2
   \   0000020C   0x.... 0x....      BL       __aeabi_dadd
   \   00000210   0x2200             MOVS     R2,#+0
   \   00000212   0x4613             MOV      R3,R2
   \   00000214   0x.... 0x....      BL       __aeabi_ddiv
   \   00000218   0x.... 0x....      BL       __aeabi_d2iz
   \   0000021C   0x4607             MOV      R7,R0
   \   0000021E   0xB27F             SXTB     R7,R7
   5419                      j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000220   0x69E0             LDR      R0,[R4, #+28]
   \   00000222   0x.... 0x....      BL       __aeabi_i2f
   \   00000226   0x4601             MOV      R1,R0
   \   00000228   0x4630             MOV      R0,R6
   \   0000022A   0x.... 0x....      BL       __aeabi_fsub
   \   0000022E   0x.... 0x....      BL       __aeabi_f2d
   \   00000232   0x2200             MOVS     R2,#+0
   \   00000234   0x4613             MOV      R3,R2
   \   00000236   0x.... 0x....      BL       __aeabi_dadd
   \   0000023A   0x2200             MOVS     R2,#+0
   \   0000023C   0x4613             MOV      R3,R2
   \   0000023E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000242   0x.... 0x....      BL       __aeabi_d2iz
   \   00000246   0x4604             MOV      R4,R0
   \   00000248   0xB264             SXTB     R4,R4
   5420                      i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
   \   0000024A   0x2F00             CMP      R7,#+0
   \   0000024C   0xD501             BPL.N    ??gcode_G29_18
   \   0000024E   0x2700             MOVS     R7,#+0
   \   00000250   0xE007             B.N      ??gcode_G29_19
   \                     ??gcode_G29_18: (+1)
   \   00000252   0xF8DF 0x0AB4      LDR.W    R0,??gcode_G29_1
   \   00000256   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   0000025A   0x1E41             SUBS     R1,R0,#+1
   \   0000025C   0x42B9             CMP      R1,R7
   \   0000025E   0xDA00             BGE.N    ??gcode_G29_19
   \   00000260   0x1E47             SUBS     R7,R0,#+1
   \                     ??gcode_G29_19: (+1)
   \   00000262   0xB27F             SXTB     R7,R7
   5421                      j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
   \   00000264   0x2C00             CMP      R4,#+0
   \   00000266   0xD501             BPL.N    ??gcode_G29_20
   \   00000268   0x2400             MOVS     R4,#+0
   \   0000026A   0xE005             B.N      ??gcode_G29_21
   \                     ??gcode_G29_20: (+1)
   \   0000026C   0x9808             LDR      R0,[SP, #+32]
   \   0000026E   0x7840             LDRB     R0,[R0, #+1]
   \   00000270   0x1E41             SUBS     R1,R0,#+1
   \   00000272   0x42A1             CMP      R1,R4
   \   00000274   0xDA00             BGE.N    ??gcode_G29_21
   \   00000276   0x1E44             SUBS     R4,R0,#+1
   \                     ??gcode_G29_21: (+1)
   \   00000278   0xB264             SXTB     R4,R4
   5422                    }
   5423                    if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
   \                     ??gcode_G29_17: (+1)
   \   0000027A   0x2F00             CMP      R7,#+0
   \   0000027C   0xF100 0x853F      BMI.W    ??gcode_G29_0
   \   00000280   0xF8DF 0x0A84      LDR.W    R0,??gcode_G29_1
   \   00000284   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   00000288   0x1E40             SUBS     R0,R0,#+1
   \   0000028A   0x42B8             CMP      R0,R7
   \   0000028C   0xF2C0 0x8537      BLT.W    ??gcode_G29_0
   \   00000290   0x2C00             CMP      R4,#+0
   \   00000292   0xF100 0x8534      BMI.W    ??gcode_G29_0
   \   00000296   0x9808             LDR      R0,[SP, #+32]
   \   00000298   0x7840             LDRB     R0,[R0, #+1]
   \   0000029A   0x42A0             CMP      R0,R4
   \   0000029C   0xF2C0 0x852F      BLT.W    ??gcode_G29_0
   5424                      set_bed_leveling_enabled(false);
   \   000002A0   0x2000             MOVS     R0,#+0
   \   000002A2   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5425                      z_values[i][j] = rz;
   \   000002A6   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000002AA   0xF8DF 0x1A8C      LDR.W    R1,??gcode_G29_1+0x30
   \   000002AE   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   000002B2   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
   5426                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5427                        bed_level_virt_interpolate();
   5428                      #endif
   5429                      set_bed_leveling_enabled(abl_should_enable);
   \   000002B6   0x4648             MOV      R0,R9
   \   000002B8   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5430                      if (abl_should_enable) report_current_position();
   \   000002BC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002C0   0xF000 0x851D      BEQ.W    ??gcode_G29_0
   \   000002C4   0x.... 0x....      BL       _Z23report_current_positionv
   5431                    }
   5432                    return;
   \   000002C8   0xF000 0xBD19      B.W      ??gcode_G29_0
   5433                  } // parser.seen('W')
   5434                }
   5435                //#endif
   5436          
   5437                // Jettison bed leveling data
   5438                if (parser.seen('J')) {
   \                     ??gcode_G29_11: (+1)
   \   000002CC   0x204A             MOVS     R0,#+74
   \   000002CE   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD003             BEQ.N    ??gcode_G29_22
   5439                  reset_bed_level();
   \   000002D6   0x.... 0x....      BL       _Z15reset_bed_levelv
   5440                  return;
   \   000002DA   0xF000 0xBD10      B.W      ??gcode_G29_0
   5441                }
   5442          
   5443                verbose_level = parser.intval('V');
   \                     ??gcode_G29_22: (+1)
   \   000002DE   0x2100             MOVS     R1,#+0
   \   000002E0   0x2056             MOVS     R0,#+86
   \   000002E2   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   000002E6   0x900A             STR      R0,[SP, #+40]
   5444                if (!WITHIN(verbose_level, 0, 4)) {
   \   000002E8   0x2805             CMP      R0,#+5
   \   000002EA   0xD305             BCC.N    ??gcode_G29_23
   5445                  SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   \   000002EC   0xF8DF 0x0A4C      LDR.W    R0,??gcode_G29_1+0x34
   \   000002F0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5446                  return;
   \   000002F4   0xF000 0xBD03      B.W      ??gcode_G29_0
   5447                }
   5448          
   5449                dryrun = parser.boolval('D')
   5450                  #if ENABLED(PROBE_MANUALLY)
   5451                    || no_action
   5452                  #endif
   5453                ;
   \                     ??gcode_G29_23: (+1)
   \   000002F8   0x2044             MOVS     R0,#+68
   \   000002FA   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   000002FE   0x900F             STR      R0,[SP, #+60]
   5454          
   5455                //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5456                if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   \   00000300   0xF8DF 0x0A04      LDR.W    R0,??gcode_G29_1
   \   00000304   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000308   0x0741             LSLS     R1,R0,#+29
   \   0000030A   0xD53A             BPL.N    ??gcode_G29_24
   5457                  {
   5458                  do_topography_map = verbose_level > 2 || parser.boolval('T');
   \   0000030C   0x980A             LDR      R0,[SP, #+40]
   \   0000030E   0x2803             CMP      R0,#+3
   \   00000310   0xDA05             BGE.N    ??gcode_G29_25
   \   00000312   0x2054             MOVS     R0,#+84
   \   00000314   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000318   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \   0000031C   0xE002             B.N      ??gcode_G29_26
   \                     ??gcode_G29_25: (+1)
   \   0000031E   0x2001             MOVS     R0,#+1
   \   00000320   0xF88D 0x000C      STRB     R0,[SP, #+12]
   5459          
   5460                  // X and Y specify points in each direction, overriding the default
   5461                  // These values may be saved with the completed mesh
   5462                  abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
   \                     ??gcode_G29_26: (+1)
   \   00000324   0xF8DF 0x09E0      LDR.W    R0,??gcode_G29_1
   \   00000328   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   0000032C   0x2058             MOVS     R0,#+88
   \   0000032E   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   00000332   0xB2C0             UXTB     R0,R0
   \   00000334   0x900C             STR      R0,[SP, #+48]
   5463                  abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
   \   00000336   0x9808             LDR      R0,[SP, #+32]
   \   00000338   0x7841             LDRB     R1,[R0, #+1]
   \   0000033A   0x2059             MOVS     R0,#+89
   \   0000033C   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   00000340   0xB2C0             UXTB     R0,R0
   \   00000342   0x9004             STR      R0,[SP, #+16]
   5464                  if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
   \   00000344   0x2050             MOVS     R0,#+80
   \   00000346   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000034A   0x2800             CMP      R0,#+0
   \   0000034C   0xD006             BEQ.N    ??gcode_G29_27
   \   0000034E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000352   0xB2C0             UXTB     R0,R0
   \   00000354   0x9004             STR      R0,[SP, #+16]
   \   00000356   0xA804             ADD      R0,SP,#+16
   \   00000358   0x7800             LDRB     R0,[R0, #+0]
   \   0000035A   0x900C             STR      R0,[SP, #+48]
   5465          
   5466                  if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
   \                     ??gcode_G29_27: (+1)
   \   0000035C   0x980C             LDR      R0,[SP, #+48]
   \   0000035E   0x2802             CMP      R0,#+2
   \   00000360   0xDB02             BLT.N    ??gcode_G29_28
   \   00000362   0x9804             LDR      R0,[SP, #+16]
   \   00000364   0x2802             CMP      R0,#+2
   \   00000366   0xDA05             BGE.N    ??gcode_G29_29
   5467                    SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
   \                     ??gcode_G29_28: (+1)
   \   00000368   0xF8DF 0x09D4      LDR.W    R0,??gcode_G29_1+0x38
   \   0000036C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5468                    return;
   \   00000370   0xF000 0xBCC5      B.W      ??gcode_G29_0
   5469                  }
   5470          
   5471                  abl2 = abl_grid_points_x * abl_grid_points_y;
   \                     ??gcode_G29_29: (+1)
   \   00000374   0x980C             LDR      R0,[SP, #+48]
   \   00000376   0x9904             LDR      R1,[SP, #+16]
   \   00000378   0x4348             MULS     R0,R1,R0
   \   0000037A   0x9011             STR      R0,[SP, #+68]
   5472                  mean = 0;
   \   0000037C   0xF04F 0x0800      MOV      R8,#+0
   \   00000380   0xE006             B.N      ??gcode_G29_30
   5473                  }
   5474                //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5475                else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
   \                     ??gcode_G29_24: (+1)
   \   00000382   0x0700             LSLS     R0,R0,#+28
   \   00000384   0xD504             BPL.N    ??gcode_G29_30
   5476                {
   5477                  zoffset = parser.linearval('Z');
   \   00000386   0x2100             MOVS     R1,#+0
   \   00000388   0x205A             MOVS     R0,#+90
   \   0000038A   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000038E   0x9015             STR      R0,[SP, #+84]
   5478                }
   5479          
   5480                //#endif
   5481          
   5482                //#if ABL_GRID
   5483                if(BED_LEVELING_METHOD&ABL_GRID)  {
   \                     ??gcode_G29_30: (+1)
   \   00000390   0xF8DF 0x0974      LDR.W    R0,??gcode_G29_1
   \   00000394   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000398   0x210C             MOVS     R1,#+12
   \   0000039A   0x4208             TST      R0,R1
   \   0000039C   0xF000 0x80D6      BEQ.W    ??gcode_G29_31
   5484          
   5485                  xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
   \   000003A0   0xF8DF 0x4984      LDR.W    R4,??gcode_G29_1+0x20
   \   000003A4   0x9808             LDR      R0,[SP, #+32]
   \   000003A6   0x6941             LDR      R1,[R0, #+20]
   \   000003A8   0x2053             MOVS     R0,#+83
   \   000003AA   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   000003AE   0xF8DF 0x1994      LDR.W    R1,??gcode_G29_1+0x3C  ;; 0x42700000
   \   000003B2   0x.... 0x....      BL       __aeabi_fdiv
   \   000003B6   0x6760             STR      R0,[R4, #+116]
   5486          
   5487                  left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000003B8   0x204C             MOVS     R0,#+76
   \   000003BA   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000003BE   0x2800             CMP      R0,#+0
   \   000003C0   0xD008             BEQ.N    ??gcode_G29_32
   \   000003C2   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000003C6   0x6BA1             LDR      R1,[R4, #+56]
   \   000003C8   0x.... 0x....      BL       __aeabi_fsub
   \   000003CC   0x.... 0x....      BL       __aeabi_f2iz
   \   000003D0   0x9005             STR      R0,[SP, #+20]
   \   000003D2   0xE004             B.N      ??gcode_G29_33
   \                     ??gcode_G29_32: (+1)
   \   000003D4   0x9808             LDR      R0,[SP, #+32]
   \   000003D6   0x6A80             LDR      R0,[R0, #+40]
   \   000003D8   0x.... 0x....      BL       __aeabi_f2iz
   \   000003DC   0x9005             STR      R0,[SP, #+20]
   5488                  right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_33: (+1)
   \   000003DE   0x2052             MOVS     R0,#+82
   \   000003E0   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000003E4   0x2800             CMP      R0,#+0
   \   000003E6   0xD008             BEQ.N    ??gcode_G29_34
   \   000003E8   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000003EC   0x6BA1             LDR      R1,[R4, #+56]
   \   000003EE   0x.... 0x....      BL       __aeabi_fsub
   \   000003F2   0x.... 0x....      BL       __aeabi_f2iz
   \   000003F6   0x4605             MOV      R5,R0
   \   000003F8   0xE004             B.N      ??gcode_G29_35
   \                     ??gcode_G29_34: (+1)
   \   000003FA   0x9808             LDR      R0,[SP, #+32]
   \   000003FC   0x6AC0             LDR      R0,[R0, #+44]
   \   000003FE   0x.... 0x....      BL       __aeabi_f2iz
   \   00000402   0x4605             MOV      R5,R0
   5489                  front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_35: (+1)
   \   00000404   0x2046             MOVS     R0,#+70
   \   00000406   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000040A   0x2800             CMP      R0,#+0
   \   0000040C   0xD008             BEQ.N    ??gcode_G29_36
   \   0000040E   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000412   0x6BE1             LDR      R1,[R4, #+60]
   \   00000414   0x.... 0x....      BL       __aeabi_fsub
   \   00000418   0x.... 0x....      BL       __aeabi_f2iz
   \   0000041C   0x9002             STR      R0,[SP, #+8]
   \   0000041E   0xE004             B.N      ??gcode_G29_37
   \                     ??gcode_G29_36: (+1)
   \   00000420   0x9808             LDR      R0,[SP, #+32]
   \   00000422   0x6B00             LDR      R0,[R0, #+48]
   \   00000424   0x.... 0x....      BL       __aeabi_f2iz
   \   00000428   0x9002             STR      R0,[SP, #+8]
   5490                  back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_37: (+1)
   \   0000042A   0x2042             MOVS     R0,#+66
   \   0000042C   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000430   0x2800             CMP      R0,#+0
   \   00000432   0xD008             BEQ.N    ??gcode_G29_38
   \   00000434   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000438   0x6BE1             LDR      R1,[R4, #+60]
   \   0000043A   0x.... 0x....      BL       __aeabi_fsub
   \   0000043E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000442   0x4604             MOV      R4,R0
   \   00000444   0xE004             B.N      ??gcode_G29_39
   \                     ??gcode_G29_38: (+1)
   \   00000446   0x9808             LDR      R0,[SP, #+32]
   \   00000448   0x6B40             LDR      R0,[R0, #+52]
   \   0000044A   0x.... 0x....      BL       __aeabi_f2iz
   \   0000044E   0x4604             MOV      R4,R0
   5491          
   5492                  const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
   \                     ??gcode_G29_39: (+1)
   \   00000450   0xF8DF 0x78F4      LDR.W    R7,??gcode_G29_1+0x40
   \   00000454   0x9805             LDR      R0,[SP, #+20]
   \   00000456   0x.... 0x....      BL       __aeabi_i2f
   \   0000045A   0x6839             LDR      R1,[R7, #+0]
   \   0000045C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000460   0xD304             BCC.N    ??gcode_G29_40
   5493                             left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
   \   00000462   0xF1A5 0x000A      SUB      R0,R5,#+10
   \   00000466   0x9905             LDR      R1,[SP, #+20]
   \   00000468   0x4288             CMP      R0,R1
   \   0000046A   0xDA03             BGE.N    ??gcode_G29_41
   \                     ??gcode_G29_40: (+1)
   \   0000046C   0x2001             MOVS     R0,#+1
   \   0000046E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000472   0xE002             B.N      ??gcode_G29_42
   \                     ??gcode_G29_41: (+1)
   \   00000474   0x2000             MOVS     R0,#+0
   \   00000476   0xF88D 0x0000      STRB     R0,[SP, #+0]
   5494                             right_out_r = right_probe_bed_position > MAX_PROBE_X,
   \                     ??gcode_G29_42: (+1)
   \   0000047A   0x4628             MOV      R0,R5
   \   0000047C   0x.... 0x....      BL       __aeabi_i2f
   \   00000480   0x4601             MOV      R1,R0
   \   00000482   0x6878             LDR      R0,[R7, #+4]
   \   00000484   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000488   0xD303             BCC.N    ??gcode_G29_43
   5495                             right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
   \   0000048A   0x9805             LDR      R0,[SP, #+20]
   \   0000048C   0x300A             ADDS     R0,R0,#+10
   \   0000048E   0x4285             CMP      R5,R0
   \   00000490   0xDA02             BGE.N    ??gcode_G29_44
   \                     ??gcode_G29_43: (+1)
   \   00000492   0xF04F 0x0A01      MOV      R10,#+1
   \   00000496   0xE001             B.N      ??gcode_G29_45
   \                     ??gcode_G29_44: (+1)
   \   00000498   0xF04F 0x0A00      MOV      R10,#+0
   5496                             front_out_f = front_probe_bed_position < MIN_PROBE_Y,
   \                     ??gcode_G29_45: (+1)
   \   0000049C   0x9802             LDR      R0,[SP, #+8]
   \   0000049E   0x.... 0x....      BL       __aeabi_i2f
   \   000004A2   0x68B9             LDR      R1,[R7, #+8]
   \   000004A4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000004A8   0xD304             BCC.N    ??gcode_G29_46
   5497                             front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
   \   000004AA   0xF1A4 0x000A      SUB      R0,R4,#+10
   \   000004AE   0x9902             LDR      R1,[SP, #+8]
   \   000004B0   0x4288             CMP      R0,R1
   \   000004B2   0xDA02             BGE.N    ??gcode_G29_47
   \                     ??gcode_G29_46: (+1)
   \   000004B4   0xF04F 0x0B01      MOV      R11,#+1
   \   000004B8   0xE001             B.N      ??gcode_G29_48
   \                     ??gcode_G29_47: (+1)
   \   000004BA   0xF04F 0x0B00      MOV      R11,#+0
   5498                             back_out_b = back_probe_bed_position > MAX_PROBE_Y,
   \                     ??gcode_G29_48: (+1)
   \   000004BE   0x4620             MOV      R0,R4
   \   000004C0   0x.... 0x....      BL       __aeabi_i2f
   \   000004C4   0x4601             MOV      R1,R0
   \   000004C6   0x68F8             LDR      R0,[R7, #+12]
   \   000004C8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000004CC   0xD303             BCC.N    ??gcode_G29_49
   5499                             back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
   \   000004CE   0x9802             LDR      R0,[SP, #+8]
   \   000004D0   0x300A             ADDS     R0,R0,#+10
   \   000004D2   0x4284             CMP      R4,R0
   \   000004D4   0xDA01             BGE.N    ??gcode_G29_50
   \                     ??gcode_G29_49: (+1)
   \   000004D6   0x2701             MOVS     R7,#+1
   \   000004D8   0xE000             B.N      ??gcode_G29_51
   \                     ??gcode_G29_50: (+1)
   \   000004DA   0x2700             MOVS     R7,#+0
   5500          
   5501                  if (left_out || right_out || front_out || back_out) {
   \                     ??gcode_G29_51: (+1)
   \   000004DC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000004E0   0xEA4A 0x0000      ORR      R0,R10,R0
   \   000004E4   0xEA4B 0x0000      ORR      R0,R11,R0
   \   000004E8   0x4338             ORRS     R0,R7,R0
   \   000004EA   0xD01D             BEQ.N    ??gcode_G29_52
   5502                    if (left_out) {
   \   000004EC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000004F0   0x2800             CMP      R0,#+0
   \   000004F2   0xD003             BEQ.N    ??gcode_G29_53
   5503                      out_of_range_error(PSTR("(L)eft"));
   \   000004F4   0xF8DF 0x0854      LDR.W    R0,??gcode_G29_1+0x44
   \   000004F8   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5504                      left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   5505                    }
   5506                    if (right_out) {
   \                     ??gcode_G29_53: (+1)
   \   000004FC   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000500   0xD003             BEQ.N    ??gcode_G29_54
   5507                      out_of_range_error(PSTR("(R)ight"));
   \   00000502   0xF8DF 0x084C      LDR.W    R0,??gcode_G29_1+0x48
   \   00000506   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5508                      right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   5509                    }
   5510                    if (front_out) {
   \                     ??gcode_G29_54: (+1)
   \   0000050A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000050E   0xD003             BEQ.N    ??gcode_G29_55
   5511                      out_of_range_error(PSTR("(F)ront"));
   \   00000510   0xF8DF 0x0840      LDR.W    R0,??gcode_G29_1+0x4C
   \   00000514   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5512                      front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   5513                    }
   5514                    if (back_out) {
   \                     ??gcode_G29_55: (+1)
   \   00000518   0x2F00             CMP      R7,#+0
   \   0000051A   0xF000 0x83F0      BEQ.W    ??gcode_G29_0
   5515                      out_of_range_error(PSTR("(B)ack"));
   \   0000051E   0xF8DF 0x0838      LDR.W    R0,??gcode_G29_1+0x50
   \   00000522   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5516                      back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   5517                    }
   5518                    return;
   \   00000526   0xE3EA             B.N      ??gcode_G29_0
   5519                  }
   5520          
   5521                  // probe at the points of a lattice grid
   5522                  xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
   \                     ??gcode_G29_52: (+1)
   \   00000528   0x9805             LDR      R0,[SP, #+20]
   \   0000052A   0x1A28             SUBS     R0,R5,R0
   \   0000052C   0x990C             LDR      R1,[SP, #+48]
   \   0000052E   0x1E49             SUBS     R1,R1,#+1
   \   00000530   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000534   0x.... 0x....      BL       __aeabi_i2f
   \   00000538   0x9012             STR      R0,[SP, #+72]
   5523                  yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
   \   0000053A   0x9802             LDR      R0,[SP, #+8]
   \   0000053C   0x1A20             SUBS     R0,R4,R0
   \   0000053E   0x9904             LDR      R1,[SP, #+16]
   \   00000540   0x1E49             SUBS     R1,R1,#+1
   \   00000542   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000546   0x.... 0x....      BL       __aeabi_i2f
   \   0000054A   0x9007             STR      R0,[SP, #+28]
   5524                }
   5525                //#endif // ABL_GRID
   5526          
   5527                if (verbose_level > 0) {
   \                     ??gcode_G29_31: (+1)
   \   0000054C   0x980A             LDR      R0,[SP, #+40]
   \   0000054E   0x2801             CMP      R0,#+1
   \   00000550   0xDB0F             BLT.N    ??gcode_G29_56
   5528                  SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
   \   00000552   0xF8DF 0x0808      LDR.W    R0,??gcode_G29_1+0x54
   \   00000556   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5529                  if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
   \   0000055A   0x980F             LDR      R0,[SP, #+60]
   \   0000055C   0x2800             CMP      R0,#+0
   \   0000055E   0xD003             BEQ.N    ??gcode_G29_57
   \   00000560   0xF8DF 0x07FC      LDR.W    R0,??gcode_G29_1+0x58
   \   00000564   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5530                  SERIAL_EOL();
   \                     ??gcode_G29_57: (+1)
   \   00000568   0x210A             MOVS     R1,#+10
   \   0000056A   0xF8DF 0x07F8      LDR.W    R0,??gcode_G29_1+0x5C
   \   0000056E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5531                }
   5532          
   5533                stepper.synchronize();
   \                     ??gcode_G29_56: (+1)
   \   00000572   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   5534          
   5535                // Disable auto bed leveling during G29.
   5536                // Be formal so G29 can be done successively without G28.
   5537                set_bed_leveling_enabled(false);
   \   00000576   0x2000             MOVS     R0,#+0
   \   00000578   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5538          
   5539                #if HAS_BED_PROBE
   5540                  // Deploy the probe. Probe will raise if needed.
   5541                  if (DEPLOY_PROBE()) {
   \   0000057C   0x2001             MOVS     R0,#+1
   \   0000057E   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   00000582   0x2800             CMP      R0,#+0
   \   00000584   0xD003             BEQ.N    ??gcode_G29_58
   5542                    set_bed_leveling_enabled(abl_should_enable);
   \   00000586   0x4648             MOV      R0,R9
   \   00000588   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5543                    return;
   \   0000058C   0xE3B7             B.N      ??gcode_G29_0
   5544                  }
   5545                #endif
   5546          
   5547                if (!faux) setup_for_endstop_or_probe_move();
   \                     ??gcode_G29_58: (+1)
   \   0000058E   0x.... 0x....      BL       _Z31setup_for_endstop_or_probe_movev
   5548          
   5549                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5550                if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \   00000592   0xF8DF 0x0774      LDR.W    R0,??gcode_G29_1
   \   00000596   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000059A   0x2808             CMP      R0,#+8
   \   0000059C   0xD129             BNE.N    ??gcode_G29_59
   5551                {
   5552                  #if ENABLED(PROBE_MANUALLY)
   5553                    if (!no_action)
   5554                  #endif
   5555                  if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
   5556                    || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
   5557                    || left_probe_bed_position != bilinear_start[X_AXIS]
   5558                    || front_probe_bed_position != bilinear_start[Y_AXIS]
   5559                  ) {
   \   0000059E   0xF8DF 0x4770      LDR.W    R4,??gcode_G29_1+0x8
   \   000005A2   0x6920             LDR      R0,[R4, #+16]
   \   000005A4   0x.... 0x....      BL       __aeabi_i2f
   \   000005A8   0x4601             MOV      R1,R0
   \   000005AA   0x9812             LDR      R0,[SP, #+72]
   \   000005AC   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000005B0   0xD10F             BNE.N    ??gcode_G29_60
   \   000005B2   0x6960             LDR      R0,[R4, #+20]
   \   000005B4   0x.... 0x....      BL       __aeabi_i2f
   \   000005B8   0x4601             MOV      R1,R0
   \   000005BA   0x9807             LDR      R0,[SP, #+28]
   \   000005BC   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000005C0   0xD107             BNE.N    ??gcode_G29_60
   \   000005C2   0x9805             LDR      R0,[SP, #+20]
   \   000005C4   0x69A1             LDR      R1,[R4, #+24]
   \   000005C6   0x4288             CMP      R0,R1
   \   000005C8   0xD103             BNE.N    ??gcode_G29_60
   \   000005CA   0x9802             LDR      R0,[SP, #+8]
   \   000005CC   0x69E1             LDR      R1,[R4, #+28]
   \   000005CE   0x4288             CMP      R0,R1
   \   000005D0   0xD00F             BEQ.N    ??gcode_G29_59
   5560                    // Reset grid to 0.0 or "not probed". (Also disables ABL)
   5561                    reset_bed_level();
   \                     ??gcode_G29_60: (+1)
   \   000005D2   0x.... 0x....      BL       _Z15reset_bed_levelv
   5562          
   5563                    // Initialize a grid with the given dimensions
   5564                    bilinear_grid_spacing[X_AXIS] = xGridSpacing;
                                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000005D6   0x9812             LDR      R0,[SP, #+72]
   \   000005D8   0x.... 0x....      BL       __aeabi_f2iz
   \   000005DC   0x6120             STR      R0,[R4, #+16]
   5565                    bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
                                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000005DE   0x9807             LDR      R0,[SP, #+28]
   \   000005E0   0x.... 0x....      BL       __aeabi_f2iz
   \   000005E4   0x6160             STR      R0,[R4, #+20]
   5566                    bilinear_start[X_AXIS] = left_probe_bed_position;
   \   000005E6   0x9805             LDR      R0,[SP, #+20]
   \   000005E8   0x61A0             STR      R0,[R4, #+24]
   5567                    bilinear_start[Y_AXIS] = front_probe_bed_position;
   \   000005EA   0x9802             LDR      R0,[SP, #+8]
   \   000005EC   0x61E0             STR      R0,[R4, #+28]
   5568          
   5569                    // Can't re-enable (on error) until the new grid is written
   5570                    abl_should_enable = false;
   \   000005EE   0xF04F 0x0900      MOV      R9,#+0
   5571                  }
   5572                }
   5573                //#endif // AUTO_BED_LEVELING_BILINEAR
   5574          
   5575                //#if ENABLED(AUTO_BED_LEVELING_3POINT)
   5576                if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)
   \                     ??gcode_G29_59: (+1)
   \   000005F2   0xF8DF 0x0714      LDR.W    R0,??gcode_G29_1
   \   000005F6   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000005FA   0x2802             CMP      R0,#+2
   \   000005FC   0xD104             BNE.N    ??gcode_G29_61
   5577                {
   5578                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5579                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
   5580                  #endif
   5581          
   5582                  // Probe at 3 arbitrary points
   5583                  points[0].z = points[1].z = points[2].z = 0;
   \   000005FE   0xAC16             ADD      R4,SP,#+88
   \   00000600   0x2000             MOVS     R0,#+0
   \   00000602   0x6220             STR      R0,[R4, #+32]
   \   00000604   0x6160             STR      R0,[R4, #+20]
   \   00000606   0x60A0             STR      R0,[R4, #+8]
   5584                }
   5585                //#endif // AUTO_BED_LEVELING_3POINT
   5586          
   5587              } // !g29_in_progress
   5588          
   5589              #if ENABLED(PROBE_MANUALLY)
   5590          
   5591                // For manual probing, get the next index to probe now.
   5592                // On the first probe this will be incremented to 0.
   5593                if (!no_action) {
   5594                  ++abl_probe_index;
   5595                  g29_in_progress = true;
   5596                }
   5597          
   5598                // Abort current G29 procedure, go back to idle state
   5599                if (seenA && g29_in_progress) {
   5600                  SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
   5601                  #if HAS_SOFTWARE_ENDSTOPS
   5602                    soft_endstops_enabled = enable_soft_endstops;
   5603                  #endif
   5604                  set_bed_leveling_enabled(abl_should_enable);
   5605                  g29_in_progress = false;
   5606                  #if ENABLED(LCD_BED_LEVELING)
   5607                    lcd_wait_for_move = false;
   5608                  #endif
   5609                }
   5610          
   5611                // Query G29 status
   5612                if (verbose_level || seenQ) {
   5613                  SERIAL_PROTOCOLPGM("Manual G29 ");
   5614                  if (g29_in_progress) {
   5615                    SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
   5616                    SERIAL_PROTOCOLLNPAIR(" of ", abl2);
   5617                  }
   5618                  else
   5619                    SERIAL_PROTOCOLLNPGM("idle");
   5620                }
   5621          
   5622                if (no_action) return;
   5623          
   5624                if (abl_probe_index == 0) {
   5625                  // For the initial G29 save software endstop state
   5626                  #if HAS_SOFTWARE_ENDSTOPS
   5627                    enable_soft_endstops = soft_endstops_enabled;
   5628                  #endif
   5629                }
   5630                else {
   5631                  // For G29 after adjusting Z.
   5632                  // Save the previous Z before going to the next point
   5633                  measured_z = current_position[Z_AXIS];
   5634          
   5635                  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5636          
   5637                    mean += measured_z;
   5638                    eqnBVector[abl_probe_index] = measured_z;
   5639                    eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5640                    eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5641                    eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5642          
   5643                    incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
   5644          
   5645                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5646          
   5647                    z_values[xCount][yCount] = measured_z + zoffset;
   5648          
   5649                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5650                      if (DEBUGGING(LEVELING)) {
   5651                        SERIAL_PROTOCOLPAIR("Save X", xCount);
   5652                        SERIAL_PROTOCOLPAIR(" Y", yCount);
   5653                        SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
   5654                      }
   5655                    #endif
   5656          
   5657                  #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5658          
   5659                    points[abl_probe_index].z = measured_z;
   5660          
   5661                  #endif
   5662                }
   5663          
   5664                //
   5665                // If there's another point to sample, move there with optional lift.
   5666                //
   5667          
   5668                #if ABL_GRID
   5669          
   5670                  // Skip any unreachable points
   5671                  while (abl_probe_index < abl2) {
   5672          
   5673                    // Set xCount, yCount based on abl_probe_index, with zig-zag
   5674                    PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
   5675                    PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
   5676          
   5677                    // Probe in reverse order for every other row/column
   5678                    bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
   5679          
   5680                    if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
   5681          
   5682                    const float xBase = xCount * xGridSpacing + left_probe_bed_position,
   5683                                yBase = yCount * yGridSpacing + front_probe_bed_position;
   5684          
   5685                    xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
   5686                    yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
   5687          
   5688                    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5689                      indexIntoAB[xCount][yCount] = abl_probe_index;
   5690                    #endif
   5691          
   5692                    // Keep looping till a reachable point is found
   5693                    if(MACHINETPYE & IS_KINEMATIC)
   5694                      if (position_is_reachable_IS_KINEMATIC(xProbe, yProbe)) break;
   5695                    else
   5696                      if (position_is_reachable_IS_CARTESIAN(xProbe, yProbe)) break;
   5697                      
   5698                    ++abl_probe_index;
   5699                  }
   5700          
   5701                  // Is there a next point to move to?
   5702                  if (abl_probe_index < abl2) {
   5703                    _manual_goto_xy(xProbe, yProbe); // Can be used here too!
   5704                    #if HAS_SOFTWARE_ENDSTOPS
   5705                      // Disable software endstops to allow manual adjustment
   5706                      // If G29 is not completed, they will not be re-enabled
   5707                      soft_endstops_enabled = false;
   5708                    #endif
   5709                    return;
   5710                  }
   5711                  else {
   5712          
   5713                    // Leveling done! Fall through to G29 finishing code below
   5714          
   5715                    SERIAL_PROTOCOLLNPGM("Grid probing done.");
   5716          
   5717                    // Re-enable software endstops, if needed
   5718                    #if HAS_SOFTWARE_ENDSTOPS
   5719                      soft_endstops_enabled = enable_soft_endstops;
   5720                    #endif
   5721                  }
   5722          
   5723                #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5724          
   5725                  // Probe at 3 arbitrary points
   5726                  if (abl_probe_index < abl2) {
   5727                    xProbe = points[abl_probe_index].x;
   5728                    yProbe = points[abl_probe_index].y;
   5729                    _manual_goto_xy(xProbe, yProbe);
   5730                    #if HAS_SOFTWARE_ENDSTOPS
   5731                      // Disable software endstops to allow manual adjustment
   5732                      // If G29 is not completed, they will not be re-enabled
   5733                      soft_endstops_enabled = false;
   5734                    #endif
   5735                    return;
   5736                  }
   5737                  else {
   5738          
   5739                    SERIAL_PROTOCOLLNPGM("3-point probing done.");
   5740          
   5741                    // Re-enable software endstops, if needed
   5742                    #if HAS_SOFTWARE_ENDSTOPS
   5743                      soft_endstops_enabled = enable_soft_endstops;
   5744                    #endif
   5745          
   5746                    if (!dryrun) {
   5747                      vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   5748                      if (planeNormal.z < 0) {
   5749                        planeNormal.x *= -1;
   5750                        planeNormal.y *= -1;
   5751                        planeNormal.z *= -1;
   5752                      }
   5753                      planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   5754          
   5755                      // Can't re-enable (on error) until the new grid is written
   5756                      abl_should_enable = false;
   5757                    }
   5758          
   5759                  }
   5760          
   5761                #endif // AUTO_BED_LEVELING_3POINT
   5762          
   5763              #else // !PROBE_MANUALLY
   5764              {
   5765                const bool stow_probe_after_each = parser.boolval('E');
   \                     ??gcode_G29_61: (+1)
   \   00000608   0x2045             MOVS     R0,#+69
   \   0000060A   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   0000060E   0xF88D 0x0005      STRB     R0,[SP, #+5]
   5766          
   5767                measured_z = 0;
   \   00000612   0x2000             MOVS     R0,#+0
   \   00000614   0x9009             STR      R0,[SP, #+36]
   5768          
   5769                //#if ABL_GRID
   5770                  if(BED_LEVELING_METHOD&ABL_GRID)
   \   00000616   0xF8DF 0x06F0      LDR.W    R0,??gcode_G29_1
   \   0000061A   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000061E   0x210C             MOVS     R1,#+12
   \   00000620   0x4208             TST      R0,R1
   \   00000622   0xF000 0x80F8      BEQ.W    ??gcode_G29_62
   5771                  {
   5772                  bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
   \   00000626   0x9804             LDR      R0,[SP, #+16]
   \   00000628   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000062C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   5773          
   5774                  measured_z = 0;
   5775          
   5776                  // Outer loop is Y with PROBE_Y_FIRST disabled
   5777                  for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
   \   00000630   0x2000             MOVS     R0,#+0
   \   00000632   0x9006             STR      R0,[SP, #+24]
   \   00000634   0xE0B0             B.N      ??gcode_G29_63
   5778          
   5779                    int8_t inStart, inStop, inInc;
   5780          
   5781                    if (zig) { // away from origin
   5782                      inStart = 0;
   5783                      inStop = PR_INNER_END;
   5784                      inInc = 1;
   5785                    }
   5786                    else {     // towards origin
   5787                      inStart = PR_INNER_END - 1;
   \                     ??gcode_G29_64: (+1)
   \   00000636   0x980C             LDR      R0,[SP, #+48]
   \   00000638   0x1E47             SUBS     R7,R0,#+1
   5788                      inStop = -1;
   \   0000063A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000063E   0x9014             STR      R0,[SP, #+80]
   5789                      inInc = -1;
   \   00000640   0x9013             STR      R0,[SP, #+76]
   5790                    }
   5791          
   5792                    zig ^= true; // zag
   \                     ??gcode_G29_65: (+1)
   \   00000642   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000646   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000064A   0x1E40             SUBS     R0,R0,#+1
   \   0000064C   0x4180             SBCS     R0,R0,R0
   \   0000064E   0x43C0             MVNS     R0,R0
   \   00000650   0x0FC0             LSRS     R0,R0,#+31
   \   00000652   0xF88D 0x0004      STRB     R0,[SP, #+4]
   5793          
   5794                    // Inner loop is Y with PROBE_Y_FIRST enabled
   5795                    for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
   \   00000656   0xB27F             SXTB     R7,R7
   \   00000658   0xE015             B.N      ??gcode_G29_66
   5796          
   5797                      float xBase = left_probe_bed_position + xGridSpacing * xCount,
   5798                            yBase = front_probe_bed_position + yGridSpacing * yCount;
   5799          
   5800                      xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
   5801                      yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
   5802          
   5803                      //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5804                      if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   5805                        indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
   5806                      //#endif
   5807          
   5808                      //#if IS_KINEMATIC
   5809                      if(MACHINETPYE & IS_KINEMATIC)
   5810                        // Avoid probing outside the round or hexagonal area
   5811                        if (!position_is_reachable_by_probe_IS_KINEMATIC(xProbe, yProbe)) continue;
   5812                      //#endif
   5813                      
   5814                      int16_t randData = rand()%200;
   5815                      if(randData > 100)  randData = 100 - randData;
   5816          
   5817                      measured_z = faux ? 0.001 * randData/*random(-100, 101) */: probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5818          
   5819                      if (isnan(measured_z)) {
   5820                        set_bed_leveling_enabled(abl_should_enable);
   5821                        break;
   5822                      }
   5823          
   5824                      //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5825                      if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   5826                      {
   5827                        mean += measured_z;
   5828                        /*
   5829                        eqnBVector[abl_probe_index] = measured_z;
   5830                        eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5831                        eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5832                        eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5833                        */
   5834                      *(eqnBVector+abl_probe_index) = measured_z;
   5835                      *(eqnAMatrix+abl_probe_index + 0 * abl2) = xProbe;
   5836                      *(eqnAMatrix+abl_probe_index + 1 * abl2) = yProbe;
   5837                      *(eqnAMatrix+abl_probe_index + 2 * abl2) = 1;
   5838          
   5839                        incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
   5840                      }
   5841                      //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5842                      else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
   \                     ??gcode_G29_67: (+1)
   \   0000065A   0x0700             LSLS     R0,R0,#+28
   \   0000065C   0xD50C             BPL.N    ??gcode_G29_68
   5843                      {
   5844                        z_values[xCount][yCount] = measured_z + zoffset;
   \   0000065E   0x9C06             LDR      R4,[SP, #+24]
   \   00000660   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   00000664   0xF8DF 0x16D0      LDR.W    R1,??gcode_G29_1+0x30
   \   00000668   0xEB01 0x1500      ADD      R5,R1,R0, LSL #+4
   \   0000066C   0x9909             LDR      R1,[SP, #+36]
   \   0000066E   0x9815             LDR      R0,[SP, #+84]
   \   00000670   0x.... 0x....      BL       __aeabi_fadd
   \   00000674   0xF845 0x0024      STR      R0,[R5, R4, LSL #+2]
   5845                      }
   5846                      //#endif
   5847          
   5848                      abl_should_enable = false;
   \                     ??gcode_G29_68: (+1)
   \   00000678   0xF04F 0x0900      MOV      R9,#+0
   5849                      idle();
   \   0000067C   0x.... 0x....      BL       _Z4idlev
   \                     ??gcode_G29_69: (+1)
   \   00000680   0x9813             LDR      R0,[SP, #+76]
   \   00000682   0x19C7             ADDS     R7,R0,R7
   \   00000684   0xB27F             SXTB     R7,R7
   \                     ??gcode_G29_66: (+1)
   \   00000686   0x9814             LDR      R0,[SP, #+80]
   \   00000688   0x4287             CMP      R7,R0
   \   0000068A   0xF000 0x8081      BEQ.W    ??gcode_G29_70
   \   0000068E   0x9805             LDR      R0,[SP, #+20]
   \   00000690   0x.... 0x....      BL       __aeabi_i2f
   \   00000694   0x4604             MOV      R4,R0
   \   00000696   0x4638             MOV      R0,R7
   \   00000698   0x.... 0x....      BL       __aeabi_i2f
   \   0000069C   0x4601             MOV      R1,R0
   \   0000069E   0x9812             LDR      R0,[SP, #+72]
   \   000006A0   0x.... 0x....      BL       __aeabi_fmul
   \   000006A4   0x4601             MOV      R1,R0
   \   000006A6   0x4620             MOV      R0,R4
   \   000006A8   0x.... 0x....      BL       __aeabi_fadd
   \   000006AC   0x4683             MOV      R11,R0
   \   000006AE   0x9802             LDR      R0,[SP, #+8]
   \   000006B0   0x.... 0x....      BL       __aeabi_i2f
   \   000006B4   0x4604             MOV      R4,R0
   \   000006B6   0xA806             ADD      R0,SP,#+24
   \   000006B8   0x7800             LDRB     R0,[R0, #+0]
   \   000006BA   0x.... 0x....      BL       __aeabi_ui2f
   \   000006BE   0x4601             MOV      R1,R0
   \   000006C0   0x9807             LDR      R0,[SP, #+28]
   \   000006C2   0x.... 0x....      BL       __aeabi_fmul
   \   000006C6   0x4601             MOV      R1,R0
   \   000006C8   0x4620             MOV      R0,R4
   \   000006CA   0x.... 0x....      BL       __aeabi_fadd
   \   000006CE   0x4682             MOV      R10,R0
   \   000006D0   0x4658             MOV      R0,R11
   \   000006D2   0x2100             MOVS     R1,#+0
   \   000006D4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000006D8   0x460C             MOV      R4,R1
   \   000006DA   0xD201             BCS.N    ??gcode_G29_71
   \   000006DC   0x460D             MOV      R5,R1
   \   000006DE   0xE001             B.N      ??gcode_G29_72
   \                     ??gcode_G29_71: (+1)
   \   000006E0   0xF8DF 0x5684      LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
   \                     ??gcode_G29_72: (+1)
   \   000006E4   0x.... 0x....      BL       __aeabi_f2d
   \   000006E8   0x4602             MOV      R2,R0
   \   000006EA   0x460B             MOV      R3,R1
   \   000006EC   0x4620             MOV      R0,R4
   \   000006EE   0x4629             MOV      R1,R5
   \   000006F0   0x.... 0x....      BL       __aeabi_dadd
   \   000006F4   0x.... 0x....      BL       floor
   \   000006F8   0x.... 0x....      BL       __aeabi_d2f
   \   000006FC   0x900E             STR      R0,[SP, #+56]
   \   000006FE   0x4650             MOV      R0,R10
   \   00000700   0x4621             MOV      R1,R4
   \   00000702   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000706   0xD201             BCS.N    ??gcode_G29_73
   \   00000708   0x460D             MOV      R5,R1
   \   0000070A   0xE001             B.N      ??gcode_G29_74
   \                     ??gcode_G29_73: (+1)
   \   0000070C   0xF8DF 0x5658      LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
   \                     ??gcode_G29_74: (+1)
   \   00000710   0x.... 0x....      BL       __aeabi_f2d
   \   00000714   0x4622             MOV      R2,R4
   \   00000716   0x462B             MOV      R3,R5
   \   00000718   0x.... 0x....      BL       __aeabi_dadd
   \   0000071C   0x.... 0x....      BL       floor
   \   00000720   0x.... 0x....      BL       __aeabi_d2f
   \   00000724   0x900D             STR      R0,[SP, #+52]
   \   00000726   0xF8DF 0x05E0      LDR.W    R0,??gcode_G29_1
   \   0000072A   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000072E   0x0740             LSLS     R0,R0,#+29
   \   00000730   0xD508             BPL.N    ??gcode_G29_75
   \   00000732   0x1C76             ADDS     R6,R6,#+1
   \   00000734   0x9806             LDR      R0,[SP, #+24]
   \   00000736   0xEB07 0x0147      ADD      R1,R7,R7, LSL #+1
   \   0000073A   0xAA3A             ADD      R2,SP,#+232
   \   0000073C   0xEB02 0x1101      ADD      R1,R2,R1, LSL #+4
   \   00000740   0xF841 0x6020      STR      R6,[R1, R0, LSL #+2]
   \                     ??gcode_G29_75: (+1)
   \   00000744   0xF8DF 0x05C0      LDR.W    R0,??gcode_G29_1
   \   00000748   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   0000074C   0xF240 0x3102      MOVW     R1,#+770
   \   00000750   0x4208             TST      R0,R1
   \   00000752   0xD005             BEQ.N    ??gcode_G29_76
   \   00000754   0xA90D             ADD      R1,SP,#+52
   \   00000756   0xA80E             ADD      R0,SP,#+56
   \   00000758   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
   \   0000075C   0x2800             CMP      R0,#+0
   \   0000075E   0xD08F             BEQ.N    ??gcode_G29_69
   \                     ??gcode_G29_76: (+1)
   \   00000760   0x.... 0x....      BL       rand
   \   00000764   0x2001             MOVS     R0,#+1
   \   00000766   0x9000             STR      R0,[SP, #+0]
   \   00000768   0x9B0A             LDR      R3,[SP, #+40]
   \   0000076A   0xB2DB             UXTB     R3,R3
   \   0000076C   0xF89D 0x2005      LDRB     R2,[SP, #+5]
   \   00000770   0xA90D             ADD      R1,SP,#+52
   \   00000772   0xA80E             ADD      R0,SP,#+56
   \   00000774   0x.... 0x....      BL       _Z8probe_ptRKfS0_bhb
   \   00000778   0x.... 0x....      BL       __aeabi_f2d
   \   0000077C   0x.... 0x....      BL       __aeabi_d2f
   \   00000780   0x9009             STR      R0,[SP, #+36]
   \   00000782   0x.... 0x....      BL       __iar_FDtest
   \   00000786   0x2802             CMP      R0,#+2
   \   00000788   0xD11E             BNE.N    ??gcode_G29_77
   \   0000078A   0x4648             MOV      R0,R9
   \   0000078C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   \                     ??gcode_G29_70: (+1)
   \   00000790   0x9806             LDR      R0,[SP, #+24]
   \   00000792   0x1C40             ADDS     R0,R0,#+1
   \   00000794   0xB2C0             UXTB     R0,R0
   \   00000796   0x9006             STR      R0,[SP, #+24]
   \                     ??gcode_G29_63: (+1)
   \   00000798   0x9806             LDR      R0,[SP, #+24]
   \   0000079A   0x9904             LDR      R1,[SP, #+16]
   \   0000079C   0x4288             CMP      R0,R1
   \   0000079E   0xF280 0x80C6      BGE.W    ??gcode_G29_78
   \   000007A2   0x9809             LDR      R0,[SP, #+36]
   \   000007A4   0x.... 0x....      BL       __iar_FDtest
   \   000007A8   0x2802             CMP      R0,#+2
   \   000007AA   0xF000 0x80C0      BEQ.W    ??gcode_G29_78
   \   000007AE   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000007B2   0x2800             CMP      R0,#+0
   \   000007B4   0xF43F 0xAF3F      BEQ.W    ??gcode_G29_64
   \   000007B8   0x2700             MOVS     R7,#+0
   \   000007BA   0xA80C             ADD      R0,SP,#+48
   \   000007BC   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   000007C0   0x9014             STR      R0,[SP, #+80]
   \   000007C2   0x2001             MOVS     R0,#+1
   \   000007C4   0x9013             STR      R0,[SP, #+76]
   \   000007C6   0xE73C             B.N      ??gcode_G29_65
   \                     ??gcode_G29_77: (+1)
   \   000007C8   0xF8DF 0x053C      LDR.W    R0,??gcode_G29_1
   \   000007CC   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000007D0   0x0741             LSLS     R1,R0,#+29
   \   000007D2   0xF57F 0xAF42      BPL.W    ??gcode_G29_67
   \   000007D6   0x9909             LDR      R1,[SP, #+36]
   \   000007D8   0x4640             MOV      R0,R8
   \   000007DA   0x.... 0x....      BL       __aeabi_fadd
   \   000007DE   0x4680             MOV      R8,R0
   \   000007E0   0x9809             LDR      R0,[SP, #+36]
   \   000007E2   0x9910             LDR      R1,[SP, #+64]
   \   000007E4   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \   000007E8   0x980E             LDR      R0,[SP, #+56]
   \   000007EA   0x990B             LDR      R1,[SP, #+44]
   \   000007EC   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \   000007F0   0x980B             LDR      R0,[SP, #+44]
   \   000007F2   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   000007F6   0x990D             LDR      R1,[SP, #+52]
   \   000007F8   0x9A11             LDR      R2,[SP, #+68]
   \   000007FA   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
   \   000007FE   0xF04F 0x517E      MOV      R1,#+1065353216
   \   00000802   0x9A11             LDR      R2,[SP, #+68]
   \   00000804   0xF840 0x1032      STR      R1,[R0, R2, LSL #+3]
   \   00000808   0xAB09             ADD      R3,SP,#+36
   \   0000080A   0xAA0D             ADD      R2,SP,#+52
   \   0000080C   0xA90E             ADD      R1,SP,#+56
   \   0000080E   0xA82B             ADD      R0,SP,#+172
   \   00000810   0x.... 0x....      BL       _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
   \   00000814   0xE730             B.N      ??gcode_G29_68
   5850          
   5851                    } // inner
   5852                  } // outer
   5853                }
   5854                //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5855                else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_3POINT)
   \                     ??gcode_G29_62: (+1)
   \   00000816   0x0780             LSLS     R0,R0,#+30
   \   00000818   0xF140 0x8089      BPL.W    ??gcode_G29_78
   5856                {
   5857                  // Probe at 3 arbitrary points
   5858          
   5859                  for (uint8_t i = 0; i < 3; ++i) {
   \   0000081C   0x2400             MOVS     R4,#+0
   \   0000081E   0xE003             B.N      ??gcode_G29_79
   5860                    // Retain the last probe position
   5861                    xProbe = points[i].x;
   5862                    yProbe = points[i].y;
   5863                    int16_t randData = rand()%200;
   5864          	      if(randData > 100)	randData = 100 - randData;
   5865                    measured_z = faux ? 0.001 * randData/*random(-100, 101)*/ : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5866                    if (isnan(measured_z)) {
   5867                      set_bed_leveling_enabled(abl_should_enable);
   5868                      break;
   5869                    }
   5870                    points[i].z = measured_z;
   \                     ??gcode_G29_80: (+1)
   \   00000820   0x9809             LDR      R0,[SP, #+36]
   \   00000822   0x60A8             STR      R0,[R5, #+8]
   \   00000824   0x1C64             ADDS     R4,R4,#+1
   \   00000826   0xB2E4             UXTB     R4,R4
   \                     ??gcode_G29_79: (+1)
   \   00000828   0x2C03             CMP      R4,#+3
   \   0000082A   0xDA21             BGE.N    ??gcode_G29_81
   \   0000082C   0xEB04 0x0044      ADD      R0,R4,R4, LSL #+1
   \   00000830   0x0080             LSLS     R0,R0,#+2
   \   00000832   0xA916             ADD      R1,SP,#+88
   \   00000834   0x5841             LDR      R1,[R0, R1]
   \   00000836   0x910E             STR      R1,[SP, #+56]
   \   00000838   0xA916             ADD      R1,SP,#+88
   \   0000083A   0x1845             ADDS     R5,R0,R1
   \   0000083C   0x6868             LDR      R0,[R5, #+4]
   \   0000083E   0x900D             STR      R0,[SP, #+52]
   \   00000840   0x.... 0x....      BL       rand
   \   00000844   0x2001             MOVS     R0,#+1
   \   00000846   0x9000             STR      R0,[SP, #+0]
   \   00000848   0x9B0A             LDR      R3,[SP, #+40]
   \   0000084A   0xB2DB             UXTB     R3,R3
   \   0000084C   0xF89D 0x2005      LDRB     R2,[SP, #+5]
   \   00000850   0xA90D             ADD      R1,SP,#+52
   \   00000852   0xA80E             ADD      R0,SP,#+56
   \   00000854   0x.... 0x....      BL       _Z8probe_ptRKfS0_bhb
   \   00000858   0x.... 0x....      BL       __aeabi_f2d
   \   0000085C   0x.... 0x....      BL       __aeabi_d2f
   \   00000860   0x9009             STR      R0,[SP, #+36]
   \   00000862   0x.... 0x....      BL       __iar_FDtest
   \   00000866   0x2802             CMP      R0,#+2
   \   00000868   0xD1DA             BNE.N    ??gcode_G29_80
   \   0000086A   0x4648             MOV      R0,R9
   \   0000086C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5871                  }
   5872          
   5873                  if (!dryrun && !isnan(measured_z)) {
   \                     ??gcode_G29_81: (+1)
   \   00000870   0x980F             LDR      R0,[SP, #+60]
   \   00000872   0x2800             CMP      R0,#+0
   \   00000874   0xD15B             BNE.N    ??gcode_G29_78
   \   00000876   0x9809             LDR      R0,[SP, #+36]
   \   00000878   0x.... 0x....      BL       __iar_FDtest
   \   0000087C   0x2802             CMP      R0,#+2
   \   0000087E   0xD056             BEQ.N    ??gcode_G29_78
   5874                    vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   \   00000880   0xAC16             ADD      R4,SP,#+88
   \   00000882   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000886   0xB082             SUB      SP,SP,#+8
   \   00000888   0x4669             MOV      R1,SP
   \   0000088A   0xC80C             LDM      R0!,{R2,R3}
   \   0000088C   0xC10C             STM      R1!,{R2,R3}
   \   0000088E   0x6802             LDR      R2,[R0, #0]
   \   00000890   0x600A             STR      R2,[R1, #+0]
   \   00000892   0xBC0C             POP      {R2,R3}
   \   00000894   0xA91C             ADD      R1,SP,#+112
   \   00000896   0xA822             ADD      R0,SP,#+136
   \   00000898   0x.... 0x....      BL       _ZN8vector_3miES_
   \   0000089C   0xF104 0x000C      ADD      R0,R4,#+12
   \   000008A0   0xB082             SUB      SP,SP,#+8
   \   000008A2   0x4669             MOV      R1,SP
   \   000008A4   0xC80C             LDM      R0!,{R2,R3}
   \   000008A6   0xC10C             STM      R1!,{R2,R3}
   \   000008A8   0x6802             LDR      R2,[R0, #0]
   \   000008AA   0x600A             STR      R2,[R1, #+0]
   \   000008AC   0xBC0C             POP      {R2,R3}
   \   000008AE   0xA916             ADD      R1,SP,#+88
   \   000008B0   0xA812             ADD      R0,SP,#+72
   \   000008B2   0x.... 0x....      BL       _ZN8vector_3miES_
   \   000008B6   0xA822             ADD      R0,SP,#+136
   \   000008B8   0x466A             MOV      R2,SP
   \   000008BA   0xC80A             LDM      R0!,{R1,R3}
   \   000008BC   0xC20A             STM      R2!,{R1,R3}
   \   000008BE   0x6803             LDR      R3,[R0, #0]
   \   000008C0   0x6013             STR      R3,[R2, #+0]
   \   000008C2   0xA812             ADD      R0,SP,#+72
   \   000008C4   0xE890 0x000E      LDM      R0,{R1-R3}
   \   000008C8   0xA805             ADD      R0,SP,#+20
   \   000008CA   0x.... 0x....      BL       _ZN8vector_35crossES_S_
   \   000008CE   0xA81F             ADD      R0,SP,#+124
   \   000008D0   0xA905             ADD      R1,SP,#+20
   \   000008D2   0xC91C             LDM      R1!,{R2-R4}
   \   000008D4   0xC01C             STM      R0!,{R2-R4}
   \   000008D6   0xA91F             ADD      R1,SP,#+124
   \   000008D8   0xA805             ADD      R0,SP,#+20
   \   000008DA   0x.... 0x....      BL       _ZN8vector_310get_normalEv
   \   000008DE   0xA800             ADD      R0,SP,#+0
   \   000008E0   0xA905             ADD      R1,SP,#+20
   \   000008E2   0xC91C             LDM      R1!,{R2-R4}
   \   000008E4   0xC01C             STM      R0!,{R2-R4}
   5875                    if (planeNormal.z < 0) {
   \   000008E6   0x4620             MOV      R0,R4
   \   000008E8   0x2100             MOVS     R1,#+0
   \   000008EA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000008EE   0xD210             BCS.N    ??gcode_G29_82
   5876                      planeNormal.x *= -1;
   \   000008F0   0xF8DF 0x5478      LDR.W    R5,??gcode_G29_1+0x64  ;; 0xbf800000
   \   000008F4   0x4611             MOV      R1,R2
   \   000008F6   0x4628             MOV      R0,R5
   \   000008F8   0x.... 0x....      BL       __aeabi_fmul
   \   000008FC   0x9000             STR      R0,[SP, #+0]
   5877                      planeNormal.y *= -1;
   \   000008FE   0x9901             LDR      R1,[SP, #+4]
   \   00000900   0x4628             MOV      R0,R5
   \   00000902   0x.... 0x....      BL       __aeabi_fmul
   \   00000906   0x9001             STR      R0,[SP, #+4]
   5878                      planeNormal.z *= -1;
   \   00000908   0x4620             MOV      R0,R4
   \   0000090A   0x4629             MOV      R1,R5
   \   0000090C   0x.... 0x....      BL       __aeabi_fmul
   \   00000910   0x9002             STR      R0,[SP, #+8]
   5879                    }
   5880                    planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   \                     ??gcode_G29_82: (+1)
   \   00000912   0xA800             ADD      R0,SP,#+0
   \   00000914   0xE890 0x000E      LDM      R0,{R1-R3}
   \   00000918   0xA822             ADD      R0,SP,#+136
   \   0000091A   0x.... 0x....      BL       _ZN10matrix_3x314create_look_atE8vector_3
   \   0000091E   0xF8DF 0x0450      LDR.W    R0,??gcode_G29_1+0x68
   \   00000922   0xA922             ADD      R1,SP,#+136
   \   00000924   0x2224             MOVS     R2,#+36
   \   00000926   0x.... 0x....      BL       __aeabi_memcpy4
   5881          
   5882                    // Can't re-enable (on error) until the new grid is written
   5883                    abl_should_enable = false;
   \   0000092A   0xF04F 0x0900      MOV      R9,#+0
   5884                  }
   5885                }
   5886                //#endif // AUTO_BED_LEVELING_3POINT
   5887          
   5888                // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
   5889                if (STOW_PROBE()) {
   \                     ??gcode_G29_78: (+1)
   \   0000092E   0x2000             MOVS     R0,#+0
   \   00000930   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   00000934   0x2800             CMP      R0,#+0
   \   00000936   0xD005             BEQ.N    ??gcode_G29_83
   5890                  set_bed_leveling_enabled(abl_should_enable);
   \   00000938   0x4648             MOV      R0,R9
   \   0000093A   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5891                  measured_z = NAN;
   \   0000093E   0xF06F 0x4000      MVN      R0,#-2147483648
   \   00000942   0x9009             STR      R0,[SP, #+36]
   5892                }
   5893              }
   5894              #endif // !PROBE_MANUALLY
   5895          
   5896              //
   5897              // G29 Finishing Code
   5898              //
   5899              // Unless this is a dry run, auto bed leveling will
   5900              // definitely be enabled after this point.
   5901              //
   5902              // If code above wants to continue leveling, it should
   5903              // return or loop before this point.
   5904              //
   5905          
   5906              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5907                if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
   5908              #endif
   5909          
   5910              #if ENABLED(PROBE_MANUALLY)
   5911                g29_in_progress = false;
   5912                #if ENABLED(LCD_BED_LEVELING)
   5913                  lcd_wait_for_move = false;
   5914                #endif
   5915              #endif
   5916          
   5917              // Calculate leveling, print reports, correct the position
   5918              if (!isnan(measured_z)) {
   \                     ??gcode_G29_83: (+1)
   \   00000944   0x9809             LDR      R0,[SP, #+36]
   \   00000946   0x.... 0x....      BL       __iar_FDtest
   \   0000094A   0x2802             CMP      R0,#+2
   \   0000094C   0xF000 0x81C4      BEQ.W    ??gcode_G29_84
   \   00000950   0xF8DF 0x03B4      LDR.W    R0,??gcode_G29_1
   \   00000954   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000958   0x2808             CMP      R0,#+8
   \   0000095A   0xD109             BNE.N    ??gcode_G29_85
   5919                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5920                  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   5921                  {
   5922                      if (!dryrun) extrapolate_unprobed_bed_level();
   \   0000095C   0x980F             LDR      R0,[SP, #+60]
   \   0000095E   0x2800             CMP      R0,#+0
   \   00000960   0xD101             BNE.N    ??gcode_G29_86
   \   00000962   0x.... 0x....      BL       _Z30extrapolate_unprobed_bed_levelv
   5923                      print_bilinear_leveling_grid();
   \                     ??gcode_G29_86: (+1)
   \   00000966   0x.... 0x....      BL       _Z28print_bilinear_leveling_gridv
   5924          
   5925                      refresh_bed_level();
   \   0000096A   0x.... 0x....      BL       _Z17refresh_bed_levelv
   \   0000096E   0xE14C             B.N      ??gcode_G29_87
   5926          
   5927                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5928                        print_bilinear_leveling_grid_virt();
   5929                      #endif
   5930                 }
   5931                //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5932                 else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
   \                     ??gcode_G29_85: (+1)
   \   00000970   0x2804             CMP      R0,#+4
   \   00000972   0xF040 0x814A      BNE.W    ??gcode_G29_87
   5933                  {
   5934                  // For LINEAR leveling calculate matrix, print reports, correct the position
   5935          
   5936                  /**
   5937                   * solve the plane equation ax + by + d = z
   5938                   * A is the matrix with rows [x y 1] for all the probed points
   5939                   * B is the vector of the Z positions
   5940                   * the normal vector to the plane is formed by the coefficients of the
   5941                   * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
   5942                   * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
   5943                   */
   5944                  float plane_equation_coefficients[3];
   5945          
   5946                  finish_incremental_LSF(&lsf_results);
   \   00000976   0xA82B             ADD      R0,SP,#+172
   \   00000978   0x.... 0x....      BL       _Z22finish_incremental_LSFP15linear_fit_data
   5947                  plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
   \   0000097C   0x9F36             LDR      R7,[SP, #+216]
   \   0000097E   0x46BB             MOV      R11,R7
   \   00000980   0xF08B 0x4B00      EOR      R11,R11,#0x80000000
   5948                  plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
   \   00000984   0x9E37             LDR      R6,[SP, #+220]
   \   00000986   0x4635             MOV      R5,R6
   \   00000988   0xF085 0x4500      EOR      R5,R5,#0x80000000
   5949                  plane_equation_coefficients[2] = -lsf_results.D;
   \   0000098C   0xF8DD 0xA0E0      LDR      R10,[SP, #+224]
   \   00000990   0xF08A 0x4A00      EOR      R10,R10,#0x80000000
   5950          
   5951                  mean /= abl2;
   \   00000994   0x9811             LDR      R0,[SP, #+68]
   \   00000996   0x.... 0x....      BL       __aeabi_i2f
   \   0000099A   0x4601             MOV      R1,R0
   \   0000099C   0x4640             MOV      R0,R8
   \   0000099E   0x.... 0x....      BL       __aeabi_fdiv
   \   000009A2   0x4680             MOV      R8,R0
   5952          
   5953                  if (verbose_level) {
   \   000009A4   0x980A             LDR      R0,[SP, #+40]
   \   000009A6   0x2800             CMP      R0,#+0
   \   000009A8   0xD043             BEQ.N    ??gcode_G29_88
   5954                    SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
   \   000009AA   0xF8DF 0x03C8      LDR.W    R0,??gcode_G29_1+0x6C
   \   000009AE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5955                    SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
   \   000009B2   0xF8DF 0x43B0      LDR.W    R4,??gcode_G29_1+0x5C
   \   000009B6   0x2008             MOVS     R0,#+8
   \   000009B8   0x9000             STR      R0,[SP, #+0]
   \   000009BA   0x4658             MOV      R0,R11
   \   000009BC   0x.... 0x....      BL       __aeabi_f2d
   \   000009C0   0x4602             MOV      R2,R0
   \   000009C2   0x460B             MOV      R3,R1
   \   000009C4   0x4620             MOV      R0,R4
   \   000009C6   0x.... 0x....      BL       _ZN5Print5printEdi
   5956                    SERIAL_PROTOCOLPGM(" b: ");
   \   000009CA   0xF8DF 0x03AC      LDR.W    R0,??gcode_G29_1+0x70
   \   000009CE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5957                    SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
   \   000009D2   0x2008             MOVS     R0,#+8
   \   000009D4   0x9000             STR      R0,[SP, #+0]
   \   000009D6   0x4628             MOV      R0,R5
   \   000009D8   0x.... 0x....      BL       __aeabi_f2d
   \   000009DC   0x4602             MOV      R2,R0
   \   000009DE   0x460B             MOV      R3,R1
   \   000009E0   0x4620             MOV      R0,R4
   \   000009E2   0x.... 0x....      BL       _ZN5Print5printEdi
   5958                    SERIAL_PROTOCOLPGM(" d: ");
   \   000009E6   0xF8DF 0x0394      LDR.W    R0,??gcode_G29_1+0x74
   \   000009EA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5959                    SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
   \   000009EE   0x2008             MOVS     R0,#+8
   \   000009F0   0x9000             STR      R0,[SP, #+0]
   \   000009F2   0x4650             MOV      R0,R10
   \   000009F4   0x.... 0x....      BL       __aeabi_f2d
   \   000009F8   0x4602             MOV      R2,R0
   \   000009FA   0x460B             MOV      R3,R1
   \   000009FC   0x4620             MOV      R0,R4
   \   000009FE   0x.... 0x....      BL       _ZN5Print5printEdi
   5960                    SERIAL_EOL();
   \   00000A02   0x210A             MOVS     R1,#+10
   \   00000A04   0x4620             MOV      R0,R4
   \   00000A06   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5961                    if (verbose_level > 2) {
   \   00000A0A   0x980A             LDR      R0,[SP, #+40]
   \   00000A0C   0x2803             CMP      R0,#+3
   \   00000A0E   0xDB10             BLT.N    ??gcode_G29_88
   5962                      SERIAL_PROTOCOLPGM("Mean of sampled points: ");
   \   00000A10   0x48DB             LDR.N    R0,??gcode_G29_1+0x78
   \   00000A12   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5963                      SERIAL_PROTOCOL_F(mean, 8);
   \   00000A16   0x2008             MOVS     R0,#+8
   \   00000A18   0x9000             STR      R0,[SP, #+0]
   \   00000A1A   0x4640             MOV      R0,R8
   \   00000A1C   0x.... 0x....      BL       __aeabi_f2d
   \   00000A20   0x4602             MOV      R2,R0
   \   00000A22   0x460B             MOV      R3,R1
   \   00000A24   0x4620             MOV      R0,R4
   \   00000A26   0x.... 0x....      BL       _ZN5Print5printEdi
   5964                      SERIAL_EOL();
   \   00000A2A   0x210A             MOVS     R1,#+10
   \   00000A2C   0x4620             MOV      R0,R4
   \   00000A2E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5965                    }
   5966                  }
   5967          
   5968                  // Create the matrix but don't correct the position yet
   5969                  if (!dryrun)
   \                     ??gcode_G29_88: (+1)
   \   00000A32   0x980F             LDR      R0,[SP, #+60]
   \   00000A34   0x2800             CMP      R0,#+0
   \   00000A36   0xD111             BNE.N    ??gcode_G29_89
   5970                    planner.bed_level_matrix = matrix_3x3::create_look_at(
   5971                      vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
   5972                    );
   \   00000A38   0xF04F 0x537E      MOV      R3,#+1065353216
   \   00000A3C   0x4632             MOV      R2,R6
   \   00000A3E   0x4639             MOV      R1,R7
   \   00000A40   0xA800             ADD      R0,SP,#+0
   \   00000A42   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   00000A46   0xA800             ADD      R0,SP,#+0
   \   00000A48   0xE890 0x000E      LDM      R0,{R1-R3}
   \   00000A4C   0xA81F             ADD      R0,SP,#+124
   \   00000A4E   0x.... 0x....      BL       _ZN10matrix_3x314create_look_atE8vector_3
   \   00000A52   0x48C7             LDR.N    R0,??gcode_G29_1+0x68
   \   00000A54   0xA91F             ADD      R1,SP,#+124
   \   00000A56   0x2224             MOVS     R2,#+36
   \   00000A58   0x.... 0x....      BL       __aeabi_memcpy4
   5973          
   5974                  // Show the Topography map if enabled
   5975                  if (do_topography_map) {
   \                     ??gcode_G29_89: (+1)
   \   00000A5C   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000A60   0x2800             CMP      R0,#+0
   \   00000A62   0xF000 0x80D2      BEQ.W    ??gcode_G29_87
   5976          
   5977                    SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
   5978                                           "   +--- BACK --+\n"
   5979                                           "   |           |\n"
   5980                                           " L |    (+)    | R\n"
   5981                                           " E |           | I\n"
   5982                                           " F | (-) N (+) | G\n"
   5983                                           " T |           | H\n"
   5984                                           "   |    (-)    | T\n"
   5985                                           "   |           |\n"
   5986                                           "   O-- FRONT --+\n"
   5987                                           " (0,0)");
   \   00000A66   0x48C7             LDR.N    R0,??gcode_G29_1+0x7C
   \   00000A68   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5988          
   5989                    float min_diff = 999;
   \   00000A6C   0x4FC6             LDR.N    R7,??gcode_G29_1+0x80  ;; 0x4479c000
   5990          
   5991                    for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   \   00000A6E   0x9804             LDR      R0,[SP, #+16]
   \   00000A70   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \   00000A74   0xFA4F 0xFB8B      SXTB     R11,R11
   \   00000A78   0x46DA             MOV      R10,R11
   \   00000A7A   0xE007             B.N      ??gcode_G29_90
   5992                      for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5993                        int ind = indexIntoAB[xx][yy];
   5994                        /*
   5995                        float diff = eqnBVector[ind] - mean,
   5996                              x_tmp = eqnAMatrix[ind + 0 * abl2],
   5997                              y_tmp = eqnAMatrix[ind + 1 * abl2],
   5998                              z_tmp = 0;
   5999                              */
   6000                            float diff = *(eqnBVector+ind) - mean,
   6001                                  x_tmp = *(eqnAMatrix+ind + 0 * abl2),
   6002                                  y_tmp = *(eqnAMatrix+ind + 1 * abl2),
   6003                                  z_tmp = 0;
   6004          
   6005                        apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   6006          
   6007                        //NOMORE(min_diff, eqnBVector[ind] - z_tmp);
   6008                        NOMORE(min_diff, *(eqnBVector+ind) - z_tmp);
   6009          
   6010                        if (diff >= 0.0)
   6011                          SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
   6012                        else
   6013                          SERIAL_PROTOCOLCHAR(' ');
   6014                        SERIAL_PROTOCOL_F(diff, 5);
   6015                      } // xx
   6016                      SERIAL_EOL();
   \                     ??gcode_G29_91: (+1)
   \   00000A7C   0x210A             MOVS     R1,#+10
   \   00000A7E   0x48B9             LDR.N    R0,??gcode_G29_1+0x5C
   \   00000A80   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000A84   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \   00000A88   0xFA4F 0xFA8A      SXTB     R10,R10
   \                     ??gcode_G29_90: (+1)
   \   00000A8C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000A90   0xD454             BMI.N    ??gcode_G29_92
   \   00000A92   0x2500             MOVS     R5,#+0
   \   00000A94   0xE00E             B.N      ??gcode_G29_93
   \                     ??gcode_G29_94: (+1)
   \   00000A96   0x2120             MOVS     R1,#+32
   \   00000A98   0x4620             MOV      R0,R4
   \   00000A9A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??gcode_G29_95: (+1)
   \   00000A9E   0x2005             MOVS     R0,#+5
   \   00000AA0   0x9000             STR      R0,[SP, #+0]
   \   00000AA2   0x4630             MOV      R0,R6
   \   00000AA4   0x.... 0x....      BL       __aeabi_f2d
   \   00000AA8   0x4602             MOV      R2,R0
   \   00000AAA   0x460B             MOV      R3,R1
   \   00000AAC   0x4620             MOV      R0,R4
   \   00000AAE   0x.... 0x....      BL       _ZN5Print5printEdi
   \   00000AB2   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_G29_93: (+1)
   \   00000AB4   0xB2ED             UXTB     R5,R5
   \   00000AB6   0x4628             MOV      R0,R5
   \   00000AB8   0x990C             LDR      R1,[SP, #+48]
   \   00000ABA   0x4288             CMP      R0,R1
   \   00000ABC   0xDADE             BGE.N    ??gcode_G29_91
   \   00000ABE   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000AC2   0xA83A             ADD      R0,SP,#+232
   \   00000AC4   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   00000AC8   0xF850 0x402A      LDR      R4,[R0, R10, LSL #+2]
   \   00000ACC   0x9810             LDR      R0,[SP, #+64]
   \   00000ACE   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000AD2   0x4641             MOV      R1,R8
   \   00000AD4   0x.... 0x....      BL       __aeabi_fsub
   \   00000AD8   0x4606             MOV      R6,R0
   \   00000ADA   0x980B             LDR      R0,[SP, #+44]
   \   00000ADC   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000AE0   0x9014             STR      R0,[SP, #+80]
   \   00000AE2   0x9811             LDR      R0,[SP, #+68]
   \   00000AE4   0x990B             LDR      R1,[SP, #+44]
   \   00000AE6   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   00000AEA   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000AEE   0x9013             STR      R0,[SP, #+76]
   \   00000AF0   0x2000             MOVS     R0,#+0
   \   00000AF2   0x9012             STR      R0,[SP, #+72]
   \   00000AF4   0xA812             ADD      R0,SP,#+72
   \   00000AF6   0x9007             STR      R0,[SP, #+28]
   \   00000AF8   0xA813             ADD      R0,SP,#+76
   \   00000AFA   0x9006             STR      R0,[SP, #+24]
   \   00000AFC   0xA814             ADD      R0,SP,#+80
   \   00000AFE   0x9005             STR      R0,[SP, #+20]
   \   00000B00   0x499B             LDR.N    R1,??gcode_G29_1+0x68
   \   00000B02   0xB084             SUB      SP,SP,#+16
   \   00000B04   0x4668             MOV      R0,SP
   \   00000B06   0x2224             MOVS     R2,#+36
   \   00000B08   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000B0C   0xBC0F             POP      {R0-R3}
   \   00000B0E   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
   \   00000B12   0x9810             LDR      R0,[SP, #+64]
   \   00000B14   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000B18   0x9912             LDR      R1,[SP, #+72]
   \   00000B1A   0x.... 0x....      BL       __aeabi_fsub
   \   00000B1E   0x4639             MOV      R1,R7
   \   00000B20   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000B24   0xD200             BCS.N    ??gcode_G29_96
   \   00000B26   0x4607             MOV      R7,R0
   \                     ??gcode_G29_96: (+1)
   \   00000B28   0x4C8E             LDR.N    R4,??gcode_G29_1+0x5C
   \   00000B2A   0x4630             MOV      R0,R6
   \   00000B2C   0x2100             MOVS     R1,#+0
   \   00000B2E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000B32   0xD8B0             BHI.N    ??gcode_G29_94
   \   00000B34   0x4895             LDR.N    R0,??gcode_G29_1+0x84
   \   00000B36   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000B3A   0xE7B0             B.N      ??gcode_G29_95
   6017                    } // yy
   6018                    SERIAL_EOL();
   \                     ??gcode_G29_92: (+1)
   \   00000B3C   0x4C89             LDR.N    R4,??gcode_G29_1+0x5C
   \   00000B3E   0x210A             MOVS     R1,#+10
   \   00000B40   0x4620             MOV      R0,R4
   \   00000B42   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   6019          
   6020                    if (verbose_level > 3) {
   \   00000B46   0x980A             LDR      R0,[SP, #+40]
   \   00000B48   0x2804             CMP      R0,#+4
   \   00000B4A   0xDB5E             BLT.N    ??gcode_G29_87
   6021                      SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
   \   00000B4C   0x4890             LDR.N    R0,??gcode_G29_1+0x88
   \   00000B4E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   6022          
   6023                      for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   \   00000B52   0x46D8             MOV      R8,R11
   \   00000B54   0xE007             B.N      ??gcode_G29_97
   6024                        for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   6025                          int ind = indexIntoAB[xx][yy];
   6026                          /*
   6027                          float x_tmp = eqnAMatrix[ind + 0 * abl2],
   6028                                y_tmp = eqnAMatrix[ind + 1 * abl2],
   6029                                z_tmp = 0;
   6030                                */
   6031                          float x_tmp = *(eqnAMatrix+ind + 0 * abl2),
   6032                                y_tmp = *(eqnAMatrix+ind + 1 * abl2),
   6033                                z_tmp = 0;
   6034          
   6035                          apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   6036          
   6037                          //float diff = eqnBVector[ind] - z_tmp - min_diff;
   6038                          float diff = *(eqnBVector+ind) - z_tmp - min_diff;
   6039                          if (diff >= 0.0)
   6040                            SERIAL_PROTOCOLPGM(" +");
   6041                          // Include + for column alignment
   6042                          else
   6043                            SERIAL_PROTOCOLCHAR(' ');
   6044                          SERIAL_PROTOCOL_F(diff, 5);
   6045                        } // xx
   6046                        SERIAL_EOL();
   \                     ??gcode_G29_98: (+1)
   \   00000B56   0x210A             MOVS     R1,#+10
   \   00000B58   0x4620             MOV      R0,R4
   \   00000B5A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000B5E   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   00000B62   0xFA4F 0xF888      SXTB     R8,R8
   \                     ??gcode_G29_97: (+1)
   \   00000B66   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000B6A   0xD44A             BMI.N    ??gcode_G29_99
   \   00000B6C   0x2500             MOVS     R5,#+0
   \   00000B6E   0xE00E             B.N      ??gcode_G29_100
   \                     ??gcode_G29_101: (+1)
   \   00000B70   0x2120             MOVS     R1,#+32
   \   00000B72   0x4620             MOV      R0,R4
   \   00000B74   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??gcode_G29_102: (+1)
   \   00000B78   0x2005             MOVS     R0,#+5
   \   00000B7A   0x9000             STR      R0,[SP, #+0]
   \   00000B7C   0x4630             MOV      R0,R6
   \   00000B7E   0x.... 0x....      BL       __aeabi_f2d
   \   00000B82   0x4602             MOV      R2,R0
   \   00000B84   0x460B             MOV      R3,R1
   \   00000B86   0x4620             MOV      R0,R4
   \   00000B88   0x.... 0x....      BL       _ZN5Print5printEdi
   \   00000B8C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_G29_100: (+1)
   \   00000B8E   0xB2ED             UXTB     R5,R5
   \   00000B90   0x4628             MOV      R0,R5
   \   00000B92   0x990C             LDR      R1,[SP, #+48]
   \   00000B94   0x4288             CMP      R0,R1
   \   00000B96   0xDADE             BGE.N    ??gcode_G29_98
   \   00000B98   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000B9C   0xA83A             ADD      R0,SP,#+232
   \   00000B9E   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   00000BA2   0xF850 0x6028      LDR      R6,[R0, R8, LSL #+2]
   \   00000BA6   0x980B             LDR      R0,[SP, #+44]
   \   00000BA8   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000BAC   0x9014             STR      R0,[SP, #+80]
   \   00000BAE   0x9811             LDR      R0,[SP, #+68]
   \   00000BB0   0x990B             LDR      R1,[SP, #+44]
   \   00000BB2   0xEB01 0x0186      ADD      R1,R1,R6, LSL #+2
   \   00000BB6   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000BBA   0x9013             STR      R0,[SP, #+76]
   \   00000BBC   0x2000             MOVS     R0,#+0
   \   00000BBE   0x9012             STR      R0,[SP, #+72]
   \   00000BC0   0xA812             ADD      R0,SP,#+72
   \   00000BC2   0x9007             STR      R0,[SP, #+28]
   \   00000BC4   0xA813             ADD      R0,SP,#+76
   \   00000BC6   0x9006             STR      R0,[SP, #+24]
   \   00000BC8   0xA814             ADD      R0,SP,#+80
   \   00000BCA   0x9005             STR      R0,[SP, #+20]
   \   00000BCC   0x4968             LDR.N    R1,??gcode_G29_1+0x68
   \   00000BCE   0xB084             SUB      SP,SP,#+16
   \   00000BD0   0x4668             MOV      R0,SP
   \   00000BD2   0x2224             MOVS     R2,#+36
   \   00000BD4   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000BD8   0xBC0F             POP      {R0-R3}
   \   00000BDA   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
   \   00000BDE   0x9810             LDR      R0,[SP, #+64]
   \   00000BE0   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000BE4   0x9912             LDR      R1,[SP, #+72]
   \   00000BE6   0x.... 0x....      BL       __aeabi_fsub
   \   00000BEA   0x4639             MOV      R1,R7
   \   00000BEC   0x.... 0x....      BL       __aeabi_fsub
   \   00000BF0   0x4606             MOV      R6,R0
   \   00000BF2   0x2100             MOVS     R1,#+0
   \   00000BF4   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000BF8   0xD8BA             BHI.N    ??gcode_G29_101
   \   00000BFA   0x4864             LDR.N    R0,??gcode_G29_1+0x84
   \   00000BFC   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000C00   0xE7BA             B.N      ??gcode_G29_102
   6047                      } // yy
   6048                      SERIAL_EOL();
   \                     ??gcode_G29_99: (+1)
   \   00000C02   0x210A             MOVS     R1,#+10
   \   00000C04   0x4620             MOV      R0,R4
   \   00000C06   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   6049                    }
   6050                  } //do_topography_map
   6051                  }
   6052                //#endif // AUTO_BED_LEVELING_LINEAR
   6053          
   6054                //#if ABL_PLANAR
   6055                if(BED_LEVELING_METHOD&ABL_PLANAR)  {
   \                     ??gcode_G29_87: (+1)
   \   00000C0A   0x483F             LDR.N    R0,??gcode_G29_1
   \   00000C0C   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000C10   0x2106             MOVS     R1,#+6
   \   00000C12   0x4208             TST      R0,R1
   \   00000C14   0xD047             BEQ.N    ??gcode_G29_103
   6056          
   6057                  // For LINEAR and 3POINT leveling correct the current position
   6058          
   6059                  if (verbose_level > 0)
   \   00000C16   0x980A             LDR      R0,[SP, #+40]
   \   00000C18   0x2801             CMP      R0,#+1
   \   00000C1A   0xDB03             BLT.N    ??gcode_G29_104
   6060                    planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
   \   00000C1C   0x495D             LDR.N    R1,??gcode_G29_1+0x8C
   \   00000C1E   0x4854             LDR.N    R0,??gcode_G29_1+0x68
   \   00000C20   0x.... 0x....      BL       _ZN10matrix_3x35debugEPKc
   6061          
   6062                  if (!dryrun) {
   \                     ??gcode_G29_104: (+1)
   \   00000C24   0x980F             LDR      R0,[SP, #+60]
   \   00000C26   0x2800             CMP      R0,#+0
   \   00000C28   0xD14C             BNE.N    ??gcode_G29_105
   6063                    //
   6064                    // Correct the current XYZ position based on the tilted plane.
   6065                    //
   6066          
   6067                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6068                      if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
   6069                    #endif
   6070          
   6071                    float converted[XYZ];
   6072                    COPY(converted, current_position);
   \   00000C2A   0x4C3F             LDR.N    R4,??gcode_G29_1+0x20
   \   00000C2C   0x220C             MOVS     R2,#+12
   \   00000C2E   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000C32   0xA800             ADD      R0,SP,#+0
   \   00000C34   0x.... 0x....      BL       memcpy
   6073          
   6074                    planner.leveling_active = true;
   \   00000C38   0x2001             MOVS     R0,#+1
   \   00000C3A   0x4938             LDR.N    R1,??gcode_G29_1+0x14
   \   00000C3C   0x7008             STRB     R0,[R1, #+0]
   6075                    planner.unapply_leveling(converted); // use conversion machinery
   \   00000C3E   0xA800             ADD      R0,SP,#+0
   \   00000C40   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   6076                    planner.leveling_active = false;
   \   00000C44   0x2000             MOVS     R0,#+0
   \   00000C46   0x4935             LDR.N    R1,??gcode_G29_1+0x14
   \   00000C48   0x7008             STRB     R0,[R1, #+0]
   6077          
   6078                    // Use the last measured distance to the bed, if possible
   6079                    if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
   6080                      && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
   6081                    ) {
   \   00000C4A   0x9808             LDR      R0,[SP, #+32]
   \   00000C4C   0x68C0             LDR      R0,[R0, #+12]
   \   00000C4E   0x990E             LDR      R1,[SP, #+56]
   \   00000C50   0x.... 0x....      BL       __aeabi_fsub
   \   00000C54   0x68A1             LDR      R1,[R4, #+8]
   \   00000C56   0x.... 0x....      BL       __aeabi_fadd
   \   00000C5A   0x4D4F             LDR.N    R5,??gcode_G29_1+0x90  ;; 0xb58637bd
   \   00000C5C   0x4629             MOV      R1,R5
   \   00000C5E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000C62   0xD819             BHI.N    ??gcode_G29_106
   \   00000C64   0x4E4D             LDR.N    R6,??gcode_G29_1+0x94  ;; 0x358637be
   \   00000C66   0x4631             MOV      R1,R6
   \   00000C68   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C6C   0xD214             BCS.N    ??gcode_G29_106
   \   00000C6E   0x9808             LDR      R0,[SP, #+32]
   \   00000C70   0x6900             LDR      R0,[R0, #+16]
   \   00000C72   0x990D             LDR      R1,[SP, #+52]
   \   00000C74   0x.... 0x....      BL       __aeabi_fsub
   \   00000C78   0x68E1             LDR      R1,[R4, #+12]
   \   00000C7A   0x.... 0x....      BL       __aeabi_fadd
   \   00000C7E   0x4629             MOV      R1,R5
   \   00000C80   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000C84   0xD808             BHI.N    ??gcode_G29_106
   \   00000C86   0x4631             MOV      R1,R6
   \   00000C88   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C8C   0xD204             BCS.N    ??gcode_G29_106
   6082                      const float simple_z = current_position[Z_AXIS] - measured_z;
   6083                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   6084                        if (DEBUGGING(LEVELING)) {
   6085                          SERIAL_ECHOPAIR("Z from Probe:", simple_z);
   6086                          SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
   6087                          SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
   6088                        }
   6089                      #endif
   6090                      converted[Z_AXIS] = simple_z;
   \   00000C8E   0x6920             LDR      R0,[R4, #+16]
   \   00000C90   0x9909             LDR      R1,[SP, #+36]
   \   00000C92   0x.... 0x....      BL       __aeabi_fsub
   \   00000C96   0x9002             STR      R0,[SP, #+8]
   6091                    }
   6092          
   6093                    // The rotated XY and corrected Z are now current_position
   6094                    COPY(current_position, converted);
   \                     ??gcode_G29_106: (+1)
   \   00000C98   0x220C             MOVS     R2,#+12
   \   00000C9A   0xA900             ADD      R1,SP,#+0
   \   00000C9C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000CA0   0x.... 0x....      BL       memcpy
   \   00000CA4   0xE00E             B.N      ??gcode_G29_105
   6095          
   6096                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6097                      if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
   6098                    #endif
   6099                  }
   6100                  }
   6101                //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   6102                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
   \                     ??gcode_G29_103: (+1)
   \   00000CA6   0x2808             CMP      R0,#+8
   \   00000CA8   0xD10C             BNE.N    ??gcode_G29_105
   6103          
   6104                  if (!dryrun) {
   \   00000CAA   0x980F             LDR      R0,[SP, #+60]
   \   00000CAC   0x2800             CMP      R0,#+0
   \   00000CAE   0xD109             BNE.N    ??gcode_G29_105
   6105                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6106                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
   6107                    #endif
   6108          
   6109                    // Unapply the offset because it is going to be immediately applied
   6110                    // and cause compensation movement in Z
   6111                    current_position[Z_AXIS] -= bilinear_z_offset(current_position);
   \   00000CB0   0x4C1D             LDR.N    R4,??gcode_G29_1+0x20
   \   00000CB2   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000CB6   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   00000CBA   0x4601             MOV      R1,R0
   \   00000CBC   0x6920             LDR      R0,[R4, #+16]
   \   00000CBE   0x.... 0x....      BL       __aeabi_fsub
   \   00000CC2   0x6120             STR      R0,[R4, #+16]
   6112          
   6113                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6114                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
   6115                    #endif
   6116                  }
   6117                  }
   6118                //#endif // ABL_PLANAR
   6119          
   6120                #ifdef Z_PROBE_END_SCRIPT
   6121                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   6122                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
   6123                  #endif
   6124                  enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
   6125                  stepper.synchronize();
   6126                #endif
   6127          
   6128                // Auto Bed Leveling is complete! Enable if possible.
   6129                planner.leveling_active = dryrun ? abl_should_enable : true;
   \                     ??gcode_G29_105: (+1)
   \   00000CC4   0x980F             LDR      R0,[SP, #+60]
   \   00000CC6   0x2800             CMP      R0,#+0
   \   00000CC8   0xD003             BEQ.N    ??gcode_G29_107
   \   00000CCA   0x4814             LDR.N    R0,??gcode_G29_1+0x14
   \   00000CCC   0xF880 0x9000      STRB     R9,[R0, #+0]
   \   00000CD0   0xE002             B.N      ??gcode_G29_84
   \                     ??gcode_G29_107: (+1)
   \   00000CD2   0x2001             MOVS     R0,#+1
   \   00000CD4   0x4911             LDR.N    R1,??gcode_G29_1+0x14
   \   00000CD6   0x7008             STRB     R0,[R1, #+0]
   6130              } // !isnan(measured_z)
   6131          
   6132              // Restore state after probing
   6133              if (!faux) clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G29_84: (+1)
   \   00000CD8   0x.... 0x....      BL       _Z36clean_up_after_endstop_or_probe_movev
   6134          
   6135              #if ENABLED(DEBUG_LEVELING_FEATURE)
   6136                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   6137              #endif
   6138          
   6139              report_current_position();
   \   00000CDC   0x.... 0x....      BL       _Z23report_current_positionv
   6140          
   6141              KEEPALIVE_STATE(IN_HANDLER);
   \   00000CE0   0x2001             MOVS     R0,#+1
   \   00000CE2   0x490B             LDR.N    R1,??gcode_G29_1+0x8
   \   00000CE4   0x7188             STRB     R0,[R1, #+6]
   6142          
   6143              if (planner.leveling_active)
   \   00000CE6   0x480D             LDR.N    R0,??gcode_G29_1+0x14
   \   00000CE8   0x7800             LDRB     R0,[R0, #+0]
   \   00000CEA   0x2800             CMP      R0,#+0
   \   00000CEC   0xD001             BEQ.N    ??gcode_G29_108
   6144                SYNC_PLAN_POSITION_KINEMATIC();
   \   00000CEE   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   6145          
   6146              free(eqnBVector);
   \                     ??gcode_G29_108: (+1)
   \   00000CF2   0x9810             LDR      R0,[SP, #+64]
   \   00000CF4   0x.... 0x....      BL       free
   6147          	free(eqnAMatrix);
   \   00000CF8   0x980B             LDR      R0,[SP, #+44]
   \   00000CFA   0x.... 0x....      BL       free
   6148            }
   \                     ??gcode_G29_0: (+1)
   \   00000CFE   0xF50D 0x7D4B      ADD      SP,SP,#+812
   \   00000D02   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \   00000D06   0xBF00             Nop      
   \                     ??gcode_G29_1:
   \   00000D08   0x........         DC32     mksCfg
   \   00000D0C   0x........         DC32     mksCfg+0x60
   \   00000D10   0x........         DC32     axis_relative_modes
   \   00000D14   0x........         DC32     _ZZ9gcode_G29vEs
   \   00000D18   0x........         DC32     _ZZ9gcode_G29vEs_0
   \   00000D1C   0x........         DC32     _ZN7Planner15leveling_activeE
   \   00000D20   0x........         DC32     errormagic
   \   00000D24   0x........         DC32     _ZZ9gcode_G29vEs_1
   \   00000D28   0x........         DC32     mks_heating_busy
   \   00000D2C   0xC1200000         DC32     0xc1200000
   \   00000D30   0x41200001         DC32     0x41200001
   \   00000D34   0x........         DC32     _ZZ9gcode_G29vEs_2
   \   00000D38   0x........         DC32     z_values
   \   00000D3C   0x........         DC32     _ZZ9gcode_G29vEs_3
   \   00000D40   0x........         DC32     _ZZ9gcode_G29vEs_4
   \   00000D44   0x42700000         DC32     0x42700000
   \   00000D48   0x........         DC32     mksTmp
   \   00000D4C   0x........         DC32     _ZZ9gcode_G29vEs_5
   \   00000D50   0x........         DC32     _ZZ9gcode_G29vEs_6
   \   00000D54   0x........         DC32     _ZZ9gcode_G29vEs_7
   \   00000D58   0x........         DC32     _ZZ9gcode_G29vEs_8
   \   00000D5C   0x........         DC32     _ZZ9gcode_G29vEs_9
   \   00000D60   0x........         DC32     _ZZ9gcode_G29vEs__10_
   \   00000D64   0x........         DC32     Serial3
   \   00000D68   0x3FE00000         DC32     0x3fe00000
   \   00000D6C   0xBF800000         DC32     0xbf800000
   \   00000D70   0x........         DC32     _ZN7Planner16bed_level_matrixE
   \   00000D74   0x........         DC32     _ZZ9gcode_G29vEs__11_
   \   00000D78   0x........         DC32     _ZZ9gcode_G29vEs__12_
   \   00000D7C   0x........         DC32     _ZZ9gcode_G29vEs__13_
   \   00000D80   0x........         DC32     _ZZ9gcode_G29vEs__14_
   \   00000D84   0x........         DC32     _ZZ9gcode_G29vEs__15_
   \   00000D88   0x4479C000         DC32     0x4479c000
   \   00000D8C   0x........         DC32     _ZZ9gcode_G29vEs__16_
   \   00000D90   0x........         DC32     _ZZ9gcode_G29vEs__17_
   \   00000D94   0x........         DC32     _ZZ9gcode_G29vEs__18_
   \   00000D98   0xB58637BD         DC32     0xb58637bd
   \   00000D9C   0x358637BE         DC32     0x358637be
   6149          
   6150          #endif // OLDSCHOOL_ABL
   6151          
   6152          #if HAS_BED_PROBE
   6153          
   6154            /**
   6155             * G30: Do a single Z probe at the current XY
   6156             *
   6157             * Parameters:
   6158             *
   6159             *   X   Probe X position (default current X)
   6160             *   Y   Probe Y position (default current Y)
   6161             *   E   Engage the probe for each probe
   6162             */

   \                                 In section .text, align 4
   6163            inline void gcode_G30() {
   \                     _Z9gcode_G30v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   6164              const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
   \   00000004   0x4C37             LDR.N    R4,??gcode_G30_0
   \   00000006   0xF104 0x0540      ADD      R5,R4,#+64
   \   0000000A   0x4E37             LDR.N    R6,??gcode_G30_0+0x4
   \   0000000C   0x68B1             LDR      R1,[R6, #+8]
   \   0000000E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000010   0x.... 0x....      BL       __aeabi_fadd
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x2058             MOVS     R0,#+88
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000001C   0x9002             STR      R0,[SP, #+8]
   6165                          ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
   \   0000001E   0x68F1             LDR      R1,[R6, #+12]
   \   00000020   0x6B28             LDR      R0,[R5, #+48]
   \   00000022   0x.... 0x....      BL       __aeabi_fadd
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x2059             MOVS     R0,#+89
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000002E   0x9001             STR      R0,[SP, #+4]
   6166              if(MACHINETPYE & IS_KINEMATIC)
   \   00000030   0x8B28             LDRH     R0,[R5, #+24]
   \   00000032   0xF240 0x3102      MOVW     R1,#+770
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD00B             BEQ.N    ??gcode_G30_1
   6167                  if (!position_is_reachable_by_probe_IS_KINEMATIC(xpos, ypos)) return;
   \   0000003A   0xA901             ADD      R1,SP,#+4
   \   0000003C   0xA802             ADD      R0,SP,#+8
   \   0000003E   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD04D             BEQ.N    ??gcode_G30_2
   6168              else
   6169                  if (!position_is_reachable_by_probe_IS_CARTESIAN(xpos, ypos)) return;
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0xA802             ADD      R0,SP,#+8
   \   0000004A   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD047             BEQ.N    ??gcode_G30_2
   6170          
   6171              // Disable leveling so the planner won't mess with us
   6172              //#if HAS_LEVELING
   6173          	if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??gcode_G30_1: (+1)
   \   00000052   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   00000056   0x213E             MOVS     R1,#+62
   \   00000058   0x4208             TST      R0,R1
   \   0000005A   0xD002             BEQ.N    ??gcode_G30_3
   6174                set_bed_leveling_enabled(false);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   6175              //#endif
   6176          
   6177              setup_for_endstop_or_probe_move();
   \                     ??gcode_G30_3: (+1)
   \   00000062   0x.... 0x....      BL       _Z31setup_for_endstop_or_probe_movev
   6178          
   6179              const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
   \   00000066   0x2045             MOVS     R0,#+69
   \   00000068   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x9100             STR      R1,[SP, #+0]
   \   00000070   0x460B             MOV      R3,R1
   \   00000072   0x4602             MOV      R2,R0
   \   00000074   0xA901             ADD      R1,SP,#+4
   \   00000076   0xA802             ADD      R0,SP,#+8
   \   00000078   0x.... 0x....      BL       _Z8probe_ptRKfS0_bhb
   \   0000007C   0x4606             MOV      R6,R0
   6180          
   6181              if (!isnan(measured_z)) {
   \   0000007E   0x.... 0x....      BL       __iar_FDtest
   \   00000082   0x2802             CMP      R0,#+2
   \   00000084   0xD029             BEQ.N    ??gcode_G30_4
   6182                SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
   \   00000086   0x4C19             LDR.N    R4,??gcode_G30_0+0x8  ;; 0x88e368f1
   \   00000088   0x4D19             LDR.N    R5,??gcode_G30_0+0xC  ;; 0x3ee4f8b5
   \   0000008A   0x9802             LDR      R0,[SP, #+8]
   \   0000008C   0x.... 0x....      BL       __aeabi_f2d
   \   00000090   0x4622             MOV      R2,R4
   \   00000092   0x462B             MOV      R3,R5
   \   00000094   0x.... 0x....      BL       __aeabi_dadd
   \   00000098   0x4602             MOV      R2,R0
   \   0000009A   0x460B             MOV      R3,R1
   \   0000009C   0x4815             LDR.N    R0,??gcode_G30_0+0x10
   \   0000009E   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   6183                SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
   \   000000A2   0x9801             LDR      R0,[SP, #+4]
   \   000000A4   0x.... 0x....      BL       __aeabi_f2d
   \   000000A8   0x4622             MOV      R2,R4
   \   000000AA   0x462B             MOV      R3,R5
   \   000000AC   0x.... 0x....      BL       __aeabi_dadd
   \   000000B0   0x4602             MOV      R2,R0
   \   000000B2   0x460B             MOV      R3,R1
   \   000000B4   0x4810             LDR.N    R0,??gcode_G30_0+0x14
   \   000000B6   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   6184                SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
   \   000000BA   0x4630             MOV      R0,R6
   \   000000BC   0x.... 0x....      BL       __aeabi_f2d
   \   000000C0   0x4622             MOV      R2,R4
   \   000000C2   0x462B             MOV      R3,R5
   \   000000C4   0x.... 0x....      BL       __aeabi_dadd
   \   000000C8   0x4602             MOV      R2,R0
   \   000000CA   0x460B             MOV      R3,R1
   \   000000CC   0x480B             LDR.N    R0,??gcode_G30_0+0x18
   \   000000CE   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   \   000000D2   0x210A             MOVS     R1,#+10
   \   000000D4   0x480A             LDR.N    R0,??gcode_G30_0+0x1C
   \   000000D6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   6185              }
   6186          
   6187              clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G30_4: (+1)
   \   000000DA   0x.... 0x....      BL       _Z36clean_up_after_endstop_or_probe_movev
   6188          
   6189              report_current_position();
   \   000000DE   0x.... 0x....      BL       _Z23report_current_positionv
   6190            }
   \                     ??gcode_G30_2: (+1)
   \   000000E2   0xBD7F             POP      {R0-R6,PC}       ;; return
   \                     ??gcode_G30_0:
   \   000000E4   0x........         DC32     mksCfg
   \   000000E8   0x........         DC32     mks_heating_busy
   \   000000EC   0x88E368F1         DC32     0x88e368f1
   \   000000F0   0x3EE4F8B5         DC32     0x3ee4f8b5
   \   000000F4   0x........         DC32     _ZZ9gcode_G30vEs
   \   000000F8   0x........         DC32     _ZZ9gcode_G30vEs_0
   \   000000FC   0x........         DC32     _ZZ9gcode_G30vEs_1
   \   00000100   0x........         DC32     Serial3
   6191          
   6192            #if ENABLED(Z_PROBE_SLED)
   6193          
   6194              /**
   6195               * G31: Deploy the Z probe
   6196               */
   6197              inline void gcode_G31() { DEPLOY_PROBE(); }
   6198          
   6199              /**
   6200               * G32: Stow the Z probe
   6201               */
   6202              inline void gcode_G32() { STOW_PROBE(); }
   6203          
   6204            #endif // Z_PROBE_SLED
   6205          
   6206          #endif // HAS_BED_PROBE
   6207          
   6208          #if ENABLED(DELTA_AUTO_CALIBRATION)
   6209          
   6210            constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
   6211                              _4P_STEP = _7P_STEP * 2,   // 4-point step
   6212                              NPP      = _7P_STEP * 6;   // number of calibration points on the radius
   6213            enum CalEnum {                               // the 7 main calibration points - add definitions if needed
   6214              CEN      = 0,
   6215              __A      = 1,
   6216              _AB      = __A + _7P_STEP,
   6217              __B      = _AB + _7P_STEP,
   6218              _BC      = __B + _7P_STEP,
   6219              __C      = _BC + _7P_STEP,
   6220              _CA      = __C + _7P_STEP,
   6221            };
   6222          
   6223            #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
   6224            #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
   6225            #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
   6226            #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
   6227            #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
   6228            #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
   6229          
   6230            static void print_signed_float(const char * const prefix, const float &f) {
   6231              SERIAL_PROTOCOLPGM("  ");
   6232              serialprintPGM(prefix);
   6233              SERIAL_PROTOCOLCHAR(':');
   6234              if (f >= 0) SERIAL_CHAR('+');
   6235              SERIAL_PROTOCOL_F(f, 2);
   6236            }
   6237          
   6238            static void print_G33_settings(const bool end_stops, const bool tower_angles) {
   6239              SERIAL_PROTOCOLPAIR(".Height:", delta_height);
   6240              if (end_stops) {
   6241                print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
   6242                print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
   6243                print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
   6244              }
   6245              if (end_stops && tower_angles) {
   6246                SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   6247                SERIAL_EOL();
   6248                SERIAL_CHAR('.');
   6249                SERIAL_PROTOCOL_SP(13);
   6250              }
   6251              if (tower_angles) {
   6252                print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
   6253                print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
   6254                print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
   6255              }
   6256              if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
   6257                SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   6258              }
   6259              SERIAL_EOL();
   6260            }
   6261          
   6262            static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   6263              SERIAL_PROTOCOLPGM(".    ");
   6264              print_signed_float(PSTR("c"), z_at_pt[CEN]);
   6265              if (tower_points) {
   6266                print_signed_float(PSTR(" x"), z_at_pt[__A]);
   6267                print_signed_float(PSTR(" y"), z_at_pt[__B]);
   6268                print_signed_float(PSTR(" z"), z_at_pt[__C]);
   6269              }
   6270              if (tower_points && opposite_points) {
   6271                SERIAL_EOL();
   6272                SERIAL_CHAR('.');
   6273                SERIAL_PROTOCOL_SP(13);
   6274              }
   6275              if (opposite_points) {
   6276                print_signed_float(PSTR("yz"), z_at_pt[_BC]);
   6277                print_signed_float(PSTR("zx"), z_at_pt[_CA]);
   6278                print_signed_float(PSTR("xy"), z_at_pt[_AB]);
   6279              }
   6280              SERIAL_EOL();
   6281            }
   6282          
   6283            /**
   6284             * After G33:
   6285             *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
   6286             *  - Stow the probe
   6287             *  - Restore endstops state
   6288             *  - Select the old tool, if needed
   6289             */
   6290            static void G33_cleanup(
   6291              #if HOTENDS > 1
   6292                const uint8_t old_tool_index
   6293              #endif
   6294            ) {
   6295              #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
   6296                do_blocking_move_to_z(delta_clip_start_height);
   6297              #endif
   6298              STOW_PROBE();
   6299              clean_up_after_endstop_or_probe_move();
   6300              #if HOTENDS > 1
   6301                tool_change(old_tool_index, 0, true);
   6302              #endif
   6303            }
   6304          
   6305            inline float calibration_probe(const float nx, const float ny, const bool stow) {
   6306              #if HAS_BED_PROBE
   6307                return probe_pt(nx, ny, stow, 0, false);
   6308              #else
   6309                UNUSED(stow);
   6310                return lcd_probe_pt(nx, ny);
   6311              #endif
   6312            }
   6313          
   6314            static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   6315              const bool _0p_calibration      = probe_points == 0,
   6316                         _1p_calibration      = probe_points == 1,
   6317                         _4p_calibration      = probe_points == 2,
   6318                         _4p_opposite_points  = _4p_calibration && !towers_set,
   6319                         _7p_calibration      = probe_points >= 3 || probe_points == 0,
   6320                         _7p_no_intermediates = probe_points == 3,
   6321                         _7p_1_intermediates  = probe_points == 4,
   6322                         _7p_2_intermediates  = probe_points == 5,
   6323                         _7p_4_intermediates  = probe_points == 6,
   6324                         _7p_6_intermediates  = probe_points == 7,
   6325                         _7p_8_intermediates  = probe_points == 8,
   6326                         _7p_11_intermediates = probe_points == 9,
   6327                         _7p_14_intermediates = probe_points == 10,
   6328                         _7p_intermed_points  = probe_points >= 4,
   6329                         _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
   6330                         _7p_9_centre         = probe_points >= 8;
   6331          
   6332              LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
   6333          
   6334              if (!_0p_calibration) {
   6335          
   6336                if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
   6337                  z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
   6338                  if (isnan(z_at_pt[CEN])) return NAN;
   6339                }
   6340          
   6341                if (_7p_calibration) { // probe extra center points
   6342                  const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
   6343                              steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
   6344                  I_LOOP_CAL_PT(axis, start, steps) {
   6345                    const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   6346                                r = delta_calibration_radius * 0.1;
   6347                    z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
   6348                    if (isnan(z_at_pt[CEN])) return NAN;
   6349                 }
   6350                  z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
   6351                }
   6352          
   6353                if (!_1p_calibration) {  // probe the radius
   6354                  const CalEnum start  = _4p_opposite_points ? _AB : __A;
   6355                  const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
   6356                                         _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
   6357                                         _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
   6358                                         _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
   6359                                         _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
   6360                                         _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
   6361                                         _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
   6362                                         _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
   6363                                         _4P_STEP;                                // .5r * 6 +  1c = 4
   6364                  bool zig_zag = true;
   6365                  F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
   6366                    const int8_t offset = _7p_9_centre ? 1 : 0;
   6367                    for (int8_t circle = -offset; circle <= offset; circle++) {
   6368                      const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   6369                                  r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
   6370                                  interpol = fmod(axis, 1);
   6371                      const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
   6372                      if (isnan(z_temp)) return NAN;
   6373                      // split probe point to neighbouring calibration points
   6374                      z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
   6375                      z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
   6376                    }
   6377                    zig_zag = !zig_zag;
   6378                  }
   6379                  if (_7p_intermed_points)
   6380                    LOOP_CAL_RAD(axis)
   6381                      z_at_pt[axis] /= _7P_STEP / steps;
   6382                }
   6383          
   6384                float S1 = z_at_pt[CEN],
   6385                      S2 = sq(z_at_pt[CEN]);
   6386                int16_t N = 1;
   6387                if (!_1p_calibration) { // std dev from zero plane
   6388                  LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
   6389                    S1 += z_at_pt[axis];
   6390                    S2 += sq(z_at_pt[axis]);
   6391                    N++;
   6392                  }
   6393                  return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
   6394                }
   6395              }
   6396          
   6397              return 0.00001;
   6398            }
   6399          
   6400            #if HAS_BED_PROBE
   6401          
   6402              static bool G33_auto_tune() {
   6403                float z_at_pt[NPP + 1]      = { 0.0 },
   6404                      z_at_pt_base[NPP + 1] = { 0.0 },
   6405                      z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
   6406          
   6407                #define ZP(N,I) ((N) * z_at_pt[I])
   6408                #define Z06(I)  ZP(6, I)
   6409                #define Z03(I)  ZP(3, I)
   6410                #define Z02(I)  ZP(2, I)
   6411                #define Z01(I)  ZP(1, I)
   6412                #define Z32(I)  ZP(3/2, I)
   6413          
   6414                SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
   6415                SERIAL_EOL();
   6416                if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
   6417                print_G33_results(z_at_pt_base, true, true);
   6418          
   6419                LOOP_XYZ(axis) {
   6420                  delta_endstop_adj[axis] -= 1.0;
   6421                  recalc_delta_settings();
   6422          
   6423                  endstops.enable(true);
   6424                  if (!home_delta()) return false;
   6425                  endstops.not_homing();
   6426          
   6427                  SERIAL_PROTOCOLPGM("Tuning E");
   6428                  SERIAL_CHAR(tolower(axis_codes[axis]));
   6429                  SERIAL_EOL();
   6430          
   6431                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6432                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6433                  print_G33_results(z_at_pt, true, true);
   6434                  delta_endstop_adj[axis] += 1.0;
   6435                  recalc_delta_settings();
   6436                  switch (axis) {
   6437                    case A_AXIS :
   6438                      h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
   6439                      break;
   6440                    case B_AXIS :
   6441                      h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
   6442                      break;
   6443                    case C_AXIS :
   6444                      h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
   6445                      break;
   6446                  }
   6447                }
   6448                h_fac /= 3.0;
   6449                h_fac *= norm; // Normalize to 1.02 for Kossel mini
   6450          
   6451                for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
   6452                  delta_radius += 1.0 * zig_zag;
   6453                  recalc_delta_settings();
   6454          
   6455                  endstops.enable(true);
   6456                  if (!home_delta()) return false;
   6457                  endstops.not_homing();
   6458          
   6459                  SERIAL_PROTOCOLPGM("Tuning R");
   6460                  SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
   6461                  SERIAL_EOL();
   6462                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6463                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6464                  print_G33_results(z_at_pt, true, true);
   6465                  delta_radius -= 1.0 * zig_zag;
   6466                  recalc_delta_settings();
   6467                  r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
   6468                }
   6469                r_fac /= 2.0;
   6470                r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
   6471          
   6472                LOOP_XYZ(axis) {
   6473                  delta_tower_angle_trim[axis] += 1.0;
   6474                  delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
   6475                  delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
   6476                  z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6477                  delta_height -= z_temp;
   6478                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6479                  recalc_delta_settings();
   6480          
   6481                  endstops.enable(true);
   6482                  if (!home_delta()) return false;
   6483                  endstops.not_homing();
   6484          
   6485                  SERIAL_PROTOCOLPGM("Tuning T");
   6486                  SERIAL_CHAR(tolower(axis_codes[axis]));
   6487                  SERIAL_EOL();
   6488          
   6489                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6490                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6491                  print_G33_results(z_at_pt, true, true);
   6492          
   6493                  delta_tower_angle_trim[axis] -= 1.0;
   6494                  delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
   6495                  delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
   6496                  z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6497                  delta_height -= z_temp;
   6498                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6499                  recalc_delta_settings();
   6500                  switch (axis) {
   6501                    case A_AXIS :
   6502                      a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
   6503                      break;
   6504                    case B_AXIS :
   6505                      a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
   6506                      break;
   6507                    case C_AXIS :
   6508                      a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
   6509                      break;
   6510                  }
   6511                }
   6512                a_fac /= 3.0;
   6513                a_fac *= norm; // Normalize to 0.83 for Kossel mini
   6514          
   6515                endstops.enable(true);
   6516                if (!home_delta()) return false;
   6517                endstops.not_homing();
   6518                print_signed_float(PSTR( "H_FACTOR: "), h_fac);
   6519                print_signed_float(PSTR(" R_FACTOR: "), r_fac);
   6520                print_signed_float(PSTR(" A_FACTOR: "), a_fac);
   6521                SERIAL_EOL();
   6522                SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
   6523                SERIAL_EOL();
   6524                return true;
   6525              }
   6526          
   6527            #endif // HAS_BED_PROBE
   6528          
   6529            /**
   6530             * G33 - Delta '1-4-7-point' Auto-Calibration
   6531             *       Calibrate height, endstops, delta radius, and tower angles.
   6532             *
   6533             * Parameters:
   6534             *
   6535             *   Pn  Number of probe points:
   6536             *      P0     No probe. Normalize only.
   6537             *      P1     Probe center and set height only.
   6538             *      P2     Probe center and towers. Set height, endstops and delta radius.
   6539             *      P3     Probe all positions: center, towers and opposite towers. Set all.
   6540             *      P4-P10 Probe all positions + at different itermediate locations and average them.
   6541             *
   6542             *   T   Don't calibrate tower angle corrections
   6543             *
   6544             *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
   6545             *
   6546             *   Fn  Force to run at least n iterations and takes the best result
   6547             *
   6548             *   A   Auto tune calibartion factors (set in Configuration.h)
   6549             *
   6550             *   Vn  Verbose level:
   6551             *      V0  Dry-run mode. Report settings and probe results. No calibration.
   6552             *      V1  Report start and end settings only
   6553             *      V2  Report settings at each iteration
   6554             *      V3  Report settings and probe results
   6555             *
   6556             *   E   Engage the probe for each point
   6557             */
   6558            inline void gcode_G33() {
   6559          
   6560              const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   6561              if (!WITHIN(probe_points, 0, 10)) {
   6562                SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
   6563                return;
   6564              }
   6565          
   6566              const int8_t verbose_level = parser.byteval('V', 1);
   6567              if (!WITHIN(verbose_level, 0, 3)) {
   6568                SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
   6569                return;
   6570              }
   6571          
   6572              const float calibration_precision = parser.floatval('C', 0.0);
   6573              if (calibration_precision < 0) {
   6574                SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
   6575                return;
   6576              }
   6577          
   6578              const int8_t force_iterations = parser.intval('F', 0);
   6579              if (!WITHIN(force_iterations, 0, 30)) {
   6580                SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
   6581                return;
   6582              }
   6583          
   6584              const bool towers_set           = !parser.boolval('T'),
   6585                         auto_tune            = parser.boolval('A'),
   6586                         stow_after_each      = parser.boolval('E'),
   6587                         _0p_calibration      = probe_points == 0,
   6588                         _1p_calibration      = probe_points == 1,
   6589                         _4p_calibration      = probe_points == 2,
   6590                         _7p_9_centre         = probe_points >= 8,
   6591                         _tower_results       = (_4p_calibration && towers_set)
   6592                                                || probe_points >= 3 || probe_points == 0,
   6593                         _opposite_results    = (_4p_calibration && !towers_set)
   6594                                                || probe_points >= 3 || probe_points == 0,
   6595                         _endstop_results     = probe_points != 1,
   6596                         _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
   6597              const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   6598              int8_t iterations = 0;
   6599              float test_precision,
   6600                    zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
   6601                    zero_std_dev_min = zero_std_dev,
   6602                    e_old[ABC] = {
   6603                      delta_endstop_adj[A_AXIS],
   6604                      delta_endstop_adj[B_AXIS],
   6605                      delta_endstop_adj[C_AXIS]
   6606                    },
   6607                    dr_old = delta_radius,
   6608                    zh_old = delta_height,
   6609                    ta_old[ABC] = {
   6610                      delta_tower_angle_trim[A_AXIS],
   6611                      delta_tower_angle_trim[B_AXIS],
   6612                      delta_tower_angle_trim[C_AXIS]
   6613                    };
   6614          
   6615              SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
   6616          
   6617              if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
   6618                LOOP_CAL_RAD(axis) {
   6619                  const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   6620                              r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
   6621                  if(MACHINETPYE & IS_KINEMATIC)
   6622                  {
   6623                  if (!position_is_reachable_IS_KINEMATIC(cos(a) * r, sin(a) * r)) {
   6624                    SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
   6625                    return;
   6626                  }
   6627                  else
   6628                  {
   6629                  if (!position_is_reachable_IS_CARTESIAN(cos(a) * r, sin(a) * r)) {
   6630                    SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
   6631                    return;        
   6632                  }
   6633                  }
   6634                }
   6635              }
   6636          
   6637              stepper.synchronize();
   6638              //#if HAS_LEVELING
   6639              if(BED_LEVELING_METHOD&HAS_LEVELING)
   6640                reset_bed_level(); // After calibration bed-level data is no longer valid
   6641              //#endif
   6642          
   6643              #if HOTENDS > 1
   6644                const uint8_t old_tool_index = active_extruder;
   6645                tool_change(0, 0, true);
   6646                #define G33_CLEANUP() G33_cleanup(old_tool_index)
   6647              #else
   6648                #define G33_CLEANUP() G33_cleanup()
   6649              #endif
   6650          
   6651              setup_for_endstop_or_probe_move();
   6652              endstops.enable(true);
   6653              if (!_0p_calibration) {
   6654                if (!home_delta())
   6655                  return;
   6656                endstops.not_homing();
   6657              }
   6658          
   6659              if (auto_tune) {
   6660                #if HAS_BED_PROBE
   6661                  G33_auto_tune();
   6662                #else
   6663                  SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
   6664                #endif
   6665                G33_CLEANUP();
   6666                return;
   6667              }
   6668          
   6669              // Report settings
   6670          
   6671              const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   6672              serialprintPGM(checkingac);
   6673              if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   6674              SERIAL_EOL();
   6675              lcd_setstatusPGM(checkingac);
   6676          
   6677              print_G33_settings(_endstop_results, _angle_results);
   6678          
   6679              do {
   6680          
   6681                float z_at_pt[NPP + 1] = { 0.0 };
   6682          
   6683                test_precision = zero_std_dev;
   6684          
   6685                iterations++;
   6686          
   6687                // Probe the points
   6688          
   6689                zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
   6690                if (isnan(zero_std_dev)) {
   6691                  SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
   6692                  SERIAL_EOL();
   6693                  return G33_CLEANUP();
   6694                }
   6695          
   6696                // Solve matrices
   6697          
   6698                if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
   6699                  if (zero_std_dev < zero_std_dev_min) {
   6700                    COPY(e_old, delta_endstop_adj);
   6701                    dr_old = delta_radius;
   6702                    zh_old = delta_height;
   6703                    COPY(ta_old, delta_tower_angle_trim);
   6704                  }
   6705          
   6706                  float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
   6707                  const float r_diff = delta_radius - delta_calibration_radius,
   6708                              h_factor = 1 / 6.0 *
   6709                                #ifdef H_FACTOR
   6710                                  (H_FACTOR),                                       // Set in Configuration.h
   6711                                #else
   6712                                  (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
   6713                                #endif
   6714                              r_factor = 1 / 6.0 *
   6715                                #ifdef R_FACTOR
   6716                                  -(R_FACTOR),                                      // Set in Configuration.h
   6717                                #else
   6718                                  -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
   6719                                #endif
   6720                              a_factor = 1 / 6.0 *
   6721                                #ifdef A_FACTOR
   6722                                  (A_FACTOR);                                       // Set in Configuration.h
   6723                                #else
   6724                                  (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
   6725                                #endif
   6726          
   6727                  #define ZP(N,I) ((N) * z_at_pt[I])
   6728                  #define Z6(I) ZP(6, I)
   6729                  #define Z4(I) ZP(4, I)
   6730                  #define Z2(I) ZP(2, I)
   6731                  #define Z1(I) ZP(1, I)
   6732          
   6733                  #if !HAS_BED_PROBE
   6734                    test_precision = 0.00; // forced end
   6735                  #endif
   6736          
   6737                  switch (probe_points) {
   6738                    case 0:
   6739                      test_precision = 0.00; // forced end
   6740                      break;
   6741          
   6742                    case 1:
   6743                      test_precision = 0.00; // forced end
   6744                      LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
   6745                      break;
   6746          
   6747                    case 2:
   6748                      if (towers_set) {
   6749                        e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
   6750                        e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
   6751                        e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
   6752                        r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
   6753                      }
   6754                      else {
   6755                        e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
   6756                        e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
   6757                        e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
   6758                        r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
   6759                      }
   6760                      break;
   6761          
   6762                    default:
   6763                      e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
   6764                      e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
   6765                      e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
   6766                      r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
   6767          
   6768                      if (towers_set) {
   6769                        t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
   6770                        t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
   6771                        t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
   6772                        e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
   6773                        e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
   6774                        e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
   6775                      }
   6776                      break;
   6777                  }
   6778          
   6779                  LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
   6780                  delta_radius += r_delta;
   6781                  LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
   6782                }
   6783                else if (zero_std_dev >= test_precision) {   // step one back
   6784                  COPY(delta_endstop_adj, e_old);
   6785                  delta_radius = dr_old;
   6786                  delta_height = zh_old;
   6787                  COPY(delta_tower_angle_trim, ta_old);
   6788                }
   6789          
   6790                if (verbose_level != 0) {                                    // !dry run
   6791                  // normalise angles to least squares
   6792                  if (_angle_results) {
   6793                    float a_sum = 0.0;
   6794                    LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
   6795                    LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
   6796                  }
   6797          
   6798                  // adjust delta_height and endstops by the max amount
   6799                  const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6800                  delta_height -= z_temp;
   6801                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6802                }
   6803                recalc_delta_settings();
   6804                NOMORE(zero_std_dev_min, zero_std_dev);
   6805          
   6806                // print report
   6807          
   6808                if (verbose_level > 2)
   6809                  print_G33_results(z_at_pt, _tower_results, _opposite_results);
   6810          
   6811                if (verbose_level != 0) {                                    // !dry run
   6812                  if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
   6813                    SERIAL_PROTOCOLPGM("Calibration OK");
   6814                    SERIAL_PROTOCOL_SP(32);
   6815                    #if HAS_BED_PROBE
   6816                      if (zero_std_dev >= test_precision && !_1p_calibration)
   6817                        SERIAL_PROTOCOLPGM("rolling back.");
   6818                      else
   6819                    #endif
   6820                      {
   6821                        SERIAL_PROTOCOLPGM("std dev:");
   6822                        SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
   6823                      }
   6824                    SERIAL_EOL();
   6825                    char mess[21];
   6826                    strcpy_P(mess, PSTR("Calibration sd:"));
   6827                    if (zero_std_dev_min < 1)
   6828                      sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
   6829                    else
   6830                      sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
   6831                    lcd_setstatus(mess);
   6832                    print_G33_settings(_endstop_results, _angle_results);
   6833                    serialprintPGM(save_message);
   6834                    SERIAL_EOL();
   6835                  }
   6836                  else {                                                     // !end iterations
   6837                    char mess[15];
   6838                    if (iterations < 31)
   6839                      sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
   6840                    else
   6841                      strcpy_P(mess, PSTR("No convergence"));
   6842                    SERIAL_PROTOCOL(mess);
   6843                    SERIAL_PROTOCOL_SP(32);
   6844                    SERIAL_PROTOCOLPGM("std dev:");
   6845                    SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6846                    SERIAL_EOL();
   6847                    lcd_setstatus(mess);
   6848                    if (verbose_level > 1)
   6849                      print_G33_settings(_endstop_results, _angle_results);
   6850                  }
   6851                }
   6852                else {                                                       // dry run
   6853                  const char *enddryrun = PSTR("End DRY-RUN");
   6854                  serialprintPGM(enddryrun);
   6855                  SERIAL_PROTOCOL_SP(35);
   6856                  SERIAL_PROTOCOLPGM("std dev:");
   6857                  SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6858                  SERIAL_EOL();
   6859          
   6860                  char mess[21];
   6861                  strcpy_P(mess, enddryrun);
   6862                  strcpy_P(&mess[11], PSTR(" sd:"));
   6863                  if (zero_std_dev < 1)
   6864                    sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
   6865                  else
   6866                    sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
   6867                  lcd_setstatus(mess);
   6868                }
   6869          
   6870                endstops.enable(true);
   6871                if (!home_delta())
   6872                  return;
   6873                endstops.not_homing();
   6874          
   6875              }
   6876              while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
   6877          
   6878              G33_CLEANUP();
   6879            }
   6880          
   6881          #endif // DELTA_AUTO_CALIBRATION
   6882          
   6883          #if ENABLED(G38_PROBE_TARGET)
   6884          
   6885            static bool G38_run_probe() {
   6886          
   6887              bool G38_pass_fail = false;
   6888          
   6889              #if MULTIPLE_PROBING > 1
   6890                // Get direction of move and retract
   6891                float retract_mm[XYZ];
   6892                LOOP_XYZ(i) {
   6893                  float dist = destination[i] - current_position[i];
   6894                  retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
   6895                }
   6896              #endif
   6897          
   6898              stepper.synchronize();  // wait until the machine is idle
   6899          
   6900              // Move until destination reached or target hit
   6901              endstops.enable(true);
   6902              G38_move = true;
   6903              G38_endstop_hit = false;
   6904              prepare_move_to_destination();
   6905              stepper.synchronize();
   6906              G38_move = false;
   6907          
   6908              endstops.hit_on_purpose();
   6909              set_current_from_steppers_for_axis(ALL_AXES);
   6910              SYNC_PLAN_POSITION_KINEMATIC();
   6911          
   6912              if (G38_endstop_hit) {
   6913          
   6914                G38_pass_fail = true;
   6915          
   6916                #if MULTIPLE_PROBING > 1
   6917                  // Move away by the retract distance
   6918                  set_destination_from_current();
   6919                  LOOP_XYZ(i) destination[i] += retract_mm[i];
   6920                  endstops.enable(false);
   6921                  prepare_move_to_destination();
   6922                  stepper.synchronize();
   6923          
   6924                  feedrate_mm_s /= 4;
   6925          
   6926                  // Bump the target more slowly
   6927                  LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
   6928          
   6929                  endstops.enable(true);
   6930                  G38_move = true;
   6931                  prepare_move_to_destination();
   6932                  stepper.synchronize();
   6933                  G38_move = false;
   6934          
   6935                  set_current_from_steppers_for_axis(ALL_AXES);
   6936                  SYNC_PLAN_POSITION_KINEMATIC();
   6937                #endif
   6938              }
   6939          
   6940              endstops.hit_on_purpose();
   6941              endstops.not_homing();
   6942              return G38_pass_fail;
   6943            }
   6944          
   6945            /**
   6946             * G38.2 - probe toward workpiece, stop on contact, signal error if failure
   6947             * G38.3 - probe toward workpiece, stop on contact
   6948             *
   6949             * Like G28 except uses Z min probe for all axes
   6950             */
   6951            inline void gcode_G38(bool is_38_2) {
   6952              // Get X Y Z E F
   6953              gcode_get_destination();
   6954          
   6955              setup_for_endstop_or_probe_move();
   6956          
   6957              // If any axis has enough movement, do the move
   6958              LOOP_XYZ(i)
   6959                if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
   6960                  if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
   6961                  // If G38.2 fails throw an error
   6962                  if (!G38_run_probe() && is_38_2) {
   6963                    SERIAL_ERROR_START();
   6964                    SERIAL_ERRORLNPGM("Failed to reach target");
   6965                  }
   6966                  break;
   6967                }
   6968          
   6969              clean_up_after_endstop_or_probe_move();
   6970            }
   6971          
   6972          #endif // G38_PROBE_TARGET
   6973          
   6974          #if 1//HAS_MESH
   6975          
   6976            /**
   6977             * G42: Move X & Y axes to mesh coordinates (I & J)
   6978             */

   \                                 In section .text, align 4
   6979            inline void gcode_G42() {
   \                     _Z9gcode_G42v: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   6980              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   6981                if (axis_unhomed_error()) return;
   6982              #endif
   6983          
   6984              if (IsRunning()) {
   \   00000004   0x.... 0x....      BL       _Z9IsRunningv
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xF000 0x80AF      BEQ.W    ??gcode_G42_0
   6985                const bool hasI = parser.seenval('I');
   \   0000000E   0x2049             MOVS     R0,#+73
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000014   0x0004             MOVS     R4,R0
   6986                const int8_t ix = hasI ? parser.value_int() : 0;
   \   00000016   0xD004             BEQ.N    ??gcode_G42_1
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   0000001C   0x4605             MOV      R5,R0
   \   0000001E   0xB26D             SXTB     R5,R5
   \   00000020   0xE000             B.N      ??gcode_G42_2
   \                     ??gcode_G42_1: (+1)
   \   00000022   0x2500             MOVS     R5,#+0
   6987                const bool hasJ = parser.seenval('J');
   \                     ??gcode_G42_2: (+1)
   \   00000024   0x204A             MOVS     R0,#+74
   \   00000026   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000002A   0x0006             MOVS     R6,R0
   6988                const int8_t iy = hasJ ? parser.value_int() : 0;
   \   0000002C   0xD004             BEQ.N    ??gcode_G42_3
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000032   0x4607             MOV      R7,R0
   \   00000034   0xB27F             SXTB     R7,R7
   \   00000036   0xE000             B.N      ??gcode_G42_4
   \                     ??gcode_G42_3: (+1)
   \   00000038   0x2700             MOVS     R7,#+0
   6989          
   6990                if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
   \                     ??gcode_G42_4: (+1)
   \   0000003A   0xF8DF 0x8134      LDR.W    R8,??gcode_G42_5
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD006             BEQ.N    ??gcode_G42_6
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD40E             BMI.N    ??gcode_G42_7
   \   00000046   0xF898 0x0060      LDRB     R0,[R8, #+96]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x42A8             CMP      R0,R5
   \   0000004E   0xDB09             BLT.N    ??gcode_G42_7
   \                     ??gcode_G42_6: (+1)
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD00C             BEQ.N    ??gcode_G42_8
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD405             BMI.N    ??gcode_G42_7
   \   00000058   0xF108 0x0060      ADD      R0,R8,#+96
   \   0000005C   0x7840             LDRB     R0,[R0, #+1]
   \   0000005E   0x1E40             SUBS     R0,R0,#+1
   \   00000060   0x42B8             CMP      R0,R7
   \   00000062   0xDA04             BGE.N    ??gcode_G42_8
   6991                  SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
   \                     ??gcode_G42_7: (+1)
   \   00000064   0x4843             LDR.N    R0,??gcode_G42_5+0x4
   \   00000066   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   0000006A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   6992                  return;
   6993                }
   6994          
   6995                set_destination_from_current();
   \                     ??gcode_G42_8: (+1)
   \   0000006E   0x.... 0x....      BL       _Z28set_destination_from_currentv
   6996                if (hasI) 
   \   00000072   0xF8DF 0x9104      LDR.W    R9,??gcode_G42_5+0x8
   \   00000076   0x2C00             CMP      R4,#+0
   \   00000078   0xD01F             BEQ.N    ??gcode_G42_9
   6997                {
   6998                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \   0000007A   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   0000007E   0x0700             LSLS     R0,R0,#+28
   \   00000080   0xD508             BPL.N    ??gcode_G42_10
   6999                      destination[X_AXIS] = _GET_MESH_X_ABL(ix);
   \   00000082   0x483E             LDR.N    R0,??gcode_G42_5+0xC
   \   00000084   0x6981             LDR      R1,[R0, #+24]
   \   00000086   0x6900             LDR      R0,[R0, #+16]
   \   00000088   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000008C   0x.... 0x....      BL       __aeabi_i2f
   \   00000090   0xF8C9 0x0018      STR      R0,[R9, #+24]
   7000                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
   \                     ??gcode_G42_10: (+1)
   \   00000094   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   00000098   0x06C0             LSLS     R0,R0,#+27
   \   0000009A   0xD505             BPL.N    ??gcode_G42_11
   7001                      destination[X_AXIS] = _GET_MESH_X_UBL(ix);
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0xB2C0             UXTB     R0,R0
   \   000000A0   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   000000A4   0xF8C9 0x0018      STR      R0,[R9, #+24]
   7002                  if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
   \                     ??gcode_G42_11: (+1)
   \   000000A8   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000AC   0x0680             LSLS     R0,R0,#+26
   \   000000AE   0xD504             BPL.N    ??gcode_G42_9
   7003                      destination[X_AXIS] = _GET_MESH_X_MBL(ix);        
   \   000000B0   0x4833             LDR.N    R0,??gcode_G42_5+0x10
   \   000000B2   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000000B6   0xF8C9 0x0018      STR      R0,[R9, #+24]
   7004                }
   7005                if (hasJ) 
   \                     ??gcode_G42_9: (+1)
   \   000000BA   0x2E00             CMP      R6,#+0
   \   000000BC   0xD01F             BEQ.N    ??gcode_G42_12
   7006                {
   7007                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \   000000BE   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000C2   0x0700             LSLS     R0,R0,#+28
   \   000000C4   0xD508             BPL.N    ??gcode_G42_13
   7008                      destination[Y_AXIS] = _GET_MESH_Y_ABL (iy);
   \   000000C6   0x482D             LDR.N    R0,??gcode_G42_5+0xC
   \   000000C8   0x69C1             LDR      R1,[R0, #+28]
   \   000000CA   0x6940             LDR      R0,[R0, #+20]
   \   000000CC   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000D0   0x.... 0x....      BL       __aeabi_i2f
   \   000000D4   0xF8C9 0x001C      STR      R0,[R9, #+28]
   7009                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
   \                     ??gcode_G42_13: (+1)
   \   000000D8   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000DC   0x06C0             LSLS     R0,R0,#+27
   \   000000DE   0xD505             BPL.N    ??gcode_G42_14
   7010                      destination[Y_AXIS] = _GET_MESH_Y_UBL(iy);
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0xB2C0             UXTB     R0,R0
   \   000000E4   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
   \   000000E8   0xF8C9 0x001C      STR      R0,[R9, #+28]
   7011                  if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
   \                     ??gcode_G42_14: (+1)
   \   000000EC   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000F0   0x0680             LSLS     R0,R0,#+26
   \   000000F2   0xD504             BPL.N    ??gcode_G42_12
   7012                      destination[Y_AXIS] = _GET_MESH_Y_MBL(iy);        
   \   000000F4   0x4823             LDR.N    R0,??gcode_G42_5+0x14
   \   000000F6   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   000000FA   0xF8C9 0x001C      STR      R0,[R9, #+28]
   7013                }         
   7014                if (parser.boolval('P')) {
   \                     ??gcode_G42_12: (+1)
   \   000000FE   0x2050             MOVS     R0,#+80
   \   00000100   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD015             BEQ.N    ??gcode_G42_15
   7015                  if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
   \   00000108   0x2C00             CMP      R4,#+0
   \   0000010A   0xD008             BEQ.N    ??gcode_G42_16
   \   0000010C   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   00000110   0xF108 0x0160      ADD      R1,R8,#+96
   \   00000114   0x68C9             LDR      R1,[R1, #+12]
   \   00000116   0x.... 0x....      BL       __aeabi_fsub
   \   0000011A   0xF8C9 0x0018      STR      R0,[R9, #+24]
   7016                  if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   \                     ??gcode_G42_16: (+1)
   \   0000011E   0x2E00             CMP      R6,#+0
   \   00000120   0xD008             BEQ.N    ??gcode_G42_15
   \   00000122   0xF8D9 0x001C      LDR      R0,[R9, #+28]
   \   00000126   0xF108 0x0160      ADD      R1,R8,#+96
   \   0000012A   0x6909             LDR      R1,[R1, #+16]
   \   0000012C   0x.... 0x....      BL       __aeabi_fsub
   \   00000130   0xF8C9 0x001C      STR      R0,[R9, #+28]
   7017                }
   7018          
   7019                const float fval = parser.linearval('F');
   \                     ??gcode_G42_15: (+1)
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x2046             MOVS     R0,#+70
   \   00000138   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   7020                if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
   \   0000013C   0x2100             MOVS     R1,#+0
   \   0000013E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000142   0xD204             BCS.N    ??gcode_G42_17
   \   00000144   0x4910             LDR.N    R1,??gcode_G42_5+0x18  ;; 0x42700000
   \   00000146   0x.... 0x....      BL       __aeabi_fdiv
   \   0000014A   0xF8C9 0x005C      STR      R0,[R9, #+92]
   7021          
   7022                // SCARA kinematic has "safe" XY raw moves
   7023                //#if IS_SCARA
   7024                if(MACHINETPYE & IS_SCARA)
   \                     ??gcode_G42_17: (+1)
   \   0000014E   0xF8B8 0x0058      LDRH     R0,[R8, #+88]
   \   00000152   0xF44F 0x7140      MOV      R1,#+768
   \   00000156   0x4208             TST      R0,R1
   \   00000158   0xD004             BEQ.N    ??gcode_G42_18
   7025                  prepare_uninterpolated_move_to_destination();
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000160   0x.... 0x....      B.W      _Z42prepare_uninterpolated_move_to_destinationf
   7026                //#else
   7027                else
   7028                  prepare_move_to_destination();
   \                     ??gcode_G42_18: (+1)
   \   00000164   0xE8BD 0x43F1      POP      {R0,R4-R9,LR}
   \   00000168   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   7029                //#endif
   7030              }
   7031            }
   \                     ??gcode_G42_0: (+1)
   \   0000016C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??gcode_G42_5:
   \   00000170   0x........         DC32     mksCfg
   \   00000174   0x........         DC32     _ZZ9gcode_G42vEs
   \   00000178   0x........         DC32     mks_heating_busy
   \   0000017C   0x........         DC32     axis_relative_modes
   \   00000180   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \   00000184   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \   00000188   0x42700000         DC32     0x42700000
   7032          
   7033          #endif // HAS_MESH
   7034          #if 0
   7035          /**
   7036           * G92: Set current position to given X Y Z E
   7037           */
   7038          inline void gcode_G92() {
   7039          
   7040            stepper.synchronize();
   7041          
   7042            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   7043              switch (parser.subcode) {
   7044                case 1:
   7045                  // Zero the G92 values and restore current position
   7046                  #if !IS_SCARA
   7047                    LOOP_XYZ(i) {
   7048                      const float v = position_shift[i];
   7049                      if (v) {
   7050                        position_shift[i] = 0;
   7051                        update_software_endstops((AxisEnum)i);
   7052                      }
   7053                    }
   7054                  #endif // Not SCARA
   7055                  return;
   7056              }
   7057            #endif
   7058          
   7059            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   7060              #define IS_G92_0 (parser.subcode == 0)
   7061            #else
   7062              #define IS_G92_0 true
   7063            #endif
   7064          
   7065            bool didE = false;
   7066            bool didXYZ = false;
   7067            //#if IS_SCARA || !HAS_POSITION_SHIFT
   7068            if(MACHINETPYE&IS_SCARA) {
   7069              //bool 
   7070              didXYZ = false;
   7071            }
   7072            //#else
   7073            else
   7074            {
   7075            	#if !HAS_POSITION_SHIFT
   7076          		//bool 
   7077          		didXYZ = false;	
   7078            	#else
   7079          		//constexpr bool 
   7080          		didXYZ = false;
   7081          	#endif
   7082            }
   7083            //#endif
   7084          
   7085            if (IS_G92_0) LOOP_XYZE(i) {
   7086              if (parser.seenval(axis_codes[i])) {
   7087                const float l = parser.value_axis_units((AxisEnum)i),
   7088                            v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
   7089                            d = v - current_position[i];
   7090                if (!NEAR_ZERO(d)) {
   7091                  //#if IS_SCARA || !HAS_POSITION_SHIFT
   7092                  if(MACHINETPYE&IS_SCARA) {
   7093                    if (i == E_AXIS) didE = true; else didXYZ = true;
   7094                    current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
   7095                  }
   7096          		else
   7097          		{
   7098          			#if HAS_POSITION_SHIFT
   7099          	          if (i == E_AXIS) {
   7100          	            didE = true;
   7101          	            current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
   7102          	          }
   7103          	          else {
   7104          	            position_shift[i] += d;       // Other axes simply offset the coordinate space
   7105          	            update_software_endstops((AxisEnum)i);
   7106          	          }
   7107          			
   7108                  	#endif
   7109          		}
   7110                }
   7111              }
   7112            }
   7113          
   7114            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   7115              // Apply workspace offset to the active coordinate system
   7116              if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
   7117                COPY(coordinate_system[active_coordinate_system], position_shift);
   7118            #endif
   7119          
   7120            if (didXYZ)
   7121              SYNC_PLAN_POSITION_KINEMATIC();
   7122            else if (didE)
   7123              sync_plan_position_e();
   7124          
   7125            report_current_position();
   7126          }
   7127          #else
   7128          
   7129          /**
   7130           * G92: Set current position to given X Y Z E
   7131           */

   \                                 In section .text, align 4
   7132          inline void gcode_G92() {
   \                     _Z9gcode_G92v: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   7133            bool didXYZ = false,
   \   00000004   0x2500             MOVS     R5,#+0
   7134                 didE = parser.seen('E');
   \   00000006   0x2045             MOVS     R0,#+69
   \   00000008   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000C   0x0004             MOVS     R4,R0
   7135          
   7136            if (!didE) stepper.synchronize();
   \   0000000E   0xD101             BNE.N    ??gcode_G92_0
   \   00000010   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   7137          
   7138            LOOP_XYZE(i) {
   \                     ??gcode_G92_0: (+1)
   \   00000014   0x462E             MOV      R6,R5
   \   00000016   0xE015             B.N      ??gcode_G92_1
   7139              if (parser.seenval(axis_codes[i])) {
   7140                //#if IS_SCARA
   7141                if(MACHINETPYE&IS_SCARA)
   7142                {
   7143                  current_position[i] = parser.value_axis_units((AxisEnum)i);
   7144                  if (i != E_AXIS) didXYZ = true;
   7145                }
   7146                //#else
   7147                else
   7148                {
   7149                  #if HAS_POSITION_SHIFT
   7150                    const float p = current_position[i];
   \                     ??gcode_G92_2: (+1)
   \   00000018   0xF8D7 0x8008      LDR      R8,[R7, #+8]
   7151                  #endif
   7152                  float v = parser.value_axis_units((AxisEnum)i);
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0xB240             SXTB     R0,R0
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   7153          
   7154                  current_position[i] = v;
   \   00000024   0x60B8             STR      R0,[R7, #+8]
   7155          
   7156                  if (i != E_AXIS) {
   \   00000026   0x2E03             CMP      R6,#+3
   \   00000028   0xD00B             BEQ.N    ??gcode_G92_3
   7157                    didXYZ = true;
   \   0000002A   0x2501             MOVS     R5,#+1
   7158                    #if HAS_POSITION_SHIFT
   7159                      position_shift[i] += v - p; // Offset the coordinate space
   \   0000002C   0x4641             MOV      R1,R8
   \   0000002E   0x.... 0x....      BL       __aeabi_fsub
   \   00000032   0x6E39             LDR      R1,[R7, #+96]
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x6638             STR      R0,[R7, #+96]
   7160                      update_software_endstops((AxisEnum)i);
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xB240             SXTB     R0,R0
   \   0000003E   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   7161                    #endif
   7162                  }
   7163                }
   \                     ??gcode_G92_3: (+1)
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \                     ??gcode_G92_1: (+1)
   \   00000044   0x2E04             CMP      R6,#+4
   \   00000046   0xDA18             BGE.N    ??gcode_G92_4
   \   00000048   0x4812             LDR.N    R0,??gcode_G92_5
   \   0000004A   0x5630             LDRSB    R0,[R6, R0]
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD0F6             BEQ.N    ??gcode_G92_3
   \   00000054   0x4810             LDR.N    R0,??gcode_G92_5+0x4
   \   00000056   0xEB00 0x0786      ADD      R7,R0,R6, LSL #+2
   \   0000005A   0x4810             LDR.N    R0,??gcode_G92_5+0x8
   \   0000005C   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000060   0xF44F 0x7140      MOV      R1,#+768
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD0D7             BEQ.N    ??gcode_G92_2
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0xB240             SXTB     R0,R0
   \   0000006C   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   00000070   0x60B8             STR      R0,[R7, #+8]
   \   00000072   0x2E03             CMP      R6,#+3
   \   00000074   0xD0E5             BEQ.N    ??gcode_G92_3
   \   00000076   0x2501             MOVS     R5,#+1
   \   00000078   0xE7E3             B.N      ??gcode_G92_3
   7164                //#endif
   7165              }
   7166            }
   7167            if (didXYZ)
   \                     ??gcode_G92_4: (+1)
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD002             BEQ.N    ??gcode_G92_6
   7168              SYNC_PLAN_POSITION_KINEMATIC();
   \   0000007E   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   \   00000082   0xE003             B.N      ??gcode_G92_7
   7169            else if (didE)
   \                     ??gcode_G92_6: (+1)
   \   00000084   0x2C00             CMP      R4,#+0
   \   00000086   0xD001             BEQ.N    ??gcode_G92_7
   7170              sync_plan_position_e();
   \   00000088   0x.... 0x....      BL       _Z20sync_plan_position_ev
   7171          
   7172            report_current_position();
   \                     ??gcode_G92_7: (+1)
   \   0000008C   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000090   0x.... 0x....      B.W      _Z23report_current_positionv
   \                     ??gcode_G92_5:
   \   00000094   0x........         DC32     axis_codes
   \   00000098   0x........         DC32     mks_heating_busy
   \   0000009C   0x........         DC32     mksCfg
   7173          }
   7174          
   7175          #endif
   7176          #if HAS_RESUME_CONTINUE
   7177          
   7178            /**
   7179             * M0: Unconditional stop - Wait for user button press on LCD
   7180             * M1: Conditional stop   - Wait for user button press on LCD
   7181             */
   7182            inline void gcode_M0_M1() {
   7183              const char * const args = parser.string_arg;
   7184          
   7185              millis_t ms = 0;
   7186              bool hasP = false, hasS = false;
   7187              if (parser.seenval('P')) {
   7188                ms = parser.value_millis(); // milliseconds to wait
   7189                hasP = ms > 0;
   7190              }
   7191              if (parser.seenval('S')) {
   7192                ms = parser.value_millis_from_seconds(); // seconds to wait
   7193                hasS = ms > 0;
   7194              }
   7195          
   7196              #if ENABLED(ULTIPANEL)
   7197          
   7198                if (!hasP && !hasS && args && *args)
   7199                  lcd_setstatus(args, true);
   7200                else {
   7201                  LCD_MESSAGEPGM(MSG_USERWAIT);
   7202                  #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   7203                    dontExpireStatus();
   7204                  #endif
   7205                }
   7206          
   7207              #else
   7208          
   7209                if (!hasP && !hasS && args && *args) {
   7210                  SERIAL_ECHO_START();
   7211                  SERIAL_ECHOLN(args);
   7212                }
   7213          
   7214              #endif
   7215          
   7216              KEEPALIVE_STATE(PAUSED_FOR_USER);
   7217              wait_for_user = true;
   7218          
   7219              stepper.synchronize();
   7220              refresh_cmd_timeout();
   7221          
   7222              if (ms > 0) {
   7223                ms += previous_cmd_ms;  // wait until this time for a click
   7224                while (PENDING(millis(), ms) && wait_for_user) idle();
   7225              }
   7226              else {
   7227                #if ENABLED(ULTIPANEL)
   7228                  if (lcd_detected()) {
   7229                    while (wait_for_user) idle();
   7230                    print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
   7231                  }
   7232                #else
   7233                  while (wait_for_user) idle();
   7234                #endif
   7235              }
   7236          
   7237              wait_for_user = false;
   7238              KEEPALIVE_STATE(IN_HANDLER);
   7239            }
   7240          
   7241          #endif // HAS_RESUME_CONTINUE
   7242          
   7243          #if ENABLED(SPINDLE_LASER_ENABLE)
   7244            /**
   7245             * M3: Spindle Clockwise
   7246             * M4: Spindle Counter-clockwise
   7247             *
   7248             *  S0 turns off spindle.
   7249             *
   7250             *  If no speed PWM output is defined then M3/M4 just turns it on.
   7251             *
   7252             *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
   7253             *  Hardware PWM is required. ISRs are too slow.
   7254             *
   7255             * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
   7256             *       No other settings give a PWM signal that goes from 0 to 5 volts.
   7257             *
   7258             *       The system automatically sets WGM to Mode 1, so no special
   7259             *       initialization is needed.
   7260             *
   7261             *       WGM bits for timer 2 are automatically set by the system to
   7262             *       Mode 1. This produces an acceptable 0 to 5 volt signal.
   7263             *       No special initialization is needed.
   7264             *
   7265             * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
   7266             *       factors for timers 2, 3, 4, and 5 are acceptable.
   7267             *
   7268             *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
   7269             *  the spindle/laser during power-up or when connecting to the host
   7270             *  (usually goes through a reset which sets all I/O pins to tri-state)
   7271             *
   7272             *  PWM duty cycle goes from 0 (off) to 255 (always on).
   7273             */
   7274          
   7275            // Wait for spindle to come up to speed
   7276            inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
   7277          
   7278            // Wait for spindle to stop turning
   7279            inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
   7280          
   7281            /**
   7282             * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
   7283             *
   7284             * it accepts inputs of 0-255
   7285             */
   7286          
   7287            inline void ocr_val_mode() {
   7288              uint8_t spindle_laser_power = parser.value_byte();
   7289              WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
   7290              if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
   7291              analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
   7292            }
   7293          
   7294            inline void gcode_M3_M4(bool is_M3) {
   7295          
   7296              stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
   7297              #if SPINDLE_DIR_CHANGE
   7298                const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
   7299                if (SPINDLE_STOP_ON_DIR_CHANGE \
   7300                   && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \
   7301                   && READ(SPINDLE_DIR_PIN) != rotation_dir
   7302                ) {
   7303                  WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
   7304                  delay_for_power_down();
   7305                }
   7306                WRITE(SPINDLE_DIR_PIN, rotation_dir);
   7307              #endif
   7308          
   7309              /**
   7310               * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
   7311               * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
   7312               * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
   7313               */
   7314              #if ENABLED(SPINDLE_LASER_PWM)
   7315                if (parser.seen('O')) ocr_val_mode();
   7316                else {
   7317                  const float spindle_laser_power = parser.floatval('S');
   7318                  if (spindle_laser_power == 0) {
   7319                    WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
   7320                    analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
   7321                    delay_for_power_down();
   7322                  }
   7323                  else {
   7324                    int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
   7325                    NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
   7326                    if (spindle_laser_power <= SPEED_POWER_MIN)
   7327                      ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
   7328                    if (spindle_laser_power >= SPEED_POWER_MAX)
   7329                      ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
   7330                    if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
   7331                    WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
   7332                    analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
   7333                    delay_for_power_up();
   7334                  }
   7335                }
   7336              #else
   7337                WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
   7338                delay_for_power_up();
   7339              #endif
   7340            }
   7341          
   7342           /**
   7343            * M5 turn off spindle
   7344            */
   7345            inline void gcode_M5() {
   7346              stepper.synchronize();
   7347              WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
   7348              delay_for_power_down();
   7349            }
   7350          
   7351          #endif // SPINDLE_LASER_ENABLE
   7352          
   7353          /**
   7354           * M17: Enable power on all stepper motors
   7355           */

   \                                 In section .text, align 4
   7356          inline void gcode_M17() {
   \                     _Z9gcode_M17v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   7357            LCD_MESSAGEPGM(MSG_NO_MOVE);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x4803             LDR.N    R0,??gcode_M17_0
   \   00000006   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   7358            enable_all_steppers();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      _Z19enable_all_steppersv
   \   00000012   0xBF00             Nop      
   \                     ??gcode_M17_0:
   \   00000014   0x........         DC32     _ZZ9gcode_M17vEs
   7359          }
   7360          
   7361          #if ENABLED(ADVANCED_PAUSE_FEATURE)
   7362          
   7363            static float resume_position[XYZE];
   7364            static bool move_away_flag = false;
   7365            #if ENABLED(SDSUPPORT)
   7366              static bool sd_print_paused = false;
   7367            #endif
   7368          
   7369            static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
   7370              static millis_t next_buzz = 0;
   7371              static int8_t runout_beep = 0;
   7372          
   7373              if (init) next_buzz = runout_beep = 0;
   7374          
   7375              const millis_t ms = millis();
   7376              if (ELAPSED(ms, next_buzz)) {
   7377                if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
   7378                  next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
   7379                  BUZZ(300, 2000);
   7380                  runout_beep++;
   7381                }
   7382              }
   7383            }
   7384          
   7385            static void ensure_safe_temperature() {
   7386              bool heaters_heating = true;
   7387          
   7388              wait_for_heatup = true;    // M108 will clear this
   7389              while (wait_for_heatup && heaters_heating) {
   7390                idle();
   7391                heaters_heating = false;
   7392                HOTEND_LOOP() {
   7393                  if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
   7394                    heaters_heating = true;
   7395                    #if ENABLED(ULTIPANEL)
   7396                      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
   7397                    #endif
   7398                    break;
   7399                  }
   7400                }
   7401              }
   7402            }
   7403          
   7404            #if IS_KINEMATIC
   7405              #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
   7406            #else
   7407              #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
   7408            #endif
   7409          
   7410            void do_pause_e_move(const float &length, const float fr) {
   7411              current_position[E_AXIS] += length / planner.e_factor[active_extruder];
   7412              set_destination_from_current();
   7413              RUNPLAN(fr);
   7414              stepper.synchronize();
   7415            }
   7416          
   7417            static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
   7418                                    const int8_t max_beep_count = 0, const bool show_lcd = false
   7419            ) {
   7420              if (move_away_flag) return false; // already paused
   7421          
   7422              #ifdef ACTION_ON_PAUSE
   7423                SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
   7424              #endif
   7425          
   7426              if (!DEBUGGING(DRYRUN) && unload_length != 0) {
   7427                #if ENABLED(PREVENT_COLD_EXTRUSION)
   7428                  if (!thermalManager.allow_cold_extrude &&
   7429                      thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
   7430                    SERIAL_ERROR_START();
   7431                    SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
   7432                    return false;
   7433                  }
   7434                #endif
   7435          
   7436                ensure_safe_temperature(); // wait for extruder to heat up before unloading
   7437              }
   7438          
   7439              // Indicate that the printer is paused
   7440              move_away_flag = true;
   7441          
   7442              // Pause the print job and timer
   7443              #if ENABLED(SDSUPPORT)
   7444                if (card.sdprinting) {
   7445                  card.pauseSDPrint();
   7446                  sd_print_paused = true;
   7447                }
   7448              #endif
   7449              print_job_timer.pause();
   7450          
   7451              // Show initial message and wait for synchronize steppers
   7452              if (show_lcd) {
   7453                #if ENABLED(ULTIPANEL)
   7454                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
   7455                #endif
   7456              }
   7457          
   7458              // Save current position
   7459              stepper.synchronize();
   7460              COPY(resume_position, current_position);
   7461          
   7462              // Initial retract before move to filament change position
   7463              if (retract && !thermalManager.tooColdToExtrude(active_extruder))
   7464                do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
   7465          
   7466              // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
   7467              Nozzle::park(2, park_point);
   7468          
   7469              if (unload_length != 0) {
   7470                if (show_lcd) {
   7471                  #if ENABLED(ULTIPANEL)
   7472                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
   7473                    idle();
   7474                  #endif
   7475                }
   7476          
   7477                // Unload filament
   7478                do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
   7479              }
   7480          
   7481              if (show_lcd) {
   7482                #if ENABLED(ULTIPANEL)
   7483                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7484                #endif
   7485              }
   7486          
   7487              #if HAS_BUZZER
   7488                filament_change_beep(max_beep_count, true);
   7489              #endif
   7490          
   7491              idle();
   7492          
   7493              // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
   7494              #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
   7495                disable_e_steppers();
   7496                safe_delay(100);
   7497              #endif
   7498          
   7499              // Start the heater idle timers
   7500              const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
   7501          
   7502              HOTEND_LOOP()
   7503                thermalManager.start_heater_idle_timer(e, nozzle_timeout);
   7504          
   7505              return true;
   7506            }
   7507          
   7508            static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
   7509              bool nozzle_timed_out = false;
   7510          
   7511              // Wait for filament insert by user and press button
   7512              KEEPALIVE_STATE(PAUSED_FOR_USER);
   7513              wait_for_user = true;    // LCD click or M108 will clear this
   7514              while (wait_for_user) {
   7515                #if HAS_BUZZER
   7516                  filament_change_beep(max_beep_count);
   7517                #endif
   7518          
   7519                // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
   7520                // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
   7521                if (!nozzle_timed_out)
   7522                  HOTEND_LOOP()
   7523                    nozzle_timed_out |= thermalManager.is_heater_idle(e);
   7524          
   7525                if (nozzle_timed_out) {
   7526                  #if ENABLED(ULTIPANEL)
   7527                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
   7528                  #endif
   7529          
   7530                  // Wait for LCD click or M108
   7531                  while (wait_for_user) idle(true);
   7532          
   7533                  // Re-enable the heaters if they timed out
   7534                  HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
   7535          
   7536                  // Wait for the heaters to reach the target temperatures
   7537                  ensure_safe_temperature();
   7538          
   7539                  #if ENABLED(ULTIPANEL)
   7540                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7541                  #endif
   7542          
   7543                  // Start the heater idle timers
   7544                  const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
   7545          
   7546                  HOTEND_LOOP()
   7547                    thermalManager.start_heater_idle_timer(e, nozzle_timeout);
   7548          
   7549                  wait_for_user = true; /* Wait for user to load filament */
   7550                  nozzle_timed_out = false;
   7551          
   7552                  #if HAS_BUZZER
   7553                    filament_change_beep(max_beep_count, true);
   7554                  #endif
   7555                }
   7556          
   7557                idle(true);
   7558              }
   7559              KEEPALIVE_STATE(IN_HANDLER);
   7560            }
   7561          
   7562            static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
   7563              bool nozzle_timed_out = false;
   7564          
   7565              if (!move_away_flag) return;
   7566          
   7567              // Re-enable the heaters if they timed out
   7568              HOTEND_LOOP() {
   7569                nozzle_timed_out |= thermalManager.is_heater_idle(e);
   7570                thermalManager.reset_heater_idle_timer(e);
   7571              }
   7572          
   7573              if (nozzle_timed_out) ensure_safe_temperature();
   7574          
   7575              #if HAS_BUZZER
   7576                filament_change_beep(max_beep_count, true);
   7577              #endif
   7578          
   7579              set_destination_from_current();
   7580          
   7581              if (load_length != 0) {
   7582                #if ENABLED(ULTIPANEL)
   7583                  // Show "insert filament"
   7584                  if (nozzle_timed_out)
   7585                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7586                #endif
   7587          
   7588                KEEPALIVE_STATE(PAUSED_FOR_USER);
   7589                wait_for_user = true;    // LCD click or M108 will clear this
   7590                while (wait_for_user && nozzle_timed_out) {
   7591                  #if HAS_BUZZER
   7592                    filament_change_beep(max_beep_count);
   7593                  #endif
   7594                  idle(true);
   7595                }
   7596                KEEPALIVE_STATE(IN_HANDLER);
   7597          
   7598                #if ENABLED(ULTIPANEL)
   7599                  // Show "load" message
   7600                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
   7601                #endif
   7602          
   7603                // Load filament
   7604                do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
   7605              }
   7606          
   7607              #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
   7608          
   7609                if (!thermalManager.tooColdToExtrude(active_extruder)) {
   7610                  float extrude_length = initial_extrude_length;
   7611          
   7612                  do {
   7613                    if (extrude_length > 0) {
   7614                      // "Wait for filament extrude"
   7615                      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
   7616          
   7617                      // Extrude filament to get into hotend
   7618                      do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
   7619                    }
   7620          
   7621                    // Show "Extrude More" / "Resume" menu and wait for reply
   7622                    KEEPALIVE_STATE(PAUSED_FOR_USER);
   7623                    wait_for_user = false;
   7624                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
   7625                    while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
   7626                    KEEPALIVE_STATE(IN_HANDLER);
   7627          
   7628                    extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
   7629          
   7630                    // Keep looping if "Extrude More" was selected
   7631                  } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
   7632                }
   7633          
   7634              #endif
   7635          
   7636              #if ENABLED(ULTIPANEL)
   7637                // "Wait for print to resume"
   7638                lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
   7639              #endif
   7640          
   7641              // Set extruder to saved position
   7642              destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
   7643              planner.set_e_position_mm(current_position[E_AXIS]);
   7644          
   7645              // Move XY to starting position, then Z
   7646              do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
   7647              do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
   7648          
   7649              #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   7650                filament_ran_out = false;
   7651              #endif
   7652          
   7653              #if ENABLED(ULTIPANEL)
   7654                // Show status screen
   7655                lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
   7656              #endif
   7657          
   7658              #ifdef ACTION_ON_RESUME
   7659                SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
   7660              #endif
   7661          
   7662              #if ENABLED(SDSUPPORT)
   7663                if (sd_print_paused) {
   7664                  card.startFileprint();
   7665                  sd_print_paused = false;
   7666                }
   7667              #endif
   7668          
   7669              move_away_flag = false;
   7670            }
   7671          #endif // ADVANCED_PAUSE_FEATURE
   7672          
   7673          #if ENABLED(SDSUPPORT)
   7674          
   7675            /**
   7676             * M20: List SD card to serial output
   7677             */

   \                                 In section .text, align 4
   7678            inline void gcode_M20() {
   \                     _Z9gcode_M20v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   7679              SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
   \   00000002   0x4805             LDR.N    R0,??gcode_M20_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7680              card.ls();
   \   00000008   0x4804             LDR.N    R0,??gcode_M20_0+0x4
   \   0000000A   0x.... 0x....      BL       _ZN10CardReader2lsEv
   7681              SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
   \   0000000E   0x4804             LDR.N    R0,??gcode_M20_0+0x8
   \   00000010   0xE8BD 0x4002      POP      {R1,LR}
   \   00000014   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \                     ??gcode_M20_0:
   \   00000018   0x........         DC32     _ZZ9gcode_M20vEs
   \   0000001C   0x........         DC32     card
   \   00000020   0x........         DC32     _ZZ9gcode_M20vEs_0
   7682            }
   7683          
   7684            /**
   7685             * M21: Init SD Card
   7686             */
   7687            inline void gcode_M21() { card.initsd(); }
   7688          
   7689            /**
   7690             * M22: Release SD Card
   7691             */

   \                                 In section .text, align 4
   7692            inline void gcode_M22() { card.release(); }
   \                     _Z9gcode_M22v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M22_0
   \   00000002   0x.... 0x....      B.W      _ZN10CardReader7releaseEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M22_0:
   \   00000008   0x........         DC32     card
   7693          
   7694            /**
   7695             * M23: Open a file
   7696             */
   7697             #ifdef USE_MKS_WIFI    
   7698            inline void gcode_M23() { 
   7699            	if(card.openFile(parser.command_ptr, true) < 0)
   7700            	{
   7701            		/*for 8.3 principle*/
   7702          		char *gSuffix = strstr((char *)parser.command_ptr, ".g");
   7703          		if(!gSuffix)
   7704          		{
   7705          			gSuffix = strstr((char *)parser.command_ptr, ".G");		
   7706          		}
   7707          		if(gSuffix)
   7708          		{
   7709          			*(gSuffix + 2) = '\0';
   7710          			if((uint32_t)gSuffix - (uint32_t)parser.command_ptr > 8)
   7711          			{
   7712          				parser.command_ptr[7] = '~';
   7713          				parser.command_ptr[8] = '.';
   7714          				parser.command_ptr[9] = 'g';
   7715          				parser.command_ptr[10] = '\0';
   7716          			}
   7717          			card.openFile(parser.command_ptr, true) ;
   7718          		}
   7719            	}
   7720            }
   7721          #else

   \                                 In section .text, align 4
   7722            inline void gcode_M23() {
   \                     _Z9gcode_M23v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7723              // Simplify3D includes the size, so zero out all spaces (#7227)
   7724              for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
   \   00000002   0x480D             LDR.N    R0,??gcode_M23_0
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xE004             B.N      ??gcode_M23_1
   \                     ??gcode_M23_2: (+1)
   \   00000008   0x2A20             CMP      R2,#+32
   \   0000000A   0xD101             BNE.N    ??gcode_M23_3
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x700A             STRB     R2,[R1, #+0]
   \                     ??gcode_M23_3: (+1)
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \                     ??gcode_M23_1: (+1)
   \   00000012   0xF991 0x2000      LDRSB    R2,[R1, #+0]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1F6             BNE.N    ??gcode_M23_2
   7725              card.openFile(parser.string_arg, true);
   \   0000001A   0x4C08             LDR.N    R4,??gcode_M23_0+0x4
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   7726              strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
   \   00000028   0xF204 0x717C      ADDW     R1,R4,#+1916
   \   0000002C   0x4804             LDR.N    R0,??gcode_M23_0+0x8
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x.... 0x....      B.W      strcpy
   \   00000036   0xBF00             Nop      
   \                     ??gcode_M23_0:
   \   00000038   0x........         DC32     _ZN11GCodeParser10string_argE
   \   0000003C   0x........         DC32     card
   \   00000040   0x........         DC32     curFileName
   7727            }
   7728          #endif
   7729            /**
   7730             * M24: Start or Resume SD Print
   7731             */

   \                                 In section .text, align 4
   7732            inline void gcode_M24() {
   \                     _Z9gcode_M24v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7733            	mks_resumePrint();
   \   00000002   0x.... 0x....      BL       mks_resumePrint
   7734            
   7735              #if ENABLED(PARK_HEAD_ON_PAUSE)
   7736                resume_print();
   7737              #endif
   7738          	
   7739          	#ifdef USE_MKS_WIFI
   7740          	if(card.lastOpenOk())
   7741          	#endif	
   7742          		if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
   \   00000006   0x4C08             LDR.N    R4,??gcode_M24_0
   \   00000008   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   0000000C   0x28AB             CMP      R0,#+171
   \   0000000E   0xD00A             BEQ.N    ??gcode_M24_1
   \   00000010   0x28AC             CMP      R0,#+172
   \   00000012   0xD008             BEQ.N    ??gcode_M24_1
   7743          		{
   7744          
   7745          	    	card.startFileprint();
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   7746          	    	print_job_timer.start();
   \   0000001A   0xF604 0x20E8      ADDW     R0,R4,#+2792
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   7747          		}
   7748            }
   \                     ??gcode_M24_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M24_0:
   \   00000028   0x........         DC32     card
   7749          
   7750            /**
   7751             * M25: Pause SD Print
   7752             */

   \                                 In section .text, align 4
   7753            inline void gcode_M25() {
   \                     _Z9gcode_M25v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7754              card.pauseSDPrint();
   \   00000002   0x4C06             LDR.N    R4,??gcode_M25_0
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       _ZN10CardReader12pauseSDPrintEv
   7755              print_job_timer.pause();
   \   0000000A   0xF604 0x20E8      ADDW     R0,R4,#+2792
   \   0000000E   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
   7756          
   7757              #if ENABLED(PARK_HEAD_ON_PAUSE)
   7758                enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
   7759              #endif
   7760          	
   7761          	mksReprint.mks_printer_state = MKS_PAUSING;
   \   00000012   0x20A9             MOVS     R0,#+169
   \   00000014   0xF884 0x081C      STRB     R0,[R4, #+2076]
   7762            }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   \   0000001A   0xBF00             Nop      
   \                     ??gcode_M25_0:
   \   0000001C   0x........         DC32     card
   7763          /**
   7764          	 * M998: Stop SD Print
   7765          */

   \                                 In section .text, align 4
   7766          	inline void gcode_M998() {
   \                     _Z10gcode_M998v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7767          		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
   \   00000002   0x4C17             LDR.N    R4,??gcode_M998_0
   \   00000004   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000008   0x28AC             CMP      R0,#+172
   \   0000000A   0xD027             BEQ.N    ??gcode_M998_1
   7768          		return;
   7769          			
   7770          		mksReprint.mks_printer_state = MKS_IDLE;
   \   0000000C   0x20A6             MOVS     R0,#+166
   \   0000000E   0xF884 0x081C      STRB     R0,[R4, #+2076]
   7771                  if(gCfgItems.pwroff_save_mode != 1)
   \   00000012   0x4814             LDR.N    R0,??gcode_M998_0+0x4
   \   00000014   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD006             BEQ.N    ??gcode_M998_2
   7772          		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xF604 0x011C      ADDW     R1,R4,#+2076
   \   00000022   0xF44F 0x6096      MOV      R0,#+1200
   \   00000026   0x.... 0x....      BL       epr_write_data
   7773          
   7774          		card.stopSDPrint();
   \                     ??gcode_M998_2: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader11stopSDPrintEv
   7775          		clear_command_queue();
   \   00000030   0x.... 0x....      BL       _Z19clear_command_queuev
   7776          		quickstop_stepper();
   \   00000034   0x.... 0x....      BL       _Z17quickstop_stepperv
   7777          		print_job_timer.stop();
   \   00000038   0xF604 0x20E8      ADDW     R0,R4,#+2792
   \   0000003C   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   7778          		thermalManager.disable_all_heaters();
   \   00000040   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   7779          		#if FAN_COUNT > 0
   7780          			for (uint8_t i = 0; i < FAN_COUNT; i++) 
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE004             B.N      ??gcode_M998_3
   7781                      {         
   7782                          fanSpeeds[i] = 0;
   \                     ??gcode_M998_4: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x66C8             STR      R0,[R1, #+108]
   7783                          #if 1
   7784                          MKS_FAN_TIM = 0 ;
   \   0000004C   0x4906             LDR.N    R1,??gcode_M998_0+0x8  ;; 0x40000440
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   7785                          #endif
   7786                       }
   \   00000050   0x2001             MOVS     R0,#+1
   \                     ??gcode_M998_3: (+1)
   \   00000052   0x4906             LDR.N    R1,??gcode_M998_0+0xC
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0F7             BEQ.N    ??gcode_M998_4
   7787          		#endif
   7788          		wait_for_heatup = false;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7108             STRB     R0,[R1, #+4]
   7789          	}
   \                     ??gcode_M998_1: (+1)
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   \   0000005E   0xBF00             Nop      
   \                     ??gcode_M998_0:
   \   00000060   0x........         DC32     card
   \   00000064   0x........         DC32     gCfgItems
   \   00000068   0x40000440         DC32     0x40000440
   \   0000006C   0x........         DC32     mks_heating_busy
   7790          
   7791            /**
   7792             * M26: Set SD Card file index
   7793             */

   \                                 In section .text, align 4
   7794            inline void gcode_M26() {
   \                     _Z9gcode_M26v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7795              if (card.cardOK && parser.seenval('S'))
   \   00000002   0x4C09             LDR.N    R4,??gcode_M26_0
   \   00000004   0xF894 0x0763      LDRB     R0,[R4, #+1891]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00C             BEQ.N    ??gcode_M26_1
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD007             BEQ.N    ??gcode_M26_1
   7796                card.setIndex(parser.value_long());
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _ZN10CardReader8setIndexEl
   7797            }
   \                     ??gcode_M26_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M26_0:
   \   00000028   0x........         DC32     card
   7798          
   7799            /**
   7800             * M27: Get SD Card status
   7801             */

   \                                 In section .text, align 4
   7802            inline void gcode_M27() { card.getStatus(); }
   \                     _Z9gcode_M27v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M27_0
   \   00000002   0x.... 0x....      B.W      _ZN10CardReader9getStatusEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M27_0:
   \   00000008   0x........         DC32     card
   7803          
   7804            /**
   7805             * M28: Start SD Write
   7806             */

   \                                 In section .text, align 4
   7807            inline void gcode_M28() { card.openFile(parser.string_arg, false); }
   \                     _Z9gcode_M28v: (+1)
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4802             LDR.N    R0,??gcode_M28_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x4802             LDR.N    R0,??gcode_M28_0+0x4
   \   0000000A   0x.... 0x....      B.W      _ZN10CardReader8openFileEPcbb
   \   0000000E   0xBF00             Nop      
   \                     ??gcode_M28_0:
   \   00000010   0x........         DC32     _ZN11GCodeParser10string_argE
   \   00000014   0x........         DC32     card
   7808          
   7809            /**
   7810             * M29: Stop SD Write
   7811             * Processed in write to file routine above
   7812             */

   \                                 In section .text, align 2
   7813            inline void gcode_M29() {
   7814              // card.saving = false;
   7815            }
   \                     _Z9gcode_M29v: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   7816          
   7817            /**
   7818             * M30 <filename>: Delete SD Card file
   7819             */

   \                                 In section .text, align 4
   7820            inline void gcode_M30() {
   \                     _Z9gcode_M30v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7821              if (card.cardOK) {
   \   00000002   0x4C08             LDR.N    R4,??gcode_M30_0
   \   00000004   0xF894 0x0763      LDRB     R0,[R4, #+1891]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00A             BEQ.N    ??gcode_M30_1
   7822                card.closefile();
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _ZN10CardReader9closefileEb
   7823                card.removeFile(parser.string_arg);
   \   00000014   0x4804             LDR.N    R0,??gcode_M30_0+0x4
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN10CardReader10removeFileEPc
   7824              }
   7825            }
   \                     ??gcode_M30_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M30_0:
   \   00000024   0x........         DC32     card
   \   00000028   0x........         DC32     _ZN11GCodeParser10string_argE
   7826          
   7827          #endif // SDSUPPORT
   7828          
   7829          /**
   7830           * M31: Get the time since the start of SD Print (or last M109)
   7831           */

   \                                 In section .text, align 4
   7832          inline void gcode_M31() {
   \                     _Z9gcode_M31v: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   7833            char buffer[21];
   7834            duration_t elapsed = print_job_timer.duration();
   \   00000004   0x480D             LDR.N    R0,??gcode_M31_0
   \   00000006   0x.... 0x....      BL       _ZN9Stopwatch8durationEv
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       _ZN10duration_tC1ERKj
   7835            elapsed.toString(buffer);
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x.... 0x....      BL       _ZNK10duration_t8toStringEPc
   7836            lcd_setstatus(buffer);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xA802             ADD      R0,SP,#+8
   \   0000001E   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   7837          
   7838            SERIAL_ECHO_START();
   \   00000022   0x4807             LDR.N    R0,??gcode_M31_0+0x4
   \   00000024   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7839            SERIAL_ECHOLNPAIR("Print time: ", buffer);
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0x4806             LDR.N    R0,??gcode_M31_0+0x8
   \   0000002C   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000030   0x210A             MOVS     R1,#+10
   \   00000032   0x4805             LDR.N    R0,??gcode_M31_0+0xC
   \   00000034   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   7840          }
   \   00000038   0xB009             ADD      SP,SP,#+36
   \   0000003A   0xBD00             POP      {PC}             ;; return
   \                     ??gcode_M31_0:
   \   0000003C   0x........         DC32     card+0xAE8
   \   00000040   0x........         DC32     echomagic
   \   00000044   0x........         DC32     _ZZ9gcode_M31vEs
   \   00000048   0x........         DC32     Serial3
   7841          
   7842          #if ENABLED(SDSUPPORT)
   7843          
   7844            /**
   7845             * M32: Select file and start SD Print
   7846             *
   7847             * Examples:
   7848             *
   7849             *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
   7850             *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
   7851             *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
   7852             *
   7853             */

   \                                 In section .text, align 4
   7854            inline void gcode_M32() {
   \                     _Z9gcode_M32v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   7855              if (card.sdprinting) stepper.synchronize();
   \   00000002   0x4C17             LDR.N    R4,??gcode_M32_0
   \   00000004   0xF894 0x0760      LDRB     R0,[R4, #+1888]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??gcode_M32_1
   \   0000000C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   7856          
   7857              if (card.cardOK|| card.usbOK) {
   \                     ??gcode_M32_1: (+1)
   \   00000010   0xF204 0x7060      ADDW     R0,R4,#+1888
   \   00000014   0x78C1             LDRB     R1,[R0, #+3]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0xD020             BEQ.N    ??gcode_M32_2
   7858                const bool call_procedure = parser.boolval('P');
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000022   0x4605             MOV      R5,R0
   7859          
   7860                card.openFile(parser.string_arg, true, call_procedure);
   \   00000024   0x462B             MOV      R3,R5
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x480E             LDR.N    R0,??gcode_M32_0+0x4
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   7861          
   7862                if (parser.seenval('S')) card.setIndex(parser.value_long());
   \   00000032   0x2053             MOVS     R0,#+83
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD005             BEQ.N    ??gcode_M32_3
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   7863          
   7864                card.startFileprint();
   \                     ??gcode_M32_3: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   7865          
   7866                // Procedure calls count as normal print time.
   7867                if (!call_procedure) print_job_timer.start();
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD105             BNE.N    ??gcode_M32_2
   \   00000052   0xF604 0x20E8      ADDW     R0,R4,#+2792
   \   00000056   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000005A   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   7868              }
   7869            }
   \                     ??gcode_M32_2: (+1)
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M32_0:
   \   00000060   0x........         DC32     card
   \   00000064   0x........         DC32     _ZN11GCodeParser10string_argE
   7870          
   7871            #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
   7872          
   7873              /**
   7874               * M33: Get the long full path of a file or folder
   7875               *
   7876               * Parameters:
   7877               *   <dospath> Case-insensitive DOS-style path to a file or folder
   7878               *
   7879               * Example:
   7880               *   M33 miscel~1/armchair/armcha~1.gco
   7881               *
   7882               * Output:
   7883               *   /Miscellaneous/Armchair/Armchair.gcode
   7884               */
   7885              inline void gcode_M33() {
   7886                card.printLongPath(parser.string_arg);
   7887              }
   7888          
   7889            #endif
   7890          
   7891            #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
   7892              /**
   7893               * M34: Set SD Card Sorting Options
   7894               */
   7895              inline void gcode_M34() {
   7896                if (parser.seen('S')) card.setSortOn(parser.value_bool());
   7897                if (parser.seenval('F')) {
   7898                  const int v = parser.value_long();
   7899                  card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
   7900                }
   7901                //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
   7902              }
   7903            #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
   7904          
   7905            /**
   7906             * M928: Start SD Write
   7907             */

   \                                 In section .text, align 4
   7908            inline void gcode_M928() {
   7909              card.openLogFile(parser.string_arg);
   \                     _Z10gcode_M928v: (+1)
   \   00000000   0x4802             LDR.N    R0,??gcode_M928_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x4802             LDR.N    R0,??gcode_M928_0+0x4
   \   00000006   0x.... 0x....      B.W      _ZN10CardReader11openLogFileEPc
   \   0000000A   0xBF00             Nop      
   \                     ??gcode_M928_0:
   \   0000000C   0x........         DC32     _ZN11GCodeParser10string_argE
   \   00000010   0x........         DC32     card
   7910            }
   7911          
   7912          #endif // SDSUPPORT
   7913          
   7914          /**
   7915           * Sensitive pin test for M42, M226
   7916           */

   \                                 In section .text, align 2, keep-with-next
   7917          static bool pin_is_protected(const int8_t pin) {
   7918            static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   7919            for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
   \                     _Z16pin_is_protecteda: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??pin_is_protected_0
   \                     ??pin_is_protected_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??pin_is_protected_0: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x2933             CMP      R1,#+51
   \   0000000A   0xD206             BCS.N    ??pin_is_protected_2
   7920              if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   \   0000000C   0x.... 0x....      ADR.W    R2,??sensitive_pins
   \   00000010   0x568A             LDRSB    R2,[R1, R2]
   \   00000012   0x4290             CMP      R0,R2
   \   00000014   0xD1F6             BNE.N    ??pin_is_protected_1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x4770             BX       LR
   7921            return false;
   \                     ??pin_is_protected_2: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   7922          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??sensitive_pins:
   \   00000000   0x00 0x01          DC8 0, 1, 1, 0, 2, 3, 3, 6, 5, 7, 8, 8, 11, 10, 12, 13, 14, 14, -1, 21
   \              0x01 0x00    
   \              0x02 0x03    
   \              0x03 0x06    
   \              0x05 0x07    
   \              0x08 0x08    
   \              0x0B 0x0A    
   \              0x0C 0x0D    
   \              0x0E 0x0E    
   \              0xFF 0x15    
   \   00000014   0x11 0xFF          DC8 17, -1, -1, -1, 16, 15, 17, -1, -1, 19, 18, 20, -1, -1, 21, 78, 22
   \              0xFF 0xFF    
   \              0x10 0x0F    
   \              0x11 0xFF    
   \              0xFF 0x13    
   \              0x12 0x14    
   \              0xFF 0xFF    
   \              0x15 0x4E    
   \              0x16         
   \   00000025   0xFF 0x4F          DC8 -1, 79, 23, -1, 80, 19, 18, 20, -1, -1, -1, -1, -1, -1, 0
   \              0x17 0xFF    
   \              0x50 0x13    
   \              0x12 0x14    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0x00         
   7923          
   7924          /**
   7925           * M42: Change pin status via GCode
   7926           *
   7927           *  P<pin>  Pin number (LED if omitted)
   7928           *  S<byte> Pin status from 0 - 255
   7929           */

   \                                 In section .text, align 4
   7930          inline void gcode_M42() {
   \                     _Z9gcode_M42v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   7931            if (!parser.seenval('S')) return;
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD02B             BEQ.N    ??gcode_M42_0
   7932            const byte pin_status = parser.value_byte();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4604             MOV      R4,R0
   7933          
   7934            const int pin_number = parser.intval('P', LED_PIN);
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x2050             MOVS     R0,#+80
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x0005             MOVS     R5,R0
   7935            if (pin_number < 0) return;
   \   0000001E   0xD421             BMI.N    ??gcode_M42_0
   7936          
   7937            if (pin_is_protected(pin_number)) {
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x.... 0x....      BL       _Z16pin_is_protecteda
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD007             BEQ.N    ??gcode_M42_1
   7938              SERIAL_ERROR_START();
   \   0000002A   0x480F             LDR.N    R0,??gcode_M42_2
   \   0000002C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7939              SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
   \   00000030   0x480E             LDR.N    R0,??gcode_M42_2+0x4
   \   00000032   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000036   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   7940              return;
   7941            }
   7942          
   7943            pinMode(pin_number, OUTPUT);
   7944            digitalWrite(pin_number, pin_status);
   \                     ??gcode_M42_1: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x4622             MOV      R2,R4
   \   0000003E   0xB252             SXTB     R2,R2
   \   00000040   0xD408             BMI.N    ??gcode_M42_3
   \   00000042   0x480B             LDR.N    R0,??gcode_M42_2+0x8
   \   00000044   0xF830 0x1015      LDRH     R1,[R0, R5, LSL #+1]
   \   00000048   0x480A             LDR.N    R0,??gcode_M42_2+0xC
   \   0000004A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000004E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000052   0xE003             B.N      ??gcode_M42_4
   \                     ??gcode_M42_3: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x4608             MOV      R0,R1
   \   00000058   0x.... 0x....      BL       HAL_GPIO_WritePin
   7945            //analogWrite(pin_number, pin_status);
   7946          
   7947            #if FAN_COUNT > 0
   7948              switch (pin_number) {
   \                     ??gcode_M42_4: (+1)
   \   0000005C   0x2D11             CMP      R5,#+17
   \   0000005E   0xD101             BNE.N    ??gcode_M42_0
   7949                #if HAS_FAN0
   7950                  case FAN_PIN: fanSpeeds[0] = pin_status; break;
   \   00000060   0x4805             LDR.N    R0,??gcode_M42_2+0x10
   \   00000062   0x66C4             STR      R4,[R0, #+108]
   7951                #endif
   7952                #if HAS_FAN1
   7953                  case FAN1_PIN: fanSpeeds[1] = pin_status; break;
   7954                #endif
   7955                #if HAS_FAN2
   7956                  case FAN2_PIN: fanSpeeds[2] = pin_status; break;
   7957                #endif
   7958              }
   7959            #endif
   7960          }
   \                     ??gcode_M42_0: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   00000066   0xBF00             Nop      
   \                     ??gcode_M42_2:
   \   00000068   0x........         DC32     errormagic
   \   0000006C   0x........         DC32     _ZZ9gcode_M42vEs
   \   00000070   0x........         DC32     gArrayGpioPin
   \   00000074   0x........         DC32     gArrayGpioPort
   \   00000078   0x........         DC32     mks_heating_busy
   7961          
   7962          #if ENABLED(PINS_DEBUGGING)
   7963          
   7964            #include "pinsDebug.h"
   7965          
   7966            inline void toggle_pins() {
   7967              const bool I_flag = parser.boolval('I');
   7968              const int repeat = parser.intval('R', 1),
   7969                        start = parser.intval('S'),
   7970                        end = parser.intval('L', NUM_DIGITAL_PINS - 1),
   7971                        wait = parser.intval('W', 500);
   7972          
   7973              for (uint8_t pin = start; pin <= end; pin++) {
   7974                //report_pin_state_extended(pin, I_flag, false);
   7975          
   7976                if (!I_flag && pin_is_protected(pin)) {
   7977                  report_pin_state_extended(pin, I_flag, true, "Untouched ");
   7978                  SERIAL_EOL();
   7979                }
   7980                else {
   7981                  report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
   7982                  #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
   7983                    if (pin == TEENSY_E2) {
   7984                      SET_OUTPUT(TEENSY_E2);
   7985                      for (int16_t j = 0; j < repeat; j++) {
   7986                        WRITE(TEENSY_E2, LOW);  safe_delay(wait);
   7987                        WRITE(TEENSY_E2, HIGH); safe_delay(wait);
   7988                        WRITE(TEENSY_E2, LOW);  safe_delay(wait);
   7989                      }
   7990                    }
   7991                    else if (pin == TEENSY_E3) {
   7992                      SET_OUTPUT(TEENSY_E3);
   7993                      for (int16_t j = 0; j < repeat; j++) {
   7994                        WRITE(TEENSY_E3, LOW);  safe_delay(wait);
   7995                        WRITE(TEENSY_E3, HIGH); safe_delay(wait);
   7996                        WRITE(TEENSY_E3, LOW);  safe_delay(wait);
   7997                      }
   7998                    }
   7999                    else
   8000                  #endif
   8001                  {
   8002                    pinMode(pin, OUTPUT);
   8003                    for (int16_t j = 0; j < repeat; j++) {
   8004                      digitalWrite(pin, 0); safe_delay(wait);
   8005                      digitalWrite(pin, 1); safe_delay(wait);
   8006                      digitalWrite(pin, 0); safe_delay(wait);
   8007                    }
   8008                  }
   8009          
   8010                }
   8011                SERIAL_EOL();
   8012              }
   8013              SERIAL_ECHOLNPGM("Done.");
   8014          
   8015            } // toggle_pins
   8016          
   8017            inline void servo_probe_test() {
   8018              #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
   8019          
   8020                SERIAL_ERROR_START();
   8021                SERIAL_ERRORLNPGM("SERVO not setup");
   8022          
   8023              #elif !HAS_Z_SERVO_ENDSTOP
   8024          
   8025                SERIAL_ERROR_START();
   8026                SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
   8027          
   8028              #else // HAS_Z_SERVO_ENDSTOP
   8029          
   8030                const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
   8031          
   8032                SERIAL_PROTOCOLLNPGM("Servo probe test");
   8033                SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
   8034                SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
   8035                SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
   8036          
   8037                bool probe_inverting;
   8038          
   8039                //#if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   8040                uint8_t PROBE_TEST_PIN = 0;
   8041          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   8042          	  {
   8043          
   8044                 // #define PROBE_TEST_PIN Z_MIN_PIN
   8045          	   PROBE_TEST_PIN = Z_MIN_PIN;
   8046          
   8047                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
   8048                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
   8049                  SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
   8050          /*
   8051                  #if Z_MIN_ENDSTOP_INVERTING
   8052                    SERIAL_PROTOCOLLNPGM("true");
   8053                  #else
   8054                    SERIAL_PROTOCOLLNPGM("false");
   8055                  #endif
   8056          */		if(Z_MIN_ENDSTOP_INVERTING)
   8057          			SERIAL_PROTOCOLLNPGM("true");
   8058          		else
   8059          			SERIAL_PROTOCOLLNPGM("false");
   8060          		/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
   8061          
   8062                  probe_inverting = Z_MIN_ENDSTOP_INVERTING;
   8063          	  }
   8064                //#elif ENABLED(Z_MIN_PROBE_ENDSTOP)
   8065          	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
   8066          	  {
   8067                  //#define PROBE_TEST_PIN Z_MIN_PROBE_PIN
   8068                  PROBE_TEST_PIN = Z_MAX_PIN;
   8069                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
   8070                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
   8071                  SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
   8072          /*
   8073                  #if Z_MIN_PROBE_ENDSTOP_INVERTING
   8074                    SERIAL_PROTOCOLLNPGM("true");
   8075                  #else
   8076                    SERIAL_PROTOCOLLNPGM("false");
   8077                  #endif
   8078          */
   8079          		if(Z_MIN_PROBE_ENDSTOP_INVERTING)
   8080          			SERIAL_PROTOCOLLNPGM("true");
   8081          		else
   8082          			SERIAL_PROTOCOLLNPGM("false");
   8083          	/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
   8084          
   8085                  probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
   8086          	  }
   8087                //#endif
   8088          
   8089                SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
   8090                SET_INPUT_PULLUP(PROBE_TEST_PIN);
   8091                bool deploy_state, stow_state;
   8092                for (uint8_t i = 0; i < 4; i++) {
   8093                  MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
   8094                  safe_delay(500);
   8095                  deploy_state = READ(PROBE_TEST_PIN);
   8096                  MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
   8097                  safe_delay(500);
   8098                  stow_state = READ(PROBE_TEST_PIN);
   8099                }
   8100                if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
   8101          
   8102                refresh_cmd_timeout();
   8103          
   8104                if (deploy_state != stow_state) {
   8105                  SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
   8106                  if (deploy_state) {
   8107                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
   8108                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
   8109                  }
   8110                  else {
   8111                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
   8112                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
   8113                  }
   8114                  //#if ENABLED(BLTOUCH)
   8115                  if(MKSTOUCH == 1)
   8116                    SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
   8117                  //#endif
   8118          
   8119                }
   8120                else {                                           // measure active signal length
   8121                  MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
   8122                  safe_delay(500);
   8123                  SERIAL_PROTOCOLLNPGM("please trigger probe");
   8124                  uint16_t probe_counter = 0;
   8125          
   8126                  // Allow 30 seconds max for operator to trigger probe
   8127                  for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
   8128          
   8129                    safe_delay(2);
   8130          
   8131                    if (0 == j % (500 * 1)) // keep cmd_timeout happy
   8132                      refresh_cmd_timeout();
   8133          
   8134                    if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
   8135          
   8136                      for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
   8137                        safe_delay(2);
   8138          
   8139                      if (probe_counter == 50)
   8140                        SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
   8141                      else if (probe_counter >= 2)
   8142                        SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
   8143                      else
   8144                        SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
   8145          
   8146                      MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
   8147          
   8148                    }  // pulse detected
   8149          
   8150                  } // for loop waiting for trigger
   8151          
   8152                  if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
   8153          
   8154                } // measure active signal length
   8155          
   8156              #endif
   8157          
   8158            } // servo_probe_test
   8159          
   8160            /**
   8161             * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
   8162             *
   8163             *  M43         - report name and state of pin(s)
   8164             *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
   8165             *                  I       Flag to ignore Marlin's pin protection.
   8166             *
   8167             *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
   8168             *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
   8169             *                  I       Flag to ignore Marlin's pin protection.
   8170             *
   8171             *  M43 E<bool> - Enable / disable background endstop monitoring
   8172             *                  - Machine continues to operate
   8173             *                  - Reports changes to endstops
   8174             *                  - Toggles LED_PIN when an endstop changes
   8175             *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
   8176             *
   8177             *  M43 T       - Toggle pin(s) and report which pin is being toggled
   8178             *                  S<pin>  - Start Pin number.   If not given, will default to 0
   8179             *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
   8180             *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
   8181             *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
   8182             *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
   8183             *
   8184             *  M43 S       - Servo probe test
   8185             *                  P<index> - Probe index (optional - defaults to 0
   8186             */
   8187            inline void gcode_M43() {
   8188          
   8189              if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
   8190                toggle_pins();
   8191                return;
   8192              }
   8193          
   8194              // Enable or disable endstop monitoring
   8195              if (parser.seen('E')) {
   8196                endstop_monitor_flag = parser.value_bool();
   8197                SERIAL_PROTOCOLPGM("endstop monitor ");
   8198                serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
   8199                SERIAL_PROTOCOLLNPGM("abled");
   8200                return;
   8201              }
   8202          
   8203              if (parser.seen('S')) {
   8204                servo_probe_test();
   8205                return;
   8206              }
   8207          
   8208              // Get the range of pins to test or watch
   8209              const uint8_t first_pin = parser.byteval('P'),
   8210                            last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
   8211          
   8212              if (first_pin > last_pin) return;
   8213          
   8214              const bool ignore_protection = parser.boolval('I');
   8215          
   8216              // Watch until click, M108, or reset
   8217              if (parser.boolval('W')) {
   8218                SERIAL_PROTOCOLLNPGM("Watching pins");
   8219                byte pin_state[last_pin - first_pin + 1];
   8220                for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   8221                  if (pin_is_protected(pin) && !ignore_protection) continue;
   8222                  pinMode(pin, INPUT_PULLUP);
   8223                  delay(1);
   8224                  /*
   8225                    if (IS_ANALOG(pin))
   8226                      pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
   8227                    else
   8228                  //
   8229                  */
   8230                      pin_state[pin - first_pin] = digitalRead(pin);
   8231                }
   8232          
   8233                #if HAS_RESUME_CONTINUE
   8234                  wait_for_user = true;
   8235                  KEEPALIVE_STATE(PAUSED_FOR_USER);
   8236                #endif
   8237          
   8238                for (;;) {
   8239                  for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   8240                    if (pin_is_protected(pin) && !ignore_protection) continue;
   8241                    const byte val =
   8242                      /*
   8243                        IS_ANALOG(pin)
   8244                          ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
   8245                          :
   8246                      //
   8247                      */
   8248                        digitalRead(pin);
   8249                    if (val != pin_state[pin - first_pin]) {
   8250                      report_pin_state_extended(pin, ignore_protection, false);
   8251                      pin_state[pin - first_pin] = val;
   8252                    }
   8253                  }
   8254          
   8255                  #if HAS_RESUME_CONTINUE
   8256                    if (!wait_for_user) {
   8257                      KEEPALIVE_STATE(IN_HANDLER);
   8258                      break;
   8259                    }
   8260                  #endif
   8261          
   8262                  safe_delay(200);
   8263                }
   8264                return;
   8265              }
   8266          
   8267              // Report current state of selected pin(s)
   8268              for (uint8_t pin = first_pin; pin <= last_pin; pin++)
   8269                report_pin_state_extended(pin, ignore_protection, true);
   8270            }
   8271          
   8272          #endif // PINS_DEBUGGING
   8273          
   8274          #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   8275          
   8276            /**
   8277             * M48: Z probe repeatability measurement function.
   8278             *
   8279             * Usage:
   8280             *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
   8281             *     P = Number of sampled points (4-50, default 10)
   8282             *     X = Sample X position
   8283             *     Y = Sample Y position
   8284             *     V = Verbose level (0-4, default=1)
   8285             *     E = Engage Z probe for each reading
   8286             *     L = Number of legs of movement before probe
   8287             *     S = Schizoid (Or Star if you prefer)
   8288             *
   8289             * This function requires the machine to be homed before invocation.
   8290             */
   8291            inline void gcode_M48() {
   8292          
   8293              if (axis_unhomed_error()) return;
   8294          
   8295              const int8_t verbose_level = parser.byteval('V', 1);
   8296              if (!WITHIN(verbose_level, 0, 4)) {
   8297                SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   8298                return;
   8299              }
   8300          
   8301              if (verbose_level > 0)
   8302                SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
   8303          
   8304              const int8_t n_samples = parser.byteval('P', 10);
   8305              if (!WITHIN(n_samples, 4, 50)) {
   8306                SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
   8307                return;
   8308              }
   8309          
   8310              const bool stow_probe_after_each = parser.boolval('E');
   8311          
   8312              float X_current = current_position[X_AXIS],
   8313                    Y_current = current_position[Y_AXIS];
   8314          
   8315              const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
   8316                          Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
   8317          
   8318              //#if DISABLED(DELTA)
   8319              if(MACHINETPYE != DELTA)
   8320              {
   8321                if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
   8322                  out_of_range_error(PSTR("X"));
   8323                  return;
   8324                }
   8325                if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
   8326                  out_of_range_error(PSTR("Y"));
   8327                  return;
   8328                }
   8329              }
   8330              //#else
   8331              else
   8332               {
   8333               if(MACHINETPYE & IS_KINEMATIC)
   8334                  {
   8335                if (!position_is_reachable_by_probe_IS_KINEMATIC(X_probe_location, Y_probe_location)) {
   8336                  SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
   8337                  return;
   8338                }
   8339                  }
   8340               else
   8341                  {
   8342                if (!position_is_reachable_by_probe_IS_CARTESIAN(X_probe_location, Y_probe_location)) {
   8343                  SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
   8344                  return;
   8345                }
   8346                  }        
   8347               }
   8348              //#endif
   8349          
   8350              bool seen_L = parser.seen('L');
   8351              uint8_t n_legs = seen_L ? parser.value_byte() : 0;
   8352              if (n_legs > 15) {
   8353                SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
   8354                return;
   8355              }
   8356              if (n_legs == 1) n_legs = 2;
   8357          
   8358              const bool schizoid_flag = parser.boolval('S');
   8359              if (schizoid_flag && !seen_L) n_legs = 7;
   8360          
   8361              /**
   8362               * Now get everything to the specified probe point So we can safely do a
   8363               * probe to get us close to the bed.  If the Z-Axis is far from the bed,
   8364               * we don't want to use that as a starting point for each probe.
   8365               */
   8366              if (verbose_level > 2)
   8367                SERIAL_PROTOCOLLNPGM("Positioning the probe...");
   8368          
   8369              // Disable bed level correction in M48 because we want the raw data when we probe
   8370          /*
   8371              #if HAS_LEVELING
   8372                const bool was_enabled = planner.leveling_active;
   8373                set_bed_leveling_enabled(false);
   8374              #endif
   8375          */
   8376          	bool was_enabled;
   8377          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   8378          		was_enabled = ubl.state.active;
   8379          	else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   8380          		was_enabled = mbl.active();
   8381          	else if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
   8382          		was_enabled = planner.leveling_active;
   8383          
   8384          	if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
   8385          		set_bed_leveling_enabled(false);
   8386          
   8387              setup_for_endstop_or_probe_move();
   8388          
   8389              double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
   8390          
   8391              // Move to the first point, deploy, and probe
   8392              const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
   8393              bool probing_good = !isnan(t);
   8394          
   8395              if (probing_good) {
   8396                //randomSeed(millis());
   8397          	  srand(millis());
   8398          
   8399                for (uint8_t n = 0; n < n_samples; n++) {
   8400                  if (n_legs) {
   8401                    const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
   8402                    float angle = random(0.0, 360.0);
   8403                    const float radius = random(
   8404                      #if ENABLED(DELTA)
   8405                        0.1250000000 * (DELTA_PROBEABLE_RADIUS),
   8406                        0.3333333333 * (DELTA_PROBEABLE_RADIUS)
   8407                      #else
   8408                        5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
   8409                      #endif
   8410                    );
   8411          
   8412                    if (verbose_level > 3) {
   8413                      SERIAL_ECHOPAIR("Starting radius: ", radius);
   8414                      SERIAL_ECHOPAIR("   angle: ", angle);
   8415                      SERIAL_ECHOPGM(" Direction: ");
   8416                      if (dir > 0) SERIAL_ECHOPGM("Counter-");
   8417                      SERIAL_ECHOLNPGM("Clockwise");
   8418                    }
   8419          
   8420                    for (uint8_t l = 0; l < n_legs - 1; l++) {
   8421                      double delta_angle;
   8422          
   8423                      if (schizoid_flag)
   8424                        // The points of a 5 point star are 72 degrees apart.  We need to
   8425                        // skip a point and go to the next one on the star.
   8426                        delta_angle = dir * 2.0 * 72.0;
   8427          
   8428                      else
   8429                        // If we do this line, we are just trying to move further
   8430                        // around the circle.
   8431                        delta_angle = dir * (float) random(25, 45);
   8432          
   8433                      angle += delta_angle;
   8434          
   8435                      while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
   8436                        angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
   8437                      while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
   8438                        angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
   8439          
   8440                      X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
   8441                      Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
   8442          
   8443                      //#if DISABLED(DELTA)
   8444                      if(MACHINETPYE != DELTA)
   8445                      {
   8446                        X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
   8447                        Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
   8448                      }
   8449                      //#else
   8450                      else
   8451                      {
   8452                        // If we have gone out too far, we can do a simple fix and scale the numbers
   8453                        // back in closer to the origin.
   8454                        if(MACHINETPYE & IS_KINEMATIC)
   8455                          {
   8456                        while (!position_is_reachable_by_probe_IS_KINEMATIC(X_current, Y_current)) {
   8457                          X_current *= 0.8;
   8458                          Y_current *= 0.8;
   8459                          if (verbose_level > 3) {
   8460                            SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
   8461                            SERIAL_ECHOLNPAIR(", ", Y_current);
   8462                          }
   8463                        }
   8464                          }
   8465                        else
   8466                           {
   8467                        while (!position_is_reachable_by_probe_IS_CARTESIAN(X_current, Y_current)) {
   8468                          X_current *= 0.8;
   8469                          Y_current *= 0.8;
   8470                          if (verbose_level > 3) {
   8471                            SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
   8472                            SERIAL_ECHOLNPAIR(", ", Y_current);
   8473                          }
   8474                        }
   8475                          }               
   8476                      }
   8477                      //#endif
   8478                      if (verbose_level > 3) {
   8479                        SERIAL_PROTOCOLPGM("Going to:");
   8480                        SERIAL_ECHOPAIR(" X", X_current);
   8481                        SERIAL_ECHOPAIR(" Y", Y_current);
   8482                        SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
   8483                      }
   8484                      do_blocking_move_to_xy(X_current, Y_current);
   8485                    } // n_legs loop
   8486                  } // n_legs
   8487          
   8488                  // Probe a single point
   8489                  sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
   8490          
   8491                  // Break the loop if the probe fails
   8492                  probing_good = !isnan(sample_set[n]);
   8493                  if (!probing_good) break;
   8494          
   8495                  /**
   8496                   * Get the current mean for the data points we have so far
   8497                   */
   8498                  double sum = 0.0;
   8499                  for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
   8500                  mean = sum / (n + 1);
   8501          
   8502                  NOMORE(min, sample_set[n]);
   8503                  NOLESS(max, sample_set[n]);
   8504          
   8505                  /**
   8506                   * Now, use that mean to calculate the standard deviation for the
   8507                   * data points we have so far
   8508                   */
   8509                  sum = 0.0;
   8510                  for (uint8_t j = 0; j <= n; j++)
   8511                    sum += sq(sample_set[j] - mean);
   8512          
   8513                  sigma = SQRT(sum / (n + 1));
   8514                  if (verbose_level > 0) {
   8515                    if (verbose_level > 1) {
   8516                      SERIAL_PROTOCOL(n + 1);
   8517                      SERIAL_PROTOCOLPGM(" of ");
   8518                      SERIAL_PROTOCOL((int)n_samples);
   8519                      SERIAL_PROTOCOLPGM(": z: ");
   8520                      SERIAL_PROTOCOL_F(sample_set[n], 3);
   8521                      if (verbose_level > 2) {
   8522                        SERIAL_PROTOCOLPGM(" mean: ");
   8523                        SERIAL_PROTOCOL_F(mean, 4);
   8524                        SERIAL_PROTOCOLPGM(" sigma: ");
   8525                        SERIAL_PROTOCOL_F(sigma, 6);
   8526                        SERIAL_PROTOCOLPGM(" min: ");
   8527                        SERIAL_PROTOCOL_F(min, 3);
   8528                        SERIAL_PROTOCOLPGM(" max: ");
   8529                        SERIAL_PROTOCOL_F(max, 3);
   8530                        SERIAL_PROTOCOLPGM(" range: ");
   8531                        SERIAL_PROTOCOL_F(max-min, 3);
   8532                      }
   8533                      SERIAL_EOL();
   8534                    }
   8535                  }
   8536          
   8537                } // n_samples loop
   8538              }
   8539          
   8540              STOW_PROBE();
   8541          
   8542              if (probing_good) {
   8543                SERIAL_PROTOCOLLNPGM("Finished!");
   8544          
   8545                if (verbose_level > 0) {
   8546                  SERIAL_PROTOCOLPGM("Mean: ");
   8547                  SERIAL_PROTOCOL_F(mean, 6);
   8548                  SERIAL_PROTOCOLPGM(" Min: ");
   8549                  SERIAL_PROTOCOL_F(min, 3);
   8550                  SERIAL_PROTOCOLPGM(" Max: ");
   8551                  SERIAL_PROTOCOL_F(max, 3);
   8552                  SERIAL_PROTOCOLPGM(" Range: ");
   8553                  SERIAL_PROTOCOL_F(max-min, 3);
   8554                  SERIAL_EOL();
   8555                }
   8556          
   8557                SERIAL_PROTOCOLPGM("Standard Deviation: ");
   8558                SERIAL_PROTOCOL_F(sigma, 6);
   8559                SERIAL_EOL();
   8560                SERIAL_EOL();
   8561              }
   8562          
   8563              clean_up_after_endstop_or_probe_move();
   8564          
   8565              // Re-enable bed level correction if it had been on
   8566              //#if HAS_LEVELING
   8567              if(BED_LEVELING_METHOD&HAS_LEVELING)
   8568                set_bed_leveling_enabled(was_enabled);
   8569              //#endif
   8570          
   8571              report_current_position();
   8572            }
   8573          
   8574          #endif // Z_MIN_PROBE_REPEATABILITY_TEST
   8575          
   8576          #if 1//ENABLED(G26_MESH_VALIDATION)
   8577          

   \                                 In section .text, align 4
   8578            inline void gcode_M49() {
   \                     _Z9gcode_M49v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   8579              g26_debug_flag ^= true;
   \   00000002   0x4C0B             LDR.N    R4,??gcode_M49_0
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
   \   00000012   0x7020             STRB     R0,[R4, #+0]
   8580              SERIAL_PROTOCOLPGM("G26 Debug ");
   \   00000014   0x4807             LDR.N    R0,??gcode_M49_0+0x4
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8581              serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??gcode_M49_1
   \   00000020   0x4805             LDR.N    R0,??gcode_M49_0+0x8
   \   00000022   0xE000             B.N      ??gcode_M49_2
   \                     ??gcode_M49_1: (+1)
   \   00000024   0x4805             LDR.N    R0,??gcode_M49_0+0xC
   \                     ??gcode_M49_2: (+1)
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \   0000002E   0xBF00             Nop      
   \                     ??gcode_M49_0:
   \   00000030   0x........         DC32     g26_debug_flag
   \   00000034   0x........         DC32     _ZZ9gcode_M49vEs
   \   00000038   0x........         DC32     _ZZ9gcode_M49vEs_0
   \   0000003C   0x........         DC32     _ZZ9gcode_M49vEs_1
   8582            }
   8583          
   8584          #endif // G26_MESH_VALIDATION
   8585          
   8586          #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
   8587            /**
   8588             * M73: Set percentage complete (for display on LCD)
   8589             *
   8590             * Example:
   8591             *   M73 P25 ; Set progress to 25%
   8592             *
   8593             * Notes:
   8594             *   This has no effect during an SD print job
   8595             */
   8596            inline void gcode_M73() {
   8597              if (!IS_SD_PRINTING && parser.seen('P')) {
   8598                progress_bar_percent = parser.value_byte();
   8599                NOMORE(progress_bar_percent, 100);
   8600              }
   8601            }
   8602          #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
   8603          
   8604          /**
   8605           * M75: Start print timer
   8606           */

   \                                 In section .text, align 4
   8607          inline void gcode_M75() { print_job_timer.start(); }
   \                     _Z9gcode_M75v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M75_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M75_0:
   \   00000008   0x........         DC32     card+0xAE8
   8608          
   8609          /**
   8610           * M76: Pause print timer
   8611           */

   \                                 In section .text, align 4
   8612          inline void gcode_M76() { print_job_timer.pause(); }
   \                     _Z9gcode_M76v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M76_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch5pauseEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M76_0:
   \   00000008   0x........         DC32     card+0xAE8
   8613          
   8614          /**
   8615           * M77: Stop print timer
   8616           */

   \                                 In section .text, align 4
   8617          inline void gcode_M77() { print_job_timer.stop(); }
   \                     _Z9gcode_M77v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M77_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch4stopEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M77_0:
   \   00000008   0x........         DC32     card+0xAE8
   8618          
   8619          #if ENABLED(PRINTCOUNTER)
   8620            /**
   8621             * M78: Show print statistics
   8622             */
   8623            inline void gcode_M78() {
   8624              // "M78 S78" will reset the statistics
   8625              if (parser.intval('S') == 78)
   8626                print_job_timer.initStats();
   8627              else
   8628                print_job_timer.showStats();
   8629            }
   8630          #endif
   8631          
   8632          /**
   8633           * M104: Set hot end temperature
   8634           */

   \                                 In section .text, align 4
   8635          inline void gcode_M104() {
   \                     _Z10gcode_M104v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   8636            if (get_target_extruder_from_command(104)) return;
   \   00000002   0x2068             MOVS     R0,#+104
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD157             BNE.N    ??gcode_M104_1
   8637            if (DEBUGGING(DRYRUN)) return;
   \   0000000C   0x4C2C             LDR.N    R4,??gcode_M104_2
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x0700             LSLS     R0,R0,#+28
   \   00000012   0xD453             BMI.N    ??gcode_M104_1
   8638          
   8639            #if ENABLED(SINGLENOZZLE)
   8640              if (target_extruder != active_extruder) return;
   8641            #endif
   8642          
   8643            if (parser.seenval('S')) {
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD04A             BEQ.N    ??gcode_M104_3
   8644              const int16_t temp = parser.value_celsius();
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000022   0x.... 0x....      BL       __aeabi_f2iz
   8645              thermalManager.setTargetHotend(temp, target_extruder);
   \   00000026   0x7961             LDRB     R1,[R4, #+5]
   \   00000028   0x460D             MOV      R5,R1
   \   0000002A   0xB200             SXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       __aeabi_i2f
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   8646          
   8647              #if ENABLED(DUAL_X_CARRIAGE)
   8648                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   8649                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   8650              #endif
   8651          
   8652              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   8653                /**
   8654                 * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
   8655                 * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
   8656                 * standby mode, for instance in a dual extruder setup, without affecting
   8657                 * the running print timer.
   8658                 */
   8659                if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000003A   0x4605             MOV      R5,R0
   \   0000003C   0x4821             LDR.N    R0,??gcode_M104_2+0x4
   \   0000003E   0x6AC1             LDR      R1,[R0, #+44]
   \   00000040   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000044   0x.... 0x....      BL       __aeabi_fmul
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000004E   0xD806             BHI.N    ??gcode_M104_4
   8660                  print_job_timer.stop();
   \   00000050   0x481D             LDR.N    R0,??gcode_M104_2+0x8
   \   00000052   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   8661                  LCD_MESSAGEPGM(WELCOME_MSG);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x481C             LDR.N    R0,??gcode_M104_2+0xC
   \   0000005A   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8662                }
   8663              #endif
   8664          
   8665              //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
   8666              //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   8667          		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M104_4: (+1)
   \   0000005E   0x7960             LDRB     R0,[R4, #+5]
   \   00000060   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000064   0x4605             MOV      R5,R0
   \   00000066   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000072   0xD21F             BCS.N    ??gcode_M104_3
   8668          		{
   8669          		switch(target_extruder)
   \   00000074   0x7960             LDRB     R0,[R4, #+5]
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD81C             BHI.N    ??gcode_M104_3
   \   0000007A   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M104_0:
   \   0000007E   0x03 0x08          DC8      0x3,0x8,0xD,0x12
   \              0x0D 0x12    
   \   00000082   0x17 0x00          DC8      0x17,0x0
   8670          			{
   8671          			case 0:
   8672          				LCD_MESSAGEPGM("E1 Heating...");
   \                     ??gcode_M104_5: (+1)
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x4812             LDR.N    R0,??gcode_M104_2+0x10
   \   00000088   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8673          				break;
   \   0000008C   0xE012             B.N      ??gcode_M104_3
   8674          			case 1:
   8675          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M104_6: (+1)
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x4810             LDR.N    R0,??gcode_M104_2+0x14
   \   00000092   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8676          				break;
   \   00000096   0xE00D             B.N      ??gcode_M104_3
   8677          			case 2:
   8678          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M104_7: (+1)
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x480F             LDR.N    R0,??gcode_M104_2+0x18
   \   0000009C   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8679          				break;
   \   000000A0   0xE008             B.N      ??gcode_M104_3
   8680          			case 3:
   8681          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M104_8: (+1)
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x480D             LDR.N    R0,??gcode_M104_2+0x1C
   \   000000A6   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8682          				break;
   \   000000AA   0xE003             B.N      ??gcode_M104_3
   8683          			case 4:
   8684          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M104_9: (+1)
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x480C             LDR.N    R0,??gcode_M104_2+0x20
   \   000000B0   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8685          				break;
   8686          			default: break;
   8687          				
   8688          			}
   8689          		}    
   8690            }
   8691          
   8692            #if ENABLED(AUTOTEMP)
   8693              planner.autotemp_M104_M109();
   \                     ??gcode_M104_3: (+1)
   \   000000B4   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   000000B8   0x.... 0x....      B.W      _ZN7Planner18autotemp_M104_M109Ev
   \                     ??gcode_M104_1: (+1)
   \   000000BC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   000000BE   0xBF00             Nop      
   \                     ??gcode_M104_2:
   \   000000C0   0x........         DC32     mks_heating_busy
   \   000000C4   0x........         DC32     mksCfg
   \   000000C8   0x........         DC32     card+0xAE8
   \   000000CC   0x........         DC32     _ZZ10gcode_M104vEs
   \   000000D0   0x........         DC32     _ZZ10gcode_M104vEs_0
   \   000000D4   0x........         DC32     _ZZ10gcode_M104vEs_1
   \   000000D8   0x........         DC32     _ZZ10gcode_M104vEs_2
   \   000000DC   0x........         DC32     _ZZ10gcode_M104vEs_3
   \   000000E0   0x........         DC32     _ZZ10gcode_M104vEs_4
   8694            #endif
   8695          }
   8696          
   8697          /**
   8698           * M105: Read hot end and bed temperature
   8699           */

   \                                 In section .text, align 4
   8700          inline void gcode_M105() {
   \                     _Z10gcode_M105v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8701            if (get_target_extruder_from_command(105)) return;
   \   00000002   0x2069             MOVS     R0,#+105
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD10A             BNE.N    ??gcode_M105_0
   8702          /*
   8703            #if HAS_TEMP_HOTEND || HAS_TEMP_BED
   8704              SERIAL_PROTOCOLPGM(MSG_OK);
   8705              thermalManager.print_heaterstates();
   8706            #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
   8707              SERIAL_ERROR_START();
   8708              SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
   8709            #endif
   8710          */
   8711            SERIAL_PROTOCOLPGM(MSG_OK);
   \   0000000C   0x4805             LDR.N    R0,??gcode_M105_1
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8712            thermalManager.print_heaterstates();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   8713          
   8714            SERIAL_EOL();
   \   00000016   0x210A             MOVS     R1,#+10
   \   00000018   0x4803             LDR.N    R0,??gcode_M105_1+0x4
   \   0000001A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M105_0: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M105_1:
   \   00000024   0x........         DC32     _ZZ10gcode_M105vEs
   \   00000028   0x........         DC32     Serial3
   8715          }
   8716          
   8717          #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND /*|| HAS_TEMP_BED*/)
   8718          
   8719            /**
   8720             * M155: Set temperature auto-report interval. M155 S<seconds>
   8721             */

   \                                 In section .text, align 4
   8722            inline void gcode_M155() {
   \                     _Z10gcode_M155v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8723              if (parser.seenval('S'))
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ.N    ??gcode_M155_0
   8724                thermalManager.set_auto_report_interval(parser.value_byte());
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4803             LDR.N    R0,??gcode_M155_1
   \   00000014   0xE8BD 0x4004      POP      {R2,LR}
   \   00000018   0x.... 0x....      B.W      _ZN11Temperature24set_auto_report_intervalEh
   8725            }
   \                     ??gcode_M155_0: (+1)
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??gcode_M155_1:
   \   00000020   0x........         DC32     thermalManager
   8726          
   8727          #endif // AUTO_REPORT_TEMPERATURES
   8728          
   8729          #if FAN_COUNT > 0
   8730          
   8731            /**
   8732             * M106: Set Fan Speed
   8733             *
   8734             *  S<int>   Speed between 0-255
   8735             *  P<index> Fan index, if more than one fan
   8736             *
   8737             * With EXTRA_FAN_SPEED enabled:
   8738             *
   8739             *  T<int>   Restore/Use/Set Temporary Speed:
   8740             *           1     = Restore previous speed after T2
   8741             *           2     = Use temporary speed set with T3-255
   8742             *           3-255 = Set the speed for use with T2
   8743             */

   \                                 In section .text, align 4
   8744            inline void gcode_M106() {
   \                     _Z10gcode_M106v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8745              const uint8_t p = parser.byteval('P');
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   8746              if (p < FAN_COUNT) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD111             BNE.N    ??gcode_M106_0
   8747                #if ENABLED(EXTRA_FAN_SPEED)
   8748                  const int16_t t = parser.intval('T');
   8749                  if (t > 0) {
   8750                    switch (t) {
   8751                      case 1:
   8752                        fanSpeeds[p] = old_fanSpeeds[p];
   8753                        break;
   8754                      case 2:
   8755                        old_fanSpeeds[p] = fanSpeeds[p];
   8756                        fanSpeeds[p] = new_fanSpeeds[p];
   8757                        break;
   8758                      default:
   8759                        new_fanSpeeds[p] = min(t, 255);
   8760                        break;
   8761                    }
   8762                    return;
   8763                  }
   8764                #endif // EXTRA_FAN_SPEED
   8765                const uint16_t s = parser.ushortval('S', 255);
   \   0000000E   0x21FF             MOVS     R1,#+255
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser9ushortvalEct
   8766                fanSpeeds[p] = min(s, 255);
   \   00000016   0x21FF             MOVS     R1,#+255
   \   00000018   0x28FF             CMP      R0,#+255
   \   0000001A   0xDC00             BGT.N    ??gcode_M106_1
   \   0000001C   0x4601             MOV      R1,R0
   \                     ??gcode_M106_1: (+1)
   \   0000001E   0x4A05             LDR.N    R2,??gcode_M106_2
   \   00000020   0x66D1             STR      R1,[R2, #+108]
   8767          	  MKS_FAN_TIM = s*10000/255;
   \   00000022   0xF242 0x7110      MOVW     R1,#+10000
   \   00000026   0x4348             MULS     R0,R1,R0
   \   00000028   0x21FF             MOVS     R1,#+255
   \   0000002A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000002E   0x4902             LDR.N    R1,??gcode_M106_2+0x4  ;; 0x40000440
   \   00000030   0x6008             STR      R0,[R1, #+0]
   8768              }
   8769            }
   \                     ??gcode_M106_0: (+1)
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M106_2:
   \   00000034   0x........         DC32     mks_heating_busy
   \   00000038   0x40000440         DC32     0x40000440
   8770          
   8771            /**
   8772             * M107: Fan Off
   8773             */

   \                                 In section .text, align 4
   8774            inline void gcode_M107() {
   \                     _Z10gcode_M107v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8775              const uint16_t p = parser.ushortval('P');
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser9ushortvalEct
   8776              if (p < FAN_COUNT) 
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??gcode_M107_0
   8777              {
   8778          		fanSpeeds[p] = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4902             LDR.N    R1,??gcode_M107_1
   \   00000012   0x66C8             STR      R0,[R1, #+108]
   8779          		MKS_FAN_TIM = 0 ;
   \   00000014   0x4902             LDR.N    R1,??gcode_M107_1+0x4  ;; 0x40000440
   \   00000016   0x6008             STR      R0,[R1, #+0]
   8780              }
   8781            }
   \                     ??gcode_M107_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
   \   0000001A   0xBF00             Nop      
   \                     ??gcode_M107_1:
   \   0000001C   0x........         DC32     mks_heating_busy
   \   00000020   0x40000440         DC32     0x40000440
   8782          
   8783          #endif // FAN_COUNT > 0
   8784          
   8785          #if DISABLED(EMERGENCY_PARSER)
   8786          
   8787            /**
   8788             * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
   8789             */

   \                                 In section .text, align 4
   8790            inline void gcode_M108() { wait_for_heatup = false; }
   \                     _Z10gcode_M108v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??gcode_M108_0
   \   00000004   0x7108             STRB     R0,[R1, #+4]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M108_0:
   \   00000008   0x........         DC32     mks_heating_busy
   8791          
   8792          
   8793            /**
   8794             * M112: Emergency Stop
   8795             */

   \                                 In section .text, align 4
   8796            inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
   \                     _Z10gcode_M112v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M112_0
   \   00000002   0x.... 0x....      B.W      _Z4killPKc
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M112_0:
   \   00000008   0x........         DC32     _ZZ10gcode_M112vEs
   8797          
   8798          
   8799            /**
   8800             * M410: Quickstop - Abort all planned moves
   8801             *
   8802             * This will stop the carriages mid-move, so most likely they
   8803             * will be out of sync with the stepper position after this.
   8804             */

   \                                 In section .text, align 2
   8805            inline void gcode_M410() { quickstop_stepper(); }
   \                     _Z10gcode_M410v: (+1)
   \   00000000   0x.... 0x....      B.W      _Z17quickstop_stepperv
   8806          
   8807          #endif
   8808          
   8809          /**
   8810           * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
   8811           *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
   8812           */
   8813          
   8814          #ifndef MIN_COOLING_SLOPE_DEG
   8815            #define MIN_COOLING_SLOPE_DEG 1.50
   8816          #endif
   8817          #ifndef MIN_COOLING_SLOPE_TIME
   8818            #define MIN_COOLING_SLOPE_TIME 60
   8819          #endif
   8820          

   \                                 In section .text, align 4
   8821          inline void gcode_M109() {
   \                     _Z10gcode_M109v: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   8822          
   8823            if (get_target_extruder_from_command(109)) return;
   \   00000006   0x206D             MOVS     R0,#+109
   \   00000008   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF040 0x80F7      BNE.W    ??gcode_M109_1
   8824            if (DEBUGGING(DRYRUN)) return;
   \   00000012   0x4C7C             LDR.N    R4,??gcode_M109_2
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x0700             LSLS     R0,R0,#+28
   \   00000018   0xF100 0x80F2      BMI.W    ??gcode_M109_1
   8825          
   8826            #if ENABLED(SINGLENOZZLE)
   8827              if (target_extruder != active_extruder) return;
   8828            #endif
   8829          
   8830            const bool no_wait_for_cooling = parser.seenval('S');
   \   0000001C   0x2053             MOVS     R0,#+83
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000022   0x9001             STR      R0,[SP, #+4]
   8831            if (no_wait_for_cooling || parser.seenval('R')) {
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD105             BNE.N    ??gcode_M109_3
   \   00000028   0x2052             MOVS     R0,#+82
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF000 0x80E6      BEQ.W    ??gcode_M109_1
   8832              const int16_t temp = parser.value_celsius();
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_M109_3: (+1)
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000038   0x.... 0x....      BL       __aeabi_f2iz
   8833              thermalManager.setTargetHotend(temp, target_extruder);
   \   0000003C   0x7961             LDRB     R1,[R4, #+5]
   \   0000003E   0x460D             MOV      R5,R1
   \   00000040   0xB200             SXTH     R0,R0
   \   00000042   0x.... 0x....      BL       __aeabi_i2f
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   8834          
   8835              #if ENABLED(DUAL_X_CARRIAGE)
   8836                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   8837                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   8838              #endif
   8839          
   8840              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   8841                /**
   8842                 * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
   8843                 * standby mode, (e.g., in a dual extruder setup) without affecting
   8844                 * the running print timer.
   8845                 */
   8846                if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000050   0x4605             MOV      R5,R0
   \   00000052   0x4E6D             LDR.N    R6,??gcode_M109_2+0x4
   \   00000054   0x486D             LDR.N    R0,??gcode_M109_2+0x8
   \   00000056   0x6AC1             LDR      R1,[R0, #+44]
   \   00000058   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000005C   0x.... 0x....      BL       __aeabi_fmul
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0xD806             BHI.N    ??gcode_M109_4
   8847                  print_job_timer.stop();
   \   0000006A   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   8848                  LCD_MESSAGEPGM(WELCOME_MSG);
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x4867             LDR.N    R0,??gcode_M109_2+0xC
   \   00000072   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   \   00000076   0xE001             B.N      ??gcode_M109_5
   8849                }
   8850                else
   8851                  print_job_timer.start();
   \                     ??gcode_M109_4: (+1)
   \   00000078   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   8852              #endif
   8853          
   8854              //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   8855          	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M109_5: (+1)
   \   0000007C   0x7960             LDRB     R0,[R4, #+5]
   \   0000007E   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000082   0x4605             MOV      R5,R0
   \   00000084   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000088   0x4601             MOV      R1,R0
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000090   0xD21F             BCS.N    ??gcode_M109_6
   8856          	{
   8857          			switch(target_extruder)
   \   00000092   0x7960             LDRB     R0,[R4, #+5]
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xD81C             BHI.N    ??gcode_M109_6
   \   00000098   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M109_0:
   \   0000009C   0x03 0x08          DC8      0x3,0x8,0xD,0x12
   \              0x0D 0x12    
   \   000000A0   0x17 0x00          DC8      0x17,0x0
   8858          			{
   8859          			case 0:
   8860          				LCD_MESSAGEPGM("E1 Heating...");
   \                     ??gcode_M109_7: (+1)
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x485B             LDR.N    R0,??gcode_M109_2+0x10
   \   000000A6   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8861          				break;
   \   000000AA   0xE012             B.N      ??gcode_M109_6
   8862          			case 1:
   8863          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M109_8: (+1)
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x485A             LDR.N    R0,??gcode_M109_2+0x14
   \   000000B0   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8864          				break;
   \   000000B4   0xE00D             B.N      ??gcode_M109_6
   8865          			case 2:
   8866          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M109_9: (+1)
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x4858             LDR.N    R0,??gcode_M109_2+0x18
   \   000000BA   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8867          				break;
   \   000000BE   0xE008             B.N      ??gcode_M109_6
   8868          			case 3:
   8869          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M109_10: (+1)
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x4857             LDR.N    R0,??gcode_M109_2+0x1C
   \   000000C4   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8870          				break;
   \   000000C8   0xE003             B.N      ??gcode_M109_6
   8871          			case 4:
   8872          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M109_11: (+1)
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0x4855             LDR.N    R0,??gcode_M109_2+0x20
   \   000000CE   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8873          				break;
   8874          			default: break;
   8875          			}
   8876          	}
   8877          
   8878            }
   8879            else return;
   8880          
   8881            #if ENABLED(AUTOTEMP)
   8882              planner.autotemp_M104_M109();
   \                     ??gcode_M109_6: (+1)
   \   000000D2   0x.... 0x....      BL       _ZN7Planner18autotemp_M104_M109Ev
   8883            #endif
   8884          
   8885            #if TEMP_RESIDENCY_TIME > 0
   8886              millis_t residency_start_ms = 0;
   \   000000D6   0x2500             MOVS     R5,#+0
   8887              // Loop until the temperature has stabilized
   8888              #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
   8889            #else
   8890              // Loop until the temperature is very close target
   8891              #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
   8892            #endif
   8893          
   8894            float target_temp = -1.0, old_temp = 9999.0;
   \   000000D8   0xF8DF 0x814C      LDR.W    R8,??gcode_M109_2+0x24  ;; 0xbf800000
   \   000000DC   0x4E53             LDR.N    R6,??gcode_M109_2+0x28  ;; 0x461c3c00
   8895            bool wants_to_cool = false;
   \   000000DE   0x462F             MOV      R7,R5
   8896            wait_for_heatup = true;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x7120             STRB     R0,[R4, #+4]
   8897            millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0x9000             STR      R0,[SP, #+0]
   \   000000E8   0x4681             MOV      R9,R0
   8898          
   8899            #if DISABLED(BUSY_WHILE_HEATING)
   8900              KEEPALIVE_STATE(NOT_BUSY);
   8901            #endif
   8902          
   8903            #if ENABLED(PRINTER_EVENT_LEDS)
   8904              const float start_temp = thermalManager.degHotend(target_extruder);
   8905              uint8_t old_blue = 0;
   8906            #endif
   8907            
   8908            #if WATCH_HOTENDS
   8909              thermalManager.start_watching_heater(target_extruder);
   \   000000EA   0x7960             LDRB     R0,[R4, #+5]
   \   000000EC   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   8910            #endif
   8911                
   8912            mks_heating_busy = 1;
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x7020             STRB     R0,[R4, #+0]
   8913          
   8914            do {
   8915              // Target temperature might be changed during the loop
   8916              if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
   \                     ??gcode_M109_12: (+1)
   \   000000F4   0xF894 0xA005      LDRB     R10,[R4, #+5]
   \   000000F8   0x4650             MOV      R0,R10
   \   000000FA   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   000000FE   0x4601             MOV      R1,R0
   \   00000100   0x4640             MOV      R0,R8
   \   00000102   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000106   0xD00C             BEQ.N    ??gcode_M109_13
   8917                wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
   \   00000108   0x4650             MOV      R0,R10
   \   0000010A   0x.... 0x....      BL       _ZN11Temperature15isCoolingHotendEh
   \   0000010E   0x4607             MOV      R7,R0
   8918                target_temp = thermalManager.degTargetHotend(target_extruder);
   \   00000110   0x4650             MOV      R0,R10
   \   00000112   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000116   0x4680             MOV      R8,R0
   8919          
   8920                // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   8921                if (no_wait_for_cooling && wants_to_cool) break;
   \   00000118   0x9801             LDR      R0,[SP, #+4]
   \   0000011A   0x4639             MOV      R1,R7
   \   0000011C   0xB2C0             UXTB     R0,R0
   \   0000011E   0x4208             TST      R0,R1
   \   00000120   0xD162             BNE.N    ??gcode_M109_14
   8922              }
   8923          
   8924              now = millis();
   \                     ??gcode_M109_13: (+1)
   \   00000122   0x.... 0x....      BL       HAL_GetTick
   \   00000126   0x4682             MOV      R10,R0
   8925              if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
   \   00000128   0x9800             LDR      R0,[SP, #+0]
   \   0000012A   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   0000012E   0xD41F             BMI.N    ??gcode_M109_15
   8926                next_temp_ms = now + 1000UL;
   \   00000130   0xF50A 0x707A      ADD      R0,R10,#+1000
   \   00000134   0x9000             STR      R0,[SP, #+0]
   8927                thermalManager.print_heaterstates();
   \   00000136   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   8928                #if TEMP_RESIDENCY_TIME > 0
   8929                  SERIAL_PROTOCOLPGM(" W:");
   \   0000013A   0x483D             LDR.N    R0,??gcode_M109_2+0x2C
   \   0000013C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8930                  if (residency_start_ms)
   \   00000140   0xF8DF 0xB0F0      LDR.W    R11,??gcode_M109_2+0x30
   \   00000144   0x2D00             CMP      R5,#+0
   \   00000146   0xD00B             BEQ.N    ??gcode_M109_16
   8931                    SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
   \   00000148   0x220A             MOVS     R2,#+10
   \   0000014A   0xF5CA 0x607A      RSB      R0,R10,#+4000
   \   0000014E   0x1828             ADDS     R0,R5,R0
   \   00000150   0xF44F 0x717A      MOV      R1,#+1000
   \   00000154   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000158   0x4658             MOV      R0,R11
   \   0000015A   0x.... 0x....      BL       _ZN5Print5printEli
   \   0000015E   0xE003             B.N      ??gcode_M109_17
   8932                  else
   8933                    SERIAL_PROTOCOLCHAR('?');
   \                     ??gcode_M109_16: (+1)
   \   00000160   0x213F             MOVS     R1,#+63
   \   00000162   0x4658             MOV      R0,R11
   \   00000164   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   8934                #endif
   8935                SERIAL_EOL();
   \                     ??gcode_M109_17: (+1)
   \   00000168   0x210A             MOVS     R1,#+10
   \   0000016A   0x4658             MOV      R0,R11
   \   0000016C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   8936              }
   8937          
   8938              idle();
   \                     ??gcode_M109_15: (+1)
   \   00000170   0x.... 0x....      BL       _Z4idlev
   8939              refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   \   00000174   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   8940          
   8941              const float temp = thermalManager.degHotend(target_extruder);
   \   00000178   0x7960             LDRB     R0,[R4, #+5]
   \   0000017A   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   0000017E   0x4683             MOV      R11,R0
   8942          
   8943              #if ENABLED(PRINTER_EVENT_LEDS)
   8944                // Gradually change LED strip from violet to red as nozzle heats up
   8945                if (!wants_to_cool) {
   8946                  const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
   8947                  if (blue != old_blue) {
   8948                    old_blue = blue;
   8949                    leds.set_color(
   8950                      MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
   8951                      #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
   8952                        , true
   8953                      #endif
   8954                    );
   8955                  }
   8956                }
   8957              #endif
   8958          
   8959              #if TEMP_RESIDENCY_TIME > 0
   8960          
   8961                const float temp_diff = FABS(target_temp - temp);
   \   00000180   0x4640             MOV      R0,R8
   \   00000182   0x4659             MOV      R1,R11
   \   00000184   0x.... 0x....      BL       __aeabi_fsub
   \   00000188   0xF020 0x4000      BIC      R0,R0,#0x80000000
   8962          
   8963                if (!residency_start_ms) {
   \   0000018C   0x2D00             CMP      R5,#+0
   \   0000018E   0xD106             BNE.N    ??gcode_M109_18
   8964                  // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
   8965                  if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
   \   00000190   0xF04F 0x4181      MOV      R1,#+1082130432
   \   00000194   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000198   0xD206             BCS.N    ??gcode_M109_19
   \   0000019A   0x4655             MOV      R5,R10
   \   0000019C   0xE004             B.N      ??gcode_M109_19
   8966                }
   8967                else if (temp_diff > TEMP_HYSTERESIS) {
   \                     ??gcode_M109_18: (+1)
   \   0000019E   0x4926             LDR.N    R1,??gcode_M109_2+0x34  ;; 0x40800001
   \   000001A0   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000001A4   0xD800             BHI.N    ??gcode_M109_19
   8968                  // Restart the timer whenever the temperature falls outside the hysteresis.
   8969                  residency_start_ms = now;
   \   000001A6   0x4655             MOV      R5,R10
   8970                }
   8971          
   8972              #endif
   8973          
   8974              // Prevent a wait-forever situation if R is misused i.e. M109 R0
   8975              if (wants_to_cool) {
   \                     ??gcode_M109_19: (+1)
   \   000001A8   0x2F00             CMP      R7,#+0
   \   000001AA   0xD013             BEQ.N    ??gcode_M109_20
   8976                // break after MIN_COOLING_SLOPE_TIME seconds
   8977                // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
   8978                if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   \   000001AC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001B0   0xD002             BEQ.N    ??gcode_M109_21
   \   000001B2   0xEBBA 0x0009      SUBS     R0,R10,R9
   \   000001B6   0xD40D             BMI.N    ??gcode_M109_20
   8979                  if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
   \                     ??gcode_M109_21: (+1)
   \   000001B8   0x4630             MOV      R0,R6
   \   000001BA   0x4659             MOV      R1,R11
   \   000001BC   0x.... 0x....      BL       __aeabi_fsub
   \   000001C0   0xF04F 0x517F      MOV      R1,#+1069547520
   \   000001C4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001C8   0xD30E             BCC.N    ??gcode_M109_14
   8980                  next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
   \   000001CA   0xF50A 0x496A      ADD      R9,R10,#+59904
   \   000001CE   0xF109 0x0960      ADD      R9,R9,#+96
   8981                  old_temp = temp;
   \   000001D2   0x465E             MOV      R6,R11
   8982                }
   8983              }
   8984          
   8985            } while (wait_for_heatup && TEMP_CONDITIONS);
   \                     ??gcode_M109_20: (+1)
   \   000001D4   0x7920             LDRB     R0,[R4, #+4]
   \   000001D6   0x2800             CMP      R0,#+0
   \   000001D8   0xD006             BEQ.N    ??gcode_M109_14
   \   000001DA   0x2D00             CMP      R5,#+0
   \   000001DC   0xD08A             BEQ.N    ??gcode_M109_12
   \   000001DE   0xEBAA 0x0005      SUB      R0,R10,R5
   \   000001E2   0xF5B0 0x607A      SUBS     R0,R0,#+4000
   \   000001E6   0xD485             BMI.N    ??gcode_M109_12
   8986            
   8987            mks_heating_busy = 0;
   \                     ??gcode_M109_14: (+1)
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x7020             STRB     R0,[R4, #+0]
   8988          
   8989            if (wait_for_heatup) {
   \   000001EC   0x7920             LDRB     R0,[R4, #+4]
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD006             BEQ.N    ??gcode_M109_1
   8990              LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
   \   000001F2   0x2100             MOVS     R1,#+0
   \   000001F4   0x4811             LDR.N    R0,??gcode_M109_2+0x38
   \   000001F6   0xB003             ADD      SP,SP,#+12
   \   000001F8   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000001FC   0x.... 0x....      B.W      _Z16lcd_setstatusPGMPKca
   8991              #if ENABLED(PRINTER_EVENT_LEDS)
   8992                leds.set_white();
   8993              #endif
   8994            }
   8995          
   8996            #if DISABLED(BUSY_WHILE_HEATING)
   8997              KEEPALIVE_STATE(IN_HANDLER);
   8998            #endif
   8999          }
   \                     ??gcode_M109_1: (+1)
   \   00000200   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??gcode_M109_2:
   \   00000204   0x........         DC32     mks_heating_busy
   \   00000208   0x........         DC32     card+0xAE8
   \   0000020C   0x........         DC32     mksCfg
   \   00000210   0x........         DC32     _ZZ10gcode_M109vEs
   \   00000214   0x........         DC32     _ZZ10gcode_M109vEs_0
   \   00000218   0x........         DC32     _ZZ10gcode_M109vEs_1
   \   0000021C   0x........         DC32     _ZZ10gcode_M109vEs_2
   \   00000220   0x........         DC32     _ZZ10gcode_M109vEs_3
   \   00000224   0x........         DC32     _ZZ10gcode_M109vEs_4
   \   00000228   0xBF800000         DC32     0xbf800000
   \   0000022C   0x461C3C00         DC32     0x461c3c00
   \   00000230   0x........         DC32     _ZZ10gcode_M109vEs_5
   \   00000234   0x........         DC32     Serial3
   \   00000238   0x40800001         DC32     0x40800001
   \   0000023C   0x........         DC32     _ZZ10gcode_M109vEs_6
   9000          
   9001          #if 1//HAS_TEMP_BED
   9002          
   9003            #ifndef MIN_COOLING_SLOPE_DEG_BED
   9004              #define MIN_COOLING_SLOPE_DEG_BED 1.50
   9005            #endif
   9006            #ifndef MIN_COOLING_SLOPE_TIME_BED
   9007              #define MIN_COOLING_SLOPE_TIME_BED 60
   9008            #endif
   9009          
   9010            /**
   9011             * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
   9012             *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
   9013             */

   \                                 In section .text, align 4
   9014            inline void gcode_M190() {
   \                     _Z10gcode_M190v: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   9015              if (DEBUGGING(DRYRUN)) return;
   \   00000006   0x4C59             LDR.N    R4,??gcode_M190_0
   \   00000008   0x7860             LDRB     R0,[R4, #+1]
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0xF100 0x80AB      BMI.W    ??gcode_M190_1
   9016          
   9017              LCD_MESSAGEPGM(MSG_BED_HEATING);
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4857             LDR.N    R0,??gcode_M190_0+0x4
   \   00000014   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   9018              const bool no_wait_for_cooling = parser.seenval('S');
   \   00000018   0x2053             MOVS     R0,#+83
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001E   0x9001             STR      R0,[SP, #+4]
   9019              if (no_wait_for_cooling || parser.seenval('R')) {
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD105             BNE.N    ??gcode_M190_2
   \   00000024   0x2052             MOVS     R0,#+82
   \   00000026   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF000 0x809B      BEQ.W    ??gcode_M190_1
   9020                thermalManager.setTargetBed(parser.value_celsius());
   \                     ??gcode_M190_2: (+1)
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000034   0x.... 0x....      BL       _ZN11Temperature12setTargetBedEf
   9021                #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   9022                  if (parser.value_celsius() > BED_MINTEMP)
   \   00000038   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000003C   0x494D             LDR.N    R1,??gcode_M190_0+0x8  ;; 0x40a00001
   \   0000003E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000042   0xD802             BHI.N    ??gcode_M190_3
   9023                    print_job_timer.start();
   \   00000044   0x484C             LDR.N    R0,??gcode_M190_0+0xC
   \   00000046   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   9024                #endif
   9025              }
   9026              else return;
   9027          
   9028              #if TEMP_BED_RESIDENCY_TIME > 0
   9029                millis_t residency_start_ms = 0;
   \                     ??gcode_M190_3: (+1)
   \   0000004A   0x2500             MOVS     R5,#+0
   9030                // Loop until the temperature has stabilized
   9031                #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
   9032              #else
   9033                // Loop until the temperature is very close target
   9034                #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
   9035              #endif
   9036          
   9037              float target_temp = -1.0, old_temp = 9999.0;
   \   0000004C   0xF8DF 0x812C      LDR.W    R8,??gcode_M190_0+0x10  ;; 0xbf800000
   \   00000050   0x4E4B             LDR.N    R6,??gcode_M190_0+0x14  ;; 0x461c3c00
   9038              bool wants_to_cool = false;
   \   00000052   0x462F             MOV      R7,R5
   9039              wait_for_heatup = true;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x7120             STRB     R0,[R4, #+4]
   9040              millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   \   00000058   0x4628             MOV      R0,R5
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x4681             MOV      R9,R0
   9041          
   9042              #if DISABLED(BUSY_WHILE_HEATING)
   9043                KEEPALIVE_STATE(NOT_BUSY);
   9044              #endif
   9045          
   9046              target_extruder = active_extruder; // for print_heaterstates
   \   0000005E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000060   0x7160             STRB     R0,[R4, #+5]
   9047          
   9048              #if ENABLED(PRINTER_EVENT_LEDS)
   9049                const float start_temp = thermalManager.degBed();
   9050                uint8_t old_red = 255;
   9051              #endif
   9052          	mks_heating_busy = 1;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x7020             STRB     R0,[R4, #+0]
   9053          
   9054              do {
   9055                // Target temperature might be changed during the loop
   9056                if (target_temp != thermalManager.degTargetBed()) {
   \                     ??gcode_M190_4: (+1)
   \   00000066   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000072   0xD00A             BEQ.N    ??gcode_M190_5
   9057                  wants_to_cool = thermalManager.isCoolingBed();
   \   00000074   0x.... 0x....      BL       _ZN11Temperature12isCoolingBedEv
   \   00000078   0x4607             MOV      R7,R0
   9058                  target_temp = thermalManager.degTargetBed();
   \   0000007A   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \   0000007E   0x4680             MOV      R8,R0
   9059          
   9060                  // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   9061                  if (no_wait_for_cooling && wants_to_cool) break;
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x4639             MOV      R1,R7
   \   00000084   0xB2C0             UXTB     R0,R0
   \   00000086   0x4208             TST      R0,R1
   \   00000088   0xD161             BNE.N    ??gcode_M190_6
   9062                }
   9063          
   9064                now = millis();
   \                     ??gcode_M190_5: (+1)
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0x4682             MOV      R10,R0
   9065                if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   00000096   0xD41F             BMI.N    ??gcode_M190_7
   9066                  next_temp_ms = now + 1000UL;
   \   00000098   0xF50A 0x707A      ADD      R0,R10,#+1000
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   9067                  thermalManager.print_heaterstates();
   \   0000009E   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   9068                  #if TEMP_BED_RESIDENCY_TIME > 0
   9069                    SERIAL_PROTOCOLPGM(" W:");
   \   000000A2   0x4838             LDR.N    R0,??gcode_M190_0+0x18
   \   000000A4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9070                    if (residency_start_ms)
   \   000000A8   0xF8DF 0xB0DC      LDR.W    R11,??gcode_M190_0+0x1C
   \   000000AC   0x2D00             CMP      R5,#+0
   \   000000AE   0xD00B             BEQ.N    ??gcode_M190_8
   9071                      SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
   \   000000B0   0x220A             MOVS     R2,#+10
   \   000000B2   0xF5CA 0x607A      RSB      R0,R10,#+4000
   \   000000B6   0x1828             ADDS     R0,R5,R0
   \   000000B8   0xF44F 0x717A      MOV      R1,#+1000
   \   000000BC   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000000C0   0x4658             MOV      R0,R11
   \   000000C2   0x.... 0x....      BL       _ZN5Print5printEli
   \   000000C6   0xE003             B.N      ??gcode_M190_9
   9072                    else
   9073                      SERIAL_PROTOCOLCHAR('?');
   \                     ??gcode_M190_8: (+1)
   \   000000C8   0x213F             MOVS     R1,#+63
   \   000000CA   0x4658             MOV      R0,R11
   \   000000CC   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9074                  #endif
   9075                  SERIAL_EOL();
   \                     ??gcode_M190_9: (+1)
   \   000000D0   0x210A             MOVS     R1,#+10
   \   000000D2   0x4658             MOV      R0,R11
   \   000000D4   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9076                }
   9077          
   9078                idle();
   \                     ??gcode_M190_7: (+1)
   \   000000D8   0x.... 0x....      BL       _Z4idlev
   9079                refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   \   000000DC   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   9080          
   9081                const float temp = thermalManager.degBed();
   \   000000E0   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \   000000E4   0x4683             MOV      R11,R0
   9082          
   9083                #if ENABLED(PRINTER_EVENT_LEDS)
   9084                  // Gradually change LED strip from blue to violet as bed heats up
   9085                  if (!wants_to_cool) {
   9086                    const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
   9087                    if (red != old_red) {
   9088                      old_red = red;
   9089                      leds.set_color(
   9090                        MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
   9091                        #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
   9092                          , true
   9093                        #endif
   9094                      );
   9095                    }
   9096                  }
   9097                #endif
   9098          
   9099                #if TEMP_BED_RESIDENCY_TIME > 0
   9100          
   9101                  const float temp_diff = FABS(target_temp - temp);
   \   000000E6   0x4640             MOV      R0,R8
   \   000000E8   0x4659             MOV      R1,R11
   \   000000EA   0x.... 0x....      BL       __aeabi_fsub
   \   000000EE   0xF020 0x4000      BIC      R0,R0,#0x80000000
   9102          
   9103                  if (!residency_start_ms) {
   \   000000F2   0x2D00             CMP      R5,#+0
   \   000000F4   0xD106             BNE.N    ??gcode_M190_10
   9104                    // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
   9105                    if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
   \   000000F6   0xF04F 0x4180      MOV      R1,#+1073741824
   \   000000FA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000FE   0xD206             BCS.N    ??gcode_M190_11
   \   00000100   0x4655             MOV      R5,R10
   \   00000102   0xE004             B.N      ??gcode_M190_11
   9106                  }
   9107                  else if (temp_diff > TEMP_BED_HYSTERESIS) {
   \                     ??gcode_M190_10: (+1)
   \   00000104   0x4921             LDR.N    R1,??gcode_M190_0+0x20  ;; 0x40800001
   \   00000106   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000010A   0xD800             BHI.N    ??gcode_M190_11
   9108                    // Restart the timer whenever the temperature falls outside the hysteresis.
   9109                    residency_start_ms = now;
   \   0000010C   0x4655             MOV      R5,R10
   9110                  }
   9111          
   9112                #endif // TEMP_BED_RESIDENCY_TIME > 0
   9113          
   9114                // Prevent a wait-forever situation if R is misused i.e. M190 R0
   9115                if (wants_to_cool) {
   \                     ??gcode_M190_11: (+1)
   \   0000010E   0x2F00             CMP      R7,#+0
   \   00000110   0xD013             BEQ.N    ??gcode_M190_12
   9116                  // Break after MIN_COOLING_SLOPE_TIME_BED seconds
   9117                  // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
   9118                  if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   \   00000112   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000116   0xD002             BEQ.N    ??gcode_M190_13
   \   00000118   0xEBBA 0x0009      SUBS     R0,R10,R9
   \   0000011C   0xD40D             BMI.N    ??gcode_M190_12
   9119                    if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
   \                     ??gcode_M190_13: (+1)
   \   0000011E   0x4630             MOV      R0,R6
   \   00000120   0x4659             MOV      R1,R11
   \   00000122   0x.... 0x....      BL       __aeabi_fsub
   \   00000126   0xF04F 0x517F      MOV      R1,#+1069547520
   \   0000012A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000012E   0xD30E             BCC.N    ??gcode_M190_6
   9120                    next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
   \   00000130   0xF50A 0x496A      ADD      R9,R10,#+59904
   \   00000134   0xF109 0x0960      ADD      R9,R9,#+96
   9121                    old_temp = temp;
   \   00000138   0x465E             MOV      R6,R11
   9122                  }
   9123                }
   9124          
   9125              } while (wait_for_heatup && TEMP_BED_CONDITIONS);
   \                     ??gcode_M190_12: (+1)
   \   0000013A   0x7920             LDRB     R0,[R4, #+4]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD006             BEQ.N    ??gcode_M190_6
   \   00000140   0x2D00             CMP      R5,#+0
   \   00000142   0xD090             BEQ.N    ??gcode_M190_4
   \   00000144   0xEBAA 0x0005      SUB      R0,R10,R5
   \   00000148   0xF5B0 0x607A      SUBS     R0,R0,#+4000
   \   0000014C   0xD48B             BMI.N    ??gcode_M190_4
   9126          
   9127          	mks_heating_busy = 0;
   \                     ??gcode_M190_6: (+1)
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x7020             STRB     R0,[R4, #+0]
   9128          
   9129              if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
   \   00000152   0x7920             LDRB     R0,[R4, #+4]
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD006             BEQ.N    ??gcode_M190_1
   \   00000158   0x2100             MOVS     R1,#+0
   \   0000015A   0x480D             LDR.N    R0,??gcode_M190_0+0x24
   \   0000015C   0xB003             ADD      SP,SP,#+12
   \   0000015E   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000162   0x.... 0x....      B.W      _Z16lcd_setstatusPGMPKca
   9130              #if DISABLED(BUSY_WHILE_HEATING)
   9131                KEEPALIVE_STATE(IN_HANDLER);
   9132              #endif
   9133            }
   \                     ??gcode_M190_1: (+1)
   \   00000166   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \   0000016A   0xBF00             Nop      
   \                     ??gcode_M190_0:
   \   0000016C   0x........         DC32     mks_heating_busy
   \   00000170   0x........         DC32     _ZZ10gcode_M190vEs
   \   00000174   0x40A00001         DC32     0x40a00001
   \   00000178   0x........         DC32     card+0xAE8
   \   0000017C   0xBF800000         DC32     0xbf800000
   \   00000180   0x461C3C00         DC32     0x461c3c00
   \   00000184   0x........         DC32     _ZZ10gcode_M190vEs_0
   \   00000188   0x........         DC32     Serial3
   \   0000018C   0x40800001         DC32     0x40800001
   \   00000190   0x........         DC32     _ZZ10gcode_M190vEs_1
   9134          
   9135          #endif // HAS_TEMP_BED
   9136          
   9137          /**
   9138           * M110: Set Current Line Number
   9139           */

   \                                 In section .text, align 4
   9140          inline void gcode_M110() {
   \                     _Z10gcode_M110v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9141            if (parser.seenval('N')) gcode_LastN = parser.value_long();
   \   00000002   0x204E             MOVS     R0,#+78
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M110_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M110_1
   \   00000012   0x62C8             STR      R0,[R1, #+44]
   9142          }
   \                     ??gcode_M110_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M110_1:
   \   00000018   0x........         DC32     axis_relative_modes
   9143          
   9144          /**
   9145           * M111: Set the debug level
   9146           */

   \                                 In section .text, align 4
   9147          inline void gcode_M111() {
   \                     _Z10gcode_M111v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   9148            if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
   \   00000002   0x4C1B             LDR.N    R4,??gcode_M111_0
   \   00000004   0x2053             MOVS     R0,#+83
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??gcode_M111_1
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   00000016   0x7060             STRB     R0,[R4, #+1]
   9149          
   9150            const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
   9151                              str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
   9152                              str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
   9153                              str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
   9154                              str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
   9155                              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9156                                , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
   9157                              #endif
   9158                              ;
   9159          
   9160            const static char* const debug_strings[] PROGMEM = {
   9161              str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
   9162              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9163                , str_debug_32
   9164              #endif
   9165            };
   9166          
   9167            SERIAL_ECHO_START();
   \                     ??gcode_M111_1: (+1)
   \   00000018   0x4816             LDR.N    R0,??gcode_M111_0+0x4
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9168            SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
   \   0000001E   0x4816             LDR.N    R0,??gcode_M111_0+0x8
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9169            if (marlin_debug_flags) {
   \   00000024   0x7860             LDRB     R0,[R4, #+1]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD018             BEQ.N    ??gcode_M111_2
   9170              uint8_t comma = 0;
   \   0000002A   0x2600             MOVS     R6,#+0
   9171              for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
   \   0000002C   0x4635             MOV      R5,R6
   \                     ??gcode_M111_3: (+1)
   \   0000002E   0x2D05             CMP      R5,#+5
   \   00000030   0xD217             BCS.N    ??gcode_M111_4
   9172                if (TEST(marlin_debug_flags, i)) {
   \   00000032   0x7860             LDRB     R0,[R4, #+1]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x40A9             LSLS     R1,R1,R5
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD00D             BEQ.N    ??gcode_M111_5
   9173                  if (comma++) SERIAL_CHAR(',');
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x1C46             ADDS     R6,R0,#+1
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??gcode_M111_6
   \   00000046   0x212C             MOVS     R1,#+44
   \   00000048   0x480C             LDR.N    R0,??gcode_M111_0+0xC
   \   0000004A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9174                  //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
   9175                  serialprintPGM((char*)&(debug_strings[i]));
   \                     ??gcode_M111_6: (+1)
   \   0000004E   0x480C             LDR.N    R0,??gcode_M111_0+0x10
   \   00000050   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000054   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9176                }
   9177              }
   \                     ??gcode_M111_5: (+1)
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   \   0000005A   0xE7E8             B.N      ??gcode_M111_3
   9178            }
   9179            else {
   9180              SERIAL_ECHOPGM(MSG_DEBUG_OFF);
   \                     ??gcode_M111_2: (+1)
   \   0000005C   0x4809             LDR.N    R0,??gcode_M111_0+0x14
   \   0000005E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9181            }
   9182            SERIAL_EOL();
   \                     ??gcode_M111_4: (+1)
   \   00000062   0x210A             MOVS     R1,#+10
   \   00000064   0x4805             LDR.N    R0,??gcode_M111_0+0xC
   \   00000066   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006A   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000006E   0xBF00             Nop      
   \                     ??gcode_M111_0:
   \   00000070   0x........         DC32     mks_heating_busy
   \   00000074   0x........         DC32     echomagic
   \   00000078   0x........         DC32     _ZZ10gcode_M111vEs_4
   \   0000007C   0x........         DC32     Serial3
   \   00000080   0x........         DC32     _ZZ10gcode_M111vE13debug_strings
   \   00000084   0x........         DC32     _ZZ10gcode_M111vEs_5
   9183          }

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_1:
   \   00000000   0x45 0x43          DC8 "ECHO"
   \              0x48 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_2:
   \   00000000   0x49 0x4E          DC8 "INFO"
   \              0x46 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_4:
   \   00000000   0x45 0x52          DC8 "ERRORS"
   \              0x52 0x4F    
   \              0x52 0x53    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_8:
   \   00000000   0x44 0x52          DC8 "DRYRUN"
   \              0x59 0x52    
   \              0x55 0x4E    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE12str_debug_16:
   \   00000000   0x43 0x4F          DC8 "COMMUNICATION"
   \              0x4D 0x4D    
   \              0x55 0x4E    
   \              0x49 0x43    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE13debug_strings:
   \   00000000   0x........         DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
   \              0x........   
   \   00000008   0x........         DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
   \              0x........   
   \   00000010   0x........         DC32 _ZZ10gcode_M111vE12str_debug_16
   9184          
   9185          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   9186          
   9187            /**
   9188             * M113: Get or set Host Keepalive interval (0 to disable)
   9189             *
   9190             *   S<seconds> Optional. Set the keepalive interval.
   9191             */

   \                                 In section .text, align 4
   9192            inline void gcode_M113() {
   \                     _Z10gcode_M113v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9193              if (parser.seenval('S')) {
   \   00000002   0x4C0E             LDR.N    R4,??gcode_M113_0
   \   00000004   0x2053             MOVS     R0,#+83
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD007             BEQ.N    ??gcode_M113_1
   9194                host_keepalive_interval = parser.value_byte();
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000012   0x71E0             STRB     R0,[R4, #+7]
   9195                NOMORE(host_keepalive_interval, 60);
   \   00000014   0x283D             CMP      R0,#+61
   \   00000016   0xDB0F             BLT.N    ??gcode_M113_2
   \   00000018   0x203C             MOVS     R0,#+60
   \   0000001A   0x71E0             STRB     R0,[R4, #+7]
   \   0000001C   0xBD10             POP      {R4,PC}
   9196              }
   9197              else {
   9198                SERIAL_ECHO_START();
   \                     ??gcode_M113_1: (+1)
   \   0000001E   0x4808             LDR.N    R0,??gcode_M113_0+0x4
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9199                SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
   \   00000024   0x79E1             LDRB     R1,[R4, #+7]
   \   00000026   0x4807             LDR.N    R0,??gcode_M113_0+0x8
   \   00000028   0x.... 0x....      BL       _Z17serial_echopair_PPKcm
   \   0000002C   0x210A             MOVS     R1,#+10
   \   0000002E   0x4806             LDR.N    R0,??gcode_M113_0+0xC
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9200              }
   9201            }
   \                     ??gcode_M113_2: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??gcode_M113_0:
   \   0000003C   0x........         DC32     axis_relative_modes
   \   00000040   0x........         DC32     echomagic
   \   00000044   0x........         DC32     _ZZ10gcode_M113vEs
   \   00000048   0x........         DC32     Serial3
   9202          
   9203          #endif
   9204          
   9205          #if ENABLED(BARICUDA)
   9206          
   9207            #if HAS_HEATER_1
   9208              /**
   9209               * M126: Heater 1 valve open
   9210               */
   9211              inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
   9212              /**
   9213               * M127: Heater 1 valve close
   9214               */
   9215              inline void gcode_M127() { baricuda_valve_pressure = 0; }
   9216            #endif
   9217          
   9218            #if HAS_HEATER_2
   9219              /**
   9220               * M128: Heater 2 valve open
   9221               */
   9222              inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
   9223              /**
   9224               * M129: Heater 2 valve close
   9225               */
   9226              inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
   9227            #endif
   9228          
   9229          #endif // BARICUDA
   9230          
   9231          /**
   9232           * M140: Set bed temperature
   9233           */

   \                                 In section .text, align 4
   9234          inline void gcode_M140() {
   9235            if (DEBUGGING(DRYRUN)) return;
   \                     _Z10gcode_M140v: (+1)
   \   00000000   0x4808             LDR.N    R0,??gcode_M140_0
   \   00000002   0x7840             LDRB     R0,[R0, #+1]
   \   00000004   0x0700             LSLS     R0,R0,#+28
   \   00000006   0xD500             BPL.N    ??gcode_M140_1
   \   00000008   0x4770             BX       LR
   9236            if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
   \                     ??gcode_M140_1: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??gcode_M140_2
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000001A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN11Temperature12setTargetBedEf
   9237          }
   \                     ??gcode_M140_2: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M140_0:
   \   00000024   0x........         DC32     mks_heating_busy
   9238          
   9239          #if ENABLED(ULTIPANEL)
   9240          
   9241            /**
   9242             * M145: Set the heatup state for a material in the LCD menu
   9243             *
   9244             *   S<material> (0=PLA, 1=ABS)
   9245             *   H<hotend temp>
   9246             *   B<bed temp>
   9247             *   F<fan speed>
   9248             */
   9249            inline void gcode_M145() {
   9250              const uint8_t material = (uint8_t)parser.intval('S');
   9251              if (material >= COUNT(lcd_preheat_hotend_temp)) {
   9252                SERIAL_ERROR_START();
   9253                SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
   9254              }
   9255              else {
   9256                int v;
   9257                if (parser.seenval('H')) {
   9258                  v = parser.value_int();
   9259                  lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
   9260                }
   9261                if (parser.seenval('F')) {
   9262                  v = parser.value_int();
   9263                  lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
   9264                }
   9265                #if TEMP_SENSOR_BED != 0
   9266                  if (parser.seenval('B')) {
   9267                    v = parser.value_int();
   9268                    lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
   9269                  }
   9270                #endif
   9271              }
   9272            }
   9273          
   9274          #endif // ULTIPANEL
   9275          
   9276          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   9277            /**
   9278             * M149: Set temperature units
   9279             */
   9280            inline void gcode_M149() {
   9281                   if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
   9282              else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
   9283              else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
   9284            }
   9285          #endif
   9286          
   9287          #if HAS_POWER_SWITCH
   9288          
   9289            /**
   9290             * M80   : Turn on the Power Supply
   9291             * M80 S : Report the current state and exit
   9292             */
   9293            inline void gcode_M80() {
   9294          
   9295              // S: Report the current power supply state and exit
   9296              if (parser.seen('S')) {
   9297                serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
   9298                return;
   9299              }
   9300          
   9301              OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
   9302          
   9303              /**
   9304               * If you have a switch on suicide pin, this is useful
   9305               * if you want to start another print with suicide feature after
   9306               * a print without suicide...
   9307               */
   9308              #if HAS_SUICIDE
   9309                OUT_WRITE(SUICIDE_PIN, HIGH);
   9310              #endif
   9311          
   9312              #if ENABLED(HAVE_TMC2130)
   9313                delay(100);
   9314                tmc2130_init(); // Settings only stick when the driver has power
   9315              #endif
   9316          
   9317              powersupply_on = true;
   9318          
   9319              #if ENABLED(ULTIPANEL)
   9320                LCD_MESSAGEPGM(WELCOME_MSG);
   9321              #endif
   9322          
   9323              #if ENABLED(HAVE_TMC2208)
   9324                delay(100);
   9325                tmc2208_init();
   9326              #endif
   9327            }
   9328          
   9329          #endif // HAS_POWER_SWITCH
   9330          
   9331          /**
   9332           * M81: Turn off Power, including Power Supply, if there is one.
   9333           *
   9334           *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
   9335           */

   \                                 In section .text, align 4
   9336          inline void gcode_M81() {
   \                     _Z9gcode_M81v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9337            thermalManager.disable_all_heaters();
   \   00000002   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   9338            stepper.finish_and_disable();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper18finish_and_disableEv
   9339          
   9340            #if FAN_COUNT > 0
   9341              for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4906             LDR.N    R1,??gcode_M81_0
   \   0000000E   0xE002             B.N      ??gcode_M81_1
   \                     ??gcode_M81_2: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x66C8             STR      R0,[R1, #+108]
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??gcode_M81_1: (+1)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD0FA             BEQ.N    ??gcode_M81_2
   9342              #if ENABLED(PROBING_FANS_OFF)
   9343                fans_paused = false;
   9344                ZERO(paused_fanSpeeds);
   9345              #endif
   9346            #endif
   9347          
   9348            safe_delay(1000); // Wait 1 second before switching off
   \   0000001A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000022   0x.... 0x....      B.W      _Z10safe_delaym
   \   00000026   0xBF00             Nop      
   \                     ??gcode_M81_0:
   \   00000028   0x........         DC32     mks_heating_busy
   9349          
   9350            #if HAS_SUICIDE
   9351              stepper.synchronize();
   9352              suicide();
   9353            #elif HAS_POWER_SWITCH
   9354              OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   9355              powersupply_on = false;
   9356            #endif
   9357          
   9358            #if ENABLED(ULTIPANEL)
   9359              //LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
   9360                if(LCD_LANGUAGE)
   9361                  LCD_MESSAGEPGM(MACHINE_NAME " " "\xb5 " ".");
   9362                else
   9363                  LCD_MESSAGEPGM(MACHINE_NAME " " "Off" ".");    
   9364            #endif
   9365          }
   9366          
   9367          /**
   9368           * M82: Set E codes absolute (default)
   9369           */

   \                                 In section .text, align 4
   9370          inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
   \                     _Z9gcode_M82v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??gcode_M82_0
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M82_0:
   \   00000008   0x........         DC32     axis_relative_modes
   9371          
   9372          /**
   9373           * M83: Set E codes relative while in Absolute Coordinates (G90) mode
   9374           */

   \                                 In section .text, align 4
   9375          inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
   \                     _Z9gcode_M83v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4901             LDR.N    R1,??gcode_M83_0
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M83_0:
   \   00000008   0x........         DC32     axis_relative_modes
   9376          
   9377          /**
   9378           * M18, M84: Disable stepper motors
   9379           */

   \                                 In section .text, align 4
   9380          inline void gcode_M18_M84() {
   \                     _Z13gcode_M18_M84v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   9381            if (parser.seenval('S')) {
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??gcode_M18_M84_0
   9382              stepper_inactive_time = parser.value_millis_from_seconds();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000010   0x4939             LDR.N    R1,??gcode_M18_M84_1
   \   00000012   0x6648             STR      R0,[R1, #+100]
   \   00000014   0xBD70             POP      {R4-R6,PC}
   9383            }
   9384            else {
   9385              bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
   \                     ??gcode_M18_M84_0: (+1)
   \   00000016   0x2058             MOVS     R0,#+88
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD111             BNE.N    ??gcode_M18_M84_2
   \   00000020   0x2059             MOVS     R0,#+89
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD10C             BNE.N    ??gcode_M18_M84_2
   \   0000002A   0x205A             MOVS     R0,#+90
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD107             BNE.N    ??gcode_M18_M84_2
   \   00000034   0x2045             MOVS     R0,#+69
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000003E   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000042   0xE000             B.N      ??gcode_M18_M84_3
   \                     ??gcode_M18_M84_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   9386              if (all_axis) {
   \                     ??gcode_M18_M84_3: (+1)
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD003             BEQ.N    ??gcode_M18_M84_4
   9387                stepper.finish_and_disable();
   \   0000004A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004E   0x.... 0x....      B.W      _ZN7Stepper18finish_and_disableEv
   9388              }
   9389              else {
   9390                stepper.synchronize();
   \                     ??gcode_M18_M84_4: (+1)
   \   00000052   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9391                if (parser.seen('X')) disable_X();
   \   00000056   0x2058             MOVS     R0,#+88
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD00F             BEQ.N    ??gcode_M18_M84_5
   \   00000060   0x4826             LDR.N    R0,??gcode_M18_M84_1+0x4
   \   00000062   0xF890 0x0104      LDRB     R0,[R0, #+260]
   \   00000066   0x1E42             SUBS     R2,R0,#+1
   \   00000068   0x4192             SBCS     R2,R2,R2
   \   0000006A   0x0FD2             LSRS     R2,R2,#+31
   \   0000006C   0xB252             SXTB     R2,R2
   \   0000006E   0x4824             LDR.N    R0,??gcode_M18_M84_1+0x8
   \   00000070   0x8881             LDRH     R1,[R0, #+4]
   \   00000072   0x4824             LDR.N    R0,??gcode_M18_M84_1+0xC
   \   00000074   0x6880             LDR      R0,[R0, #+8]
   \   00000076   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x491E             LDR.N    R1,??gcode_M18_M84_1
   \   0000007E   0x7108             STRB     R0,[R1, #+4]
   9392                if (parser.seen('Y')) disable_Y();
   \                     ??gcode_M18_M84_5: (+1)
   \   00000080   0x2059             MOVS     R0,#+89
   \   00000082   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD00E             BEQ.N    ??gcode_M18_M84_6
   \   0000008A   0x481F             LDR.N    R0,??gcode_M18_M84_1+0x10
   \   0000008C   0x7840             LDRB     R0,[R0, #+1]
   \   0000008E   0x1E42             SUBS     R2,R0,#+1
   \   00000090   0x4192             SBCS     R2,R2,R2
   \   00000092   0x0FD2             LSRS     R2,R2,#+31
   \   00000094   0xB252             SXTB     R2,R2
   \   00000096   0x481A             LDR.N    R0,??gcode_M18_M84_1+0x8
   \   00000098   0x89C1             LDRH     R1,[R0, #+14]
   \   0000009A   0x481A             LDR.N    R0,??gcode_M18_M84_1+0xC
   \   0000009C   0x69C0             LDR      R0,[R0, #+28]
   \   0000009E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x4914             LDR.N    R1,??gcode_M18_M84_1
   \   000000A6   0x7148             STRB     R0,[R1, #+5]
   9393                if (parser.seen('Z')) disable_Z();
   \                     ??gcode_M18_M84_6: (+1)
   \   000000A8   0x205A             MOVS     R0,#+90
   \   000000AA   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD017             BEQ.N    ??gcode_M18_M84_7
   \   000000B2   0x4C15             LDR.N    R4,??gcode_M18_M84_1+0x10
   \   000000B4   0x78A0             LDRB     R0,[R4, #+2]
   \   000000B6   0x1E42             SUBS     R2,R0,#+1
   \   000000B8   0x4192             SBCS     R2,R2,R2
   \   000000BA   0x0FD2             LSRS     R2,R2,#+31
   \   000000BC   0x4D11             LDR.N    R5,??gcode_M18_M84_1+0xC
   \   000000BE   0x4E10             LDR.N    R6,??gcode_M18_M84_1+0x8
   \   000000C0   0xB252             SXTB     R2,R2
   \   000000C2   0x8B31             LDRH     R1,[R6, #+24]
   \   000000C4   0x6B28             LDR      R0,[R5, #+48]
   \   000000C6   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000CA   0x78A0             LDRB     R0,[R4, #+2]
   \   000000CC   0x1E42             SUBS     R2,R0,#+1
   \   000000CE   0x4192             SBCS     R2,R2,R2
   \   000000D0   0x0FD2             LSRS     R2,R2,#+31
   \   000000D2   0xB252             SXTB     R2,R2
   \   000000D4   0x8D31             LDRH     R1,[R6, #+40]
   \   000000D6   0x6D28             LDR      R0,[R5, #+80]
   \   000000D8   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x4906             LDR.N    R1,??gcode_M18_M84_1
   \   000000E0   0x7188             STRB     R0,[R1, #+6]
   9394                #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
   9395                  if (parser.seen('E')) disable_e_steppers();
   \                     ??gcode_M18_M84_7: (+1)
   \   000000E2   0x2045             MOVS     R0,#+69
   \   000000E4   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD003             BEQ.N    ??gcode_M18_M84_8
   \   000000EC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000F0   0x.... 0x....      B.W      _Z18disable_e_steppersv
   9396                #endif
   9397              }
   9398          
   9399              #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
   9400                ubl.lcd_map_control = defer_return_to_status = false;
   9401              #endif
   9402            }
   9403          }
   \                     ??gcode_M18_M84_8: (+1)
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
   \   000000F6   0xBF00             Nop      
   \                     ??gcode_M18_M84_1:
   \   000000F8   0x........         DC32     axis_homed
   \   000000FC   0x........         DC32     mksCfg
   \   00000100   0x........         DC32     gArrayGpioPin
   \   00000104   0x........         DC32     gArrayGpioPort
   \   00000108   0x........         DC32     mksCfg+0x104
   9404          
   9405          /**
   9406           * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
   9407           */

   \                                 In section .text, align 4
   9408          inline void gcode_M85() {
   \                     _Z9gcode_M85v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9409            if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M85_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M85_1
   \   00000012   0x6608             STR      R0,[R1, #+96]
   9410          }
   \                     ??gcode_M85_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M85_1:
   \   00000018   0x........         DC32     axis_homed
   9411          
   9412          /**
   9413           * Multi-stepper support for M92, M201, M203
   9414           */
   9415          #if ENABLED(DISTINCT_E_FACTORS)
   9416            #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
   9417            #define TARGET_EXTRUDER target_extruder
   9418          #else
   9419            #define GET_TARGET_EXTRUDER(CMD) NOOP
   9420            #define TARGET_EXTRUDER 0
   9421          #endif
   9422          
   9423          /**
   9424           * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
   9425           *      (Follows the same syntax as G92)
   9426           *
   9427           *      With multiple extruders use T to specify which one.
   9428           */

   \                                 In section .text, align 4
   9429          inline void gcode_M92() {
   \                     _Z9gcode_M92v: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   9430          
   9431            GET_TARGET_EXTRUDER(92);
   \   00000004   0x205C             MOVS     R0,#+92
   \   00000006   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD14C             BNE.N    ??gcode_M92_0
   9432          
   9433            LOOP_XYZE(i) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE006             B.N      ??gcode_M92_1
   9434              if (parser.seen(axis_codes[i])) {
   9435                if (i == E_AXIS) {
   9436                  const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
   9437                  if (value < 20.0) {
   9438                    float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
   9439                    planner.max_jerk[E_AXIS] *= factor;
   9440                    planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
   9441                    planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
   9442                  }
   9443                  planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
   9444                }
   9445                else {
   9446                  planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
   \                     ??gcode_M92_2: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xB240             SXTB     R0,R0
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
   \   0000001A   0xF847 0x0024      STR      R0,[R7, R4, LSL #+2]
   9447                }
   \                     ??gcode_M92_3: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M92_1: (+1)
   \   00000020   0x2C04             CMP      R4,#+4
   \   00000022   0xDA3D             BGE.N    ??gcode_M92_4
   \   00000024   0x4821             LDR.N    R0,??gcode_M92_5
   \   00000026   0x5620             LDRSB    R0,[R4, R0]
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD0F6             BEQ.N    ??gcode_M92_3
   \   00000030   0x4F1F             LDR.N    R7,??gcode_M92_5+0x4
   \   00000032   0x2C03             CMP      R4,#+3
   \   00000034   0xD1ED             BNE.N    ??gcode_M92_2
   \   00000036   0x4E1F             LDR.N    R6,??gcode_M92_5+0x8
   \   00000038   0xF996 0x0005      LDRSB    R0,[R6, #+5]
   \   0000003C   0x1CC0             ADDS     R0,R0,#+3
   \   0000003E   0xB240             SXTB     R0,R0
   \   00000040   0x.... 0x....      BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x7976             LDRB     R6,[R6, #+5]
   \   00000048   0xEB07 0x0786      ADD      R7,R7,R6, LSL #+2
   \   0000004C   0x491A             LDR.N    R1,??gcode_M92_5+0xC  ;; 0x41a00000
   \   0000004E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000052   0xD223             BCS.N    ??gcode_M92_6
   \   00000054   0x68F8             LDR      R0,[R7, #+12]
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0x.... 0x....      BL       __aeabi_fdiv
   \   0000005C   0x4680             MOV      R8,R0
   \   0000005E   0xF8DF 0x905C      LDR.W    R9,??gcode_M92_5+0x10
   \   00000062   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   00000066   0x4641             MOV      R1,R8
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0xF8C9 0x000C      STR      R0,[R9, #+12]
   \   00000070   0x4813             LDR.N    R0,??gcode_M92_5+0x14
   \   00000072   0xEB00 0x0986      ADD      R9,R0,R6, LSL #+2
   \   00000076   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0xF8C9 0x000C      STR      R0,[R9, #+12]
   \   00000084   0x480F             LDR.N    R0,??gcode_M92_5+0x18
   \   00000086   0xEB00 0x0686      ADD      R6,R0,R6, LSL #+2
   \   0000008A   0x68F0             LDR      R0,[R6, #+12]
   \   0000008C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000090   0x4641             MOV      R1,R8
   \   00000092   0x.... 0x....      BL       __aeabi_fmul
   \   00000096   0x.... 0x....      BL       __aeabi_f2uiz
   \   0000009A   0x60F0             STR      R0,[R6, #+12]
   \                     ??gcode_M92_6: (+1)
   \   0000009C   0x60FD             STR      R5,[R7, #+12]
   \   0000009E   0xE7BE             B.N      ??gcode_M92_3
   9448              }
   9449            }
   9450            planner.refresh_positioning();
   \                     ??gcode_M92_4: (+1)
   \   000000A0   0xE8BD 0x43F1      POP      {R0,R4-R9,LR}
   \   000000A4   0x.... 0x....      B.W      _ZN7Planner19refresh_positioningEv
   \                     ??gcode_M92_0: (+1)
   \   000000A8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??gcode_M92_5:
   \   000000AC   0x........         DC32     axis_codes
   \   000000B0   0x........         DC32     _ZN7Planner17axis_steps_per_mmE
   \   000000B4   0x........         DC32     mks_heating_busy
   \   000000B8   0x41A00000         DC32     0x41a00000
   \   000000BC   0x........         DC32     _ZN7Planner8max_jerkE
   \   000000C0   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE
   \   000000C4   0x........         DC32     _ZN7Planner29max_acceleration_steps_per_s2E
   9451          }
   9452          
   9453          /**
   9454           * Output the current position to serial
   9455           */

   \                                 In section .text, align 2, keep-with-next
   9456          void report_current_position() {
   \                     _Z23report_current_positionv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9457            SERIAL_PROTOCOLPGM("X:");
   \   00000002   0x....             ADR.N    R0,??DataTable156_3  ;; 0x58, 0x3A, 0x00, 0x00
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9458            SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
   \   00000008   0x....             LDR.N    R4,??DataTable156_2
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable158_1
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x68A8             LDR      R0,[R5, #+8]
   \   00000014   0x.... 0x....      BL       __aeabi_f2d
   \   00000018   0x4602             MOV      R2,R0
   \   0000001A   0x460B             MOV      R3,R1
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN5Print5printEdi
   9459            SERIAL_PROTOCOLPGM(" Y:");
   \   00000022   0x....             ADR.N    R0,??DataTable156_4  ;; " Y:"
   \   00000024   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9460            SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x68E8             LDR      R0,[R5, #+12]
   \   0000002E   0x.... 0x....      BL       __aeabi_f2d
   \   00000032   0x4602             MOV      R2,R0
   \   00000034   0x460B             MOV      R3,R1
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _ZN5Print5printEdi
   9461            SERIAL_PROTOCOLPGM(" Z:");
   \   0000003C   0x....             ADR.N    R0,??DataTable156_6  ;; " Z:"
   \   0000003E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9462            SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0x6928             LDR      R0,[R5, #+16]
   \   00000048   0x.... 0x....      BL       __aeabi_f2d
   \   0000004C   0x4602             MOV      R2,R0
   \   0000004E   0x460B             MOV      R3,R1
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       _ZN5Print5printEdi
   9463            SERIAL_PROTOCOLPGM(" E:");
   \   00000056   0x....             ADR.N    R0,??DataTable157  ;; " E:"
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9464            SERIAL_PROTOCOL(current_position[E_AXIS]);
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x6968             LDR      R0,[R5, #+20]
   \   00000062   0x.... 0x....      BL       __aeabi_f2d
   \   00000066   0x4602             MOV      R2,R0
   \   00000068   0x460B             MOV      R3,R1
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       _ZN5Print5printEdi
   9465          
   9466            stepper.report_positions();
   \   00000070   0x.... 0x....      BL       _ZN7Stepper16report_positionsEv
   9467          
   9468            //#if IS_SCARA
   9469            if(MACHINETPYE&IS_SCARA)  
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable160
   \   00000078   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   0000007C   0xF44F 0x7140      MOV      R1,#+768
   \   00000080   0x4208             TST      R0,R1
   \   00000082   0xD019             BEQ.N    ??report_current_position_0
   9470            {
   9471              SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   0000008A   0x4601             MOV      R1,R0
   \   0000008C   0x.... 0x....      ADR.W    R0,`?<Constant "SCARA Theta:">`
   \   00000090   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9472              SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x.... 0x....      ADR.W    R0,`?<Constant "   Psi+Theta:">`
   \   000000A0   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000000A4   0x210A             MOVS     R1,#+10
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9473              SERIAL_EOL();
   \   000000AC   0x210A             MOVS     R1,#+10
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000B4   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9474            }
   9475            //#endif
   9476          }
   \                     ??report_current_position_0: (+1)
   \   000000B8   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   9477          
   9478          #ifdef M114_DETAIL
   9479          
   9480            void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
   9481              char str[12];
   9482              for (uint8_t i = 0; i < n; i++) {
   9483                SERIAL_CHAR(' ');
   9484                SERIAL_CHAR(axis_codes[i]);
   9485                SERIAL_CHAR(':');
   9486                SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
   9487              }
   9488              SERIAL_EOL();
   9489            }
   9490          
   9491            inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
   9492          
   9493            void report_current_position_detail() {
   9494          
   9495              stepper.synchronize();
   9496          
   9497              SERIAL_PROTOCOLPGM("\nLogical:");
   9498              const float logical[XYZ] = {
   9499                LOGICAL_X_POSITION(current_position[X_AXIS]),
   9500                LOGICAL_Y_POSITION(current_position[Y_AXIS]),
   9501                LOGICAL_Z_POSITION(current_position[Z_AXIS])
   9502              };
   9503              report_xyze(logical);
   9504          
   9505              SERIAL_PROTOCOLPGM("Raw:    ");
   9506              report_xyz(current_position);
   9507          
   9508              float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   9509          
   9510              #if PLANNER_LEVELING
   9511                SERIAL_PROTOCOLPGM("Leveled:");
   9512                planner.apply_leveling(leveled);
   9513                report_xyz(leveled);
   9514          
   9515                SERIAL_PROTOCOLPGM("UnLevel:");
   9516                float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
   9517                planner.unapply_leveling(unleveled);
   9518                report_xyz(unleveled);
   9519              #endif
   9520          
   9521              #if IS_KINEMATIC
   9522                #if IS_SCARA
   9523                  SERIAL_PROTOCOLPGM("ScaraK: ");
   9524                #else
   9525                  SERIAL_PROTOCOLPGM("DeltaK: ");
   9526                #endif
   9527                inverse_kinematics(leveled);  // writes delta[]
   9528                report_xyz(delta);
   9529              #endif
   9530          
   9531              SERIAL_PROTOCOLPGM("Stepper:");
   9532              LOOP_XYZE(i) {
   9533                SERIAL_CHAR(' ');
   9534                SERIAL_CHAR(axis_codes[i]);
   9535                SERIAL_CHAR(':');
   9536                SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
   9537              }
   9538              SERIAL_EOL();
   9539          
   9540              #if IS_SCARA
   9541                const float deg[XYZ] = {
   9542                  stepper.get_axis_position_degrees(A_AXIS),
   9543                  stepper.get_axis_position_degrees(B_AXIS)
   9544                };
   9545                SERIAL_PROTOCOLPGM("Degrees:");
   9546                report_xyze(deg, 2);
   9547              #endif
   9548          
   9549              SERIAL_PROTOCOLPGM("FromStp:");
   9550              get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
   9551              const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
   9552              report_xyze(from_steppers);
   9553          
   9554              const float diff[XYZE] = {
   9555                from_steppers[X_AXIS] - leveled[X_AXIS],
   9556                from_steppers[Y_AXIS] - leveled[Y_AXIS],
   9557                from_steppers[Z_AXIS] - leveled[Z_AXIS],
   9558                from_steppers[E_AXIS] - current_position[E_AXIS]
   9559              };
   9560              SERIAL_PROTOCOLPGM("Differ: ");
   9561              report_xyze(diff);
   9562            }
   9563          #endif // M114_DETAIL
   9564          
   9565          /**
   9566           * M114: Report current position to host
   9567           */

   \                                 In section .text, align 2
   9568          inline void gcode_M114() {
   \                     _Z10gcode_M114v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9569          
   9570            #ifdef M114_DETAIL
   9571              if (parser.seen('D')) {
   9572                report_current_position_detail();
   9573                return;
   9574              }
   9575            #endif
   9576          
   9577            stepper.synchronize();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9578            report_current_position();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      _Z23report_current_positionv
   9579          }
   9580          
   9581          /**
   9582           * M115: Capabilities string
   9583           */
   9584          
   9585          #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

   \                                 In section .text, align 2, keep-with-next
   9586            static void cap_line(const char * const name, bool ena=false) {
   \                     _Z8cap_linePKcb: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   9587              SERIAL_PROTOCOLPGM("Cap:");
   \   00000006   0x.... 0x....      ADR.W    R0,`?<Constant "Cap:">`
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9588              serialprintPGM(name);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9589              SERIAL_PROTOCOLPGM(":");
   \   00000014   0x....             ADR.N    R0,??DataTable157_1  ;; ":"
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9590              SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
   \   0000001A   0x....             LDR.N    R4,??DataTable156_2
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000002E   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9591            }
   9592          #endif
   9593          

   \                                 In section .text, align 4
   9594          inline void gcode_M115() {
   \                     _Z10gcode_M115v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9595            SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
   \   00000002   0x481E             LDR.N    R0,??gcode_M115_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9596          
   9597            #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
   9598          
   9599              // SERIAL_XON_XOFF
   9600              cap_line(PSTR("SERIAL_XON_XOFF")
   9601                #if ENABLED(SERIAL_XON_XOFF)
   9602                  , true
   9603                #endif
   9604              );
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x481D             LDR.N    R0,??gcode_M115_0+0x4
   \   0000000C   0x.... 0x....      BL       _Z8cap_linePKcb
   9605          
   9606              // EEPROM (M500, M501)
   9607              cap_line(PSTR("EEPROM")
   9608                #if ENABLED(EEPROM_SETTINGS)
   9609                  , true
   9610                #endif
   9611              );
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x481C             LDR.N    R0,??gcode_M115_0+0x8
   \   00000014   0x.... 0x....      BL       _Z8cap_linePKcb
   9612          
   9613              // Volumetric Extrusion (M200)
   9614              cap_line(PSTR("VOLUMETRIC")
   9615                #if DISABLED(NO_VOLUMETRICS)
   9616                  , true
   9617                #endif
   9618              );
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x481B             LDR.N    R0,??gcode_M115_0+0xC
   \   0000001C   0x.... 0x....      BL       _Z8cap_linePKcb
   9619          
   9620              // AUTOREPORT_TEMP (M155)
   9621              cap_line(PSTR("AUTOREPORT_TEMP")
   9622                #if ENABLED(AUTO_REPORT_TEMPERATURES)
   9623                  , true
   9624                #endif
   9625              );
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x481A             LDR.N    R0,??gcode_M115_0+0x10
   \   00000024   0x.... 0x....      BL       _Z8cap_linePKcb
   9626          
   9627              // PROGRESS (M530 S L, M531 <file>, M532 X L)
   9628              cap_line(PSTR("PROGRESS"));
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x4819             LDR.N    R0,??gcode_M115_0+0x14
   \   0000002C   0x.... 0x....      BL       _Z8cap_linePKcb
   9629          
   9630              // Print Job timer M75, M76, M77
   9631              cap_line(PSTR("PRINT_JOB"), true);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x4818             LDR.N    R0,??gcode_M115_0+0x18
   \   00000034   0x.... 0x....      BL       _Z8cap_linePKcb
   9632          
   9633              // AUTOLEVEL (G29)
   9634              cap_line(PSTR("AUTOLEVEL")
   9635                #if HAS_AUTOLEVEL
   9636                  , true
   9637                #endif
   9638              );
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x4817             LDR.N    R0,??gcode_M115_0+0x1C
   \   0000003C   0x.... 0x....      BL       _Z8cap_linePKcb
   9639          
   9640              // Z_PROBE (G30)
   9641              cap_line(PSTR("Z_PROBE")
   9642                #if HAS_BED_PROBE
   9643                  , true
   9644                #endif
   9645              );
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x4816             LDR.N    R0,??gcode_M115_0+0x20
   \   00000044   0x.... 0x....      BL       _Z8cap_linePKcb
   9646          
   9647              // MESH_REPORT (M420 V)
   9648              cap_line(PSTR("LEVELING_DATA")
   9649                #if HAS_LEVELING
   9650                  , true
   9651                #endif
   9652              );
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x4815             LDR.N    R0,??gcode_M115_0+0x24
   \   0000004C   0x.... 0x....      BL       _Z8cap_linePKcb
   9653          
   9654              // BUILD_PERCENT (M73)
   9655              cap_line(PSTR("BUILD_PERCENT")
   9656                #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   9657                  , true
   9658                #endif
   9659              );
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x4814             LDR.N    R0,??gcode_M115_0+0x28
   \   00000054   0x.... 0x....      BL       _Z8cap_linePKcb
   9660          
   9661              // SOFTWARE_POWER (M80, M81)
   9662              cap_line(PSTR("SOFTWARE_POWER")
   9663                #if HAS_POWER_SWITCH
   9664                  , true
   9665                #endif
   9666              );
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x4813             LDR.N    R0,??gcode_M115_0+0x2C
   \   0000005C   0x.... 0x....      BL       _Z8cap_linePKcb
   9667          
   9668              // CASE LIGHTS (M355)
   9669              cap_line(PSTR("TOGGLE_LIGHTS")
   9670                #if HAS_CASE_LIGHT
   9671                  , true
   9672                #endif
   9673              );
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x4812             LDR.N    R0,??gcode_M115_0+0x30
   \   00000064   0x.... 0x....      BL       _Z8cap_linePKcb
   9674              cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
   9675                #if HAS_CASE_LIGHT
   9676                  , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
   9677                #endif
   9678              );
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x4811             LDR.N    R0,??gcode_M115_0+0x34
   \   0000006C   0x.... 0x....      BL       _Z8cap_linePKcb
   9679          
   9680              // EMERGENCY_PARSER (M108, M112, M410)
   9681              cap_line(PSTR("EMERGENCY_PARSER")
   9682                #if ENABLED(EMERGENCY_PARSER)
   9683                  , true
   9684                #endif
   9685              );
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x4810             LDR.N    R0,??gcode_M115_0+0x38
   \   00000074   0xE8BD 0x4004      POP      {R2,LR}
   \   00000078   0x.... 0x....      B.W      _Z8cap_linePKcb
   \                     ??gcode_M115_0:
   \   0000007C   0x........         DC32     _ZZ10gcode_M115vEs
   \   00000080   0x........         DC32     _ZZ10gcode_M115vEs_0
   \   00000084   0x........         DC32     _ZZ10gcode_M115vEs_1
   \   00000088   0x........         DC32     _ZZ10gcode_M115vEs_2
   \   0000008C   0x........         DC32     _ZZ10gcode_M115vEs_3
   \   00000090   0x........         DC32     _ZZ10gcode_M115vEs_4
   \   00000094   0x........         DC32     _ZZ10gcode_M115vEs_5
   \   00000098   0x........         DC32     _ZZ10gcode_M115vEs_6
   \   0000009C   0x........         DC32     _ZZ10gcode_M115vEs_7
   \   000000A0   0x........         DC32     _ZZ10gcode_M115vEs_8
   \   000000A4   0x........         DC32     _ZZ10gcode_M115vEs_9
   \   000000A8   0x........         DC32     _ZZ10gcode_M115vEs__10_
   \   000000AC   0x........         DC32     _ZZ10gcode_M115vEs__11_
   \   000000B0   0x........         DC32     _ZZ10gcode_M115vEs__12_
   \   000000B4   0x........         DC32     _ZZ10gcode_M115vEs__13_
   9686          
   9687            #endif // EXTENDED_CAPABILITIES_REPORT
   9688          }
   9689          
   9690          /**
   9691           * M117: Set LCD Status Message
   9692           */

   \                                 In section .text, align 4
   9693          inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
   \                     _Z10gcode_M117v: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x4802             LDR.N    R0,??gcode_M117_0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb
   \   0000000A   0xBF00             Nop      
   \                     ??gcode_M117_0:
   \   0000000C   0x........         DC32     _ZN11GCodeParser10string_argE
   9694          
   9695          /**
   9696           * M118: Display a message in the host console.
   9697           *
   9698           *  A1  Append '// ' for an action command, as in OctoPrint
   9699           *  E1  Have the host 'echo:' the text
   9700           */

   \                                 In section .text, align 4
   9701          inline void gcode_M118() {
   \                     _Z10gcode_M118v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9702            if (parser.boolval('E')) SERIAL_ECHO_START();
   \   00000002   0x2045             MOVS     R0,#+69
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??gcode_M118_0
   \   0000000C   0x480B             LDR.N    R0,??gcode_M118_1
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9703            if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
   \                     ??gcode_M118_0: (+1)
   \   00000012   0x2041             MOVS     R0,#+65
   \   00000014   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??gcode_M118_2
   \   0000001C   0x4808             LDR.N    R0,??gcode_M118_1+0x4
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9704            SERIAL_ECHOLN(parser.string_arg);
   \                     ??gcode_M118_2: (+1)
   \   00000022   0x4C08             LDR.N    R4,??gcode_M118_1+0x8
   \   00000024   0x4808             LDR.N    R0,??gcode_M118_1+0xC
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xE8BD 0x4010      POP      {R4,LR}
   \   00000036   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000003A   0xBF00             Nop      
   \                     ??gcode_M118_1:
   \   0000003C   0x........         DC32     echomagic
   \   00000040   0x........         DC32     _ZZ10gcode_M118vEs
   \   00000044   0x........         DC32     Serial3
   \   00000048   0x........         DC32     _ZN11GCodeParser10string_argE
   9705          }
   9706          
   9707          /**
   9708           * M119: Output endstop states to serial output
   9709           */

   \                                 In section .text, align 2
   9710          inline void gcode_M119() { endstops.M119(); }
   \                     _Z10gcode_M119v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN8Endstops4M119Ev
   9711          
   9712          /**
   9713           * M120: Enable endstops and set non-homing endstop state to "enabled"
   9714           */

   \                                 In section .text, align 2
   9715          inline void gcode_M120() { endstops.enable_globally(true); }
   \                     _Z10gcode_M120v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   9716          
   9717          /**
   9718           * M121: Disable endstops and set non-homing endstop state to "disabled"
   9719           */

   \                                 In section .text, align 2
   9720          inline void gcode_M121() { endstops.enable_globally(false); }
   \                     _Z10gcode_M121v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   9721          
   9722          #if ENABLED(PARK_HEAD_ON_PAUSE)
   9723          
   9724            /**
   9725             * M125: Store current position and move to filament change position.
   9726             *       Called on pause (by M25) to prevent material leaking onto the
   9727             *       object. On resume (M24) the head will be moved back and the
   9728             *       print will resume.
   9729             *
   9730             *       If Marlin is compiled without SD Card support, M125 can be
   9731             *       used directly to pause the print and move to park position,
   9732             *       resuming with a button click or M108.
   9733             *
   9734             *    L = override retract length
   9735             *    X = override X
   9736             *    Y = override Y
   9737             *    Z = override Z raise
   9738             */
   9739            inline void gcode_M125() {
   9740          
   9741              // Initial retract before move to filament change position
   9742              const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
   9743                #ifdef PAUSE_PARK_RETRACT_LENGTH
   9744                  - (PAUSE_PARK_RETRACT_LENGTH)
   9745                #endif
   9746              ;
   9747          
   9748              point_t park_point = NOZZLE_PARK_POINT;
   9749          
   9750              // Move XY axes to filament change position or given position
   9751              if (parser.seenval('X')) park_point.x = parser.linearval('X');
   9752              if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
   9753          
   9754              // Lift Z axis
   9755              if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
   9756          
   9757              #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
   9758                park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
   9759                park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
   9760              #endif
   9761          
   9762              #if DISABLED(SDSUPPORT)
   9763                const bool job_running = print_job_timer.isRunning();
   9764              #endif
   9765          
   9766              if (pause_print(retract, park_point)) {
   9767                #if DISABLED(SDSUPPORT)
   9768                  // Wait for lcd click or M108
   9769                  wait_for_filament_reload();
   9770          
   9771                  // Return to print position and continue
   9772                  resume_print();
   9773          
   9774                  if (job_running) print_job_timer.start();
   9775                #endif
   9776              }
   9777            }
   9778          
   9779          #endif // PARK_HEAD_ON_PAUSE
   9780          
   9781          #if HAS_COLOR_LEDS
   9782          
   9783            /**
   9784             * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
   9785             *       and Brightness       - Use P (for NEOPIXEL only)
   9786             *
   9787             * Always sets all 3 or 4 components. If a component is left out, set to 0.
   9788             *                                    If brightness is left out, no value changed
   9789             *
   9790             * Examples:
   9791             *
   9792             *   M150 R255       ; Turn LED red
   9793             *   M150 R255 U127  ; Turn LED orange (PWM only)
   9794             *   M150            ; Turn LED off
   9795             *   M150 R U B      ; Turn LED white
   9796             *   M150 W          ; Turn LED white using a white LED
   9797             *   M150 P127       ; Set LED 50% brightness
   9798             *   M150 P          ; Set LED full brightness
   9799             */
   9800            inline void gcode_M150() {
   9801              leds.set_color(MakeLEDColor(
   9802                parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9803                parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9804                parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9805                parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9806                parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
   9807              ));
   9808            }
   9809          
   9810          #endif // HAS_COLOR_LEDS
   9811          
   9812          #if DISABLED(NO_VOLUMETRICS)
   9813          
   9814            /**
   9815             * M200: Set filament diameter and set E axis units to cubic units
   9816             *
   9817             *    T<extruder> - Optional extruder number. Current extruder if omitted.
   9818             *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
   9819             */

   \                                 In section .text, align 4
   9820            inline void gcode_M200() {
   \                     _Z10gcode_M200v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   9821          
   9822              if (get_target_extruder_from_command(200)) return;
   \   00000004   0x20C8             MOVS     R0,#+200
   \   00000006   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11D             BNE.N    ??gcode_M200_0
   9823          
   9824              if (parser.seen('D')) {
   \   0000000E   0x2044             MOVS     R0,#+68
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD016             BEQ.N    ??gcode_M200_1
   9825                // setting any extruder filament size disables volumetric on the assumption that
   9826                // slicers either generate in extruder values as cubic mm or as as filament feeds
   9827                // for all extruders
   9828                if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
   \   00000018   0x4C0C             LDR.N    R4,??gcode_M200_2
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000024   0xD002             BEQ.N    ??gcode_M200_3
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   \   0000002A   0xE001             B.N      ??gcode_M200_4
   \                     ??gcode_M200_3: (+1)
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x7020             STRB     R0,[R4, #+0]
   \                     ??gcode_M200_4: (+1)
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD007             BEQ.N    ??gcode_M200_1
   9829                  planner.set_filament_size(target_extruder, parser.value_linear_units());
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xA900             ADD      R1,SP,#+0
   \   0000003E   0x4804             LDR.N    R0,??gcode_M200_2+0x4
   \   00000040   0x7940             LDRB     R0,[R0, #+5]
   \   00000042   0x.... 0x....      BL       _ZN7Planner17set_filament_sizeEhRKf
   9830              }
   9831              planner.calculate_volumetric_multipliers();
   \                     ??gcode_M200_1: (+1)
   \   00000046   0x.... 0x....      BL       _ZN7Planner32calculate_volumetric_multipliersEv
   9832            }
   \                     ??gcode_M200_0: (+1)
   \   0000004A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \                     ??gcode_M200_2:
   \   0000004C   0x........         DC32     _ZN11GCodeParser18volumetric_enabledE
   \   00000050   0x........         DC32     mks_heating_busy
   9833          
   9834          #endif // !NO_VOLUMETRICS
   9835          
   9836          /**
   9837           * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
   9838           *
   9839           *       With multiple extruders use T to specify which one.
   9840           */

   \                                 In section .text, align 4
   9841          inline void gcode_M201() {
   \                     _Z10gcode_M201v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9842          
   9843            GET_TARGET_EXTRUDER(201);
   \   00000002   0x20C9             MOVS     R0,#+201
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD11F             BNE.N    ??gcode_M201_0
   9844          
   9845            LOOP_XYZE(i) {
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE00C             B.N      ??gcode_M201_1
   9846              if (parser.seen(axis_codes[i])) {
   9847                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   \                     ??gcode_M201_2: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??gcode_M201_3: (+1)
   \   00000012   0x1905             ADDS     R5,R0,R4
   \   00000014   0xB2ED             UXTB     R5,R5
   9848                planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
                                                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xB240             SXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000001E   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000022   0x490B             LDR.N    R1,??gcode_M201_4
   \   00000024   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \                     ??gcode_M201_5: (+1)
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M201_1: (+1)
   \   0000002A   0x2C04             CMP      R4,#+4
   \   0000002C   0xDA0A             BGE.N    ??gcode_M201_6
   \   0000002E   0x4809             LDR.N    R0,??gcode_M201_4+0x4
   \   00000030   0x5620             LDRSB    R0,[R4, R0]
   \   00000032   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD0F6             BEQ.N    ??gcode_M201_5
   \   0000003A   0x2C03             CMP      R4,#+3
   \   0000003C   0xD1E8             BNE.N    ??gcode_M201_2
   \   0000003E   0x4806             LDR.N    R0,??gcode_M201_4+0x8
   \   00000040   0x7940             LDRB     R0,[R0, #+5]
   \   00000042   0xE7E6             B.N      ??gcode_M201_3
   9849              }
   9850            }
   9851            // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
   9852            planner.reset_acceleration_rates();
   \                     ??gcode_M201_6: (+1)
   \   00000044   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000048   0x.... 0x....      B.W      _ZN7Planner24reset_acceleration_ratesEv
   \                     ??gcode_M201_0: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   0000004E   0xBF00             Nop      
   \                     ??gcode_M201_4:
   \   00000050   0x........         DC32     _ZN7Planner26max_acceleration_mm_per_s2E
   \   00000054   0x........         DC32     axis_codes
   \   00000058   0x........         DC32     mks_heating_busy
   9853          }
   9854          
   9855          #if 0 // Not used for Sprinter/grbl gen6
   9856            inline void gcode_M202() {
   9857              LOOP_XYZE(i) {
   9858                if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
   9859              }
   9860            }
   9861          #endif
   9862          
   9863          
   9864          /**
   9865           * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
   9866           *
   9867           *       With multiple extruders use T to specify which one.
   9868           */

   \                                 In section .text, align 4
   9869          inline void gcode_M203() {
   \                     _Z10gcode_M203v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9870          
   9871            GET_TARGET_EXTRUDER(203);
   \   00000002   0x20CB             MOVS     R0,#+203
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD119             BNE.N    ??gcode_M203_0
   9872          
   9873            LOOP_XYZE(i)
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE00A             B.N      ??gcode_M203_1
   9874              if (parser.seen(axis_codes[i])) {
   9875                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   \                     ??gcode_M203_2: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??gcode_M203_3: (+1)
   \   00000012   0x1905             ADDS     R5,R0,R4
   \   00000014   0xB2ED             UXTB     R5,R5
   9876                planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xB240             SXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000001E   0x4909             LDR.N    R1,??gcode_M203_4
   \   00000020   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \                     ??gcode_M203_5: (+1)
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M203_1: (+1)
   \   00000026   0x2C04             CMP      R4,#+4
   \   00000028   0xDA0A             BGE.N    ??gcode_M203_0
   \   0000002A   0x4807             LDR.N    R0,??gcode_M203_4+0x4
   \   0000002C   0x5620             LDRSB    R0,[R4, R0]
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD0F6             BEQ.N    ??gcode_M203_5
   \   00000036   0x2C03             CMP      R4,#+3
   \   00000038   0xD1EA             BNE.N    ??gcode_M203_2
   \   0000003A   0x4804             LDR.N    R0,??gcode_M203_4+0x8
   \   0000003C   0x7940             LDRB     R0,[R0, #+5]
   \   0000003E   0xE7E8             B.N      ??gcode_M203_3
   9877              }
   9878          }
   \                     ??gcode_M203_0: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   00000042   0xBF00             Nop      
   \                     ??gcode_M203_4:
   \   00000044   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE
   \   00000048   0x........         DC32     axis_codes
   \   0000004C   0x........         DC32     mks_heating_busy
   9879          
   9880          /**
   9881           * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
   9882           *
   9883           *    P = Printing moves
   9884           *    R = Retract only (no X, Y, Z) moves
   9885           *    T = Travel (non printing) moves
   9886           *
   9887           *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
   9888           */

   \                                 In section .text, align 4
   9889          inline void gcode_M204() {
   \                     _Z10gcode_M204v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9890            if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00D             BEQ.N    ??gcode_M204_0
   9891              planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x4920             LDR.N    R1,??gcode_M204_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x4920             LDR.N    R1,??gcode_M204_1+0x4
   \   00000016   0x6008             STR      R0,[R1, #+0]
   9892              SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x4820             LDR.N    R0,??gcode_M204_1+0x8
   \   0000001C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000020   0x210A             MOVS     R1,#+10
   \   00000022   0x481F             LDR.N    R0,??gcode_M204_1+0xC
   \   00000024   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9893            }
   9894            if (parser.seen('P')) {
   \                     ??gcode_M204_0: (+1)
   \   00000028   0x2050             MOVS     R0,#+80
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00B             BEQ.N    ??gcode_M204_2
   9895              planner.acceleration = parser.value_linear_units();
   \   00000032   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000036   0x4917             LDR.N    R1,??gcode_M204_1
   \   00000038   0x6008             STR      R0,[R1, #+0]
   9896              SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0x4819             LDR.N    R0,??gcode_M204_1+0x10
   \   0000003E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000042   0x210A             MOVS     R1,#+10
   \   00000044   0x4816             LDR.N    R0,??gcode_M204_1+0xC
   \   00000046   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9897            }
   9898            if (parser.seen('R')) {
   \                     ??gcode_M204_2: (+1)
   \   0000004A   0x2052             MOVS     R0,#+82
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD00B             BEQ.N    ??gcode_M204_3
   9899              planner.retract_acceleration = parser.value_linear_units();
   \   00000054   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000058   0x4913             LDR.N    R1,??gcode_M204_1+0x14
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   9900              SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4813             LDR.N    R0,??gcode_M204_1+0x18
   \   00000060   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000064   0x210A             MOVS     R1,#+10
   \   00000066   0x480E             LDR.N    R0,??gcode_M204_1+0xC
   \   00000068   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9901            }
   9902            if (parser.seen('T')) {
   \                     ??gcode_M204_3: (+1)
   \   0000006C   0x2054             MOVS     R0,#+84
   \   0000006E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD00D             BEQ.N    ??gcode_M204_4
   9903              planner.travel_acceleration = parser.value_linear_units();
   \   00000076   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000007A   0x4907             LDR.N    R1,??gcode_M204_1+0x4
   \   0000007C   0x6008             STR      R0,[R1, #+0]
   9904              SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
   \   0000007E   0x4601             MOV      R1,R0
   \   00000080   0x480B             LDR.N    R0,??gcode_M204_1+0x1C
   \   00000082   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000086   0x210A             MOVS     R1,#+10
   \   00000088   0x4805             LDR.N    R0,??gcode_M204_1+0xC
   \   0000008A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000008E   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9905            }
   9906          }
   \                     ??gcode_M204_4: (+1)
   \   00000092   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M204_1:
   \   00000094   0x........         DC32     _ZN7Planner12accelerationE
   \   00000098   0x........         DC32     _ZN7Planner19travel_accelerationE
   \   0000009C   0x........         DC32     _ZZ10gcode_M204vEs
   \   000000A0   0x........         DC32     Serial3
   \   000000A4   0x........         DC32     _ZZ10gcode_M204vEs_0
   \   000000A8   0x........         DC32     _ZN7Planner20retract_accelerationE
   \   000000AC   0x........         DC32     _ZZ10gcode_M204vEs_1
   \   000000B0   0x........         DC32     _ZZ10gcode_M204vEs_2
   9907          
   9908          /**
   9909           * M205: Set Advanced Settings
   9910           *
   9911           *    S = Min Feed Rate (units/s)
   9912           *    T = Min Travel Feed Rate (units/s)
   9913           *    B = Min Segment Time (¬µs)
   9914           *    X = Max X Jerk (units/sec^2)
   9915           *    Y = Max Y Jerk (units/sec^2)
   9916           *    Z = Max Z Jerk (units/sec^2)
   9917           *    E = Max E Jerk (units/sec^2)
   9918           */

   \                                 In section .text, align 4
   9919          inline void gcode_M205() {
   \                     _Z10gcode_M205v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9920            if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M205_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x491C             LDR.N    R1,??gcode_M205_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
   9921            if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
   \                     ??gcode_M205_0: (+1)
   \   00000014   0x2054             MOVS     R0,#+84
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??gcode_M205_2
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000022   0x4919             LDR.N    R1,??gcode_M205_1+0x4
   \   00000024   0x6008             STR      R0,[R1, #+0]
   9922            if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
   \                     ??gcode_M205_2: (+1)
   \   00000026   0x2042             MOVS     R0,#+66
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??gcode_M205_3
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser11value_ulongEv
   \   00000034   0x4915             LDR.N    R1,??gcode_M205_1+0x8
   \   00000036   0x6008             STR      R0,[R1, #+0]
   9923            if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_3: (+1)
   \   00000038   0x2058             MOVS     R0,#+88
   \   0000003A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD003             BEQ.N    ??gcode_M205_4
   \   00000042   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000046   0x4912             LDR.N    R1,??gcode_M205_1+0xC
   \   00000048   0x6008             STR      R0,[R1, #+0]
   9924            if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_4: (+1)
   \   0000004A   0x2059             MOVS     R0,#+89
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD003             BEQ.N    ??gcode_M205_5
   \   00000054   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000058   0x490D             LDR.N    R1,??gcode_M205_1+0xC
   \   0000005A   0x6048             STR      R0,[R1, #+4]
   9925            if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_5: (+1)
   \   0000005C   0x205A             MOVS     R0,#+90
   \   0000005E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD003             BEQ.N    ??gcode_M205_6
   \   00000066   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000006A   0x4909             LDR.N    R1,??gcode_M205_1+0xC
   \   0000006C   0x6088             STR      R0,[R1, #+8]
   9926            if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_6: (+1)
   \   0000006E   0x2045             MOVS     R0,#+69
   \   00000070   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD003             BEQ.N    ??gcode_M205_7
   \   00000078   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000007C   0x4904             LDR.N    R1,??gcode_M205_1+0xC
   \   0000007E   0x60C8             STR      R0,[R1, #+12]
   9927          }
   \                     ??gcode_M205_7: (+1)
   \   00000080   0xBD01             POP      {R0,PC}          ;; return
   \   00000082   0xBF00             Nop      
   \                     ??gcode_M205_1:
   \   00000084   0x........         DC32     _ZN7Planner17min_feedrate_mm_sE
   \   00000088   0x........         DC32     _ZN7Planner24min_travel_feedrate_mm_sE
   \   0000008C   0x........         DC32     _ZN7Planner19min_segment_time_usE
   \   00000090   0x........         DC32     _ZN7Planner8max_jerkE
   9928          
   9929          #if 1//HAS_M206_COMMAND
   9930          
   9931            /**
   9932             * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
   9933             *
   9934             * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
   9935             * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
   9936             * ***              In the next 1.2 release, it will simply be disabled by default.
   9937             */

   \                                 In section .text, align 4
   9938            inline void gcode_M206() {
   \                     _Z10gcode_M206v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9939            if(MACHINETPYE == DELTA) return;
   \   00000002   0x4C1B             LDR.N    R4,??gcode_M206_0
   \   00000004   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD030             BEQ.N    ??gcode_M206_1
   9940              LOOP_XYZ(i)
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0xE00D             B.N      ??gcode_M206_2
   9941                if (parser.seen(axis_codes[i]))
   \                     ??gcode_M206_3: (+1)
   \   00000010   0x4818             LDR.N    R0,??gcode_M206_0+0x4
   \   00000012   0x5628             LDRSB    R0,[R5, R0]
   \   00000014   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ.N    ??gcode_M206_4
   9942                  set_home_offset((AxisEnum)i, parser.value_linear_units());
   \   0000001C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0xB240             SXTB     R0,R0
   \   00000026   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   \                     ??gcode_M206_4: (+1)
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_M206_2: (+1)
   \   0000002C   0x2D03             CMP      R5,#+3
   \   0000002E   0xDBEF             BLT.N    ??gcode_M206_3
   9943          
   9944              //#if ENABLED(MORGAN_SCARA)
   9945              if(MACHINETPYE == MORGAN_SCARA)
   \   00000030   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD115             BNE.N    ??gcode_M206_5
   9946              {
   9947                if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
   \   0000003A   0x2054             MOVS     R0,#+84
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD005             BEQ.N    ??gcode_M206_6
   \   00000044   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000048   0x4601             MOV      R1,R0
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   9948                if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
   \                     ??gcode_M206_6: (+1)
   \   00000050   0x2050             MOVS     R0,#+80
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD005             BEQ.N    ??gcode_M206_5
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   9949              }
   9950              //#endif
   9951          
   9952              report_current_position();
   \                     ??gcode_M206_5: (+1)
   \   00000066   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000006A   0x.... 0x....      B.W      _Z23report_current_positionv
   \                     ??gcode_M206_1: (+1)
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M206_0:
   \   00000070   0x........         DC32     mksCfg
   \   00000074   0x........         DC32     axis_codes
   9953            }
   9954          
   9955          #endif // HAS_M206_COMMAND
   9956          
   9957          #if 1//ENABLED(DELTA)
   9958            /**
   9959             * M665: Set delta configurations
   9960             *
   9961             *    H = delta height
   9962             *    L = diagonal rod
   9963             *    R = delta radius
   9964             *    S = segments per second
   9965             *    B = delta calibration radius
   9966             *    X = Alpha (Tower 1) angle trim
   9967             *    Y = Beta (Tower 2) angle trim
   9968             *    Z = Rotate A and B by this angle
   9969             */

   \                                 In section .text, align 4
   9970            inline void gcode_M665() {
   \                     _Z10gcode_M665v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9971              if (parser.seen('H')) delta_height                   = parser.value_linear_units();
   \   00000002   0x2048             MOVS     R0,#+72
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M665_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x491F             LDR.N    R1,??gcode_M665_1
   \   00000012   0x6788             STR      R0,[R1, #+120]
   9972              if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
   \                     ??gcode_M665_0: (+1)
   \   00000014   0x4C1F             LDR.N    R4,??gcode_M665_1+0x4
   \   00000016   0x204C             MOVS     R0,#+76
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD002             BEQ.N    ??gcode_M665_2
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000024   0x66E0             STR      R0,[R4, #+108]
   9973              if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
   \                     ??gcode_M665_2: (+1)
   \   00000026   0x2052             MOVS     R0,#+82
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??gcode_M665_3
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000034   0x66A0             STR      R0,[R4, #+104]
   9974              if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
   \                     ??gcode_M665_3: (+1)
   \   00000036   0x2053             MOVS     R0,#+83
   \   00000038   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??gcode_M665_4
   \   00000040   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000044   0x6760             STR      R0,[R4, #+116]
   9975              if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
   \                     ??gcode_M665_4: (+1)
   \   00000046   0x2042             MOVS     R0,#+66
   \   00000048   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??gcode_M665_5
   \   00000050   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000054   0x6720             STR      R0,[R4, #+112]
   9976              if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
   \                     ??gcode_M665_5: (+1)
   \   00000056   0x2058             MOVS     R0,#+88
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??gcode_M665_6
   \   00000060   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000064   0x6320             STR      R0,[R4, #+48]
   9977              if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
   \                     ??gcode_M665_6: (+1)
   \   00000066   0x2059             MOVS     R0,#+89
   \   00000068   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD002             BEQ.N    ??gcode_M665_7
   \   00000070   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000074   0x6360             STR      R0,[R4, #+52]
   9978              if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
   \                     ??gcode_M665_7: (+1)
   \   00000076   0x205A             MOVS     R0,#+90
   \   00000078   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD002             BEQ.N    ??gcode_M665_8
   \   00000080   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000084   0x63A0             STR      R0,[R4, #+56]
   9979              recalc_delta_settings();
   \                     ??gcode_M665_8: (+1)
   \   00000086   0xE8BD 0x4010      POP      {R4,LR}
   \   0000008A   0x.... 0x....      B.W      _Z21recalc_delta_settingsv
   \   0000008E   0xBF00             Nop      
   \                     ??gcode_M665_1:
   \   00000090   0x........         DC32     mks_heating_busy
   \   00000094   0x........         DC32     axis_homed
   9980            }
   9981            /**
   9982             * M666: Set delta endstop adjustment
   9983             */

   \                                 In section .text, align 4
   9984            inline void gcode_M666() {
   \                     _Z10gcode_M666v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9985              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9986                if (DEBUGGING(LEVELING)) {
   9987                  SERIAL_ECHOLNPGM(">>> gcode_M666");
   9988                }
   9989              #endif
   9990              LOOP_XYZ(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE01B             B.N      ??gcode_M666_0
   9991                if (parser.seen(axis_codes[i])) {
   \                     ??gcode_M666_1: (+1)
   \   00000006   0x480F             LDR.N    R0,??gcode_M666_2
   \   00000008   0x5620             LDRSB    R0,[R4, R0]
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD014             BEQ.N    ??gcode_M666_3
   9992                  if (parser.value_linear_units() * Z_HOME_DIR <= 0)
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000016   0x4605             MOV      R5,R0
   \   00000018   0x480B             LDR.N    R0,??gcode_M666_2+0x4
   \   0000001A   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   0000001E   0x.... 0x....      BL       __aeabi_i2f
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x.... 0x....      BL       __aeabi_fmul
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002E   0xD805             BHI.N    ??gcode_M666_3
   9993                    delta_endstop_adj[i] = parser.value_linear_units();
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000034   0x4905             LDR.N    R1,??gcode_M666_2+0x8
   \   00000036   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   0000003A   0x6048             STR      R0,[R1, #+4]
   9994                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   9995                    if (DEBUGGING(LEVELING)) {
   9996                      SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
   9997                      SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
   9998                    }
   9999                  #endif
  10000                }
  10001              }
   \                     ??gcode_M666_3: (+1)
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M666_0: (+1)
   \   0000003E   0x2C03             CMP      R4,#+3
   \   00000040   0xDBE1             BLT.N    ??gcode_M666_1
  10002              #if ENABLED(DEBUG_LEVELING_FEATURE)
  10003                if (DEBUGGING(LEVELING)) {
  10004                  SERIAL_ECHOLNPGM("<<< gcode_M666");
  10005                }
  10006              #endif
  10007            }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M666_2:
   \   00000044   0x........         DC32     axis_codes
   \   00000048   0x........         DC32     mksCfg
   \   0000004C   0x........         DC32     z_endstop_adj
  10008          
  10009          #elif IS_SCARA
  10010          
  10011            /**
  10012             * M665: Set SCARA settings
  10013             *
  10014             * Parameters:
  10015             *
  10016             *   S[segments-per-second] - Segments-per-second
  10017             *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
  10018             *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
  10019             *
  10020             *   A, P, and X are all aliases for the shoulder angle
  10021             *   B, T, and Y are all aliases for the elbow angle
  10022             */
  10023            inline void gcode_M665() {
  10024              if (parser.seen('S')) delta_segments_per_second = parser.value_float();
  10025          
  10026              const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
  10027              const uint8_t sumAPX = hasA + hasP + hasX;
  10028              if (sumAPX == 1)
  10029                home_offset[A_AXIS] = parser.value_float();
  10030              else if (sumAPX > 1) {
  10031                SERIAL_ERROR_START();
  10032                SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
  10033                return;
  10034              }
  10035          
  10036              const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
  10037              const uint8_t sumBTY = hasB + hasT + hasY;
  10038              if (sumBTY == 1)
  10039                home_offset[B_AXIS] = parser.value_float();
  10040              else if (sumBTY > 1) {
  10041                SERIAL_ERROR_START();
  10042                SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
  10043                return;
  10044              }
  10045            }
  10046          
  10047          
  10048          #endif
  10049          //#elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
  10050          
  10051            /**
  10052             * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
  10053             */

   \                                 In section .text, align 4
  10054            inline void gcode_M666_dual() {
   \                     _Z15gcode_M666_dualv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10055              SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
   \   00000002   0x480D             LDR.N    R0,??gcode_M666_dual_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10056              #if ENABLED(X_DUAL_ENDSTOPS)
  10057                if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
  10058                SERIAL_ECHOPAIR(" X", x_endstop_adj);
  10059              #endif
  10060              #if ENABLED(Y_DUAL_ENDSTOPS)
  10061                if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
  10062                SERIAL_ECHOPAIR(" Y", y_endstop_adj);
  10063              #endif
  10064              //#if ENABLED(Z_DUAL_ENDSTOPS)
  10065              if(Z_DUAL_ENDSTOPS==1)
   \   00000008   0x480C             LDR.N    R0,??gcode_M666_dual_0+0x4
   \   0000000A   0xF890 0x0102      LDRB     R0,[R0, #+258]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD10C             BNE.N    ??gcode_M666_dual_1
  10066              {
  10067                if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
   \   00000012   0x4C0B             LDR.N    R4,??gcode_M666_dual_0+0x8
   \   00000014   0x205A             MOVS     R0,#+90
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??gcode_M666_dual_2
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000022   0x6020             STR      R0,[R4, #+0]
  10068                SERIAL_ECHOPAIR(" Z", z_endstop_adj);
   \                     ??gcode_M666_dual_2: (+1)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x4807             LDR.N    R0,??gcode_M666_dual_0+0xC
   \   00000028   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10069              }
  10070              //#endif
  10071              SERIAL_EOL();
   \                     ??gcode_M666_dual_1: (+1)
   \   0000002C   0x210A             MOVS     R1,#+10
   \   0000002E   0x4806             LDR.N    R0,??gcode_M666_dual_0+0x10
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M666_dual_0:
   \   00000038   0x........         DC32     _ZZ15gcode_M666_dualvEs
   \   0000003C   0x........         DC32     mksCfg
   \   00000040   0x........         DC32     z_endstop_adj
   \   00000044   0x........         DC32     _ZZ15gcode_M666_dualvEs_0
   \   00000048   0x........         DC32     Serial3
  10072            }
  10073          
  10074          //#endif // !DELTA && Z_DUAL_ENDSTOPS
  10075          
  10076          #if ENABLED(FWRETRACT)
  10077          
  10078            /**
  10079             * M207: Set firmware retraction values
  10080             *
  10081             *   S[+units]    retract_length
  10082             *   W[+units]    swap_retract_length (multi-extruder)
  10083             *   F[units/min] retract_feedrate_mm_s
  10084             *   Z[units]     retract_zlift
  10085             */
  10086            inline void gcode_M207() {
  10087              if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
  10088              if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
  10089              if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
  10090              if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
  10091            }
  10092          
  10093            /**
  10094             * M208: Set firmware un-retraction values
  10095             *
  10096             *   S[+units]    retract_recover_length (in addition to M207 S*)
  10097             *   W[+units]    swap_retract_recover_length (multi-extruder)
  10098             *   F[units/min] retract_recover_feedrate_mm_s
  10099             *   R[units/min] swap_retract_recover_feedrate_mm_s
  10100             */
  10101            inline void gcode_M208() {
  10102              if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
  10103              if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
  10104              if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
  10105              if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
  10106            }
  10107          
  10108            /**
  10109             * M209: Enable automatic retract (M209 S1)
  10110             *   For slicers that don't support G10/11, reversed extrude-only
  10111             *   moves will be classified as retraction.
  10112             */
  10113            inline void gcode_M209() {
  10114              if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
  10115                if (parser.seen('S')) {
  10116                  autoretract_enabled = parser.value_bool();
  10117                  for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
  10118                }
  10119              }
  10120            }
  10121          
  10122          #endif // FWRETRACT
  10123          
  10124          /**
  10125           * M211: Enable, Disable, and/or Report software endstops
  10126           *
  10127           * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
  10128           */

   \                                 In section .text, align 4
  10129          inline void gcode_M211() {
   \                     _Z10gcode_M211v: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
  10130            SERIAL_ECHO_START();
   \   00000004   0x482B             LDR.N    R0,??gcode_M211_0
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10131            #if HAS_SOFTWARE_ENDSTOPS
  10132              if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
   \   0000000A   0x4C2B             LDR.N    R4,??gcode_M211_0+0x4
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??gcode_M211_1
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   0000001A   0x7220             STRB     R0,[R4, #+8]
  10133              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
   \                     ??gcode_M211_1: (+1)
   \   0000001C   0x4827             LDR.N    R0,??gcode_M211_0+0x8
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10134              serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
   \   00000022   0x7A20             LDRB     R0,[R4, #+8]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??gcode_M211_2
   \   00000028   0x4825             LDR.N    R0,??gcode_M211_0+0xC
   \   0000002A   0xE000             B.N      ??gcode_M211_3
   \                     ??gcode_M211_2: (+1)
   \   0000002C   0x4825             LDR.N    R0,??gcode_M211_0+0x10
   \                     ??gcode_M211_3: (+1)
   \   0000002E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10135            #else
  10136              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
  10137              SERIAL_ECHOPGM(MSG_OFF);
  10138            #endif
  10139            SERIAL_ECHOPGM(MSG_SOFT_MIN);
   \   00000032   0x4825             LDR.N    R0,??gcode_M211_0+0x14
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10140            SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
   \   00000038   0x4D24             LDR.N    R5,??gcode_M211_0+0x18
   \   0000003A   0x4E25             LDR.N    R6,??gcode_M211_0+0x1C
   \   0000003C   0x6C71             LDR      R1,[R6, #+68]
   \   0000003E   0x6BB0             LDR      R0,[R6, #+56]
   \   00000040   0x.... 0x....      BL       __aeabi_fadd
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10141            SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
   \   0000004C   0x4F21             LDR.N    R7,??gcode_M211_0+0x20
   \   0000004E   0x6CB1             LDR      R1,[R6, #+72]
   \   00000050   0x6BF0             LDR      R0,[R6, #+60]
   \   00000052   0x.... 0x....      BL       __aeabi_fadd
   \   00000056   0x4601             MOV      R1,R0
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10142            SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
   \   0000005E   0xF8DF 0x8078      LDR.W    R8,??gcode_M211_0+0x24
   \   00000062   0x6CF1             LDR      R1,[R6, #+76]
   \   00000064   0x6C30             LDR      R0,[R6, #+64]
   \   00000066   0x.... 0x....      BL       __aeabi_fadd
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10143            SERIAL_ECHOPGM(MSG_SOFT_MAX);
   \   00000072   0x481A             LDR.N    R0,??gcode_M211_0+0x28
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10144            SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
   \   00000078   0x6A61             LDR      R1,[R4, #+36]
   \   0000007A   0x6BB0             LDR      R0,[R6, #+56]
   \   0000007C   0x.... 0x....      BL       __aeabi_fadd
   \   00000080   0x4601             MOV      R1,R0
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10145            SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
   \   00000088   0x6AA1             LDR      R1,[R4, #+40]
   \   0000008A   0x6BF0             LDR      R0,[R6, #+60]
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
   \   00000090   0x4601             MOV      R1,R0
   \   00000092   0x4638             MOV      R0,R7
   \   00000094   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10146            SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
   \   00000098   0x6AE1             LDR      R1,[R4, #+44]
   \   0000009A   0x6C30             LDR      R0,[R6, #+64]
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4601             MOV      R1,R0
   \   000000A2   0x4640             MOV      R0,R8
   \   000000A4   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000000A8   0x210A             MOVS     R1,#+10
   \   000000AA   0x480D             LDR.N    R0,??gcode_M211_0+0x2C
   \   000000AC   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000B0   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M211_0:
   \   000000B4   0x........         DC32     echomagic
   \   000000B8   0x........         DC32     axis_homed
   \   000000BC   0x........         DC32     _ZZ10gcode_M211vEs
   \   000000C0   0x........         DC32     _ZZ10gcode_M211vEs_0
   \   000000C4   0x........         DC32     _ZZ10gcode_M211vEs_1
   \   000000C8   0x........         DC32     _ZZ10gcode_M211vEs_2
   \   000000CC   0x........         DC32     _ZZ10gcode_M211vEs_3
   \   000000D0   0x........         DC32     mks_heating_busy
   \   000000D4   0x........         DC32     _ZZ10gcode_M211vEs_4
   \   000000D8   0x........         DC32     _ZZ10gcode_M211vEs_5
   \   000000DC   0x........         DC32     _ZZ10gcode_M211vEs_6
   \   000000E0   0x........         DC32     Serial3
  10147          }
  10148          
  10149          #if HOTENDS > 1
  10150          
  10151            /**
  10152             * M218 - set hotend offset (in linear units)
  10153             *
  10154             *   T<tool>
  10155             *   X<xoffset>
  10156             *   Y<yoffset>
  10157             *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
  10158             */

   \                                 In section .text, align 4
  10159            inline void gcode_M218() {
   \                     _Z10gcode_M218v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
  10160              if (get_target_extruder_from_command(218) || target_extruder == 0) return;
   \   00000004   0x20DA             MOVS     R0,#+218
   \   00000006   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD150             BNE.N    ??gcode_M218_0
   \   0000000E   0x4C29             LDR.N    R4,??gcode_M218_1
   \   00000010   0x7960             LDRB     R0,[R4, #+5]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD04C             BEQ.N    ??gcode_M218_0
  10161          
  10162              if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
   \   00000016   0x2058             MOVS     R0,#+88
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??gcode_M218_2
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000024   0x7961             LDRB     R1,[R4, #+5]
   \   00000026   0x4A24             LDR.N    R2,??gcode_M218_1+0x4
   \   00000028   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
  10163              if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
   \                     ??gcode_M218_2: (+1)
   \   0000002C   0x2059             MOVS     R0,#+89
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD006             BEQ.N    ??gcode_M218_3
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000003A   0x7961             LDRB     R1,[R4, #+5]
   \   0000003C   0x4A1E             LDR.N    R2,??gcode_M218_1+0x4
   \   0000003E   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \   00000042   0x6088             STR      R0,[R1, #+8]
  10164          
  10165              #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
  10166                if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
  10167              #endif
  10168          
  10169              SERIAL_ECHO_START();
   \                     ??gcode_M218_3: (+1)
   \   00000044   0x481D             LDR.N    R0,??gcode_M218_1+0x8
   \   00000046   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10170              SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
   \   0000004A   0x481D             LDR.N    R0,??gcode_M218_1+0xC
   \   0000004C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10171              HOTEND_LOOP() {
   \   00000050   0x2400             MOVS     R4,#+0
   \   00000052   0x4D1C             LDR.N    R5,??gcode_M218_1+0x10
   \   00000054   0x4E18             LDR.N    R6,??gcode_M218_1+0x4
   \   00000056   0xE020             B.N      ??gcode_M218_4
  10172                SERIAL_CHAR(' ');
   \                     ??gcode_M218_5: (+1)
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10173                SERIAL_ECHO(hotend_offset[X_AXIS][e]);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   00000068   0x.... 0x....      BL       __aeabi_f2d
   \   0000006C   0x4602             MOV      R2,R0
   \   0000006E   0x460B             MOV      R3,R1
   \   00000070   0x4628             MOV      R0,R5
   \   00000072   0x.... 0x....      BL       _ZN5Print5printEdi
  10174                SERIAL_CHAR(',');
   \   00000076   0x212C             MOVS     R1,#+44
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10175                SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0xEB06 0x0084      ADD      R0,R6,R4, LSL #+2
   \   00000086   0x6880             LDR      R0,[R0, #+8]
   \   00000088   0x.... 0x....      BL       __aeabi_f2d
   \   0000008C   0x4602             MOV      R2,R0
   \   0000008E   0x460B             MOV      R3,R1
   \   00000090   0x4628             MOV      R0,R5
   \   00000092   0x.... 0x....      BL       _ZN5Print5printEdi
  10176                #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
  10177                  SERIAL_CHAR(',');
  10178                  SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
  10179                #endif
  10180              }
   \   00000096   0x1C64             ADDS     R4,R4,#+1
   \   00000098   0xB264             SXTB     R4,R4
   \                     ??gcode_M218_4: (+1)
   \   0000009A   0x480B             LDR.N    R0,??gcode_M218_1+0x14
   \   0000009C   0xF890 0x00F7      LDRB     R0,[R0, #+247]
   \   000000A0   0x4284             CMP      R4,R0
   \   000000A2   0xDBD9             BLT.N    ??gcode_M218_5
  10181              SERIAL_EOL();
   \   000000A4   0x210A             MOVS     R1,#+10
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   000000AC   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M218_0: (+1)
   \   000000B0   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   \   000000B2   0xBF00             Nop      
   \                     ??gcode_M218_1:
   \   000000B4   0x........         DC32     mks_heating_busy
   \   000000B8   0x........         DC32     hotend_offset
   \   000000BC   0x........         DC32     echomagic
   \   000000C0   0x........         DC32     _ZZ10gcode_M218vEs
   \   000000C4   0x........         DC32     Serial3
   \   000000C8   0x........         DC32     mksCfg
  10182            }
  10183          
  10184          #endif // HOTENDS > 1
  10185          
  10186          /**
  10187           * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
  10188           */

   \                                 In section .text, align 4
  10189          inline void gcode_M220() {
   \                     _Z10gcode_M220v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10190            if (parser.seenval('S')) feedrate_percentage = parser.value_int();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M220_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M220_1
   \   00000012   0x80C8             STRH     R0,[R1, #+6]
  10191          }
   \                     ??gcode_M220_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M220_1:
   \   00000018   0x........         DC32     mks_heating_busy
  10192          
  10193          /**
  10194           * M221: Set extrusion percentage (M221 T0 S95)
  10195           */

   \                                 In section .text, align 4
  10196          inline void gcode_M221() {
   \                     _Z10gcode_M221v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10197            if (get_target_extruder_from_command(221)) return;
   \   00000002   0x20DD             MOVS     R0,#+221
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD110             BNE.N    ??gcode_M221_0
  10198            if (parser.seenval('S')) {
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD00B             BEQ.N    ??gcode_M221_0
  10199              planner.flow_percentage[target_extruder] = parser.value_int();
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   0000001A   0x4905             LDR.N    R1,??gcode_M221_1
   \   0000001C   0x7949             LDRB     R1,[R1, #+5]
   \   0000001E   0x4A05             LDR.N    R2,??gcode_M221_1+0x4
   \   00000020   0xF822 0x0011      STRH     R0,[R2, R1, LSL #+1]
  10200              planner.refresh_e_factor(target_extruder);
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0xE8BD 0x4002      POP      {R1,LR}
   \   0000002A   0x.... 0x....      B.W      _ZN7Planner16refresh_e_factorEh
  10201            }
  10202          }
   \                     ??gcode_M221_0: (+1)
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M221_1:
   \   00000030   0x........         DC32     mks_heating_busy
   \   00000034   0x........         DC32     _ZN7Planner15flow_percentageE
  10203          
  10204          /**
  10205           * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
  10206           */

   \                                 In section .text, align 4
  10207          inline void gcode_M226() {
   \                     _Z10gcode_M226v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  10208            if (parser.seen('P')) {
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD03E             BEQ.N    ??gcode_M226_0
  10209              const int pin_number = parser.value_int(),
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4604             MOV      R4,R0
  10210                        pin_state = parser.intval('S', -1); // required pin state - default is inverted
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x2053             MOVS     R0,#+83
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x4605             MOV      R5,R0
  10211          
  10212              if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
   \   0000001E   0x1C68             ADDS     R0,R5,#+1
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD232             BCS.N    ??gcode_M226_0
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD430             BMI.N    ??gcode_M226_0
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xB240             SXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       _Z16pin_is_protecteda
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD12A             BNE.N    ??gcode_M226_0
  10213          
  10214                int target = LOW;
   \   00000034   0x2600             MOVS     R6,#+0
  10215          
  10216                stepper.synchronize();
   \   00000036   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10217          
  10218                pinMode(pin_number, INPUT);
  10219                switch (pin_state) {
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD003             BEQ.N    ??gcode_M226_1
   \   0000003E   0xF1B5 0x3FFF      CMP      R5,#-1
   \   00000042   0xD002             BEQ.N    ??gcode_M226_2
   \   00000044   0xE00F             B.N      ??gcode_M226_3
  10220                  case 1:
  10221                    target = HIGH;
   \                     ??gcode_M226_1: (+1)
   \   00000046   0x2601             MOVS     R6,#+1
  10222                    break;
   \   00000048   0xE00D             B.N      ??gcode_M226_3
  10223                  case 0:
  10224                    target = LOW;
  10225                    break;
  10226                  case -1:
  10227                    target = !digitalRead(pin_number);
   \                     ??gcode_M226_2: (+1)
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD50B             BPL.N    ??gcode_M226_3
   \   0000004E   0x480F             LDR.N    R0,??gcode_M226_4
   \   00000050   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   00000054   0x480E             LDR.N    R0,??gcode_M226_4+0x4
   \   00000056   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000005A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000005E   0x4606             MOV      R6,R0
   \   00000060   0xE001             B.N      ??gcode_M226_3
  10228                    break;
  10229                }
  10230          
  10231                while (digitalRead(pin_number) != target) idle();
   \                     ??gcode_M226_5: (+1)
   \   00000062   0x.... 0x....      BL       _Z4idlev
   \                     ??gcode_M226_3: (+1)
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD408             BMI.N    ??gcode_M226_6
   \   0000006A   0x4808             LDR.N    R0,??gcode_M226_4
   \   0000006C   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   00000070   0x4807             LDR.N    R0,??gcode_M226_4+0x4
   \   00000072   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000076   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000007A   0xE004             B.N      ??gcode_M226_7
   \                     ??gcode_M226_6: (+1)
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x4180             SBCS     R0,R0,R0
   \   00000082   0x43C0             MVNS     R0,R0
   \   00000084   0x0FC0             LSRS     R0,R0,#+31
   \                     ??gcode_M226_7: (+1)
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD1EB             BNE.N    ??gcode_M226_5
  10232          
  10233              } // pin_state -1 0 1 && pin_number > -1
  10234            } // parser.seen('P')
  10235          }
   \                     ??gcode_M226_0: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??gcode_M226_4:
   \   0000008C   0x........         DC32     gArrayGpioPin
   \   00000090   0x........         DC32     gArrayGpioPort
  10236          
  10237          #if ENABLED(EXPERIMENTAL_I2CBUS)
  10238          
  10239            /**
  10240             * M260: Send data to a I2C slave device
  10241             *
  10242             * This is a PoC, the formating and arguments for the GCODE will
  10243             * change to be more compatible, the current proposal is:
  10244             *
  10245             *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
  10246             *
  10247             *  M260 B<byte-1 value in base 10>
  10248             *  M260 B<byte-2 value in base 10>
  10249             *  M260 B<byte-3 value in base 10>
  10250             *
  10251             *  M260 S1 ; Send the buffered data and reset the buffer
  10252             *  M260 R1 ; Reset the buffer without sending data
  10253             *
  10254             */
  10255            inline void gcode_M260() {
  10256              // Set the target address
  10257              if (parser.seen('A')) i2c.address(parser.value_byte());
  10258          
  10259              // Add a new byte to the buffer
  10260              if (parser.seen('B')) i2c.addbyte(parser.value_byte());
  10261          
  10262              // Flush the buffer to the bus
  10263              if (parser.seen('S')) i2c.send();
  10264          
  10265              // Reset and rewind the buffer
  10266              else if (parser.seen('R')) i2c.reset();
  10267            }
  10268          
  10269            /**
  10270             * M261: Request X bytes from I2C slave device
  10271             *
  10272             * Usage: M261 A<slave device address base 10> B<number of bytes>
  10273             */
  10274            inline void gcode_M261() {
  10275              if (parser.seen('A')) i2c.address(parser.value_byte());
  10276          
  10277              uint8_t bytes = parser.byteval('B', 1);
  10278          
  10279              if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
  10280                i2c.relay(bytes);
  10281              }
  10282              else {
  10283                SERIAL_ERROR_START();
  10284                SERIAL_ERRORLN("Bad i2c request");
  10285              }
  10286            }
  10287          
  10288          #endif // EXPERIMENTAL_I2CBUS
  10289          
  10290          //#if HAS_SERVOS
  10291          
  10292            /**
  10293             * M280: Get or set servo position. P<index> [S<angle>]
  10294             */

   \                                 In section .text, align 4
  10295            inline void gcode_M280() {
   \                     _Z10gcode_M280v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10296            	int mksAngle;
  10297            #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
  10298              if (!parser.seen('P')) return;
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD03C             BEQ.N    ??gcode_M280_0
  10299              const int servo_index = parser.value_int();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x0004             MOVS     R4,R0
  10300              if (WITHIN(servo_index, 0, 0/*NUM_SERVOS - 1*/)) {
   \   00000012   0xD12C             BNE.N    ??gcode_M280_1
  10301              if (parser.seen('S'))
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD01B             BEQ.N    ??gcode_M280_2
  10302              //MOVE_SERVO(servo_index, parser.value_int());
  10303              {
  10304               switch(parser.value_int())
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000022   0x280A             CMP      R0,#+10
   \   00000024   0xD006             BEQ.N    ??gcode_M280_3
   \   00000026   0x283C             CMP      R0,#+60
   \   00000028   0xD00D             BEQ.N    ??gcode_M280_4
   \   0000002A   0x285A             CMP      R0,#+90
   \   0000002C   0xD005             BEQ.N    ??gcode_M280_5
   \   0000002E   0x2878             CMP      R0,#+120
   \   00000030   0xD006             BEQ.N    ??gcode_M280_6
   \   00000032   0xE00B             B.N      ??gcode_M280_7
  10305              	{
  10306              	case 10:
  10307          			mksAngle = 700/2;
   \                     ??gcode_M280_3: (+1)
   \   00000034   0xF44F 0x70AF      MOV      R0,#+350
  10308          			break;
   \   00000038   0xE00A             B.N      ??gcode_M280_8
  10309          		case 90:
  10310          			mksAngle = 1500/2;
   \                     ??gcode_M280_5: (+1)
   \   0000003A   0xF240 0x20EE      MOVW     R0,#+750
  10311          			break;
   \   0000003E   0xE007             B.N      ??gcode_M280_8
  10312          			case 120:
  10313          			mksAngle = 1800/2;
   \                     ??gcode_M280_6: (+1)
   \   00000040   0xF44F 0x7061      MOV      R0,#+900
  10314          			break;
   \   00000044   0xE004             B.N      ??gcode_M280_8
  10315          		case 160:
  10316          			mksAngle = 2200/2;
  10317          			break;
  10318          		case 60:
  10319          			mksAngle = 1200/2;
   \                     ??gcode_M280_4: (+1)
   \   00000046   0xF44F 0x7016      MOV      R0,#+600
  10320          			break;
   \   0000004A   0xE001             B.N      ??gcode_M280_8
  10321          		default:
  10322          			mksAngle = 2200/2;
   \                     ??gcode_M280_7: (+1)
   \   0000004C   0xF240 0x404C      MOVW     R0,#+1100
  10323          			break;
  10324          			
  10325              	}
  10326          		MKS_TOUCH_TIM = mksAngle;
   \                     ??gcode_M280_8: (+1)
   \   00000050   0x490D             LDR.N    R1,??gcode_M280_9  ;; 0x40012c34
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0xBD10             POP      {R4,PC}
  10327              }        
  10328                else {
  10329                  SERIAL_ECHO_START();
   \                     ??gcode_M280_2: (+1)
   \   00000056   0x480D             LDR.N    R0,??gcode_M280_9+0x4
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10330                  SERIAL_ECHOPAIR(" Servo ", servo_index);
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x480C             LDR.N    R0,??gcode_M280_9+0x8
   \   00000060   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  10331          		SERIAL_ECHOLNPGM(" out of range");
   \   00000064   0x480B             LDR.N    R0,??gcode_M280_9+0xC
   \   00000066   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10332                  //SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
  10333                }
  10334              }
  10335              else {
  10336                SERIAL_ERROR_START();
   \                     ??gcode_M280_1: (+1)
   \   0000006E   0x480A             LDR.N    R0,??gcode_M280_9+0x10
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10337                SERIAL_ECHOPAIR("Servo ", servo_index);
   \   00000074   0x4621             MOV      R1,R4
   \   00000076   0x4809             LDR.N    R0,??gcode_M280_9+0x14
   \   00000078   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  10338                SERIAL_ECHOLNPGM(" out of range");
   \   0000007C   0x4805             LDR.N    R0,??gcode_M280_9+0xC
   \   0000007E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000082   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10339              }
  10340              #endif
  10341            }
   \                     ??gcode_M280_0: (+1)
   \   00000086   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M280_9:
   \   00000088   0x40012C34         DC32     0x40012c34
   \   0000008C   0x........         DC32     echomagic
   \   00000090   0x........         DC32     _ZZ10gcode_M280vEs
   \   00000094   0x........         DC32     _ZZ10gcode_M280vEs_0
   \   00000098   0x........         DC32     errormagic
   \   0000009C   0x........         DC32     _ZZ10gcode_M280vEs_1
  10342          
  10343          //#endif // HAS_SERVOS
  10344          
  10345          #if ENABLED(BABYSTEPPING)
  10346          
  10347            #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
  10348              FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
  10349                zprobe_zoffset += offs;
  10350                SERIAL_ECHO_START();
  10351                SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
  10352              }
  10353            #endif
  10354          
  10355            /**
  10356             * M290: Babystepping
  10357             */
  10358            inline void gcode_M290() {
  10359              #if ENABLED(BABYSTEP_XY)
  10360                for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
  10361                  if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
  10362                    const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
  10363                    thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
  10364                    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
  10365                      if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
  10366                    #endif
  10367                  }
  10368              #else
  10369                if (parser.seenval('Z') || parser.seenval('S')) {
  10370                  const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
  10371                  thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
  10372                  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
  10373                    if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
  10374                  #endif
  10375                }
  10376              #endif
  10377            }
  10378          
  10379          #endif // BABYSTEPPING
  10380          
  10381          #if HAS_BUZZER
  10382          
  10383            /**
  10384             * M300: Play beep sound S<frequency Hz> P<duration ms>
  10385             */
  10386            inline void gcode_M300() {
  10387              uint16_t const frequency = parser.ushortval('S', 260);
  10388              uint16_t duration = parser.ushortval('P', 1000);
  10389          
  10390              // Limits the tone duration to 0-5 seconds.
  10391              NOMORE(duration, 5000);
  10392          
  10393              BUZZ(duration, frequency);
  10394            }
  10395          
  10396          #endif // HAS_BUZZER
  10397          
  10398          #if 1//ENABLED(PIDTEMP)
  10399          
  10400            /**
  10401             * M301: Set PID parameters P I D (and optionally C, L)
  10402             *
  10403             *   P[float] Kp term
  10404             *   I[float] Ki term (unscaled)
  10405             *   D[float] Kd term (unscaled)
  10406             *
  10407             * With PID_EXTRUSION_SCALING:
  10408             *
  10409             *   C[float] Kc term
  10410             *   L[float] LPQ length
  10411             */

   \                                 In section .text, align 4
  10412            inline void gcode_M301() {
   \                     _Z10gcode_M301v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10413          
  10414              // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
  10415              // default behaviour (omitting E parameter) is to update for extruder 0 only
  10416              const uint8_t e = parser.byteval('E'); // extruder being updated
  10417          
  10418              if (e < HOTENDS) { // catch bad input value
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2045             MOVS     R0,#+69
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xDA53             BGE.N    ??gcode_M301_0
  10419                if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
   \   0000000E   0x2050             MOVS     R0,#+80
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??gcode_M301_1
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000001C   0x492D             LDR.N    R1,??gcode_M301_2
   \   0000001E   0x6008             STR      R0,[R1, #+0]
  10420                if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
   \                     ??gcode_M301_1: (+1)
   \   00000020   0x2049             MOVS     R0,#+73
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD00B             BEQ.N    ??gcode_M301_3
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000002E   0x.... 0x....      BL       __aeabi_f2d
   \   00000032   0x4A29             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   00000034   0x4B29             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   00000036   0x.... 0x....      BL       __aeabi_dmul
   \   0000003A   0x.... 0x....      BL       __aeabi_d2f
   \   0000003E   0x4928             LDR.N    R1,??gcode_M301_2+0xC
   \   00000040   0x6008             STR      R0,[R1, #+0]
  10421                if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
   \                     ??gcode_M301_3: (+1)
   \   00000042   0x4C28             LDR.N    R4,??gcode_M301_2+0x10
   \   00000044   0x2044             MOVS     R0,#+68
   \   00000046   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD00A             BEQ.N    ??gcode_M301_4
   \   0000004E   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000052   0x.... 0x....      BL       __aeabi_f2d
   \   00000056   0x4A20             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   00000058   0x4B20             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   0000005A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000005E   0x.... 0x....      BL       __aeabi_d2f
   \   00000062   0x6020             STR      R0,[R4, #+0]
  10422                #if ENABLED(PID_EXTRUSION_SCALING)
  10423                  if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
  10424                  if (parser.seen('L')) lpq_len = parser.value_float();
  10425                  NOMORE(lpq_len, LPQ_MAX_LEN);
  10426                #endif
  10427          
  10428                thermalManager.updatePID();
   \                     ??gcode_M301_4: (+1)
   \   00000064   0x.... 0x....      BL       _ZN11Temperature9updatePIDEv
  10429                SERIAL_ECHO_START();
   \   00000068   0x481F             LDR.N    R0,??gcode_M301_2+0x14
   \   0000006A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10430                #if ENABLED(PID_PARAMS_PER_HOTEND)
  10431                  SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
  10432                #endif // PID_PARAMS_PER_HOTEND
  10433                SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
   \   0000006E   0x4819             LDR.N    R0,??gcode_M301_2
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x481E             LDR.N    R0,??gcode_M301_2+0x18
   \   00000074   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10434                SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
   \   00000078   0x4819             LDR.N    R0,??gcode_M301_2+0xC
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x.... 0x....      BL       __aeabi_f2d
   \   00000080   0x4A15             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   00000082   0x4B16             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   00000084   0x.... 0x....      BL       __aeabi_ddiv
   \   00000088   0x4602             MOV      R2,R0
   \   0000008A   0x460B             MOV      R3,R1
   \   0000008C   0x4818             LDR.N    R0,??gcode_M301_2+0x1C
   \   0000008E   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
  10435                SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       __aeabi_f2d
   \   00000098   0x4A0F             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   0000009A   0x4B10             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   0000009C   0x.... 0x....      BL       __aeabi_dmul
   \   000000A0   0x4602             MOV      R2,R0
   \   000000A2   0x460B             MOV      R3,R1
   \   000000A4   0x4813             LDR.N    R0,??gcode_M301_2+0x20
   \   000000A6   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
  10436                #if ENABLED(PID_EXTRUSION_SCALING)
  10437                  //Kc does not have scaling applied above, or in resetting defaults
  10438                  SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
  10439                #endif
  10440                SERIAL_EOL();
   \   000000AA   0x210A             MOVS     R1,#+10
   \   000000AC   0x4812             LDR.N    R0,??gcode_M301_2+0x24
   \   000000AE   0xE8BD 0x4010      POP      {R4,LR}
   \   000000B2   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
  10441              }
  10442              else {
  10443                SERIAL_ERROR_START();
   \                     ??gcode_M301_0: (+1)
   \   000000B6   0x4811             LDR.N    R0,??gcode_M301_2+0x28
   \   000000B8   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10444                SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
   \   000000BC   0x4C0E             LDR.N    R4,??gcode_M301_2+0x24
   \   000000BE   0x4910             LDR.N    R1,??gcode_M301_2+0x2C
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000000C6   0x210A             MOVS     R1,#+10
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0xE8BD 0x4010      POP      {R4,LR}
   \   000000CE   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   000000D2   0xBF00             Nop      
   \                     ??gcode_M301_2:
   \   000000D4   0x........         DC32     _ZN11Temperature2KpE
   \   000000D8   0x88E368F1         DC32     0x88e368f1
   \   000000DC   0x3FC4F8B5         DC32     0x3fc4f8b5
   \   000000E0   0x........         DC32     _ZN11Temperature2KiE
   \   000000E4   0x........         DC32     _ZN11Temperature2KdE
   \   000000E8   0x........         DC32     echomagic
   \   000000EC   0x........         DC32     _ZZ10gcode_M301vEs
   \   000000F0   0x........         DC32     _ZZ10gcode_M301vEs_0
   \   000000F4   0x........         DC32     _ZZ10gcode_M301vEs_1
   \   000000F8   0x........         DC32     Serial3
   \   000000FC   0x........         DC32     errormagic
   \   00000100   0x........         DC32     _ZZ10gcode_M301vEs_2
  10445              }
  10446            }
  10447          
  10448          #endif // PIDTEMP
  10449          
  10450          #if 1//ENABLED(PIDTEMPBED)
  10451          

   \                                 In section .text, align 4
  10452            inline void gcode_M304() {
   \                     _Z10gcode_M304v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10453              if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M304_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000010   0x4925             LDR.N    R1,??gcode_M304_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
  10454              if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
   \                     ??gcode_M304_0: (+1)
   \   00000014   0x2049             MOVS     R0,#+73
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD00B             BEQ.N    ??gcode_M304_2
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000022   0x.... 0x....      BL       __aeabi_f2d
   \   00000026   0x4A21             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   00000028   0x4B21             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   0000002A   0x.... 0x....      BL       __aeabi_dmul
   \   0000002E   0x.... 0x....      BL       __aeabi_d2f
   \   00000032   0x4920             LDR.N    R1,??gcode_M304_1+0xC
   \   00000034   0x6008             STR      R0,[R1, #+0]
  10455              if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
   \                     ??gcode_M304_2: (+1)
   \   00000036   0x4C20             LDR.N    R4,??gcode_M304_1+0x10
   \   00000038   0x2044             MOVS     R0,#+68
   \   0000003A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00A             BEQ.N    ??gcode_M304_3
   \   00000042   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0x4A18             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   0000004C   0x4B18             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   0000004E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000052   0x.... 0x....      BL       __aeabi_d2f
   \   00000056   0x6020             STR      R0,[R4, #+0]
  10456          
  10457              SERIAL_ECHO_START();
   \                     ??gcode_M304_3: (+1)
   \   00000058   0x4818             LDR.N    R0,??gcode_M304_1+0x14
   \   0000005A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10458              SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
   \   0000005E   0x4812             LDR.N    R0,??gcode_M304_1
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x4817             LDR.N    R0,??gcode_M304_1+0x18
   \   00000064   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10459              SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
   \   00000068   0x4812             LDR.N    R0,??gcode_M304_1+0xC
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       __aeabi_f2d
   \   00000070   0x4A0E             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   00000072   0x4B0F             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   00000074   0x.... 0x....      BL       __aeabi_ddiv
   \   00000078   0x4602             MOV      R2,R0
   \   0000007A   0x460B             MOV      R3,R1
   \   0000007C   0x4811             LDR.N    R0,??gcode_M304_1+0x1C
   \   0000007E   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
  10460              SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x.... 0x....      BL       __aeabi_f2d
   \   00000088   0x4A08             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   0000008A   0x4B09             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   0000008C   0x.... 0x....      BL       __aeabi_dmul
   \   00000090   0x4602             MOV      R2,R0
   \   00000092   0x460B             MOV      R3,R1
   \   00000094   0x480C             LDR.N    R0,??gcode_M304_1+0x20
   \   00000096   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   \   0000009A   0x210A             MOVS     R1,#+10
   \   0000009C   0x480B             LDR.N    R0,??gcode_M304_1+0x24
   \   0000009E   0xE8BD 0x4010      POP      {R4,LR}
   \   000000A2   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   000000A6   0xBF00             Nop      
   \                     ??gcode_M304_1:
   \   000000A8   0x........         DC32     _ZN11Temperature5bedKpE
   \   000000AC   0x88E368F1         DC32     0x88e368f1
   \   000000B0   0x3FC4F8B5         DC32     0x3fc4f8b5
   \   000000B4   0x........         DC32     _ZN11Temperature5bedKiE
   \   000000B8   0x........         DC32     _ZN11Temperature5bedKdE
   \   000000BC   0x........         DC32     echomagic
   \   000000C0   0x........         DC32     _ZZ10gcode_M304vEs
   \   000000C4   0x........         DC32     _ZZ10gcode_M304vEs_0
   \   000000C8   0x........         DC32     _ZZ10gcode_M304vEs_1
   \   000000CC   0x........         DC32     Serial3
  10461            }
  10462          
  10463          #endif // PIDTEMPBED
  10464          
  10465          #if defined(CHDK) || HAS_PHOTOGRAPH
  10466          
  10467            /**
  10468             * M240: Trigger a camera by emulating a Canon RC-1
  10469             *       See http://www.doc-diy.net/photo/rc-1_hacked/
  10470             */
  10471            inline void gcode_M240() {
  10472              #ifdef CHDK
  10473          
  10474                OUT_WRITE(CHDK, HIGH);
  10475                chdkHigh = millis();
  10476                chdkActive = true;
  10477          
  10478              #elif HAS_PHOTOGRAPH
  10479          
  10480                const uint8_t NUM_PULSES = 16;
  10481                const float PULSE_LENGTH = 0.01524;
  10482                for (int i = 0; i < NUM_PULSES; i++) {
  10483                  WRITE(PHOTOGRAPH_PIN, HIGH);
  10484                  _delay_ms(PULSE_LENGTH);
  10485                  WRITE(PHOTOGRAPH_PIN, LOW);
  10486                  _delay_ms(PULSE_LENGTH);
  10487                }
  10488                delay(7.33);
  10489                for (int i = 0; i < NUM_PULSES; i++) {
  10490                  WRITE(PHOTOGRAPH_PIN, HIGH);
  10491                  _delay_ms(PULSE_LENGTH);
  10492                  WRITE(PHOTOGRAPH_PIN, LOW);
  10493                  _delay_ms(PULSE_LENGTH);
  10494                }
  10495          
  10496              #endif // !CHDK && HAS_PHOTOGRAPH
  10497            }
  10498          
  10499          #endif // CHDK || PHOTOGRAPH_PIN
  10500          
  10501          #if HAS_LCD_CONTRAST
  10502          
  10503            /**
  10504             * M250: Read and optionally set the LCD contrast
  10505             */
  10506            inline void gcode_M250() {
  10507              if (parser.seen('C')) set_lcd_contrast(parser.value_int());
  10508              SERIAL_PROTOCOLPGM("lcd contrast value: ");
  10509              SERIAL_PROTOCOL(lcd_contrast);
  10510              SERIAL_EOL();
  10511            }
  10512          
  10513          #endif // HAS_LCD_CONTRAST
  10514          
  10515          #if ENABLED(PREVENT_COLD_EXTRUSION)
  10516          
  10517            /**
  10518             * M302: Allow cold extrudes, or set the minimum extrude temperature
  10519             *
  10520             *       S<temperature> sets the minimum extrude temperature
  10521             *       P<bool> enables (1) or disables (0) cold extrusion
  10522             *
  10523             *  Examples:
  10524             *
  10525             *       M302         ; report current cold extrusion state
  10526             *       M302 P0      ; enable cold extrusion checking
  10527             *       M302 P1      ; disables cold extrusion checking
  10528             *       M302 S0      ; always allow extrusion (disables checking)
  10529             *       M302 S170    ; only allow extrusion above 170
  10530             *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
  10531             */

   \                                 In section .text, align 4
  10532            inline void gcode_M302() {
   \                     _Z10gcode_M302v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  10533              const bool seen_S = parser.seen('S');
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x0004             MOVS     R4,R0
  10534              if (seen_S) {
   \   0000000A   0xD00C             BEQ.N    ??gcode_M302_0
  10535                thermalManager.extrude_min_temp = parser.value_celsius();
                                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000000C   0x4D1C             LDR.N    R5,??gcode_M302_1
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000012   0x.... 0x....      BL       __aeabi_f2iz
   \   00000016   0x8028             STRH     R0,[R5, #+0]
  10536                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
   \   00000018   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   0000001C   0x1E41             SUBS     R1,R0,#+1
   \   0000001E   0x4189             SBCS     R1,R1,R1
   \   00000020   0x0FC9             LSRS     R1,R1,#+31
   \   00000022   0x4818             LDR.N    R0,??gcode_M302_1+0x4
   \   00000024   0x7001             STRB     R1,[R0, #+0]
  10537              }
  10538          
  10539              if (parser.seen('P'))
   \                     ??gcode_M302_0: (+1)
   \   00000026   0x2050             MOVS     R0,#+80
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00C             BEQ.N    ??gcode_M302_2
  10540                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
   \   00000030   0x4C14             LDR.N    R4,??gcode_M302_1+0x4
   \   00000032   0x4813             LDR.N    R0,??gcode_M302_1
   \   00000034   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD003             BEQ.N    ??gcode_M302_3
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000040   0x7020             STRB     R0,[R4, #+0]
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??gcode_M302_3: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7020             STRB     R0,[R4, #+0]
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}
  10541              else if (!seen_S) {
   \                     ??gcode_M302_2: (+1)
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD117             BNE.N    ??gcode_M302_4
  10542                // Report current state
  10543                SERIAL_ECHO_START();
   \   0000004E   0x480E             LDR.N    R0,??gcode_M302_1+0x8
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10544                SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
   \   00000054   0x480B             LDR.N    R0,??gcode_M302_1+0x4
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??gcode_M302_5
   \   0000005C   0x490B             LDR.N    R1,??gcode_M302_1+0xC
   \   0000005E   0xE000             B.N      ??gcode_M302_6
   \                     ??gcode_M302_5: (+1)
   \   00000060   0x490B             LDR.N    R1,??gcode_M302_1+0x10
   \                     ??gcode_M302_6: (+1)
   \   00000062   0x480C             LDR.N    R0,??gcode_M302_1+0x14
   \   00000064   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
  10545                SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
   \   00000068   0x4805             LDR.N    R0,??gcode_M302_1
   \   0000006A   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000006E   0x480A             LDR.N    R0,??gcode_M302_1+0x18
   \   00000070   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  10546                SERIAL_ECHOLNPGM("C)");
   \   00000074   0x4809             LDR.N    R0,??gcode_M302_1+0x1C
   \   00000076   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000007A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10547              }
  10548            }
   \                     ??gcode_M302_4: (+1)
   \   0000007E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M302_1:
   \   00000080   0x........         DC32     _ZN11Temperature16extrude_min_tempE
   \   00000084   0x........         DC32     _ZN11Temperature18allow_cold_extrudeE
   \   00000088   0x........         DC32     echomagic
   \   0000008C   0x........         DC32     _ZZ10gcode_M302vEs_0
   \   00000090   0x........         DC32     _ZZ10gcode_M302vEs_1
   \   00000094   0x........         DC32     _ZZ10gcode_M302vEs
   \   00000098   0x........         DC32     _ZZ10gcode_M302vEs_2
   \   0000009C   0x........         DC32     _ZZ10gcode_M302vEs_3
  10549          
  10550          #endif // PREVENT_COLD_EXTRUSION
  10551          
  10552          /**
  10553           * M303: PID relay autotune
  10554           *
  10555           *       S<temperature> sets the target temperature. (default 150C)
  10556           *       E<extruder> (-1 for the bed) (default 0)
  10557           *       C<cycles>
  10558           *       U<bool> with a non-zero value will apply the result to current settings
  10559           */

   \                                 In section .text, align 4
  10560          inline void gcode_M303() {
   \                     _Z10gcode_M303v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  10561            //#if HAS_PID_HEATING
  10562            if(HAS_PID_HEATING) {
   \   00000002   0x4820             LDR.N    R0,??gcode_M303_0
   \   00000004   0xF890 0x1034      LDRB     R1,[R0, #+52]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD103             BNE.N    ??gcode_M303_1
   \   0000000C   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD02E             BEQ.N    ??gcode_M303_2
  10563              const int e = parser.intval('E'), c = parser.intval('C', 5);
   \                     ??gcode_M303_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2045             MOVS     R0,#+69
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x4604             MOV      R4,R0
   \   0000001E   0x2105             MOVS     R1,#+5
   \   00000020   0x2043             MOVS     R0,#+67
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   00000026   0x4605             MOV      R5,R0
  10564              const bool u = parser.boolval('U');
   \   00000028   0x2055             MOVS     R0,#+85
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   0000002E   0x4606             MOV      R6,R0
  10565          
  10566              int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
                                    ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD501             BPL.N    ??gcode_M303_3
   \   00000034   0x2046             MOVS     R0,#+70
   \   00000036   0xE000             B.N      ??gcode_M303_4
   \                     ??gcode_M303_3: (+1)
   \   00000038   0x2096             MOVS     R0,#+150
   \                     ??gcode_M303_4: (+1)
   \   0000003A   0x.... 0x....      BL       __aeabi_i2f
   \   0000003E   0x4601             MOV      R1,R0
   \   00000040   0x2053             MOVS     R0,#+83
   \   00000042   0x.... 0x....      BL       _ZN11GCodeParser10celsiusvalEcf
   \   00000046   0x.... 0x....      BL       __aeabi_f2iz
  10567          
  10568              if (WITHIN(e, 0, HOTENDS - 1))
   \   0000004A   0x2C02             CMP      R4,#+2
   \   0000004C   0xD201             BCS.N    ??gcode_M303_5
  10569                target_extruder = e;
   \   0000004E   0x490E             LDR.N    R1,??gcode_M303_0+0x4
   \   00000050   0x714C             STRB     R4,[R1, #+5]
  10570          
  10571              #if DISABLED(BUSY_WHILE_HEATING)
  10572                KEEPALIVE_STATE(NOT_BUSY);
  10573              #endif
  10574          
  10575              thermalManager.PID_autotune(temp, e, c, u);
   \                     ??gcode_M303_5: (+1)
   \   00000052   0x462A             MOV      R2,R5
   \   00000054   0xB252             SXTB     R2,R2
   \   00000056   0x4621             MOV      R1,R4
   \   00000058   0xB249             SXTB     R1,R1
   \   0000005A   0x460C             MOV      R4,R1
   \   0000005C   0x4615             MOV      R5,R2
   \   0000005E   0xB200             SXTH     R0,R0
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   \   00000064   0x4633             MOV      R3,R6
   \   00000066   0x462A             MOV      R2,R5
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006E   0x.... 0x....      B.W      _ZN11Temperature12PID_autotuneEfaab
  10576          
  10577              #if DISABLED(BUSY_WHILE_HEATING)
  10578                KEEPALIVE_STATE(IN_HANDLER);
  10579              #endif
  10580            }
  10581            //#else
  10582            else
  10583            {
  10584              SERIAL_ERROR_START();
   \                     ??gcode_M303_2: (+1)
   \   00000072   0x4806             LDR.N    R0,??gcode_M303_0+0x8
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10585              SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
   \   00000078   0x4805             LDR.N    R0,??gcode_M303_0+0xC
   \   0000007A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \   00000082   0xBF00             Nop      
   \                     ??gcode_M303_0:
   \   00000084   0x........         DC32     mksCfg
   \   00000088   0x........         DC32     mks_heating_busy
   \   0000008C   0x........         DC32     errormagic
   \   00000090   0x........         DC32     _ZZ10gcode_M303vEs
  10586            }
  10587            //#endif
  10588          }
  10589          
  10590          #if 1//ENABLED(MORGAN_SCARA)
  10591          

   \                                 In section .text, align 2, keep-with-next
  10592            bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
   \                     _Z17SCARA_move_to_calhh: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
  10593              if (IsRunning()) {
   \   00000008   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD019             BEQ.N    ??SCARA_move_to_cal_0
  10594                forward_kinematics_SCARA(delta_a, delta_b);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0xA801             ADD      R0,SP,#+4
   \   00000024   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
  10595                destination[X_AXIS] = cartes[X_AXIS];
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable158_1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable158
   \   00000030   0x6C8A             LDR      R2,[R1, #+72]
   \   00000032   0x6182             STR      R2,[R0, #+24]
  10596                destination[Y_AXIS] = cartes[Y_AXIS];
   \   00000034   0x6CC9             LDR      R1,[R1, #+76]
   \   00000036   0x61C1             STR      R1,[R0, #+28]
  10597                destination[Z_AXIS] = current_position[Z_AXIS];
   \   00000038   0x6901             LDR      R1,[R0, #+16]
   \   0000003A   0x6201             STR      R1,[R0, #+32]
  10598                prepare_move_to_destination();
   \   0000003C   0x.... 0x....      BL       _Z27prepare_move_to_destinationv
  10599                return true;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xBD3E             POP      {R1-R5,PC}
  10600              }
  10601              return false;
   \                     ??SCARA_move_to_cal_0: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD3E             POP      {R1-R5,PC}       ;; return
  10602            }
  10603          
  10604            /**
  10605             * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
  10606             */

   \                                 In section .text, align 4
  10607            inline bool gcode_M360() {
   \                     _Z10gcode_M360v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10608              SERIAL_ECHOLNPGM(" Cal: Theta 0");
   \   00000002   0x4804             LDR.N    R0,??gcode_M360_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10609              return SCARA_move_to_cal(0, 120);
   \   00000008   0x2178             MOVS     R1,#+120
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M360_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M360vEs
  10610            }
  10611          
  10612            /**
  10613             * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
  10614             */

   \                                 In section .text, align 4
  10615            inline bool gcode_M361() {
   \                     _Z10gcode_M361v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10616              SERIAL_ECHOLNPGM(" Cal: Theta 90");
   \   00000002   0x4804             LDR.N    R0,??gcode_M361_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10617              return SCARA_move_to_cal(90, 130);
   \   00000008   0x2182             MOVS     R1,#+130
   \   0000000A   0x205A             MOVS     R0,#+90
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M361_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M361vEs
  10618            }
  10619          
  10620            /**
  10621             * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
  10622             */

   \                                 In section .text, align 4
  10623            inline bool gcode_M362() {
   \                     _Z10gcode_M362v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10624              SERIAL_ECHOLNPGM(" Cal: Psi 0");
   \   00000002   0x4804             LDR.N    R0,??gcode_M362_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10625              return SCARA_move_to_cal(60, 180);
   \   00000008   0x21B4             MOVS     R1,#+180
   \   0000000A   0x203C             MOVS     R0,#+60
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M362_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M362vEs
  10626            }
  10627          
  10628            /**
  10629             * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
  10630             */

   \                                 In section .text, align 4
  10631            inline bool gcode_M363() {
   \                     _Z10gcode_M363v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10632              SERIAL_ECHOLNPGM(" Cal: Psi 90");
   \   00000002   0x4804             LDR.N    R0,??gcode_M363_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10633              return SCARA_move_to_cal(50, 90);
   \   00000008   0x215A             MOVS     R1,#+90
   \   0000000A   0x2032             MOVS     R0,#+50
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M363_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M363vEs
  10634            }
  10635          
  10636            /**
  10637             * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
  10638             */

   \                                 In section .text, align 4
  10639            inline bool gcode_M364() {
   \                     _Z10gcode_M364v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10640              SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
   \   00000002   0x4804             LDR.N    R0,??gcode_M364_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10641              return SCARA_move_to_cal(45, 135);
   \   00000008   0x2187             MOVS     R1,#+135
   \   0000000A   0x202D             MOVS     R0,#+45
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M364_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M364vEs
  10642            }
  10643          
  10644          #endif // SCARA
  10645          
  10646          #if ENABLED(EXT_SOLENOID)
  10647          
  10648            void enable_solenoid(const uint8_t num) {
  10649              switch (num) {
  10650                case 0:
  10651                  OUT_WRITE(SOL0_PIN, HIGH);
  10652                  break;
  10653                  #if HAS_SOLENOID_1 && EXTRUDERS > 1
  10654                    case 1:
  10655                      OUT_WRITE(SOL1_PIN, HIGH);
  10656                      break;
  10657                  #endif
  10658                  #if HAS_SOLENOID_2 && EXTRUDERS > 2
  10659                    case 2:
  10660                      OUT_WRITE(SOL2_PIN, HIGH);
  10661                      break;
  10662                  #endif
  10663                  #if HAS_SOLENOID_3 && EXTRUDERS > 3
  10664                    case 3:
  10665                      OUT_WRITE(SOL3_PIN, HIGH);
  10666                      break;
  10667                  #endif
  10668                  #if HAS_SOLENOID_4 && EXTRUDERS > 4
  10669                    case 4:
  10670                      OUT_WRITE(SOL4_PIN, HIGH);
  10671                      break;
  10672                  #endif
  10673                default:
  10674                  SERIAL_ECHO_START();
  10675                  SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
  10676                  break;
  10677              }
  10678            }
  10679          
  10680            void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
  10681          
  10682            void disable_all_solenoids() {
  10683              OUT_WRITE(SOL0_PIN, LOW);
  10684              #if HAS_SOLENOID_1 && EXTRUDERS > 1
  10685                OUT_WRITE(SOL1_PIN, LOW);
  10686              #endif
  10687              #if HAS_SOLENOID_2 && EXTRUDERS > 2
  10688                OUT_WRITE(SOL2_PIN, LOW);
  10689              #endif
  10690              #if HAS_SOLENOID_3 && EXTRUDERS > 3
  10691                OUT_WRITE(SOL3_PIN, LOW);
  10692              #endif
  10693              #if HAS_SOLENOID_4 && EXTRUDERS > 4
  10694                OUT_WRITE(SOL4_PIN, LOW);
  10695              #endif
  10696            }
  10697          
  10698            /**
  10699             * M380: Enable solenoid on the active extruder
  10700             */
  10701            inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
  10702          
  10703            /**
  10704             * M381: Disable all solenoids
  10705             */
  10706            inline void gcode_M381() { disable_all_solenoids(); }
  10707          
  10708          #endif // EXT_SOLENOID
  10709          
  10710          /**
  10711           * M400: Finish all moves
  10712           */

   \                                 In section .text, align 2
  10713          inline void gcode_M400() { stepper.synchronize(); }
   \                     _Z10gcode_M400v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN7Stepper11synchronizeEv
  10714          
  10715          #if HAS_BED_PROBE
  10716          
  10717            /**
  10718             * M401: Engage Z Servo endstop if available
  10719             */

   \                                 In section .text, align 2
  10720            inline void gcode_M401() { DEPLOY_PROBE(); }
   \                     _Z10gcode_M401v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _Z18set_probe_deployedb
  10721          
  10722            /**
  10723             * M402: Retract Z Servo endstop if enabled
  10724             */

   \                                 In section .text, align 2
  10725            inline void gcode_M402() { STOW_PROBE(); }
   \                     _Z10gcode_M402v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      _Z18set_probe_deployedb
  10726          
  10727          #endif // HAS_BED_PROBE
  10728          
  10729          #if ENABLED(FILAMENT_WIDTH_SENSOR)
  10730          
  10731            /**
  10732             * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
  10733             */
  10734            inline void gcode_M404() {
  10735              if (parser.seen('W')) {
  10736                filament_width_nominal = parser.value_linear_units();
  10737                planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
  10738              }
  10739              else {
  10740                SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
  10741                SERIAL_PROTOCOLLN(filament_width_nominal);
  10742              }
  10743            }
  10744          
  10745            /**
  10746             * M405: Turn on filament sensor for control
  10747             */
  10748            inline void gcode_M405() {
  10749              // This is technically a linear measurement, but since it's quantized to centimeters and is a different
  10750              // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
  10751              if (parser.seen('D')) {
  10752                meas_delay_cm = parser.value_byte();
  10753                NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
  10754              }
  10755          
  10756              if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
  10757                const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
  10758          
  10759                for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
  10760                  measurement_delay[i] = temp_ratio;
  10761          
  10762                filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
  10763              }
  10764          
  10765              filament_sensor = true;
  10766            }
  10767          
  10768            /**
  10769             * M406: Turn off filament sensor for control
  10770             */
  10771            inline void gcode_M406() {
  10772              filament_sensor = false;
  10773              planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
  10774            }
  10775          
  10776            /**
  10777             * M407: Get measured filament diameter on serial output
  10778             */
  10779            inline void gcode_M407() {
  10780              SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
  10781              SERIAL_PROTOCOLLN(filament_width_meas);
  10782            }
  10783          
  10784          #endif // FILAMENT_WIDTH_SENSOR
  10785          

   \                                 In section .text, align 2, keep-with-next
  10786          void quickstop_stepper() {
   \                     _Z17quickstop_stepperv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10787            stepper.quick_stop();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper10quick_stopEv
  10788            stepper.synchronize();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10789            set_current_from_steppers_for_axis(ALL_AXES);
   \   0000000A   0x2064             MOVS     R0,#+100
   \   0000000C   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
  10790            SYNC_PLAN_POSITION_KINEMATIC();
   \   00000010   0xE8BD 0x4001      POP      {R0,LR}
   \   00000014   0x.... 0x....      B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
  10791          }
  10792          
  10793          #if 1//HAS_LEVELING
  10794            /**
  10795             * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
  10796             *
  10797             *   S[bool]   Turns leveling on or off
  10798             *   Z[height] Sets the Z fade height (0 or none to disable)
  10799             *   V[bool]   Verbose - Print the leveling grid
  10800             *
  10801             * With AUTO_BED_LEVELING_UBL only:
  10802             *
  10803             *   L[index]  Load UBL mesh from index (0 is default)
  10804             */

   \                                 In section .text, align 4
  10805            inline void gcode_M420() {
   \                     _Z10gcode_M420v: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
  10806          
  10807              const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   \   00000004   0x4C71             LDR.N    R4,??gcode_M420_0
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x9003             STR      R0,[SP, #+12]
  10808          
  10809              //#if ENABLED(AUTO_BED_LEVELING_UBL)
  10810          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	
   \   00000012   0x4E6F             LDR.N    R6,??gcode_M420_0+0x4
   \   00000014   0xF896 0x0040      LDRB     R0,[R6, #+64]
   \   00000018   0x2810             CMP      R0,#+16
   \   0000001A   0xD153             BNE.N    ??gcode_M420_1
  10811          	{
  10812                // L to load a mesh from the EEPROM
  10813                if (parser.seen('L')) {
   \   0000001C   0x204C             MOVS     R0,#+76
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD02A             BEQ.N    ??gcode_M420_2
  10814          
  10815                  #if ENABLED(EEPROM_SETTINGS)
  10816                    const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
   \   00000026   0x.... 0x....      BL       _ZN11GCodeParser9has_valueEv
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD003             BEQ.N    ??gcode_M420_3
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000032   0x4605             MOV      R5,R0
   \   00000034   0xE002             B.N      ??gcode_M420_4
   \                     ??gcode_M420_3: (+1)
   \   00000036   0x4867             LDR.N    R0,??gcode_M420_0+0x8
   \   00000038   0xF990 0x5000      LDRSB    R5,[R0, #+0]
  10817                    const int16_t a = settings.calc_num_meshes();
   \                     ??gcode_M420_4: (+1)
   \   0000003C   0x.... 0x....      BL       _ZN14MarlinSettings15calc_num_meshesEv
   \   00000040   0xB200             SXTH     R0,R0
  10818          
  10819                    if (!a) {
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD103             BNE.N    ??gcode_M420_5
  10820                      SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
   \   00000046   0x4864             LDR.N    R0,??gcode_M420_0+0xC
   \   00000048   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10821                      return;
   \   0000004C   0xE0BB             B.N      ??gcode_M420_6
  10822                    }
  10823          
  10824                    if (!WITHIN(storage_slot, 0, a - 1)) {
   \                     ??gcode_M420_5: (+1)
   \   0000004E   0x1E47             SUBS     R7,R0,#+1
   \   00000050   0xB26D             SXTB     R5,R5
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xD401             BMI.N    ??gcode_M420_7
   \   00000056   0x4287             CMP      R7,R0
   \   00000058   0xDA0B             BGE.N    ??gcode_M420_8
  10825                      SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
   \                     ??gcode_M420_7: (+1)
   \   0000005A   0x4860             LDR.N    R0,??gcode_M420_0+0x10
   \   0000005C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10826                      SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
   \   00000060   0x4639             MOV      R1,R7
   \   00000062   0x485F             LDR.N    R0,??gcode_M420_0+0x14
   \   00000064   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000068   0x210A             MOVS     R1,#+10
   \   0000006A   0x485E             LDR.N    R0,??gcode_M420_0+0x18
   \   0000006C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10827                      return;
   \   00000070   0xE0A9             B.N      ??gcode_M420_6
  10828                    }
  10829          
  10830                    settings.load_mesh(storage_slot);
   \                     ??gcode_M420_8: (+1)
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x.... 0x....      BL       _ZN14MarlinSettings9load_meshEaPv
  10831                    ubl.storage_slot = storage_slot;
   \   00000078   0x4856             LDR.N    R0,??gcode_M420_0+0x8
   \   0000007A   0x7005             STRB     R5,[R0, #+0]
  10832          
  10833                  #else
  10834          
  10835                    SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
  10836                    return;
  10837          
  10838                  #endif
  10839                }
  10840          
  10841                // L to load a mesh from the EEPROM
  10842                if (parser.seen('L') || parser.seen('V')) {
   \                     ??gcode_M420_2: (+1)
   \   0000007C   0x204C             MOVS     R0,#+76
   \   0000007E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD104             BNE.N    ??gcode_M420_9
   \   00000086   0x2056             MOVS     R0,#+86
   \   00000088   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD019             BEQ.N    ??gcode_M420_1
  10843                  ubl.display_map(0);  // Currently only supports one map type
   \                     ??gcode_M420_9: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x.... 0x....      BL       _ZN20unified_bed_leveling11display_mapEi
  10844                  SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
   \   00000096   0xF104 0x0084      ADD      R0,R4,#+132
   \   0000009A   0x.... 0x....      BL       _ZN20unified_bed_leveling13mesh_is_validEv
   \   0000009E   0x4601             MOV      R1,R0
   \   000000A0   0x4851             LDR.N    R0,??gcode_M420_0+0x1C
   \   000000A2   0x.... 0x....      BL       _Z17serial_echopair_PPKcb
   \   000000A6   0x4D4F             LDR.N    R5,??gcode_M420_0+0x18
   \   000000A8   0x210A             MOVS     R1,#+10
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10845                  SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
   \   000000B0   0x4848             LDR.N    R0,??gcode_M420_0+0x8
   \   000000B2   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   000000B6   0x484D             LDR.N    R0,??gcode_M420_0+0x20
   \   000000B8   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   000000BC   0x210A             MOVS     R1,#+10
   \   000000BE   0x4628             MOV      R0,R5
   \   000000C0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10846                }
  10847          	}
  10848              //#endif // AUTO_BED_LEVELING_UBL
  10849          
  10850              // V to print the matrix or mesh
  10851              if (parser.seen('V')) {
   \                     ??gcode_M420_1: (+1)
   \   000000C4   0x2056             MOVS     R0,#+86
   \   000000C6   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD019             BEQ.N    ??gcode_M420_10
  10852                //#if ABL_PLANAR
  10853                if(BED_LEVELING_METHOD&ABL_PLANAR)
   \   000000CE   0xF896 0x5040      LDRB     R5,[R6, #+64]
   \   000000D2   0x2006             MOVS     R0,#+6
   \   000000D4   0x4205             TST      R5,R0
   \   000000D6   0xD004             BEQ.N    ??gcode_M420_11
  10854                  planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
   \   000000D8   0x4945             LDR.N    R1,??gcode_M420_0+0x24
   \   000000DA   0x4846             LDR.N    R0,??gcode_M420_0+0x28
   \   000000DC   0x.... 0x....      BL       _ZN10matrix_3x35debugEPKc
   \   000000E0   0xE00F             B.N      ??gcode_M420_10
  10855          	  else
  10856          	  {
  10857                //#else
  10858                  if (leveling_is_valid()) {
   \                     ??gcode_M420_11: (+1)
   \   000000E2   0x.... 0x....      BL       _Z17leveling_is_validv
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD00B             BEQ.N    ??gcode_M420_10
  10859                    //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
  10860                    if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \   000000EA   0x2D08             CMP      R5,#+8
   \   000000EC   0xD102             BNE.N    ??gcode_M420_12
  10861                    {
  10862                      print_bilinear_leveling_grid();
   \   000000EE   0x.... 0x....      BL       _Z28print_bilinear_leveling_gridv
   \   000000F2   0xE006             B.N      ??gcode_M420_10
  10863                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  10864                        print_bilinear_leveling_grid_virt();
  10865                      #endif
  10866                    }
  10867                   //#elif ENABLED(MESH_BED_LEVELING)
  10868                   else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??gcode_M420_12: (+1)
   \   000000F4   0x2D20             CMP      R5,#+32
   \   000000F6   0xD104             BNE.N    ??gcode_M420_10
  10869                   {
  10870                      SERIAL_ECHOLNPGM("Mesh Bed Level data:");
   \   000000F8   0x483F             LDR.N    R0,??gcode_M420_0+0x2C
   \   000000FA   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10871                      mbl_mesh_report();
   \   000000FE   0x.... 0x....      BL       _Z15mbl_mesh_reportv
  10872                   }
  10873                   // #endif
  10874                  }
  10875          	  }
  10876                //#endif
  10877              }
  10878          
  10879              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  10880          	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
   \                     ??gcode_M420_10: (+1)
   \   00000102   0xF9B6 0x0058      LDRSH    R0,[R6, #+88]
   \   00000106   0x2802             CMP      R0,#+2
   \   00000108   0xD00D             BEQ.N    ??gcode_M420_13
   \   0000010A   0xF896 0x0040      LDRB     R0,[R6, #+64]
   \   0000010E   0x06C0             LSLS     R0,R0,#+27
   \   00000110   0xD509             BPL.N    ??gcode_M420_13
  10881          	{
  10882                if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
   \   00000112   0x205A             MOVS     R0,#+90
   \   00000114   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD004             BEQ.N    ??gcode_M420_13
   \   0000011C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x.... 0x....      BL       _Z17set_z_fade_heightfb
  10883          	}
  10884              #endif
  10885          
  10886              bool to_enable = false;
   \                     ??gcode_M420_13: (+1)
   \   00000126   0x2500             MOVS     R5,#+0
  10887              if (parser.seen('S')) {
   \   00000128   0x2053             MOVS     R0,#+83
   \   0000012A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD004             BEQ.N    ??gcode_M420_14
  10888                to_enable = parser.value_bool();
   \   00000132   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000136   0x4605             MOV      R5,R0
  10889                set_bed_leveling_enabled(to_enable);
   \   00000138   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
  10890              }
  10891          
  10892              const bool new_status = planner.leveling_active;
   \                     ??gcode_M420_14: (+1)
   \   0000013C   0x482F             LDR.N    R0,??gcode_M420_0+0x30
   \   0000013E   0x7806             LDRB     R6,[R0, #+0]
  10893          
  10894              if (to_enable && !new_status) {
   \   00000140   0xF086 0x0001      EOR      R0,R6,#0x1
   \   00000144   0x4629             MOV      R1,R5
   \   00000146   0x4201             TST      R1,R0
   \   00000148   0xD005             BEQ.N    ??gcode_M420_15
  10895                SERIAL_ERROR_START();
   \   0000014A   0x482D             LDR.N    R0,??gcode_M420_0+0x34
   \   0000014C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10896                SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
   \   00000150   0x482C             LDR.N    R0,??gcode_M420_0+0x38
   \   00000152   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10897              }
  10898          
  10899              SERIAL_ECHO_START();
   \                     ??gcode_M420_15: (+1)
   \   00000156   0x4F2C             LDR.N    R7,??gcode_M420_0+0x3C
   \   00000158   0x4638             MOV      R0,R7
   \   0000015A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10900              SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
   \   0000015E   0x2E00             CMP      R6,#+0
   \   00000160   0xD001             BEQ.N    ??gcode_M420_16
   \   00000162   0x492A             LDR.N    R1,??gcode_M420_0+0x40
   \   00000164   0xE000             B.N      ??gcode_M420_17
   \                     ??gcode_M420_16: (+1)
   \   00000166   0x492A             LDR.N    R1,??gcode_M420_0+0x44
   \                     ??gcode_M420_17: (+1)
   \   00000168   0x482A             LDR.N    R0,??gcode_M420_0+0x48
   \   0000016A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   0000016E   0x4D1D             LDR.N    R5,??gcode_M420_0+0x18
   \   00000170   0x210A             MOVS     R1,#+10
   \   00000172   0x4628             MOV      R0,R5
   \   00000174   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10901          
  10902              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  10903                SERIAL_ECHO_START();
   \   00000178   0x4638             MOV      R0,R7
   \   0000017A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10904                SERIAL_ECHOPGM("Fade Height ");
   \   0000017E   0x4826             LDR.N    R0,??gcode_M420_0+0x4C
   \   00000180   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10905                if (planner.z_fade_height > 0.0)
   \   00000184   0x4825             LDR.N    R0,??gcode_M420_0+0x50
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0x2100             MOVS     R1,#+0
   \   0000018A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000018E   0xD20D             BCS.N    ??gcode_M420_18
  10906                  SERIAL_ECHOLN(planner.z_fade_height);
   \   00000190   0x2102             MOVS     R1,#+2
   \   00000192   0x9100             STR      R1,[SP, #+0]
   \   00000194   0x.... 0x....      BL       __aeabi_f2d
   \   00000198   0x4602             MOV      R2,R0
   \   0000019A   0x460B             MOV      R3,R1
   \   0000019C   0x4628             MOV      R0,R5
   \   0000019E   0x.... 0x....      BL       _ZN5Print5printEdi
   \   000001A2   0x210A             MOVS     R1,#+10
   \   000001A4   0x4628             MOV      R0,R5
   \   000001A6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000001AA   0xE002             B.N      ??gcode_M420_19
  10907                else
  10908                  SERIAL_ECHOLNPGM(MSG_OFF);
   \                     ??gcode_M420_18: (+1)
   \   000001AC   0x481C             LDR.N    R0,??gcode_M420_0+0x54
   \   000001AE   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10909              #endif
  10910          
  10911              // Report change in position
  10912              if (memcmp(oldpos, current_position, sizeof(oldpos)))
   \                     ??gcode_M420_19: (+1)
   \   000001B2   0x220C             MOVS     R2,#+12
   \   000001B4   0xF104 0x0108      ADD      R1,R4,#+8
   \   000001B8   0xA801             ADD      R0,SP,#+4
   \   000001BA   0x.... 0x....      BL       memcmp
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD001             BEQ.N    ??gcode_M420_6
  10913                report_current_position();
   \   000001C2   0x.... 0x....      BL       _Z23report_current_positionv
  10914            }
   \                     ??gcode_M420_6: (+1)
   \   000001C6   0xB005             ADD      SP,SP,#+20
   \   000001C8   0xBDF0             POP      {R4-R7,PC}       ;; return
   \   000001CA   0xBF00             Nop      
   \                     ??gcode_M420_0:
   \   000001CC   0x........         DC32     mks_heating_busy
   \   000001D0   0x........         DC32     mksCfg
   \   000001D4   0x........         DC32     _ZN20unified_bed_leveling12storage_slotE
   \   000001D8   0x........         DC32     _ZZ10gcode_M420vEs
   \   000001DC   0x........         DC32     _ZZ10gcode_M420vEs_0
   \   000001E0   0x........         DC32     _ZZ10gcode_M420vEs_1
   \   000001E4   0x........         DC32     Serial3
   \   000001E8   0x........         DC32     _ZZ10gcode_M420vEs_2
   \   000001EC   0x........         DC32     _ZZ10gcode_M420vEs_3
   \   000001F0   0x........         DC32     _ZZ10gcode_M420vEs_4
   \   000001F4   0x........         DC32     _ZN7Planner16bed_level_matrixE
   \   000001F8   0x........         DC32     _ZZ10gcode_M420vEs_5
   \   000001FC   0x........         DC32     _ZN7Planner15leveling_activeE
   \   00000200   0x........         DC32     errormagic
   \   00000204   0x........         DC32     _ZZ10gcode_M420vEs_6
   \   00000208   0x........         DC32     echomagic
   \   0000020C   0x........         DC32     _ZZ10gcode_M420vEs_8
   \   00000210   0x........         DC32     _ZZ10gcode_M420vEs_9
   \   00000214   0x........         DC32     _ZZ10gcode_M420vEs_7
   \   00000218   0x........         DC32     _ZZ10gcode_M420vEs__10_
   \   0000021C   0x........         DC32     _ZN7Planner13z_fade_heightE
   \   00000220   0x........         DC32     _ZZ10gcode_M420vEs__11_
  10915          #endif
  10916          
  10917          #if 1//ENABLED(MESH_BED_LEVELING)
  10918          
  10919            /**
  10920             * M421: Set a single Mesh Bed Leveling Z coordinate
  10921             *
  10922             * Usage:
  10923             *   M421 X<linear> Y<linear> Z<linear>
  10924             *   M421 X<linear> Y<linear> Q<offset>
  10925             *   M421 I<xindex> J<yindex> Z<linear>
  10926             *   M421 I<xindex> J<yindex> Q<offset>
  10927             */

   \                                 In section .text, align 4
  10928            inline void gcode_M421_MESH_BED_LEVELING() {
   \                     _Z28gcode_M421_MESH_BED_LEVELINGv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
  10929              const bool hasX = parser.seen('X'), hasI = parser.seen('I');
   \   00000004   0x2058             MOVS     R0,#+88
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x2049             MOVS     R0,#+73
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000012   0x0005             MOVS     R5,R0
  10930              const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
   \   00000014   0xD003             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_0
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   0000001A   0x4606             MOV      R6,R0
   \   0000001C   0xE00B             B.N      ??gcode_M421_MESH_BED_LEVELING_1
   \                     ??gcode_M421_MESH_BED_LEVELING_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD007             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_2
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       _ZN17mesh_bed_leveling13probe_index_xERKf
   \   0000002E   0x4606             MOV      R6,R0
   \   00000030   0xE001             B.N      ??gcode_M421_MESH_BED_LEVELING_1
   \                     ??gcode_M421_MESH_BED_LEVELING_2: (+1)
   \   00000032   0xF04F 0x36FF      MOV      R6,#-1
  10931              const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
   \                     ??gcode_M421_MESH_BED_LEVELING_1: (+1)
   \   00000036   0x2059             MOVS     R0,#+89
   \   00000038   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x204A             MOVS     R0,#+74
   \   00000040   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000044   0x4680             MOV      R8,R0
  10932              const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
   \   00000046   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004A   0xD003             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_3
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000050   0x4681             MOV      R9,R0
   \   00000052   0xE00B             B.N      ??gcode_M421_MESH_BED_LEVELING_4
   \                     ??gcode_M421_MESH_BED_LEVELING_3: (+1)
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD007             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_5
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xA800             ADD      R0,SP,#+0
   \   00000060   0x.... 0x....      BL       _ZN17mesh_bed_leveling13probe_index_yERKf
   \   00000064   0x4681             MOV      R9,R0
   \   00000066   0xE001             B.N      ??gcode_M421_MESH_BED_LEVELING_4
   \                     ??gcode_M421_MESH_BED_LEVELING_5: (+1)
   \   00000068   0xF04F 0x39FF      MOV      R9,#-1
  10933              const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
   \                     ??gcode_M421_MESH_BED_LEVELING_4: (+1)
   \   0000006C   0x205A             MOVS     R0,#+90
   \   0000006E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000072   0x4683             MOV      R11,R0
   \   00000074   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000078   0xD104             BNE.N    ??gcode_M421_MESH_BED_LEVELING_6
   \   0000007A   0x2051             MOVS     R0,#+81
   \   0000007C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000080   0x4682             MOV      R10,R0
   \   00000082   0xE001             B.N      ??gcode_M421_MESH_BED_LEVELING_7
   \                     ??gcode_M421_MESH_BED_LEVELING_6: (+1)
   \   00000084   0xF04F 0x0A00      MOV      R10,#+0
  10934          
  10935              if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
   \                     ??gcode_M421_MESH_BED_LEVELING_7: (+1)
   \   00000088   0xEA08 0x0005      AND      R0,R8,R5
   \   0000008C   0xEA07 0x0104      AND      R1,R7,R4
   \   00000090   0x1808             ADDS     R0,R1,R0
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD102             BNE.N    ??gcode_M421_MESH_BED_LEVELING_8
   \   00000096   0xEA5A 0x000B      ORRS     R0,R10,R11
   \   0000009A   0xD106             BNE.N    ??gcode_M421_MESH_BED_LEVELING_9
  10936                SERIAL_ERROR_START();
   \                     ??gcode_M421_MESH_BED_LEVELING_8: (+1)
   \   0000009C   0x4816             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
   \   0000009E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10937                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \   000000A2   0x4816             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x4
   \   000000A4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000000A8   0xE024             B.N      ??gcode_M421_MESH_BED_LEVELING_11
  10938              }
  10939              else if (ix < 0 || iy < 0) {
   \                     ??gcode_M421_MESH_BED_LEVELING_9: (+1)
   \   000000AA   0xB276             SXTB     R6,R6
   \   000000AC   0x0034             MOVS     R4,R6
   \   000000AE   0xD404             BMI.N    ??gcode_M421_MESH_BED_LEVELING_12
   \   000000B0   0xFA4F 0xF989      SXTB     R9,R9
   \   000000B4   0x464D             MOV      R5,R9
   \   000000B6   0x2D00             CMP      R5,#+0
   \   000000B8   0xD506             BPL.N    ??gcode_M421_MESH_BED_LEVELING_13
  10940                SERIAL_ERROR_START();
   \                     ??gcode_M421_MESH_BED_LEVELING_12: (+1)
   \   000000BA   0x480F             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
   \   000000BC   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10941                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \   000000C0   0x480F             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x8
   \   000000C2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000000C6   0xE015             B.N      ??gcode_M421_MESH_BED_LEVELING_11
  10942              }
  10943              else
  10944                mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
   \                     ??gcode_M421_MESH_BED_LEVELING_13: (+1)
   \   000000C8   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000000CC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000D0   0xD007             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_14
   \   000000D2   0xEB04 0x0144      ADD      R1,R4,R4, LSL #+1
   \   000000D6   0x4A0B             LDR.N    R2,??gcode_M421_MESH_BED_LEVELING_10+0xC
   \   000000D8   0xEB02 0x1101      ADD      R1,R2,R1, LSL #+4
   \   000000DC   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   000000E0   0xE000             B.N      ??gcode_M421_MESH_BED_LEVELING_15
   \                     ??gcode_M421_MESH_BED_LEVELING_14: (+1)
   \   000000E2   0x2100             MOVS     R1,#+0
   \                     ??gcode_M421_MESH_BED_LEVELING_15: (+1)
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0xAA00             ADD      R2,SP,#+0
   \   000000EC   0x4649             MOV      R1,R9
   \   000000EE   0x4630             MOV      R0,R6
   \   000000F0   0x.... 0x....      BL       _ZN17mesh_bed_leveling5set_zEaaRKf
  10945            }
   \                     ??gcode_M421_MESH_BED_LEVELING_11: (+1)
   \   000000F4   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   \                     ??gcode_M421_MESH_BED_LEVELING_10:
   \   000000F8   0x........         DC32     errormagic
   \   000000FC   0x........         DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
   \   00000100   0x........         DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
   \   00000104   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE
  10946          #endif
  10947          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
  10948          
  10949            /**
  10950             * M421: Set a single Mesh Bed Leveling Z coordinate
  10951             *
  10952             * Usage:
  10953             *   M421 I<xindex> J<yindex> Z<linear>
  10954             *   M421 I<xindex> J<yindex> Q<offset>
  10955             */

   \                                 In section .text, align 4
  10956            inline void gcode_M421_AUTO_BED_LEVELING_BILINEAR() {
   \                     _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
  10957              int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x2049             MOVS     R0,#+73
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000000E   0x4606             MOV      R6,R0
   \   00000010   0xB276             SXTB     R6,R6
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x204A             MOVS     R0,#+74
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x4604             MOV      R4,R0
   \   0000001E   0xB264             SXTB     R4,R4
  10958              const bool hasI = ix >= 0,
   \   00000020   0x4637             MOV      R7,R6
   \   00000022   0x43FF             MVNS     R7,R7
  10959                         hasJ = iy >= 0,
   \   00000024   0x46A0             MOV      R8,R4
   \   00000026   0xEA6F 0x0808      MVN      R8,R8
   \   0000002A   0xEA4F 0x78D8      LSR      R8,R8,#+31
  10960                         hasZ = parser.seen('Z'),
   \   0000002E   0x205A             MOVS     R0,#+90
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000034   0x4681             MOV      R9,R0
  10961                         hasQ = !hasZ && parser.seen('Q');
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD104             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0
   \   0000003C   0x2051             MOVS     R0,#+81
   \   0000003E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000042   0x4605             MOV      R5,R0
   \   00000044   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0: (+1)
   \   00000046   0x2500             MOVS     R5,#+0
  10962          
  10963              if (!hasI || !hasJ || !(hasZ || hasQ)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1: (+1)
   \   00000048   0xEA08 0x70D7      AND      R0,R8,R7, LSR #+31
   \   0000004C   0xEA45 0x0109      ORR      R1,R5,R9
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD107             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2
  10964                SERIAL_ERROR_START();
   \   00000054   0x4818             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
   \   00000056   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10965                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \   0000005A   0x4818             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x4
   \   0000005C   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000060   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10966              }
  10967              else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2: (+1)
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD40C             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
   \   00000068   0x4815             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x8
   \   0000006A   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   0000006E   0x1E49             SUBS     R1,R1,#+1
   \   00000070   0x42B1             CMP      R1,R6
   \   00000072   0xDB06             BLT.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD404             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
   \   00000078   0xF890 0x0061      LDRB     R0,[R0, #+97]
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x42A0             CMP      R0,R4
   \   00000080   0xDA07             BGE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5
  10968                SERIAL_ERROR_START();
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4: (+1)
   \   00000082   0x480D             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
   \   00000084   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10969                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \   00000088   0x480E             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0xC
   \   0000008A   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   0000008E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10970              }
  10971              else {
  10972                z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5: (+1)
   \   00000092   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000096   0xEB06 0x0146      ADD      R1,R6,R6, LSL #+1
   \   0000009A   0x4A0B             LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x10
   \   0000009C   0xEB02 0x1601      ADD      R6,R2,R1, LSL #+4
   \   000000A0   0x2D00             CMP      R5,#+0
   \   000000A2   0xD002             BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6
   \   000000A4   0xF856 0x1024      LDR      R1,[R6, R4, LSL #+2]
   \   000000A8   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6: (+1)
   \   000000AA   0x2100             MOVS     R1,#+0
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7: (+1)
   \   000000AC   0x.... 0x....      BL       __aeabi_fadd
   \   000000B0   0xF846 0x0024      STR      R0,[R6, R4, LSL #+2]
  10973                #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  10974                  bed_level_virt_interpolate();
  10975                #endif
  10976              }
  10977            }
   \   000000B4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3:
   \   000000B8   0x........         DC32     errormagic
   \   000000BC   0x........         DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
   \   000000C0   0x........         DC32     mksCfg
   \   000000C4   0x........         DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
   \   000000C8   0x........         DC32     z_values
  10978          #endif
  10979          #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
  10980          
  10981            /**
  10982             * M421: Set a single Mesh Bed Leveling Z coordinate
  10983             *
  10984             * Usage:
  10985             *   M421 I<xindex> J<yindex> Z<linear>
  10986             *   M421 I<xindex> J<yindex> Q<offset>
  10987             *   M421 C Z<linear>
  10988             *   M421 C Q<offset>
  10989             */

   \                                 In section .text, align 4
  10990            inline void gcode_M421_AUTO_BED_LEVELING_UBL() {
   \                     _Z32gcode_M421_AUTO_BED_LEVELING_UBLv: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
  10991              int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x2049             MOVS     R0,#+73
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000000E   0x4682             MOV      R10,R0
   \   00000010   0xFA4F 0xFA8A      SXTB     R10,R10
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x204A             MOVS     R0,#+74
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001E   0x4605             MOV      R5,R0
   \   00000020   0xB26D             SXTB     R5,R5
  10992              const bool hasI = ix >= 0,
   \   00000022   0x4656             MOV      R6,R10
   \   00000024   0x43F6             MVNS     R6,R6
  10993                         hasJ = iy >= 0,
   \   00000026   0x462F             MOV      R7,R5
   \   00000028   0x43FF             MVNS     R7,R7
   \   0000002A   0x0FFF             LSRS     R7,R7,#+31
  10994                         hasC = parser.seen('C'),
   \   0000002C   0x2043             MOVS     R0,#+67
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000032   0x4680             MOV      R8,R0
  10995                         hasZ = parser.seen('Z'),
   \   00000034   0x205A             MOVS     R0,#+90
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003A   0x4681             MOV      R9,R0
  10996                         hasQ = !hasZ && parser.seen('Q');
   \   0000003C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000040   0xD104             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_0
   \   00000042   0x2051             MOVS     R0,#+81
   \   00000044   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000048   0x4604             MOV      R4,R0
   \   0000004A   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_1
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_0: (+1)
   \   0000004C   0x2400             MOVS     R4,#+0
  10997          
  10998              if (hasC) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_1: (+1)
   \   0000004E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000052   0xD00F             BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_2
  10999                const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
   \   00000054   0x4826             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x9101             STR      R1,[SP, #+4]
   \   0000005A   0x9100             STR      R1,[SP, #+0]
   \   0000005C   0xF100 0x030C      ADD      R3,R0,#+12
   \   00000060   0xF100 0x0208      ADD      R2,R0,#+8
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0xA802             ADD      R0,SP,#+8
   \   00000068   0x.... 0x....      BL       _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
  11000                ix = location.x_index;
   \   0000006C   0xF99D 0xA008      LDRSB    R10,[SP, #+8]
  11001                iy = location.y_index;
   \   00000070   0xF99D 0x5009      LDRSB    R5,[SP, #+9]
  11002              }
  11003          
  11004              if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_2: (+1)
   \   00000074   0xEA07 0x70D6      AND      R0,R7,R6, LSR #+31
   \   00000078   0x4440             ADD      R0,R0,R8
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD102             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_4
   \   0000007E   0xEA54 0x0009      ORRS     R0,R4,R9
   \   00000082   0xD108             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_5
  11005                SERIAL_ERROR_START();
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_4: (+1)
   \   00000084   0x481B             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
   \   00000086   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11006                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \   0000008A   0x481B             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x8
   \   0000008C   0xB004             ADD      SP,SP,#+16
   \   0000008E   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   00000092   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  11007              }
  11008              else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_5: (+1)
   \   00000096   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000009A   0xD40C             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
   \   0000009C   0x4817             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0xC
   \   0000009E   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   000000A2   0x1E49             SUBS     R1,R1,#+1
   \   000000A4   0x4551             CMP      R1,R10
   \   000000A6   0xDB06             BLT.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
   \   000000A8   0x2D00             CMP      R5,#+0
   \   000000AA   0xD404             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
   \   000000AC   0xF890 0x0061      LDRB     R0,[R0, #+97]
   \   000000B0   0x1E40             SUBS     R0,R0,#+1
   \   000000B2   0x42A8             CMP      R0,R5
   \   000000B4   0xDA08             BGE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_7
  11009                SERIAL_ERROR_START();
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_6: (+1)
   \   000000B6   0x480F             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
   \   000000B8   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11010                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \   000000BC   0x4810             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x10
   \   000000BE   0xB004             ADD      SP,SP,#+16
   \   000000C0   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000C4   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  11011              }
  11012              else
  11013                ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_7: (+1)
   \   000000C8   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000000CC   0xEB0A 0x014A      ADD      R1,R10,R10, LSL #+1
   \   000000D0   0x4A0C             LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x14
   \   000000D2   0xEB02 0x1601      ADD      R6,R2,R1, LSL #+4
   \   000000D6   0x2C00             CMP      R4,#+0
   \   000000D8   0xD002             BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_8
   \   000000DA   0xF856 0x1025      LDR      R1,[R6, R5, LSL #+2]
   \   000000DE   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_9
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_8: (+1)
   \   000000E0   0x2100             MOVS     R1,#+0
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_9: (+1)
   \   000000E2   0x.... 0x....      BL       __aeabi_fadd
   \   000000E6   0xF846 0x0025      STR      R0,[R6, R5, LSL #+2]
  11014            }
   \   000000EA   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \   000000EE   0xBF00             Nop      
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_3:
   \   000000F0   0x........         DC32     mks_heating_busy
   \   000000F4   0x........         DC32     errormagic
   \   000000F8   0x........         DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
   \   000000FC   0x........         DC32     mksCfg
   \   00000100   0x........         DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
   \   00000104   0x........         DC32     _ZN20unified_bed_leveling8z_valuesE
  11015          
  11016          #endif // AUTO_BED_LEVELING_UBL
  11017          
  11018          #if 1//HAS_M206_COMMAND
  11019          
  11020            /**
  11021             * M428: Set home_offset based on the distance between the
  11022             *       current_position and the nearest "reference point."
  11023             *       If an axis is past center its endstop position
  11024             *       is the reference-point. Otherwise it uses 0. This allows
  11025             *       the Z offset to be set near the bed when using a max endstop.
  11026             *
  11027             *       M428 can't be used more than 2cm away from 0 or an endstop.
  11028             *
  11029             *       Use M206 to set these values directly.
  11030             */

   \                                 In section .text, align 4
  11031            inline void gcode_M428() {
  11032            
  11033            	if(MACHINETPYE == DELTA) return;
   \                     _Z10gcode_M428v: (+1)
   \   00000000   0x482D             LDR.N    R0,??gcode_M428_0
   \   00000002   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD100             BNE.N    ??gcode_M428_1
   \   0000000A   0x4770             BX       LR
  11034          	
  11035              if (axis_unhomed_error()) return;
   \                     ??gcode_M428_1: (+1)
   \   0000000C   0xB5FE             PUSH     {R1-R7,LR}
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x4611             MOV      R1,R2
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x.... 0x....      BL       _Z18axis_unhomed_errorbbb
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD14C             BNE.N    ??gcode_M428_2
  11036          
  11037              float diff[XYZ];
  11038              LOOP_XYZ(i) {
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0xAE00             ADD      R6,SP,#+0
   \   00000020   0x4F26             LDR.N    R7,??gcode_M428_0+0x4  ;; 0xc1a00000
   \   00000022   0xE001             B.N      ??gcode_M428_3
   \                     ??gcode_M428_4: (+1)
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \   00000026   0xB2E4             UXTB     R4,R4
   \                     ??gcode_M428_3: (+1)
   \   00000028   0x2C03             CMP      R4,#+3
   \   0000002A   0xDA32             BGE.N    ??gcode_M428_5
   \   0000002C   0x4824             LDR.N    R0,??gcode_M428_0+0x8
   \   0000002E   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000032   0x6885             LDR      R5,[R0, #+8]
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xB240             SXTB     R0,R0
  11039                diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
   \   00000038   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x.... 0x....      BL       __aeabi_fsub
   \   00000042   0xF846 0x0024      STR      R0,[R6, R4, LSL #+2]
  11040                if (!WITHIN(diff[i], -20, 20) && home_dir((AxisEnum)i) > 0)
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000004C   0xD803             BHI.N    ??gcode_M428_6
   \   0000004E   0x491D             LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
   \   00000050   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000054   0xD309             BCC.N    ??gcode_M428_7
   \                     ??gcode_M428_6: (+1)
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xB240             SXTB     R0,R0
   \   0000005A   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xDB03             BLT.N    ??gcode_M428_7
  11041                  diff[i] = -current_position[i];
   \   00000062   0xF085 0x4500      EOR      R5,R5,#0x80000000
   \   00000066   0xF846 0x5024      STR      R5,[R6, R4, LSL #+2]
  11042                if (!WITHIN(diff[i], -20, 20)) {
   \                     ??gcode_M428_7: (+1)
   \   0000006A   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   0000006E   0x4639             MOV      R1,R7
   \   00000070   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000074   0xD803             BHI.N    ??gcode_M428_8
   \   00000076   0x4913             LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
   \   00000078   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000007C   0xD3D2             BCC.N    ??gcode_M428_4
  11043                  SERIAL_ERROR_START();
   \                     ??gcode_M428_8: (+1)
   \   0000007E   0x4812             LDR.N    R0,??gcode_M428_0+0x10
   \   00000080   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11044                  SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
   \   00000084   0x4811             LDR.N    R0,??gcode_M428_0+0x14
   \   00000086   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11045                  LCD_ALERTMESSAGEPGM("Err: Too far!");
   \   0000008A   0x4811             LDR.N    R0,??gcode_M428_0+0x18
   \   0000008C   0x.... 0x....      BL       _Z21lcd_setalertstatusPGMPKc
  11046                  BUZZ(200, 40);
  11047                  return;
   \   00000090   0xBDF7             POP      {R0-R2,R4-R7,PC}
  11048                }
  11049              }
  11050          
  11051              LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
   \                     ??gcode_M428_5: (+1)
   \   00000092   0x2400             MOVS     R4,#+0
   \   00000094   0xE007             B.N      ??gcode_M428_9
   \                     ??gcode_M428_10: (+1)
   \   00000096   0xA800             ADD      R0,SP,#+0
   \   00000098   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0xB240             SXTB     R0,R0
   \   000000A0   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   \   000000A4   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M428_9: (+1)
   \   000000A6   0x2C03             CMP      R4,#+3
   \   000000A8   0xDBF5             BLT.N    ??gcode_M428_10
  11052              report_current_position();
   \   000000AA   0x.... 0x....      BL       _Z23report_current_positionv
  11053              LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x4808             LDR.N    R0,??gcode_M428_0+0x1C
   \   000000B2   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
  11054              BUZZ(100, 659);
  11055              BUZZ(100, 698);
  11056            }
   \                     ??gcode_M428_2: (+1)
   \   000000B6   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   \                     ??gcode_M428_0:
   \   000000B8   0x........         DC32     mksCfg
   \   000000BC   0xC1A00000         DC32     0xc1a00000
   \   000000C0   0x........         DC32     mks_heating_busy
   \   000000C4   0x41A00001         DC32     0x41a00001
   \   000000C8   0x........         DC32     errormagic
   \   000000CC   0x........         DC32     _ZZ10gcode_M428vEs
   \   000000D0   0x........         DC32     _ZZ10gcode_M428vEs_0
   \   000000D4   0x........         DC32     _ZZ10gcode_M428vEs_1
  11057          
  11058          #endif // HAS_M206_COMMAND
  11059          
  11060          /**
  11061           * M500: Store settings in EEPROM
  11062           */

   \                                 In section .text, align 2
  11063          inline void gcode_M500() {
  11064            (void)settings.save();
   \                     _Z10gcode_M500v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings4saveEv
  11065          }
  11066          
  11067          /**
  11068           * M501: Read settings from EEPROM
  11069           */

   \                                 In section .text, align 2
  11070          inline void gcode_M501() {
  11071            (void)settings.load();
   \                     _Z10gcode_M501v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings4loadEv
  11072          }
  11073          
  11074          /**
  11075           * M502: Revert to default settings
  11076           */

   \                                 In section .text, align 2
  11077          inline void gcode_M502() {
  11078            (void)settings.reset();
   \                     _Z10gcode_M502v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings5resetEv
  11079          }
  11080          
  11081          #if DISABLED(DISABLE_M503)
  11082            /**
  11083             * M503: print settings currently in memory
  11084             */

   \                                 In section .text, align 2
  11085            inline void gcode_M503() {
   \                     _Z10gcode_M503v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  11086              (void)settings.report(parser.seen('S') && !parser.value_bool());
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??gcode_M503_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000010   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000014   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000018   0xE000             B.N      ??gcode_M503_1
   \                     ??gcode_M503_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??gcode_M503_1: (+1)
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x.... 0x....      B.W      _ZN14MarlinSettings6reportEb
  11087            }
  11088          #endif
  11089          
  11090          #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
  11091          
  11092            /**
  11093             * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
  11094             */
  11095            inline void gcode_M540() {
  11096              if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
  11097            }
  11098          
  11099          #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
  11100          
  11101          #if HAS_BED_PROBE
  11102          

   \                                 In section .text, align 4
  11103            inline void gcode_M851() {
   \                     _Z10gcode_M851v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  11104              SERIAL_ECHO_START();
   \   00000002   0x4813             LDR.N    R0,??gcode_M851_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11105              SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
   \   00000008   0x4812             LDR.N    R0,??gcode_M851_0+0x4
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11106              if (parser.seen('Z')) {
   \   0000000E   0x205A             MOVS     R0,#+90
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD010             BEQ.N    ??gcode_M851_1
  11107                const float value = parser.value_linear_units();
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
  11108                if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
   \   0000001C   0x490E             LDR.N    R1,??gcode_M851_0+0x8  ;; 0xc1a00000
   \   0000001E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000022   0xD803             BHI.N    ??gcode_M851_2
   \   00000024   0x490D             LDR.N    R1,??gcode_M851_0+0xC  ;; 0x41a00001
   \   00000026   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002A   0xD304             BCC.N    ??gcode_M851_3
  11109                  SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
   \                     ??gcode_M851_2: (+1)
   \   0000002C   0x480C             LDR.N    R0,??gcode_M851_0+0x10
   \   0000002E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000032   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  11110                  return;
  11111                }
  11112                zprobe_zoffset = value;
   \                     ??gcode_M851_3: (+1)
   \   00000036   0x490B             LDR.N    R1,??gcode_M851_0+0x14
   \   00000038   0x6708             STR      R0,[R1, #+112]
  11113              }
  11114              SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
   \                     ??gcode_M851_1: (+1)
   \   0000003A   0x480A             LDR.N    R0,??gcode_M851_0+0x14
   \   0000003C   0x6F01             LDR      R1,[R0, #+112]
   \   0000003E   0x480A             LDR.N    R0,??gcode_M851_0+0x18
   \   00000040   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0x4809             LDR.N    R0,??gcode_M851_0+0x1C
   \   00000048   0xE8BD 0x4004      POP      {R2,LR}
   \   0000004C   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M851_0:
   \   00000050   0x........         DC32     echomagic
   \   00000054   0x........         DC32     _ZZ10gcode_M851vEs
   \   00000058   0xC1A00000         DC32     0xc1a00000
   \   0000005C   0x41A00001         DC32     0x41a00001
   \   00000060   0x........         DC32     _ZZ10gcode_M851vEs_0
   \   00000064   0x........         DC32     mks_heating_busy
   \   00000068   0x........         DC32     _ZZ10gcode_M851vEs_1
   \   0000006C   0x........         DC32     Serial3
  11115            }
  11116          
  11117          #endif // HAS_BED_PROBE
  11118          
  11119          #if ENABLED(SKEW_CORRECTION_GCODE)
  11120          
  11121            /**
  11122             * M852: Get or set the machine skew factors. Reports current values with no arguments.
  11123             *
  11124             *  S[xy_factor] - Alias for 'I'
  11125             *  I[xy_factor] - New XY skew factor
  11126             *  J[xz_factor] - New XZ skew factor
  11127             *  K[yz_factor] - New YZ skew factor
  11128             */
  11129            inline void gcode_M852() {
  11130              uint8_t ijk = 0, badval = 0, setval = 0;
  11131          
  11132              if (parser.seen('I') || parser.seen('S')) {
  11133                ++ijk;
  11134                const float value = parser.value_linear_units();
  11135                if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  11136                  if (planner.xy_skew_factor != value) {
  11137                    planner.xy_skew_factor = value;
  11138                    ++setval;
  11139                  }
  11140                }
  11141                else
  11142                  ++badval;
  11143              }
  11144          
  11145              #if ENABLED(SKEW_CORRECTION_FOR_Z)
  11146          
  11147                if (parser.seen('J')) {
  11148                  ++ijk;
  11149                  const float value = parser.value_linear_units();
  11150                  if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  11151                    if (planner.xz_skew_factor != value) {
  11152                      planner.xz_skew_factor = value;
  11153                      ++setval;
  11154                    }
  11155                  }
  11156                  else
  11157                    ++badval;
  11158                }
  11159          
  11160                if (parser.seen('K')) {
  11161                  ++ijk;
  11162                  const float value = parser.value_linear_units();
  11163                  if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  11164                    if (planner.yz_skew_factor != value) {
  11165                      planner.yz_skew_factor = value;
  11166                      ++setval;
  11167                    }
  11168                  }
  11169                  else
  11170                    ++badval;
  11171                }
  11172          
  11173              #endif
  11174          
  11175              if (badval)
  11176                SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
  11177          
  11178              // When skew is changed the current position changes
  11179              if (setval) {
  11180                set_current_from_steppers_for_axis(ALL_AXES);
  11181                SYNC_PLAN_POSITION_KINEMATIC();
  11182                report_current_position();
  11183              }
  11184          
  11185              if (!ijk) {
  11186                SERIAL_ECHO_START();
  11187                SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
  11188                #if ENABLED(SKEW_CORRECTION_FOR_Z)
  11189                  SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
  11190                  SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
  11191                #else
  11192                  SERIAL_EOL();
  11193                #endif
  11194              }
  11195            }
  11196          
  11197          #endif // SKEW_CORRECTION_GCODE
  11198          
  11199          #if ENABLED(ADVANCED_PAUSE_FEATURE)
  11200          
  11201            /**
  11202             * M600: Pause for filament change
  11203             *
  11204             *  E[distance] - Retract the filament this far (negative value)
  11205             *  Z[distance] - Move the Z axis by this distance
  11206             *  X[position] - Move to this X position, with Y
  11207             *  Y[position] - Move to this Y position, with X
  11208             *  U[distance] - Retract distance for removal (negative value) (manual reload)
  11209             *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
  11210             *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
  11211             *
  11212             *  Default values are used for omitted arguments.
  11213             *
  11214             */
  11215            inline void gcode_M600() {
  11216              point_t park_point = NOZZLE_PARK_POINT;
  11217          
  11218              #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
  11219                // Don't allow filament change without homing first
  11220                if (axis_unhomed_error()) home_all_axes();
  11221              #endif
  11222          
  11223              // Initial retract before move to filament change position
  11224              const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
  11225                #ifdef PAUSE_PARK_RETRACT_LENGTH
  11226                  - (PAUSE_PARK_RETRACT_LENGTH)
  11227                #endif
  11228              ;
  11229          
  11230              // Lift Z axis
  11231              if (parser.seenval('Z'))
  11232                park_point.z = parser.linearval('Z');
  11233          
  11234              // Move XY axes to filament change position or given position
  11235              if (parser.seenval('X'))
  11236                park_point.x = parser.linearval('X');
  11237          
  11238              if (parser.seenval('Y'))
  11239                park_point.y = parser.linearval('Y');
  11240          
  11241              #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
  11242                park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
  11243                park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
  11244              #endif
  11245          
  11246              // Unload filament
  11247              const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
  11248                #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
  11249                  - (FILAMENT_CHANGE_UNLOAD_LENGTH)
  11250                #endif
  11251              ;
  11252          
  11253              // Load filament
  11254              const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
  11255                #ifdef FILAMENT_CHANGE_LOAD_LENGTH
  11256                  + FILAMENT_CHANGE_LOAD_LENGTH
  11257                #endif
  11258              ;
  11259          
  11260              const int beep_count = parser.intval('B',
  11261                #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
  11262                  FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
  11263                #else
  11264                  -1
  11265                #endif
  11266              );
  11267          
  11268              const bool job_running = print_job_timer.isRunning();
  11269          
  11270              if (pause_print(retract, park_point, unload_length, beep_count, true)) {
  11271                wait_for_filament_reload(beep_count);
  11272                resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
  11273              }
  11274          
  11275              // Resume the print job timer if it was running
  11276              if (job_running) print_job_timer.start();
  11277            }
  11278          
  11279          #endif // ADVANCED_PAUSE_FEATURE
  11280          
  11281          #if ENABLED(MK2_MULTIPLEXER)
  11282          
  11283            inline void select_multiplexed_stepper(const uint8_t e) {
  11284              stepper.synchronize();
  11285              disable_e_steppers();
  11286              WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
  11287              WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
  11288              WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
  11289              safe_delay(100);
  11290            }
  11291          
  11292            /**
  11293             * M702: Unload all extruders
  11294             */
  11295            inline void gcode_M702() {
  11296              for (uint8_t s = 0; s < E_STEPPERS; s++) {
  11297                select_multiplexed_stepper(e);
  11298                // TODO: standard unload filament function
  11299                // MK2 firmware behavior:
  11300                //  - Make sure temperature is high enough
  11301                //  - Raise Z to at least 15 to make room
  11302                //  - Extrude 1cm of filament in 1 second
  11303                //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
  11304                //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
  11305                //  - Restore E max feedrate to 50
  11306              }
  11307              // Go back to the last active extruder
  11308              select_multiplexed_stepper(active_extruder);
  11309              disable_e_steppers();
  11310            }
  11311          
  11312          #endif // MK2_MULTIPLEXER
  11313          
  11314          #if ENABLED(DUAL_X_CARRIAGE)
  11315          
  11316            /**
  11317             * M605: Set dual x-carriage movement mode
  11318             *
  11319             *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
  11320             *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
  11321             *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
  11322             *                         units x-offset and an optional differential hotend temperature of
  11323             *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
  11324             *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
  11325             *
  11326             *    Note: the X axis should be homed after changing dual x-carriage mode.
  11327             */
  11328            inline void gcode_M605() {
  11329              stepper.synchronize();
  11330              if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
  11331              switch (dual_x_carriage_mode) {
  11332                case DXC_FULL_CONTROL_MODE:
  11333                case DXC_AUTO_PARK_MODE:
  11334                  break;
  11335                case DXC_DUPLICATION_MODE:
  11336                  if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
  11337                  if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
  11338                  SERIAL_ECHO_START();
  11339                  SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
  11340                  SERIAL_CHAR(' ');
  11341                  SERIAL_ECHO(hotend_offset[X_AXIS][0]);
  11342                  SERIAL_CHAR(',');
  11343                  SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
  11344                  SERIAL_CHAR(' ');
  11345                  SERIAL_ECHO(duplicate_extruder_x_offset);
  11346                  SERIAL_CHAR(',');
  11347                  SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
  11348                  break;
  11349                default:
  11350                  dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
  11351                  break;
  11352              }
  11353              active_extruder_parked = false;
  11354              extruder_duplication_enabled = false;
  11355              delayed_move_time = 0;
  11356            }
  11357          
  11358          #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
  11359          
  11360            inline void gcode_M605() {
  11361              stepper.synchronize();
  11362              extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
  11363              SERIAL_ECHO_START();
  11364              SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
  11365            }
  11366          
  11367          #endif // DUAL_NOZZLE_DUPLICATION_MODE
  11368          
  11369          #if ENABLED(LIN_ADVANCE)
  11370            /**
  11371             * M900: Set and/or Get advance K factor and WH/D ratio
  11372             *
  11373             *  K<factor>                  Set advance K factor
  11374             *  R<ratio>                   Set ratio directly (overrides WH/D)
  11375             *  W<width> H<height> D<diam> Set ratio from WH/D
  11376             */
  11377            inline void gcode_M900() {
  11378              stepper.synchronize();
  11379          
  11380              const float newK = parser.floatval('K', -1);
  11381              if (newK >= 0) planner.extruder_advance_k = newK;
  11382          
  11383              float newR = parser.floatval('R', -1);
  11384              if (newR < 0) {
  11385                const float newD = parser.floatval('D', -1),
  11386                            newW = parser.floatval('W', -1),
  11387                            newH = parser.floatval('H', -1);
  11388                if (newD >= 0 && newW >= 0 && newH >= 0)
  11389                  newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
  11390              }
  11391              if (newR >= 0) planner.advance_ed_ratio = newR;
  11392          
  11393              SERIAL_ECHO_START();
  11394              SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
  11395              SERIAL_ECHOPGM(" E/D=");
  11396              const float ratio = planner.advance_ed_ratio;
  11397              if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
  11398              SERIAL_EOL();
  11399            }
  11400          #endif // LIN_ADVANCE
  11401          
  11402          #if HAS_TRINAMIC
  11403            static bool report_tmc_status = false;
  11404            const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
  11405            enum TMC_AxisEnum {
  11406              TMC_X,
  11407              TMC_X2,
  11408              TMC_Y,
  11409              TMC_Y2,
  11410              TMC_Z,
  11411              TMC_Z2,
  11412              TMC_E0,
  11413              TMC_E1,
  11414              TMC_E2,
  11415              TMC_E3,
  11416              TMC_E4
  11417            };
  11418            #if ENABLED(TMC_DEBUG)
  11419              enum TMC_debug_enum {
  11420                TMC_CODES,
  11421                TMC_ENABLED,
  11422                TMC_CURRENT,
  11423                TMC_RMS_CURRENT,
  11424                TMC_MAX_CURRENT,
  11425                TMC_IRUN,
  11426                TMC_IHOLD,
  11427                TMC_CS_ACTUAL,
  11428                TMC_PWM_SCALE,
  11429                TMC_VSENSE,
  11430                TMC_STEALTHCHOP,
  11431                TMC_MICROSTEPS,
  11432                TMC_TSTEP,
  11433                TMC_TPWMTHRS,
  11434                TMC_TPWMTHRS_MMS,
  11435                TMC_OTPW,
  11436                TMC_OTPW_TRIGGERED,
  11437                TMC_TOFF,
  11438                TMC_TBL,
  11439                TMC_HEND,
  11440                TMC_HSTRT,
  11441                TMC_SGT
  11442              };
  11443              enum TMC_drv_status_enum {
  11444                TMC_DRV_CODES,
  11445                TMC_STST,
  11446                TMC_OLB,
  11447                TMC_OLA,
  11448                TMC_S2GB,
  11449                TMC_S2GA,
  11450                TMC_DRV_OTPW,
  11451                TMC_OT,
  11452                TMC_STALLGUARD,
  11453                TMC_DRV_CS_ACTUAL,
  11454                TMC_FSACTIVE,
  11455                TMC_SG_RESULT,
  11456                TMC_DRV_STATUS_HEX,
  11457                TMC_T157,
  11458                TMC_T150,
  11459                TMC_T143,
  11460                TMC_T120,
  11461                TMC_STEALTH,
  11462                TMC_S2VSB,
  11463                TMC_S2VSA
  11464              };
  11465              static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
  11466                SERIAL_ECHO(name);
  11467                SERIAL_ECHOPGM(" = 0x");
  11468                for(int B=24; B>=8; B-=8){
  11469                  MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
  11470                  MYSERIAL.print((drv_status>>B)&0xF, HEX);
  11471                  MYSERIAL.print(':');
  11472                }
  11473                MYSERIAL.print((drv_status>>4)&0xF, HEX);
  11474                MYSERIAL.print((drv_status)&0xF, HEX);
  11475                SERIAL_EOL();
  11476              }
  11477          
  11478              #if ENABLED(HAVE_TMC2130)
  11479                static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
  11480                  switch(i) {
  11481                    case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
  11482                    case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
  11483                    case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
  11484                    case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
  11485                    default: break;
  11486                  }
  11487                }
  11488                static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
  11489                  switch(i) {
  11490                    case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
  11491                    case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
  11492                    case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
  11493                    default: break;
  11494                  }
  11495                }
  11496              #endif
  11497              #if ENABLED(HAVE_TMC2208)
  11498                static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
  11499                  switch(i) {
  11500                    case TMC_TSTEP:
  11501                      {
  11502                        uint32_t data = 0;
  11503                        st.TSTEP(&data);
  11504                        MYSERIAL.print(data);
  11505                        break;
  11506                      }
  11507                    case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
  11508                    case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
  11509                    case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
  11510                    case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
  11511                    default: break;
  11512                  }
  11513                }
  11514                static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
  11515                  switch(i) {
  11516                    case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
  11517                    case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
  11518                    case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
  11519                    case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
  11520                    default: break;
  11521                  }
  11522                }
  11523              #endif
  11524              template <typename TMC>
  11525              static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
  11526                SERIAL_ECHO('\t');
  11527                switch(i) {
  11528                  case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
  11529                  case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
  11530                  case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
  11531                  case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
  11532                  case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
  11533                  case TMC_IRUN:
  11534                    MYSERIAL.print(st.irun(), DEC);
  11535                    SERIAL_ECHOPGM("/31");
  11536                    break;
  11537                  case TMC_IHOLD:
  11538                    MYSERIAL.print(st.ihold(), DEC);
  11539                    SERIAL_ECHOPGM("/31");
  11540                    break;
  11541                  case TMC_CS_ACTUAL:
  11542                    MYSERIAL.print(st.cs_actual(), DEC);
  11543                    SERIAL_ECHOPGM("/31");
  11544                    break;
  11545          
  11546                  case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
  11547          
  11548                  case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
  11549                  case TMC_TPWMTHRS:
  11550                    {
  11551                      uint32_t tpwmthrs_val = st.TPWMTHRS();
  11552                      SERIAL_ECHO(tpwmthrs_val);
  11553                    }
  11554                    break;
  11555                  case TMC_TPWMTHRS_MMS:
  11556                    {
  11557                      uint32_t tpwmthrs_val = st.TPWMTHRS();
  11558                      tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
  11559                    }
  11560                    break;
  11561                  case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
  11562                  case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
  11563                  case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
  11564                  case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
  11565                  case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
  11566                  case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
  11567                  default: tmc_status(st, i); break;
  11568                }
  11569              }
  11570              template <typename TMC>
  11571              static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
  11572                SERIAL_ECHOPGM("\t");
  11573                switch(i) {
  11574                  case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
  11575                  case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
  11576                  case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
  11577                  case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
  11578                  case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
  11579                  case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
  11580                  case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
  11581                  case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
  11582                  case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
  11583                  case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
  11584                  default: tmc_parse_drv_status(st, i); break;
  11585                }
  11586              }
  11587          
  11588              static void tmc_debug_loop(const TMC_debug_enum i) {
  11589                #if X_IS_TRINAMIC
  11590                  tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
  11591                #endif
  11592                #if X2_IS_TRINAMIC
  11593                  tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
  11594                #endif
  11595          
  11596                #if Y_IS_TRINAMIC
  11597                  tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
  11598                #endif
  11599                #if Y2_IS_TRINAMIC
  11600                  tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
  11601                #endif
  11602          
  11603                #if Z_IS_TRINAMIC
  11604                  tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
  11605                #endif
  11606                #if Z2_IS_TRINAMIC
  11607                  tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
  11608                #endif
  11609          
  11610                #if E0_IS_TRINAMIC
  11611                  tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
  11612                #endif
  11613                #if E1_IS_TRINAMIC
  11614                  tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
  11615                #endif
  11616                #if E2_IS_TRINAMIC
  11617                  tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
  11618                #endif
  11619                #if E3_IS_TRINAMIC
  11620                  tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
  11621                #endif
  11622                #if E4_IS_TRINAMIC
  11623                  tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
  11624                #endif
  11625          
  11626                SERIAL_EOL();
  11627              }
  11628          
  11629              static void drv_status_loop(const TMC_drv_status_enum i) {
  11630                #if X_IS_TRINAMIC
  11631                  tmc_parse_drv_status(stepperX, TMC_X, i);
  11632                #endif
  11633                #if X2_IS_TRINAMIC
  11634                  tmc_parse_drv_status(stepperX2, TMC_X2, i);
  11635                #endif
  11636          
  11637                #if Y_IS_TRINAMIC
  11638                  tmc_parse_drv_status(stepperY, TMC_Y, i);
  11639                #endif
  11640                #if Y2_IS_TRINAMIC
  11641                  tmc_parse_drv_status(stepperY2, TMC_Y2, i);
  11642                #endif
  11643          
  11644                #if Z_IS_TRINAMIC
  11645                  tmc_parse_drv_status(stepperZ, TMC_Z, i);
  11646                #endif
  11647                #if Z2_IS_TRINAMIC
  11648                  tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
  11649                #endif
  11650          
  11651                #if E0_IS_TRINAMIC
  11652                  tmc_parse_drv_status(stepperE0, TMC_E0, i);
  11653                #endif
  11654                #if E1_IS_TRINAMIC
  11655                  tmc_parse_drv_status(stepperE1, TMC_E1, i);
  11656                #endif
  11657                #if E2_IS_TRINAMIC
  11658                  tmc_parse_drv_status(stepperE2, TMC_E2, i);
  11659                #endif
  11660                #if E3_IS_TRINAMIC
  11661                  tmc_parse_drv_status(stepperE3, TMC_E3, i);
  11662                #endif
  11663                #if E4_IS_TRINAMIC
  11664                  tmc_parse_drv_status(stepperE4, TMC_E4, i);
  11665                #endif
  11666          
  11667                SERIAL_EOL();
  11668              }
  11669          
  11670              inline void gcode_M122() {
  11671                if (parser.seen('S')) {
  11672                  if (parser.value_bool()) {
  11673                    SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
  11674                    report_tmc_status = true;
  11675                  } else
  11676                    report_tmc_status = false;
  11677                } else {
  11678                  SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
  11679                  SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
  11680                  SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
  11681                  SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
  11682                  SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
  11683                  SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
  11684                  SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
  11685                  SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
  11686                  SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
  11687                  SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
  11688                  SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
  11689                  SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
  11690                  SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
  11691                  SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
  11692                  SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
  11693                  SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
  11694                  SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
  11695                  SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
  11696                  SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
  11697                  SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
  11698                  SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
  11699                  SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
  11700          
  11701                  SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
  11702                  #if ENABLED(HAVE_TMC2130)
  11703                    SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
  11704                    SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
  11705                    SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
  11706                  #endif
  11707                  SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
  11708                  SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
  11709                  SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
  11710                  SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
  11711                  SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
  11712                  SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
  11713                  SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
  11714                  #if ENABLED(HAVE_TMC2208)
  11715                    SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
  11716                    SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
  11717                    SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
  11718                    SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
  11719                    SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
  11720                    SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
  11721                  #endif
  11722                  SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
  11723                }
  11724              }
  11725            #endif
  11726          
  11727            template<typename TMC>
  11728            static void tmc_get_current(TMC &st, const char name[]) {
  11729              SERIAL_ECHO(name);
  11730              SERIAL_ECHOPGM(" axis driver current: ");
  11731              SERIAL_ECHOLN(st.getCurrent());
  11732            }
  11733            template<typename TMC>
  11734            static void tmc_set_current(TMC &st, const char name[], const int mA) {
  11735              st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
  11736              tmc_get_current(st, name);
  11737            }
  11738          
  11739            template<typename TMC>
  11740            static void tmc_report_otpw(TMC &st, const char name[]) {
  11741              SERIAL_ECHO(name);
  11742              SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
  11743              serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
  11744              SERIAL_EOL();
  11745            }
  11746            template<typename TMC>
  11747            static void tmc_clear_otpw(TMC &st, const char name[]) {
  11748              st.clear_otpw();
  11749              SERIAL_ECHO(name);
  11750              SERIAL_ECHOLNPGM(" prewarn flag cleared");
  11751            }
  11752          
  11753            template<typename TMC>
  11754            static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
  11755              SERIAL_ECHO(name);
  11756              SERIAL_ECHOPGM(" stealthChop max speed set to ");
  11757              SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
  11758            }
  11759            template<typename TMC>
  11760            static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
  11761              st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
  11762              tmc_get_pwmthrs(st, name, spmm);
  11763            }
  11764          
  11765            template<typename TMC>
  11766            static void tmc_get_sgt(TMC &st, const char name[]) {
  11767              SERIAL_ECHO(name);
  11768              SERIAL_ECHOPGM(" driver homing sensitivity set to ");
  11769              MYSERIAL.println(st.sgt(), DEC);
  11770            }
  11771            template<typename TMC>
  11772            static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
  11773              st.sgt(sgt_val);
  11774              tmc_get_sgt(st, name);
  11775            }
  11776          
  11777            /**
  11778             * M906: Set motor current in milliamps using axis codes X, Y, Z, E
  11779             * Report driver currents when no axis specified
  11780             */
  11781            inline void gcode_M906() {
  11782              uint16_t values[XYZE];
  11783              LOOP_XYZE(i)
  11784                values[i] = parser.intval(axis_codes[i]);
  11785          
  11786              #if X_IS_TRINAMIC
  11787                if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
  11788                else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
  11789              #endif
  11790              #if X2_IS_TRINAMIC
  11791                if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
  11792                else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
  11793              #endif
  11794              #if Y_IS_TRINAMIC
  11795                if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
  11796                else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
  11797              #endif
  11798              #if Y2_IS_TRINAMIC
  11799                if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
  11800                else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
  11801              #endif
  11802              #if Z_IS_TRINAMIC
  11803                if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
  11804                else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
  11805              #endif
  11806              #if Z2_IS_TRINAMIC
  11807                if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
  11808                else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
  11809              #endif
  11810              #if E0_IS_TRINAMIC
  11811                if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
  11812                else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
  11813              #endif
  11814              #if E1_IS_TRINAMIC
  11815                if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
  11816                else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
  11817              #endif
  11818              #if E2_IS_TRINAMIC
  11819                if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
  11820                else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
  11821              #endif
  11822              #if E3_IS_TRINAMIC
  11823                if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
  11824                else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
  11825              #endif
  11826              #if E4_IS_TRINAMIC
  11827                if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
  11828                else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
  11829              #endif
  11830          
  11831            }
  11832          
  11833            /**
  11834             * M911: Report TMC stepper driver overtemperature pre-warn flag
  11835             * The flag is held by the library and persist until manually cleared by M912
  11836             */
  11837            inline void gcode_M911() {
  11838              #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11839                tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
  11840              #endif
  11841              #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11842                tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
  11843              #endif
  11844              #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11845                tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
  11846              #endif
  11847              #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11848                tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
  11849              #endif
  11850            }
  11851          
  11852            /**
  11853             * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
  11854             */
  11855            inline void gcode_M912() {
  11856              const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
  11857                       clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
  11858              #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
  11859                if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
  11860              #endif
  11861              #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
  11862                if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
  11863              #endif
  11864          
  11865              #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
  11866                if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
  11867              #endif
  11868          
  11869              #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
  11870                if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
  11871              #endif
  11872          
  11873              #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
  11874                if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
  11875              #endif
  11876            }
  11877          
  11878            /**
  11879             * M913: Set HYBRID_THRESHOLD speed.
  11880             */
  11881            #if ENABLED(HYBRID_THRESHOLD)
  11882              inline void gcode_M913() {
  11883                uint16_t values[XYZE];
  11884                LOOP_XYZE(i)
  11885                  values[i] = parser.intval(axis_codes[i]);
  11886          
  11887                #if X_IS_TRINAMIC
  11888                  if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
  11889                  else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
  11890                #endif
  11891                #if X2_IS_TRINAMIC
  11892                  if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
  11893                  else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
  11894                #endif
  11895          
  11896                #if Y_IS_TRINAMIC
  11897                  if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
  11898                  else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
  11899                #endif
  11900                #if Y2_IS_TRINAMIC
  11901                  if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
  11902                  else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
  11903                #endif
  11904          
  11905                #if Z_IS_TRINAMIC
  11906                  if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
  11907                  else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
  11908                #endif
  11909                #if Z2_IS_TRINAMIC
  11910                  if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
  11911                  else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
  11912                #endif
  11913          
  11914                #if E0_IS_TRINAMIC
  11915                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11916                  else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
  11917                #endif
  11918                #if E1_IS_TRINAMIC
  11919                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11920                  else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
  11921                #endif
  11922                #if E2_IS_TRINAMIC
  11923                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11924                  else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
  11925                #endif
  11926                #if E3_IS_TRINAMIC
  11927                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11928                  else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
  11929                #endif
  11930                #if E4_IS_TRINAMIC
  11931                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11932                  else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
  11933                #endif
  11934              }
  11935            #endif // HYBRID_THRESHOLD
  11936          
  11937            /**
  11938             * M914: Set SENSORLESS_HOMING sensitivity.
  11939             */
  11940            #if ENABLED(SENSORLESS_HOMING)
  11941              inline void gcode_M914() {
  11942                #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
  11943                  if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
  11944                  else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
  11945                #endif
  11946                #if ENABLED(X2_IS_TMC2130)
  11947                  if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
  11948                  else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
  11949                #endif
  11950                #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
  11951                  if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
  11952                  else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
  11953                #endif
  11954                #if ENABLED(Y2_IS_TMC2130)
  11955                  if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
  11956                  else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
  11957                #endif
  11958              }
  11959            #endif // SENSORLESS_HOMING
  11960          
  11961            /**
  11962             * TMC Z axis calibration routine
  11963             */
  11964            #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
  11965              inline void gcode_M915() {
  11966                uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
  11967                uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
  11968          
  11969                if (!axis_known_position[Z_AXIS]) {
  11970                  SERIAL_ECHOLNPGM("\nPlease home Z axis first");
  11971                  return;
  11972                }
  11973          
  11974                uint16_t Z_current_1 = stepperZ.getCurrent();
  11975                uint16_t Z2_current_1 = stepperZ.getCurrent();
  11976          
  11977                stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
  11978                stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
  11979                SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
  11980          
  11981                soft_endstops_enabled = false;
  11982          
  11983                do_blocking_move_to_z(Z_MAX_POS+_z);
  11984          
  11985                stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
  11986                stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
  11987          
  11988                do_blocking_move_to_z(Z_MAX_POS);
  11989                soft_endstops_enabled = true;
  11990          
  11991                SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
  11992                home_z_safely();
  11993              }
  11994            #endif
  11995          
  11996          #endif // HAS_TRINAMIC
  11997          
  11998          /**
  11999           * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
  12000           */

   \                                 In section .text, align 2
  12001          inline void gcode_M907() {
  12002            #if HAS_DIGIPOTSS
  12003          
  12004              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
  12005              if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
  12006              if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
  12007          
  12008            #elif HAS_MOTOR_CURRENT_PWM
  12009          
  12010              #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
  12011                if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
  12012              #endif
  12013              #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
  12014                if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
  12015              #endif
  12016              #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
  12017                if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
  12018              #endif
  12019          
  12020            #endif
  12021          
  12022            #if ENABLED(DIGIPOT_I2C)
  12023              // this one uses actual amps in floating point
  12024              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
  12025              // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
  12026              for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
  12027            #endif
  12028          
  12029            #if ENABLED(DAC_STEPPER_CURRENT)
  12030              if (parser.seen('S')) {
  12031                const float dac_percent = parser.value_float();
  12032                for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
  12033              }
  12034              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
  12035            #endif
  12036          }
   \                     _Z10gcode_M907v: (+1)
   \   00000000   0x4770             BX       LR               ;; return
  12037          
  12038          #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  12039          
  12040            /**
  12041             * M908: Control digital trimpot directly (M908 P<pin> S<current>)
  12042             */
  12043            inline void gcode_M908() {
  12044              #if HAS_DIGIPOTSS
  12045                stepper.digitalPotWrite(
  12046                  parser.intval('P'),
  12047                  parser.intval('S')
  12048                );
  12049              #endif
  12050              #ifdef DAC_STEPPER_CURRENT
  12051                dac_current_raw(
  12052                  parser.byteval('P', -1),
  12053                  parser.ushortval('S', 0)
  12054                );
  12055              #endif
  12056            }
  12057          
  12058            #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  12059          
  12060              inline void gcode_M909() { dac_print_values(); }
  12061          
  12062              inline void gcode_M910() { dac_commit_eeprom(); }
  12063          
  12064            #endif
  12065          
  12066          #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  12067          
  12068          #if HAS_MICROSTEPS
  12069          
  12070            // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  12071            inline void gcode_M350() {
  12072              if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
  12073              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
  12074              if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
  12075              stepper.microstep_readings();
  12076            }
  12077          
  12078            /**
  12079             * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
  12080             *       S# determines MS1 or MS2, X# sets the pin high/low.
  12081             */
  12082            inline void gcode_M351() {
  12083              if (parser.seenval('S')) switch (parser.value_byte()) {
  12084                case 1:
  12085                  LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
  12086                  if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
  12087                  break;
  12088                case 2:
  12089                  LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
  12090                  if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
  12091                  break;
  12092              }
  12093              stepper.microstep_readings();
  12094            }
  12095          
  12096          #endif // HAS_MICROSTEPS
  12097          
  12098          #if HAS_CASE_LIGHT
  12099            #ifndef INVERT_CASE_LIGHT
  12100              #define INVERT_CASE_LIGHT false
  12101            #endif
  12102            uint8_t case_light_brightness;  // LCD routine wants INT
  12103            bool case_light_on;
  12104          
  12105            void update_case_light() {
  12106              pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
  12107              if (case_light_on) {
  12108                if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
  12109                  analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
  12110                else
  12111                  WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
  12112              }
  12113              else {
  12114                if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
  12115                  analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
  12116                else
  12117                  WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
  12118              }
  12119            }
  12120          #endif // HAS_CASE_LIGHT
  12121          
  12122          /**
  12123           * M355: Turn case light on/off and set brightness
  12124           *
  12125           *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
  12126           *
  12127           *   S<bool>  Set case light on/off
  12128           *
  12129           *   When S turns on the light on a PWM pin then the current brightness level is used/restored
  12130           *
  12131           *   M355 P200 S0 turns off the light & sets the brightness level
  12132           *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
  12133           */

   \                                 In section .text, align 4
  12134          inline void gcode_M355() {
   \                     _Z10gcode_M355v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  12135            #if HAS_CASE_LIGHT
  12136              uint8_t args = 0;
  12137              if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
  12138              if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
  12139              if (args) update_case_light();
  12140          
  12141              // always report case light status
  12142              SERIAL_ECHO_START();
  12143              if (!case_light_on) {
  12144                SERIAL_ECHOLN("Case light: off");
  12145              }
  12146              else {
  12147                if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
  12148                else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
  12149              }
  12150          
  12151            #else
  12152              SERIAL_ERROR_START();
   \   00000002   0x4804             LDR.N    R0,??gcode_M355_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12153              SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
   \   00000008   0x4803             LDR.N    R0,??gcode_M355_0+0x4
   \   0000000A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \   00000012   0xBF00             Nop      
   \                     ??gcode_M355_0:
   \   00000014   0x........         DC32     errormagic
   \   00000018   0x........         DC32     _ZZ10gcode_M355vEs
  12154            #endif // HAS_CASE_LIGHT
  12155          }
  12156          
  12157          #if ENABLED(MIXING_EXTRUDER)
  12158          
  12159            /**
  12160             * M163: Set a single mix factor for a mixing extruder
  12161             *       This is called "weight" by some systems.
  12162             *
  12163             *   S[index]   The channel index to set
  12164             *   P[float]   The mix value
  12165             *
  12166             */
  12167            inline void gcode_M163() {
  12168              const int mix_index = parser.intval('S');
  12169              if (mix_index < MIXING_STEPPERS) {
  12170                float mix_value = parser.floatval('P');
  12171                NOLESS(mix_value, 0.0);
  12172                mixing_factor[mix_index] = RECIPROCAL(mix_value);
  12173              }
  12174            }
  12175          
  12176            #if MIXING_VIRTUAL_TOOLS > 1
  12177          
  12178              /**
  12179               * M164: Store the current mix factors as a virtual tool.
  12180               *
  12181               *   S[index]   The virtual tool to store
  12182               *
  12183               */
  12184              inline void gcode_M164() {
  12185                const int tool_index = parser.intval('S');
  12186                if (tool_index < MIXING_VIRTUAL_TOOLS) {
  12187                  normalize_mix();
  12188                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  12189                    mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
  12190                }
  12191              }
  12192          
  12193            #endif
  12194          
  12195            #if ENABLED(DIRECT_MIXING_IN_G1)
  12196              /**
  12197               * M165: Set multiple mix factors for a mixing extruder.
  12198               *       Factors that are left out will be set to 0.
  12199               *       All factors together must add up to 1.0.
  12200               *
  12201               *   A[factor] Mix factor for extruder stepper 1
  12202               *   B[factor] Mix factor for extruder stepper 2
  12203               *   C[factor] Mix factor for extruder stepper 3
  12204               *   D[factor] Mix factor for extruder stepper 4
  12205               *   H[factor] Mix factor for extruder stepper 5
  12206               *   I[factor] Mix factor for extruder stepper 6
  12207               *
  12208               */
  12209              inline void gcode_M165() { gcode_get_mix(); }
  12210            #endif
  12211          
  12212          #endif // MIXING_EXTRUDER
  12213          
  12214          /**
  12215           * M999: Restart after being stopped
  12216           *
  12217           * Default behaviour is to flush the serial buffer and request
  12218           * a resend to the host starting on the last N line received.
  12219           *
  12220           * Sending "M999 S1" will resume printing without flushing the
  12221           * existing command buffer.
  12222           *
  12223           */

   \                                 In section .text, align 4
  12224          inline void gcode_M999() {
   \                     _Z10gcode_M999v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  12225            Running = true;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4906             LDR.N    R1,??gcode_M999_0
   \   00000006   0x7108             STRB     R0,[R1, #+4]
  12226            lcd_reset_alert_level();
   \   00000008   0x.... 0x....      BL       _Z21lcd_reset_alert_levelv
  12227          
  12228            if (parser.boolval('S')) return;
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD103             BNE.N    ??gcode_M999_1
  12229          
  12230            // gcode_LastN = Stopped_gcode_LastN;
  12231            FlushSerialRequestResend();
   \   00000016   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001A   0x.... 0x....      B.W      _Z24FlushSerialRequestResendv
   \                     ??gcode_M999_1: (+1)
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M999_0:
   \   00000020   0x........         DC32     axis_relative_modes
  12232          }
  12233          
  12234          #if ENABLED(SWITCHING_EXTRUDER)
  12235            #if EXTRUDERS > 3
  12236              #define REQ_ANGLES 4
  12237              #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
  12238            #else
  12239              #define REQ_ANGLES 2
  12240              #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
  12241            #endif
  12242            inline void move_extruder_servo(const uint8_t e) {
  12243              constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
  12244              static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
  12245              stepper.synchronize();
  12246              #if EXTRUDERS & 1
  12247                if (e < EXTRUDERS - 1)
  12248              #endif
  12249              {
  12250                MOVE_SERVO(_SERVO_NR, angles[e]);
  12251                safe_delay(500);
  12252              }
  12253            }
  12254          #endif // SWITCHING_EXTRUDER
  12255          
  12256          #if ENABLED(SWITCHING_NOZZLE)
  12257            inline void move_nozzle_servo(const uint8_t e) {
  12258              const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
  12259              stepper.synchronize();
  12260              MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
  12261              safe_delay(500);
  12262            }
  12263          #endif
  12264          

   \                                 In section .text, align 4
  12265          inline void invalid_extruder_error(const uint8_t e) {
   \                     _Z22invalid_extruder_errorh: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
  12266            SERIAL_ECHO_START();
   \   00000004   0x480D             LDR.N    R0,??invalid_extruder_error_0
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12267            SERIAL_CHAR('T');
   \   0000000A   0x4D0D             LDR.N    R5,??invalid_extruder_error_0+0x4
   \   0000000C   0x2154             MOVS     R1,#+84
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  12268            SERIAL_ECHO_F(e, DEC);
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _ZN5Print5printEhi
  12269            SERIAL_CHAR(' ');
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  12270            SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
   \   00000026   0x4907             LDR.N    R1,??invalid_extruder_error_0+0x8
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000036   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000003A   0xBF00             Nop      
   \                     ??invalid_extruder_error_0:
   \   0000003C   0x........         DC32     echomagic
   \   00000040   0x........         DC32     Serial3
   \   00000044   0x........         DC32     _ZZ22invalid_extruder_errorhEs
  12271          }
  12272          
  12273          #if ENABLED(PARKING_EXTRUDER)
  12274          
  12275            #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  12276              #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
  12277            #else
  12278              #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
  12279            #endif
  12280          
  12281            void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
  12282              switch (extruder_num) {
  12283                case 1: OUT_WRITE(SOL1_PIN, state); break;
  12284                default: OUT_WRITE(SOL0_PIN, state); break;
  12285              }
  12286              #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
  12287                dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
  12288              #endif
  12289            }
  12290          
  12291            inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
  12292            inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
  12293          
  12294          #endif // PARKING_EXTRUDER
  12295          
  12296          #if HAS_FANMUX
  12297          
  12298            void fanmux_switch(const uint8_t e) {
  12299              WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
  12300              #if PIN_EXISTS(FANMUX1)
  12301                WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
  12302                #if PIN_EXISTS(FANMUX2)
  12303                  WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
  12304                #endif
  12305              #endif
  12306            }
  12307          
  12308            FORCE_INLINE void fanmux_init(void) {
  12309              SET_OUTPUT(FANMUX0_PIN);
  12310              #if PIN_EXISTS(FANMUX1)
  12311                SET_OUTPUT(FANMUX1_PIN);
  12312                #if PIN_EXISTS(FANMUX2)
  12313                  SET_OUTPUT(FANMUX2_PIN);
  12314                #endif
  12315              #endif
  12316              fanmux_switch(0);
  12317            }
  12318          
  12319          #endif // HAS_FANMUX
  12320          
  12321          /**
  12322           * Perform a tool-change, which may result in moving the
  12323           * previous tool out of the way and the new tool into place.
  12324           */

   \                                 In section .text, align 2, keep-with-next
  12325          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   \                     _Z11tool_changehfb: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB099             SUB      SP,SP,#+100
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x4615             MOV      R5,R2
  12326            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  12327          
  12328              if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
  12329                return invalid_extruder_error(tmp_extruder);
  12330          
  12331              // T0-Tnnn: Switch virtual tool by changing the mix
  12332              for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
  12333                mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
  12334          
  12335            #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  12336          
  12337              if (tmp_extruder >= EXTRUDERS)
   \   0000000C   0x46B2             MOV      R10,R6
   \   0000000E   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000012   0xDB03             BLT.N    ??tool_change_0
  12338                return invalid_extruder_error(tmp_extruder);
   \   00000014   0x4630             MOV      R0,R6
   \   00000016   0x.... 0x....      BL       _Z22invalid_extruder_errorh
   \   0000001A   0xE0F2             B.N      ??tool_change_1
  12339          
  12340              #if HOTENDS > 1
  12341          
  12342                const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
   \                     ??tool_change_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R4,??DataTable158_1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000026   0xD201             BCS.N    ??tool_change_2
   \   00000028   0x9006             STR      R0,[SP, #+24]
   \   0000002A   0xE001             B.N      ??tool_change_3
   \                     ??tool_change_2: (+1)
   \   0000002C   0x6DE1             LDR      R1,[R4, #+92]
   \   0000002E   0x9106             STR      R1,[SP, #+24]
  12343          
  12344                feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \                     ??tool_change_3: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000036   0xD201             BCS.N    ??tool_change_4
   \   00000038   0x65E0             STR      R0,[R4, #+92]
   \   0000003A   0xE001             B.N      ??tool_change_5
   \                     ??tool_change_4: (+1)
   \   0000003C   0x6F60             LDR      R0,[R4, #+116]
   \   0000003E   0x65E0             STR      R0,[R4, #+92]
  12345          
  12346                if (tmp_extruder != active_extruder) {
   \                     ??tool_change_5: (+1)
   \   00000040   0x78E0             LDRB     R0,[R4, #+3]
   \   00000042   0x4286             CMP      R6,R0
   \   00000044   0xF000 0x80CC      BEQ.W    ??tool_change_6
  12347                  if (!no_move && axis_unhomed_error()) {
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD107             BNE.N    ??tool_change_7
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x4611             MOV      R1,R2
   \   00000050   0x4608             MOV      R0,R1
   \   00000052   0x.... 0x....      BL       _Z18axis_unhomed_errorbbb
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD000             BEQ.N    ??tool_change_7
  12348                    no_move = true;
   \   0000005A   0x2501             MOVS     R5,#+1
  12349                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12350                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
  12351                    #endif
  12352                  }
  12353          
  12354                  // Save current position to destination, for use later
  12355                  //if(gCfgItems.breakpoint_flg!=1)
  12356                      set_destination_from_current();
   \                     ??tool_change_7: (+1)
   \   0000005C   0x.... 0x....      BL       _Z28set_destination_from_currentv
  12357          
  12358                  #if ENABLED(DUAL_X_CARRIAGE)
  12359          
  12360                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12361                      if (DEBUGGING(LEVELING)) {
  12362                        SERIAL_ECHOPGM("Dual X Carriage Mode ");
  12363                        switch (dual_x_carriage_mode) {
  12364                          case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
  12365                          case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
  12366                          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
  12367                        }
  12368                      }
  12369                    #endif
  12370          
  12371                    const float xhome = x_home_pos(active_extruder);
  12372                    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
  12373                        && IsRunning()
  12374                        && (delayed_move_time || current_position[X_AXIS] != xhome)
  12375                    ) {
  12376                      float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
  12377                      //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
  12378                      if(mksCfg.max_software_endstops){
  12379                        NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
  12380                      }
  12381                      //#endif
  12382                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12383                        if (DEBUGGING(LEVELING)) {
  12384                          SERIAL_ECHOLNPAIR("Raise to ", raised_z);
  12385                          SERIAL_ECHOLNPAIR("MoveX to ", xhome);
  12386                          SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
  12387                        }
  12388                      #endif
  12389                      // Park old head: 1) raise 2) move to park position 3) lower
  12390                      for (uint8_t i = 0; i < 3; i++)
  12391                        planner.buffer_line(
  12392                          i == 0 ? current_position[X_AXIS] : xhome,
  12393                          current_position[Y_AXIS],
  12394                          i == 2 ? current_position[Z_AXIS] : raised_z,
  12395                          current_position[E_AXIS],
  12396                          planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
  12397                          active_extruder
  12398                        );
  12399                      stepper.synchronize();
  12400                    }
  12401          
  12402                    // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
  12403                    current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
  12404                    current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  12405          
  12406                    // Activate the new extruder ahead of calling set_axis_is_at_home!
  12407                    active_extruder = tmp_extruder;
  12408          
  12409                    // This function resets the max/min values - the current position may be overwritten below.
  12410                    set_axis_is_at_home(X_AXIS);
  12411          
  12412                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12413                      if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
  12414                    #endif
  12415          
  12416                    // Only when auto-parking are carriages safe to move
  12417                    if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
  12418          
  12419                    switch (dual_x_carriage_mode) {
  12420                      case DXC_FULL_CONTROL_MODE:
  12421                        // New current position is the position of the activated extruder
  12422                        current_position[X_AXIS] = inactive_extruder_x_pos;
  12423                        // Save the inactive extruder's position (from the old current_position)
  12424                        inactive_extruder_x_pos = destination[X_AXIS];
  12425                        break;
  12426                      case DXC_AUTO_PARK_MODE:
  12427                        // record raised toolhead position for use by unpark
  12428                        COPY(raised_parked_position, current_position);
  12429                        raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
  12430                        //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
  12431                        if(mksCfg.max_software_endstops){
  12432                          NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
  12433                        }
  12434                        //#endif
  12435                        active_extruder_parked = true;
  12436                        delayed_move_time = 0;
  12437                        break;
  12438                      case DXC_DUPLICATION_MODE:
  12439                        // If the new extruder is the left one, set it "parked"
  12440                        // This triggers the second extruder to move into the duplication position
  12441                        active_extruder_parked = (active_extruder == 0);
  12442          
  12443                        if (active_extruder_parked)
  12444                          current_position[X_AXIS] = inactive_extruder_x_pos;
  12445                        else
  12446                          current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
  12447                        inactive_extruder_x_pos = destination[X_AXIS];
  12448                        extruder_duplication_enabled = false;
  12449                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12450                          if (DEBUGGING(LEVELING)) {
  12451                            SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
  12452                            SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
  12453                          }
  12454                        #endif
  12455                        break;
  12456                    }
  12457          
  12458                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12459                      if (DEBUGGING(LEVELING)) {
  12460                        SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
  12461                        DEBUG_POS("New extruder (parked)", current_position);
  12462                      }
  12463                    #endif
  12464          
  12465                    // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
  12466          
  12467                  #else // !DUAL_X_CARRIAGE
  12468          
  12469                    #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
  12470                      const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  12471                      float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
  12472                      if (!no_move) {
  12473          
  12474                        const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
  12475                                    midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
  12476                                    grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
  12477                                              + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
  12478                        /**
  12479                         *  Steps:
  12480                         *    1. Raise Z-Axis to give enough clearance
  12481                         *    2. Move to park position of old extruder
  12482                         *    3. Disengage magnetic field, wait for delay
  12483                         *    4. Move near new extruder
  12484                         *    5. Engage magnetic field for new extruder
  12485                         *    6. Move to parking incl. offset of new extruder
  12486                         *    7. Lower Z-Axis
  12487                         */
  12488          
  12489                        // STEP 1
  12490                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12491                          SERIAL_ECHOLNPGM("Starting Autopark");
  12492                          if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
  12493                        #endif
  12494                        current_position[Z_AXIS] += z_raise;
  12495                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12496                          SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
  12497                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
  12498                        #endif
  12499                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
  12500                        stepper.synchronize();
  12501          
  12502                        // STEP 2
  12503                        current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
  12504                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12505                          SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
  12506                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
  12507                        #endif
  12508                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12509                        stepper.synchronize();
  12510          
  12511                        // STEP 3
  12512                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12513                          SERIAL_ECHOLNPGM("(3) Disengage magnet ");
  12514                        #endif
  12515                        pe_deactivate_magnet(active_extruder);
  12516          
  12517                        // STEP 4
  12518                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12519                          SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
  12520                        #endif
  12521                        current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
  12522          
  12523                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12524                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
  12525                        #endif
  12526                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12527                        stepper.synchronize();
  12528          
  12529                        // STEP 5
  12530                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12531                          SERIAL_ECHOLNPGM("(5) Engage magnetic field");
  12532                        #endif
  12533          
  12534                        #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  12535                          pe_activate_magnet(active_extruder); //just save power for inverted magnets
  12536                        #endif
  12537                        pe_activate_magnet(tmp_extruder);
  12538          
  12539                        // STEP 6
  12540                        current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
  12541                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12542                        current_position[X_AXIS] = grabpos;
  12543                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12544                          SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
  12545                          if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
  12546                        #endif
  12547                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
  12548                        stepper.synchronize();
  12549          
  12550                        // Step 7
  12551                        current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
  12552                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12553                          SERIAL_ECHOLNPGM("(7) Move midway between hotends");
  12554                          if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
  12555                        #endif
  12556                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12557                        stepper.synchronize();
  12558                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12559                          SERIAL_ECHOLNPGM("Autopark done.");
  12560                        #endif
  12561                      }
  12562                      else { // nomove == true
  12563                        // Only engage magnetic field for new extruder
  12564                        pe_activate_magnet(tmp_extruder);
  12565                        #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  12566                          pe_activate_magnet(active_extruder); // Just save power for inverted magnets
  12567                        #endif
  12568                      }
  12569                      current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
  12570          
  12571                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12572                        if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
  12573                      #endif
  12574          
  12575                    #endif // dualParking extruder
  12576          
  12577                    #if ENABLED(SWITCHING_NOZZLE)
  12578                      #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
  12579                      // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
  12580                      const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
  12581                                  z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
  12582          
  12583                      // Always raise by some amount (destination copied from current_position earlier)
  12584                      current_position[Z_AXIS] += z_raise;
  12585                      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
  12586                      move_nozzle_servo(tmp_extruder);
  12587                    #endif
  12588          
  12589                    /**
  12590                     * Set current_position to the position of the new nozzle.
  12591                     * Offsets are based on linear distance, so we need to get
  12592                     * the resulting position in coordinate space.
  12593                     *
  12594                     * - With grid or 3-point leveling, offset XYZ by a tilted vector
  12595                     * - With mesh leveling, update Z for the new position
  12596                     * - Otherwise, just use the raw linear distance
  12597                     *
  12598                     * Software endstops are altered here too. Consider a case where:
  12599                     *   E0 at X=0 ... E1 at X=10
  12600                     * When we switch to E1 now X=10, but E1 can't move left.
  12601                     * To express this we apply the change in XY to the software endstops.
  12602                     * E1 can move farther right than E0, so the right limit is extended.
  12603                     *
  12604                     * Note that we don't adjust the Z software endstops. Why not?
  12605                     * Consider a case where Z=0 (here) and switching to E1 makes Z=1
  12606                     * because the bed is 1mm lower at the new position. As long as
  12607                     * the first nozzle is out of the way, the carriage should be
  12608                     * allowed to move 1mm lower. This technically "breaks" the
  12609                     * Z software endstop. But this is technically correct (and
  12610                     * there is no viable alternative).
  12611                     */
  12612                    //#if ABL_PLANAR
  12613                    float xydiff[2]={0};
   \   00000060   0xF04F 0x0800      MOV      R8,#+0
   \   00000064   0x46C1             MOV      R9,R8
   \   00000066   0x.... 0x....      LDR.W    R7,??DataTable162_1
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable160
   \   0000006E   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000072   0x2106             MOVS     R1,#+6
   \   00000074   0x4208             TST      R0,R1
   \   00000076   0xD045             BEQ.N    ??tool_change_8
  12614          		  if(BED_LEVELING_METHOD&ABL_PLANAR)
  12615          		  	{
  12616                      // Offset extruder, make sure to apply the bed level rotation matrix
  12617                      vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
  12618                                                         hotend_offset[Y_AXIS][tmp_extruder],
  12619                                                         0),
   \   00000078   0x.... 0x....      LDR.W    R9,??DataTable162_2
   \   0000007C   0x4643             MOV      R3,R8
   \   0000007E   0xEB09 0x008A      ADD      R0,R9,R10, LSL #+2
   \   00000082   0x6882             LDR      R2,[R0, #+8]
   \   00000084   0xF859 0x102A      LDR      R1,[R9, R10, LSL #+2]
   \   00000088   0xA80D             ADD      R0,SP,#+52
   \   0000008A   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   0000008E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000090   0x4643             MOV      R3,R8
   \   00000092   0xEB09 0x0180      ADD      R1,R9,R0, LSL #+2
   \   00000096   0x688A             LDR      R2,[R1, #+8]
   \   00000098   0xF859 0x1020      LDR      R1,[R9, R0, LSL #+2]
   \   0000009C   0xA80A             ADD      R0,SP,#+40
  12620                               act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
  12621                                                         hotend_offset[Y_AXIS][active_extruder],
  12622                                                         0),
   \   0000009E   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   000000A2   0xA80A             ADD      R0,SP,#+40
   \   000000A4   0xB082             SUB      SP,SP,#+8
   \   000000A6   0x4669             MOV      R1,SP
   \   000000A8   0xC80C             LDM      R0!,{R2,R3}
   \   000000AA   0xC10C             STM      R1!,{R2,R3}
   \   000000AC   0x6802             LDR      R2,[R0, #0]
   \   000000AE   0x600A             STR      R2,[R1, #+0]
   \   000000B0   0xBC0C             POP      {R2,R3}
   \   000000B2   0xA90D             ADD      R1,SP,#+52
   \   000000B4   0xA801             ADD      R0,SP,#+4
   \   000000B6   0x.... 0x....      BL       _ZN8vector_3miES_
  12623                               offset_vec = tmp_offset_vec - act_offset_vec;
   \   000000BA   0xA807             ADD      R0,SP,#+28
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0xE8B1 0x100C      LDM      R1!,{R2,R3,R12}
   \   000000C2   0xE8A0 0x100C      STM      R0!,{R2,R3,R12}
  12624          
  12625                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12626                        if (DEBUGGING(LEVELING)) {
  12627                          tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
  12628                          act_offset_vec.debug(PSTR("act_offset_vec"));
  12629                          offset_vec.debug(PSTR("offset_vec (BEFORE)"));
  12630                        }
  12631                      #endif
  12632          
  12633                      offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable162_3
   \   000000CA   0xB083             SUB      SP,SP,#+12
   \   000000CC   0x4668             MOV      R0,SP
   \   000000CE   0x2224             MOVS     R2,#+36
   \   000000D0   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000D4   0xBC0E             POP      {R1-R3}
   \   000000D6   0xA810             ADD      R0,SP,#+64
   \   000000D8   0x.... 0x....      BL       _ZN10matrix_3x39transposeES_
   \   000000DC   0xA910             ADD      R1,SP,#+64
   \   000000DE   0xB083             SUB      SP,SP,#+12
   \   000000E0   0x4668             MOV      R0,SP
   \   000000E2   0x2224             MOVS     R2,#+36
   \   000000E4   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000E8   0xBC0E             POP      {R1-R3}
   \   000000EA   0xA807             ADD      R0,SP,#+28
   \   000000EC   0x.... 0x....      BL       _ZN8vector_314apply_rotationE10matrix_3x3
  12634          
  12635                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12636                        if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
  12637                      #endif
  12638          
  12639                      // Adjustments to the current position
  12640                      //const float xydiff[2] = { offset_vec.x, offset_vec.y };
  12641          			xydiff[0] = offset_vec.x;
   \   000000F0   0xF8DD 0x801C      LDR      R8,[SP, #+28]
  12642          			xydiff[1] = offset_vec.y;
   \   000000F4   0xF8DD 0x9020      LDR      R9,[SP, #+32]
  12643                      current_position[Z_AXIS] += offset_vec.z;
   \   000000F8   0x6921             LDR      R1,[R4, #+16]
   \   000000FA   0x9809             LDR      R0,[SP, #+36]
   \   000000FC   0x.... 0x....      BL       __aeabi_fadd
   \   00000100   0x6120             STR      R0,[R4, #+16]
   \   00000102   0xE043             B.N      ??tool_change_9
  12644          		  }
  12645                    //#else // !ABL_PLANAR
  12646          			else
  12647          			{
  12648          				/*
  12649                      		const float xydiff[2] = {
  12650                        			hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
  12651                       	 		hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
  12652                      		};*/
  12653                      if(gCfgItems.breakpoint_flg!=1)
   \                     ??tool_change_8: (+1)
   \   00000104   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   00000108   0x2801             CMP      R0,#+1
   \   0000010A   0xD013             BEQ.N    ??tool_change_10
   \   0000010C   0xF894 0xB003      LDRB     R11,[R4, #+3]
   \   00000110   0x.... 0x....      LDR.W    R9,??DataTable162_2
   \   00000114   0xF859 0x002A      LDR      R0,[R9, R10, LSL #+2]
   \   00000118   0xF859 0x102B      LDR      R1,[R9, R11, LSL #+2]
   \   0000011C   0x.... 0x....      BL       __aeabi_fsub
   \   00000120   0x4680             MOV      R8,R0
  12654                      {
  12655          			    xydiff[0] = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
  12656          			    xydiff[1] = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
   \   00000122   0xEB09 0x008A      ADD      R0,R9,R10, LSL #+2
   \   00000126   0x6880             LDR      R0,[R0, #+8]
   \   00000128   0xEB09 0x018B      ADD      R1,R9,R11, LSL #+2
   \   0000012C   0x6889             LDR      R1,[R1, #+8]
   \   0000012E   0x.... 0x....      BL       __aeabi_fsub
   \   00000132   0x4681             MOV      R9,R0
  12657                      }
  12658          				
  12659                      //#if ENABLED(MESH_BED_LEVELING)
  12660          			if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??tool_change_10: (+1)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable160
   \   00000138   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000013C   0x2820             CMP      R0,#+32
   \   0000013E   0xD125             BNE.N    ??tool_change_9
  12661          			{
  12662                        if (planner.leveling_active) {
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable162_4
   \   00000144   0x7800             LDRB     R0,[R0, #+0]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD020             BEQ.N    ??tool_change_9
  12663                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  12664                            if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
  12665                          #endif
  12666                          float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
   \   0000014A   0x68A0             LDR      R0,[R4, #+8]
   \   0000014C   0x4641             MOV      R1,R8
   \   0000014E   0x.... 0x....      BL       __aeabi_fadd
   \   00000152   0x9003             STR      R0,[SP, #+12]
  12667                                y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
   \   00000154   0x68E0             LDR      R0,[R4, #+12]
   \   00000156   0x4649             MOV      R1,R9
   \   00000158   0x.... 0x....      BL       __aeabi_fadd
   \   0000015C   0x9002             STR      R0,[SP, #+8]
  12668                                z1 = current_position[Z_AXIS], z2 = z1;
   \   0000015E   0x6920             LDR      R0,[R4, #+16]
   \   00000160   0x9000             STR      R0,[SP, #+0]
   \   00000162   0x9001             STR      R0,[SP, #+4]
  12669                          planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
   \   00000164   0xAA00             ADD      R2,SP,#+0
   \   00000166   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000016A   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000016E   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
  12670                          planner.apply_leveling(x2, y2, z2);
   \   00000172   0xAA01             ADD      R2,SP,#+4
   \   00000174   0xA902             ADD      R1,SP,#+8
   \   00000176   0xA803             ADD      R0,SP,#+12
   \   00000178   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
  12671                          current_position[Z_AXIS] += z2 - z1;
   \   0000017C   0x9801             LDR      R0,[SP, #+4]
   \   0000017E   0x9900             LDR      R1,[SP, #+0]
   \   00000180   0x.... 0x....      BL       __aeabi_fsub
   \   00000184   0x6921             LDR      R1,[R4, #+16]
   \   00000186   0x.... 0x....      BL       __aeabi_fadd
   \   0000018A   0x6120             STR      R0,[R4, #+16]
  12672                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  12673                            if (DEBUGGING(LEVELING))
  12674                              SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
  12675                          #endif
  12676                        }
  12677          			}
  12678                      //#endif // MESH_BED_LEVELING
  12679          				}
  12680                    //#endif // !HAS_ABL
  12681          
  12682                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12683                      if (DEBUGGING(LEVELING)) {
  12684                        SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
  12685                        SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
  12686                        SERIAL_ECHOLNPGM(" }");
  12687                      }
  12688                    #endif
  12689          
  12690                    // The newly-selected extruder XY is actually at...
  12691                    if(gCfgItems.breakpoint_flg!=1)
   \                     ??tool_change_9: (+1)
   \   0000018C   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   00000190   0x2801             CMP      R0,#+1
   \   00000192   0xD009             BEQ.N    ??tool_change_11
  12692                    {
  12693                      current_position[X_AXIS] += xydiff[X_AXIS];
   \   00000194   0x68A0             LDR      R0,[R4, #+8]
   \   00000196   0x4641             MOV      R1,R8
   \   00000198   0x.... 0x....      BL       __aeabi_fadd
   \   0000019C   0x60A0             STR      R0,[R4, #+8]
  12694                      current_position[Y_AXIS] += xydiff[Y_AXIS];
   \   0000019E   0x68E0             LDR      R0,[R4, #+12]
   \   000001A0   0x4649             MOV      R1,R9
   \   000001A2   0x.... 0x....      BL       __aeabi_fadd
   \   000001A6   0x60E0             STR      R0,[R4, #+12]
  12695                    }
  12696                    // Set the new active extruder
  12697                    active_extruder = tmp_extruder;
   \                     ??tool_change_11: (+1)
   \   000001A8   0x70E6             STRB     R6,[R4, #+3]
  12698          
  12699                  #endif // !DUAL_X_CARRIAGE
  12700          
  12701                  #if ENABLED(DEBUG_LEVELING_FEATURE)
  12702                    if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
  12703                  #endif
  12704          
  12705                  // Tell the planner the new "current position"
  12706                  if(gCfgItems.breakpoint_flg!=1)
   \   000001AA   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   000001AE   0x2801             CMP      R0,#+1
   \   000001B0   0xD001             BEQ.N    ??tool_change_12
  12707                      SYNC_PLAN_POSITION_KINEMATIC();
   \   000001B2   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
  12708          
  12709                  // Move to the "old position" (move the extruder into place)
  12710                  #if ENABLED(SWITCHING_NOZZLE)
  12711                    destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
  12712                  #endif
  12713                  if (!no_move && IsRunning()) {
   \                     ??tool_change_12: (+1)
   \   000001B6   0x2D00             CMP      R5,#+0
   \   000001B8   0xD112             BNE.N    ??tool_change_6
   \   000001BA   0x.... 0x....      BL       _Z9IsRunningv
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD00E             BEQ.N    ??tool_change_6
  12714                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12715                      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
  12716                    #endif
  12717                    // Move back to the original (or tweaked) position
  12718                    if(gCfgItems.breakpoint_flg!=1)
   \   000001C2   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xD00A             BEQ.N    ??tool_change_6
  12719                      do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x9000             STR      R0,[SP, #+0]
   \   000001CE   0xAB00             ADD      R3,SP,#+0
   \   000001D0   0xF104 0x0220      ADD      R2,R4,#+32
   \   000001D4   0xF104 0x011C      ADD      R1,R4,#+28
   \   000001D8   0xF104 0x0018      ADD      R0,R4,#+24
   \   000001DC   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
  12720                  }
  12721                  #if ENABLED(SWITCHING_NOZZLE)
  12722                    else {
  12723                      // Move back down. (Including when the new tool is higher.)
  12724                      do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
  12725                    }
  12726                  #endif
  12727                } // (tmp_extruder != active_extruder)
  12728          
  12729                stepper.synchronize();
   \                     ??tool_change_6: (+1)
   \   000001E0   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  12730          
  12731                #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
  12732                  disable_all_solenoids();
  12733                  enable_solenoid_on_active_extruder();
  12734                #endif // EXT_SOLENOID
  12735          
  12736                feedrate_mm_s = old_feedrate_mm_s;
   \   000001E4   0x9806             LDR      R0,[SP, #+24]
   \   000001E6   0x65E0             STR      R0,[R4, #+92]
  12737          
  12738              #else // HOTENDS <= 1
  12739          
  12740                UNUSED(fr_mm_s);
  12741                UNUSED(no_move);
  12742          
  12743                #if ENABLED(MK2_MULTIPLEXER)
  12744                  if (tmp_extruder >= E_STEPPERS)
  12745                    return invalid_extruder_error(tmp_extruder);
  12746          
  12747                  select_multiplexed_stepper(tmp_extruder);
  12748                #endif
  12749          
  12750                // Set the new active extruder
  12751                active_extruder = tmp_extruder;
  12752          
  12753              #endif // HOTENDS <= 1
  12754          
  12755              #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
  12756                stepper.synchronize();
  12757                move_extruder_servo(active_extruder);
  12758              #endif
  12759          
  12760              #if HAS_FANMUX
  12761                fanmux_switch(active_extruder);
  12762              #endif
  12763          
  12764              SERIAL_ECHO_START();
   \   000001E8   0x....             LDR.N    R0,??DataTable157_8
   \   000001EA   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12765              SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
   \   000001EE   0x78E1             LDRB     R1,[R4, #+3]
   \   000001F0   0x.... 0x....      ADR.W    R0,`?<Constant "Active Extruder: ">`
   \   000001F4   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   000001F8   0x210A             MOVS     R1,#+10
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable163
   \   000001FE   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  12766          
  12767            #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  12768          }
   \                     ??tool_change_1: (+1)
   \   00000202   0xB019             ADD      SP,SP,#+100
   \   00000204   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  12769          
  12770          /**
  12771           * T0-T3: Switch tool, usually switching extruders
  12772           *
  12773           *   F[units/min] Set the movement feedrate
  12774           *   S1           Don't move the tool in XY after change
  12775           */

   \                                 In section .text, align 4
  12776          inline void gcode_T(const uint8_t tmp_extruder) {
   \                     _Z7gcode_Th: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
  12777          
  12778            #if ENABLED(DEBUG_LEVELING_FEATURE)
  12779              if (DEBUGGING(LEVELING)) {
  12780                SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
  12781                SERIAL_CHAR(')');
  12782                SERIAL_EOL();
  12783                DEBUG_POS("BEFORE", current_position);
  12784              }
  12785            #endif
  12786          
  12787            #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
  12788          
  12789              tool_change(tmp_extruder);
  12790          
  12791            #elif HOTENDS > 1
  12792          
  12793              tool_change(
  12794                tmp_extruder,
  12795                MMM_TO_MMS(parser.linearval('F')),
  12796                (tmp_extruder == active_extruder) || parser.boolval('S')
  12797              );
   \   00000004   0x480B             LDR.N    R0,??gcode_T_0
   \   00000006   0x78C0             LDRB     R0,[R0, #+3]
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??gcode_T_1
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000012   0x4605             MOV      R5,R0
   \   00000014   0xE000             B.N      ??gcode_T_2
   \                     ??gcode_T_1: (+1)
   \   00000016   0x2501             MOVS     R5,#+1
   \                     ??gcode_T_2: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x2046             MOVS     R0,#+70
   \   0000001C   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   00000020   0x4905             LDR.N    R1,??gcode_T_0+0x4  ;; 0x42700000
   \   00000022   0x.... 0x....      BL       __aeabi_fdiv
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x462A             MOV      R2,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000030   0x.... 0x....      B.W      _Z11tool_changehfb
   \                     ??gcode_T_0:
   \   00000034   0x........         DC32     mks_heating_busy
   \   00000038   0x42700000         DC32     0x42700000
  12798          
  12799            #endif
  12800          
  12801            #if ENABLED(DEBUG_LEVELING_FEATURE)
  12802              if (DEBUGGING(LEVELING)) {
  12803                DEBUG_POS("AFTER", current_position);
  12804                SERIAL_ECHOLNPGM("<<< gcode_T");
  12805              }
  12806            #endif
  12807          }
  12808          
  12809          /**
  12810           * Process the parsed command and dispatch it to its handler
  12811           */

   \                                 In section .text, align 2, keep-with-next
  12812          void process_parsed_command() {
   \                     _Z22process_parsed_commandv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  12813            KEEPALIVE_STATE(IN_HANDLER);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable163_1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x71A0             STRB     R0,[R4, #+6]
  12814          
  12815            // Handle a known G, M, or T
  12816            switch (parser.command_letter) {
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable162_5
   \   0000000E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000012   0x2847             CMP      R0,#+71
   \   00000014   0xD006             BEQ.N    ??process_parsed_command_0
   \   00000016   0x284D             CMP      R0,#+77
   \   00000018   0xF000 0x80B3      BEQ.W    ??process_parsed_command_1
   \   0000001C   0x2854             CMP      R0,#+84
   \   0000001E   0xF000 0x8375      BEQ.W    ??process_parsed_command_2
   \   00000022   0xE37A             B.N      ??process_parsed_command_3
  12817              case 'G': switch (parser.codenum) {
   \                     ??process_parsed_command_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable163_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0001             MOVS     R1,R0
   \   0000002C   0xD01D             BEQ.N    ??process_parsed_command_4
   \   0000002E   0x2901             CMP      R1,#+1
   \   00000030   0xD01B             BEQ.N    ??process_parsed_command_4
   \   00000032   0x2902             CMP      R1,#+2
   \   00000034   0xD029             BEQ.N    ??process_parsed_command_5
   \   00000036   0x2903             CMP      R1,#+3
   \   00000038   0xD027             BEQ.N    ??process_parsed_command_5
   \   0000003A   0x2904             CMP      R1,#+4
   \   0000003C   0xD02D             BEQ.N    ??process_parsed_command_6
   \   0000003E   0x291A             CMP      R1,#+26
   \   00000040   0xD02E             BEQ.N    ??process_parsed_command_7
   \   00000042   0x291C             CMP      R1,#+28
   \   00000044   0xD035             BEQ.N    ??process_parsed_command_8
   \   00000046   0x291D             CMP      R1,#+29
   \   00000048   0xD061             BEQ.N    ??process_parsed_command_9
   \   0000004A   0x291E             CMP      R1,#+30
   \   0000004C   0xF000 0x808A      BEQ.W    ??process_parsed_command_10
   \   00000050   0x292A             CMP      R1,#+42
   \   00000052   0xF000 0x8093      BEQ.W    ??process_parsed_command_11
   \   00000056   0x295A             CMP      R1,#+90
   \   00000058   0xF000 0x8087      BEQ.W    ??process_parsed_command_12
   \   0000005C   0x295B             CMP      R1,#+91
   \   0000005E   0xF000 0x8087      BEQ.W    ??process_parsed_command_13
   \   00000062   0x295C             CMP      R1,#+92
   \   00000064   0xF000 0x8087      BEQ.W    ??process_parsed_command_14
   \   00000068   0xE35B             B.N      ??process_parsed_command_15
  12818          
  12819                // G0, G1
  12820                case 0:
  12821                case 1:
  12822                  //#if IS_SCARA
  12823                  if(MACHINETPYE&IS_SCARA)
   \                     ??process_parsed_command_4: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable163_3
   \   0000006E   0x8C89             LDRH     R1,[R1, #+36]
   \   00000070   0xF44F 0x7240      MOV      R2,#+768
   \   00000074   0x4211             TST      R1,R2
   \   00000076   0xD005             BEQ.N    ??process_parsed_command_16
  12824                    gcode_G0_G1_SCARA(parser.codenum == 0);
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x4180             SBCS     R0,R0,R0
   \   0000007C   0x0FC0             LSRS     R0,R0,#+31
   \   0000007E   0x.... 0x....      BL       _Z17gcode_G0_G1_SCARAb
   \   00000082   0xE34E             B.N      ??process_parsed_command_15
  12825                  //#else
  12826                  else
  12827                    gcode_G0_G1();
   \                     ??process_parsed_command_16: (+1)
   \   00000084   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000088   0xE34B             B.N      ??process_parsed_command_15
  12828                  //#endif
  12829                  break;
  12830          
  12831                // G2, G3
  12832                #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
  12833                  case 2: // G2: CW ARC
  12834                  case 3: // G3: CCW ARC
  12835                    gcode_G2_G3(parser.codenum == 2);
   \                     ??process_parsed_command_5: (+1)
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xD101             BNE.N    ??process_parsed_command_17
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE000             B.N      ??process_parsed_command_18
   \                     ??process_parsed_command_17: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \                     ??process_parsed_command_18: (+1)
   \   00000094   0x.... 0x....      BL       _Z11gcode_G2_G3b
  12836                    break;
   \   00000098   0xE343             B.N      ??process_parsed_command_15
  12837                #endif
  12838          
  12839                // G4 Dwell
  12840                case 4:
  12841                  gcode_G4();
   \                     ??process_parsed_command_6: (+1)
   \   0000009A   0x.... 0x....      BL       _Z8gcode_G4v
  12842                  break;
   \   0000009E   0xE340             B.N      ??process_parsed_command_15
  12843          
  12844                #if ENABLED(BEZIER_CURVE_SUPPORT)
  12845                  case 5: // G5: Cubic B_spline
  12846                    gcode_G5();
  12847                    break;
  12848                #endif // BEZIER_CURVE_SUPPORT
  12849          
  12850                #if ENABLED(FWRETRACT)
  12851                  case 10: // G10: retract
  12852                    gcode_G10();
  12853                    break;
  12854                  case 11: // G11: retract_recover
  12855                    gcode_G11();
  12856                    break;
  12857                #endif // FWRETRACT
  12858          
  12859                #if ENABLED(NOZZLE_CLEAN_FEATURE)
  12860                  case 12:
  12861                    gcode_G12(); // G12: Nozzle Clean
  12862                    break;
  12863                #endif // NOZZLE_CLEAN_FEATURE
  12864          
  12865                #if ENABLED(CNC_WORKSPACE_PLANES)
  12866                  case 17: // G17: Select Plane XY
  12867                    gcode_G17();
  12868                    break;
  12869                  case 18: // G18: Select Plane ZX
  12870                    gcode_G18();
  12871                    break;
  12872                  case 19: // G19: Select Plane YZ
  12873                    gcode_G19();
  12874                    break;
  12875                #endif // CNC_WORKSPACE_PLANES
  12876          
  12877                #if ENABLED(INCH_MODE_SUPPORT)
  12878                  case 20: // G20: Inch Mode
  12879                    gcode_G20();
  12880                    break;
  12881          
  12882                  case 21: // G21: MM Mode
  12883                    gcode_G21();
  12884                    break;
  12885                #endif // INCH_MODE_SUPPORT
  12886          
  12887                //#if ENABLED(G26_MESH_VALIDATION)
  12888                  case 26: // G26: Mesh Validation Pattern generation
  12889                  if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
   \                     ??process_parsed_command_7: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   000000A4   0x7B00             LDRB     R0,[R0, #+12]
   \   000000A6   0x06C0             LSLS     R0,R0,#+27
   \   000000A8   0xF140 0x833B      BPL.W    ??process_parsed_command_15
  12890                    gcode_G26();
   \   000000AC   0x.... 0x....      BL       _Z9gcode_G26v
   \   000000B0   0xE337             B.N      ??process_parsed_command_15
  12891                    break;
  12892                //#endif // G26_MESH_VALIDATION
  12893          
  12894                #if ENABLED(NOZZLE_PARK_FEATURE)
  12895                  case 27: // G27: Nozzle Park
  12896                    gcode_G27();
  12897                    break;
  12898                #endif // NOZZLE_PARK_FEATURE
  12899          
  12900                case 28: // G28: Home all axes, one at a time
  12901                  #if 1
  12902                	if (gCfgItems.breakpoint_reprint_flg == 1) break;
   \                     ??process_parsed_command_8: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable162_1
   \   000000B6   0xF890 0x0148      LDRB     R0,[R0, #+328]
   \   000000BA   0x2801             CMP      R0,#+1
   \   000000BC   0xF000 0x8331      BEQ.W    ??process_parsed_command_15
  12903                  #endif
  12904                  gcode_G28(false);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       _Z9gcode_G28b
  12905          		if((BED_LEVELING_METHOD & HAS_LEVELING) && (BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL))
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable160
   \   000000CA   0xF100 0x0534      ADD      R5,R0,#+52
   \   000000CE   0x7B28             LDRB     R0,[R5, #+12]
   \   000000D0   0x213E             MOVS     R1,#+62
   \   000000D2   0x4208             TST      R0,R1
   \   000000D4   0xF000 0x8325      BEQ.W    ??process_parsed_command_15
   \   000000D8   0x2810             CMP      R0,#+16
   \   000000DA   0xF000 0x8322      BEQ.W    ??process_parsed_command_15
  12906          		{
  12907          			 set_bed_leveling_enabled(true);
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
  12908          			#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  12909          				if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
   \   000000E4   0xF9B5 0x0024      LDRSH    R0,[R5, #+36]
   \   000000E8   0x2802             CMP      R0,#+2
   \   000000EA   0xF000 0x831A      BEQ.W    ??process_parsed_command_15
   \   000000EE   0x7B28             LDRB     R0,[R5, #+12]
   \   000000F0   0x06C0             LSLS     R0,R0,#+27
   \   000000F2   0xF140 0x8316      BPL.W    ??process_parsed_command_15
  12910          				 { 
  12911          				 	if (parser.seenval('Z')) set_z_fade_height(parser.value_linear_units()/*code_value_linear_units()*/);
   \   000000F6   0x205A             MOVS     R0,#+90
   \   000000F8   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xF000 0x8310      BEQ.W    ??process_parsed_command_15
   \   00000102   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000106   0x2101             MOVS     R1,#+1
   \   00000108   0x.... 0x....      BL       _Z17set_z_fade_heightfb
   \   0000010C   0xE309             B.N      ??process_parsed_command_15
  12912          				 }
  12913          			#endif
  12914                    }
  12915                  break;
  12916          
  12917                //#if HAS_LEVELING
  12918                  case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
  12919                           // or provides access to the UBL System if enabled.
  12920          		if(BED_LEVELING_METHOD&HAS_LEVELING)	 
   \                     ??process_parsed_command_9: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable160
   \   00000112   0xF100 0x0534      ADD      R5,R0,#+52
   \   00000116   0x7B28             LDRB     R0,[R5, #+12]
   \   00000118   0x213E             MOVS     R1,#+62
   \   0000011A   0x4208             TST      R0,R1
   \   0000011C   0xD016             BEQ.N    ??process_parsed_command_19
  12921          		{
  12922          			switch(BED_LEVELING_METHOD)	 /*--mks cfg-- MESH_BED_LEVELING */ 
   \   0000011E   0x2802             CMP      R0,#+2
   \   00000120   0xD00C             BEQ.N    ??process_parsed_command_20
   \   00000122   0x2804             CMP      R0,#+4
   \   00000124   0xD00A             BEQ.N    ??process_parsed_command_20
   \   00000126   0x2808             CMP      R0,#+8
   \   00000128   0xD008             BEQ.N    ??process_parsed_command_20
   \   0000012A   0x2810             CMP      R0,#+16
   \   0000012C   0xD00B             BEQ.N    ??process_parsed_command_21
   \   0000012E   0x2820             CMP      R0,#+32
   \   00000130   0xD10C             BNE.N    ??process_parsed_command_19
  12923          			{
  12924          				case MESH_BED_LEVELING:
  12925          					gcode_G29_MESH_BED_LEVELING();
   \   00000132   0x.... 0x....      BL       _Z27gcode_G29_MESH_BED_LEVELINGv
  12926          					(void)settings.save();
   \   00000136   0x.... 0x....      BL       _ZN14MarlinSettings4saveEv
  12927          				break;
   \   0000013A   0xE2F2             B.N      ??process_parsed_command_15
  12928          				case AUTO_BED_LEVELING_3POINT:
  12929          				case AUTO_BED_LEVELING_LINEAR:
  12930          				case AUTO_BED_LEVELING_BILINEAR:
  12931          					gcode_G29();
   \                     ??process_parsed_command_20: (+1)
   \   0000013C   0x.... 0x....      BL       _Z9gcode_G29v
  12932          					(void)settings.save();
   \   00000140   0x.... 0x....      BL       _ZN14MarlinSettings4saveEv
  12933          				break;
   \   00000144   0xE2ED             B.N      ??process_parsed_command_15
  12934          				case AUTO_BED_LEVELING_UBL:
  12935          					gcode_G29_UBL();
   \                     ??process_parsed_command_21: (+1)
   \   00000146   0x.... 0x....      BL       _Z13gcode_G29_UBLv
  12936          				break;
   \   0000014A   0xE2EA             B.N      ??process_parsed_command_15
  12937          				default:
  12938          					SERIAL_PROTOCOL("bed leveling hasn't defined!");
  12939          					SERIAL_EOL();
  12940          				break;
  12941          			}
  12942          		}
  12943          		else
  12944          		{
  12945          			SERIAL_PROTOCOL("bed leveling hasn't defined!");
   \                     ??process_parsed_command_19: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R5,??DataTable163
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable163_4
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x.... 0x....      BL       _ZN5Print5printEPKc
  12946          			SERIAL_EOL();
   \   0000015A   0x210A             MOVS     R1,#+10
   \   0000015C   0x4628             MOV      R0,R5
   \   0000015E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000162   0xE2DE             B.N      ??process_parsed_command_15
  12947          		}
  12948          
  12949                  break;
  12950                //#endif // HAS_LEVELING
  12951          
  12952                #if HAS_BED_PROBE
  12953          
  12954                  case 30: // G30 Single Z probe
  12955                    gcode_G30();
   \                     ??process_parsed_command_10: (+1)
   \   00000164   0x.... 0x....      BL       _Z9gcode_G30v
  12956                    break;
   \   00000168   0xE2DB             B.N      ??process_parsed_command_15
  12957          
  12958                  #if ENABLED(Z_PROBE_SLED)
  12959          
  12960                      case 31: // G31: dock the sled
  12961                        gcode_G31();
  12962                        break;
  12963          
  12964                      case 32: // G32: undock the sled
  12965                        gcode_G32();
  12966                        break;
  12967          
  12968                  #endif // Z_PROBE_SLED
  12969          
  12970                #endif // HAS_BED_PROBE
  12971          
  12972                #if ENABLED(DELTA_AUTO_CALIBRATION)
  12973          
  12974                  case 33: // G33: Delta Auto-Calibration
  12975                    gcode_G33();
  12976                    break;
  12977          
  12978                #endif // DELTA_AUTO_CALIBRATION
  12979          
  12980                #if ENABLED(G38_PROBE_TARGET)
  12981                  case 38: // G38.2 & G38.3
  12982                    if (parser.subcode == 2 || parser.subcode == 3)
  12983                      gcode_G38(parser.subcode == 2);
  12984                    break;
  12985                #endif
  12986          
  12987                case 90: // G90
  12988                  relative_mode = false;
   \                     ??process_parsed_command_12: (+1)
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x7160             STRB     R0,[R4, #+5]
  12989                  break;
   \   0000016E   0xE2D8             B.N      ??process_parsed_command_15
  12990                case 91: // G91
  12991                  relative_mode = true;
   \                     ??process_parsed_command_13: (+1)
   \   00000170   0x2001             MOVS     R0,#+1
   \   00000172   0x7160             STRB     R0,[R4, #+5]
  12992                  break;
   \   00000174   0xE2D5             B.N      ??process_parsed_command_15
  12993          
  12994                case 92: // G92
  12995                  gcode_G92();
   \                     ??process_parsed_command_14: (+1)
   \   00000176   0x.... 0x....      BL       _Z9gcode_G92v
  12996                  break;
   \   0000017A   0xE2D2             B.N      ??process_parsed_command_15
  12997          
  12998                #if HAS_MESH
  12999                  case 42:
  13000                    gcode_G42();
   \                     ??process_parsed_command_11: (+1)
   \   0000017C   0x.... 0x....      BL       _Z9gcode_G42v
  13001                    break;
   \   00000180   0xE2CF             B.N      ??process_parsed_command_15
  13002                #endif
  13003          
  13004                #if ENABLED(DEBUG_GCODE_PARSER)
  13005                  case 800:
  13006                    parser.debug(); // GCode Parser Test for G
  13007                    break;
  13008                #endif
  13009              }
  13010              break;
  13011          
  13012              case 'M': switch (parser.codenum) {
   \                     ??process_parsed_command_1: (+1)
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable163_2
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0x3811             SUBS     R0,R0,#+17
   \   0000018A   0xF000 0x80FC      BEQ.W    ??process_parsed_command_22
   \   0000018E   0x1E40             SUBS     R0,R0,#+1
   \   00000190   0xF000 0x81BB      BEQ.W    ??process_parsed_command_23
   \   00000194   0x1E80             SUBS     R0,R0,#+2
   \   00000196   0xF000 0x80F9      BEQ.W    ??process_parsed_command_24
   \   0000019A   0x1E40             SUBS     R0,R0,#+1
   \   0000019C   0x2801             CMP      R0,#+1
   \   0000019E   0xF240 0x80F8      BLS.W    ??process_parsed_command_25
   \   000001A2   0x1E80             SUBS     R0,R0,#+2
   \   000001A4   0xF000 0x80F8      BEQ.W    ??process_parsed_command_26
   \   000001A8   0x1E40             SUBS     R0,R0,#+1
   \   000001AA   0xF000 0x80F8      BEQ.W    ??process_parsed_command_27
   \   000001AE   0x1E40             SUBS     R0,R0,#+1
   \   000001B0   0xF000 0x810D      BEQ.W    ??process_parsed_command_28
   \   000001B4   0x1E40             SUBS     R0,R0,#+1
   \   000001B6   0xF000 0x8132      BEQ.W    ??process_parsed_command_29
   \   000001BA   0x1E40             SUBS     R0,R0,#+1
   \   000001BC   0xF000 0x8132      BEQ.W    ??process_parsed_command_30
   \   000001C0   0x1E40             SUBS     R0,R0,#+1
   \   000001C2   0xF000 0x8132      BEQ.W    ??process_parsed_command_31
   \   000001C6   0x1E40             SUBS     R0,R0,#+1
   \   000001C8   0xF000 0x8132      BEQ.W    ??process_parsed_command_32
   \   000001CC   0x1E40             SUBS     R0,R0,#+1
   \   000001CE   0xF000 0x8132      BEQ.W    ??process_parsed_command_33
   \   000001D2   0x1E40             SUBS     R0,R0,#+1
   \   000001D4   0xF000 0x8138      BEQ.W    ??process_parsed_command_34
   \   000001D8   0x1E40             SUBS     R0,R0,#+1
   \   000001DA   0xF000 0x812F      BEQ.W    ??process_parsed_command_35
   \   000001DE   0x380A             SUBS     R0,R0,#+10
   \   000001E0   0xF000 0x8135      BEQ.W    ??process_parsed_command_36
   \   000001E4   0x1FC0             SUBS     R0,R0,#+7
   \   000001E6   0xF000 0x8135      BEQ.W    ??process_parsed_command_37
   \   000001EA   0x381A             SUBS     R0,R0,#+26
   \   000001EC   0xF000 0x813B      BEQ.W    ??process_parsed_command_38
   \   000001F0   0x1E40             SUBS     R0,R0,#+1
   \   000001F2   0xF000 0x813B      BEQ.W    ??process_parsed_command_39
   \   000001F6   0x1E40             SUBS     R0,R0,#+1
   \   000001F8   0xF000 0x813B      BEQ.W    ??process_parsed_command_40
   \   000001FC   0x1F00             SUBS     R0,R0,#+4
   \   000001FE   0xF000 0x817B      BEQ.W    ??process_parsed_command_41
   \   00000202   0x1E40             SUBS     R0,R0,#+1
   \   00000204   0xF000 0x817B      BEQ.W    ??process_parsed_command_42
   \   00000208   0x1E40             SUBS     R0,R0,#+1
   \   0000020A   0xF000 0x817B      BEQ.W    ??process_parsed_command_43
   \   0000020E   0x1E40             SUBS     R0,R0,#+1
   \   00000210   0xF000 0x817B      BEQ.W    ??process_parsed_command_23
   \   00000214   0x1E40             SUBS     R0,R0,#+1
   \   00000216   0xF000 0x817B      BEQ.W    ??process_parsed_command_44
   \   0000021A   0x1FC0             SUBS     R0,R0,#+7
   \   0000021C   0xF000 0x817B      BEQ.W    ??process_parsed_command_45
   \   00000220   0x380C             SUBS     R0,R0,#+12
   \   00000222   0xF000 0x8129      BEQ.W    ??process_parsed_command_46
   \   00000226   0x1E40             SUBS     R0,R0,#+1
   \   00000228   0xF000 0x8148      BEQ.W    ??process_parsed_command_47
   \   0000022C   0x1E40             SUBS     R0,R0,#+1
   \   0000022E   0xF000 0x815D      BEQ.W    ??process_parsed_command_48
   \   00000232   0x1E40             SUBS     R0,R0,#+1
   \   00000234   0xF000 0x815D      BEQ.W    ??process_parsed_command_49
   \   00000238   0x1E40             SUBS     R0,R0,#+1
   \   0000023A   0xF000 0x8126      BEQ.W    ??process_parsed_command_50
   \   0000023E   0x1E40             SUBS     R0,R0,#+1
   \   00000240   0xF000 0x8144      BEQ.W    ??process_parsed_command_51
   \   00000244   0x1E40             SUBS     R0,R0,#+1
   \   00000246   0xF000 0x811A      BEQ.W    ??process_parsed_command_52
   \   0000024A   0x1E40             SUBS     R0,R0,#+1
   \   0000024C   0xF000 0x811A      BEQ.W    ??process_parsed_command_53
   \   00000250   0x1E40             SUBS     R0,R0,#+1
   \   00000252   0xF000 0x811D      BEQ.W    ??process_parsed_command_54
   \   00000256   0x1E40             SUBS     R0,R0,#+1
   \   00000258   0xF000 0x8120      BEQ.W    ??process_parsed_command_55
   \   0000025C   0x1E40             SUBS     R0,R0,#+1
   \   0000025E   0xF000 0x815D      BEQ.W    ??process_parsed_command_56
   \   00000262   0x1E40             SUBS     R0,R0,#+1
   \   00000264   0xF000 0x815D      BEQ.W    ??process_parsed_command_57
   \   00000268   0x1E80             SUBS     R0,R0,#+2
   \   0000026A   0xF000 0x815D      BEQ.W    ??process_parsed_command_58
   \   0000026E   0x1E40             SUBS     R0,R0,#+1
   \   00000270   0xF000 0x815D      BEQ.W    ??process_parsed_command_59
   \   00000274   0x1E40             SUBS     R0,R0,#+1
   \   00000276   0xF000 0x815D      BEQ.W    ??process_parsed_command_60
   \   0000027A   0x1E40             SUBS     R0,R0,#+1
   \   0000027C   0xF000 0x815D      BEQ.W    ??process_parsed_command_61
   \   00000280   0x1E40             SUBS     R0,R0,#+1
   \   00000282   0xF000 0x815D      BEQ.W    ??process_parsed_command_62
   \   00000286   0x3813             SUBS     R0,R0,#+19
   \   00000288   0xF000 0x810B      BEQ.W    ??process_parsed_command_63
   \   0000028C   0x380F             SUBS     R0,R0,#+15
   \   0000028E   0xF000 0x811A      BEQ.W    ??process_parsed_command_64
   \   00000292   0x3823             SUBS     R0,R0,#+35
   \   00000294   0xF000 0x811D      BEQ.W    ??process_parsed_command_65
   \   00000298   0x380A             SUBS     R0,R0,#+10
   \   0000029A   0xF000 0x8154      BEQ.W    ??process_parsed_command_66
   \   0000029E   0x1E40             SUBS     R0,R0,#+1
   \   000002A0   0xF000 0x8154      BEQ.W    ??process_parsed_command_67
   \   000002A4   0x1E80             SUBS     R0,R0,#+2
   \   000002A6   0xF000 0x8154      BEQ.W    ??process_parsed_command_68
   \   000002AA   0x1E40             SUBS     R0,R0,#+1
   \   000002AC   0xF000 0x8154      BEQ.W    ??process_parsed_command_69
   \   000002B0   0x1E40             SUBS     R0,R0,#+1
   \   000002B2   0xF000 0x8154      BEQ.W    ??process_parsed_command_70
   \   000002B6   0x1E40             SUBS     R0,R0,#+1
   \   000002B8   0xF000 0x8154      BEQ.W    ??process_parsed_command_71
   \   000002BC   0x1F40             SUBS     R0,R0,#+5
   \   000002BE   0xF000 0x8177      BEQ.W    ??process_parsed_command_72
   \   000002C2   0x1FC0             SUBS     R0,R0,#+7
   \   000002C4   0xF000 0x8177      BEQ.W    ??process_parsed_command_73
   \   000002C8   0x1E80             SUBS     R0,R0,#+2
   \   000002CA   0xF000 0x8177      BEQ.W    ??process_parsed_command_74
   \   000002CE   0x1E40             SUBS     R0,R0,#+1
   \   000002D0   0xF000 0x8177      BEQ.W    ??process_parsed_command_75
   \   000002D4   0x1F40             SUBS     R0,R0,#+5
   \   000002D6   0xF000 0x8177      BEQ.W    ??process_parsed_command_76
   \   000002DA   0x3836             SUBS     R0,R0,#+54
   \   000002DC   0xF000 0x8177      BEQ.W    ??process_parsed_command_77
   \   000002E0   0x3815             SUBS     R0,R0,#+21
   \   000002E2   0xF000 0x8177      BEQ.W    ??process_parsed_command_78
   \   000002E6   0x1E40             SUBS     R0,R0,#+1
   \   000002E8   0xF000 0x8186      BEQ.W    ??process_parsed_command_79
   \   000002EC   0x1E40             SUBS     R0,R0,#+1
   \   000002EE   0xF000 0x8186      BEQ.W    ??process_parsed_command_80
   \   000002F2   0x1E40             SUBS     R0,R0,#+1
   \   000002F4   0xF000 0x8177      BEQ.W    ??process_parsed_command_81
   \   000002F8   0x3833             SUBS     R0,R0,#+51
   \   000002FA   0xF000 0x8201      BEQ.W    ??process_parsed_command_82
   \   000002FE   0x1F40             SUBS     R0,R0,#+5
   \   00000300   0xF000 0x8180      BEQ.W    ??process_parsed_command_83
   \   00000304   0x1E40             SUBS     R0,R0,#+1
   \   00000306   0xF000 0x818B      BEQ.W    ??process_parsed_command_84
   \   0000030A   0x1E40             SUBS     R0,R0,#+1
   \   0000030C   0xF000 0x8194      BEQ.W    ??process_parsed_command_85
   \   00000310   0x1E40             SUBS     R0,R0,#+1
   \   00000312   0xF000 0x819D      BEQ.W    ??process_parsed_command_86
   \   00000316   0x1E40             SUBS     R0,R0,#+1
   \   00000318   0xF000 0x81A6      BEQ.W    ??process_parsed_command_87
   \   0000031C   0x3824             SUBS     R0,R0,#+36
   \   0000031E   0xF000 0x81AF      BEQ.W    ??process_parsed_command_88
   \   00000322   0x1E40             SUBS     R0,R0,#+1
   \   00000324   0xF000 0x81AF      BEQ.W    ??process_parsed_command_89
   \   00000328   0x1E40             SUBS     R0,R0,#+1
   \   0000032A   0xF000 0x81AF      BEQ.W    ??process_parsed_command_90
   \   0000032E   0x3808             SUBS     R0,R0,#+8
   \   00000330   0xF000 0x80B1      BEQ.W    ??process_parsed_command_91
   \   00000334   0x380A             SUBS     R0,R0,#+10
   \   00000336   0xF000 0x81AC      BEQ.W    ??process_parsed_command_92
   \   0000033A   0x1E40             SUBS     R0,R0,#+1
   \   0000033C   0xF000 0x81B2      BEQ.W    ??process_parsed_command_93
   \   00000340   0x1FC0             SUBS     R0,R0,#+7
   \   00000342   0xF000 0x81C2      BEQ.W    ??process_parsed_command_94
   \   00000346   0x3848             SUBS     R0,R0,#+72
   \   00000348   0xF000 0x81C8      BEQ.W    ??process_parsed_command_95
   \   0000034C   0x1E40             SUBS     R0,R0,#+1
   \   0000034E   0xF000 0x81C8      BEQ.W    ??process_parsed_command_96
   \   00000352   0x1E40             SUBS     R0,R0,#+1
   \   00000354   0xF000 0x81C8      BEQ.W    ??process_parsed_command_97
   \   00000358   0x1E40             SUBS     R0,R0,#+1
   \   0000035A   0xF000 0x81C8      BEQ.W    ??process_parsed_command_98
   \   0000035E   0x38A2             SUBS     R0,R0,#+162
   \   00000360   0xF000 0x810A      BEQ.W    ??process_parsed_command_99
   \   00000364   0x1E40             SUBS     R0,R0,#+1
   \   00000366   0xF000 0x8111      BEQ.W    ??process_parsed_command_100
   \   0000036A   0x38B9             SUBS     R0,R0,#+185
   \   0000036C   0xF000 0x81C2      BEQ.W    ??process_parsed_command_101
   \   00000370   0x3838             SUBS     R0,R0,#+56
   \   00000372   0xF000 0x81C2      BEQ.W    ??process_parsed_command_102
   \   00000376   0x3815             SUBS     R0,R0,#+21
   \   00000378   0xD063             BEQ.N    ??process_parsed_command_103
   \   0000037A   0x3846             SUBS     R0,R0,#+70
   \   0000037C   0xD04C             BEQ.N    ??process_parsed_command_104
   \   0000037E   0x1E40             SUBS     R0,R0,#+1
   \   00000380   0xF000 0x81C1      BEQ.W    ??process_parsed_command_105
   \   00000384   0xE1CD             B.N      ??process_parsed_command_15
  13013                #if HAS_RESUME_CONTINUE
  13014                  case 0: // M0: Unconditional stop - Wait for user button press on LCD
  13015                  case 1: // M1: Conditional stop - Wait for user button press on LCD
  13016                    gcode_M0_M1();
  13017                    break;
  13018                #endif // ULTIPANEL
  13019          
  13020                #if ENABLED(SPINDLE_LASER_ENABLE)
  13021                  case 3:
  13022                    gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
  13023                    break;               // synchronizes with movement commands
  13024                  case 4:
  13025                    gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
  13026                    break;               // synchronizes with movement commands
  13027                  case 5:
  13028                    gcode_M5();     // M5 - turn spindle/laser off
  13029                    break;          // synchronizes with movement commands
  13030                #endif
  13031                case 17: // M17: Enable all stepper motors
  13032                  gcode_M17();
   \                     ??process_parsed_command_22: (+1)
   \   00000386   0x.... 0x....      BL       _Z9gcode_M17v
  13033                  break;
   \   0000038A   0xE1CA             B.N      ??process_parsed_command_15
  13034          
  13035                #if ENABLED(SDSUPPORT)
  13036                  case 20: // M20: list SD card
  13037                    gcode_M20(); break;
   \                     ??process_parsed_command_24: (+1)
   \   0000038C   0x.... 0x....      BL       _Z9gcode_M20v
   \   00000390   0xE1C7             B.N      ??process_parsed_command_15
  13038                  case 21: // M21: init SD card
  13039                    //gcode_M21(); break;
  13040                  case 22: // M22: release SD card
  13041                    gcode_M22(); break;
   \                     ??process_parsed_command_25: (+1)
   \   00000392   0x.... 0x....      BL       _Z9gcode_M22v
   \   00000396   0xE1C4             B.N      ??process_parsed_command_15
  13042                  case 23: // M23: Select file
  13043                    gcode_M23(); break;
   \                     ??process_parsed_command_26: (+1)
   \   00000398   0x.... 0x....      BL       _Z9gcode_M23v
   \   0000039C   0xE1C1             B.N      ??process_parsed_command_15
  13044                  case 24: // M24: Start SD print
  13045                    gcode_M24(); 
   \                     ??process_parsed_command_27: (+1)
   \   0000039E   0x.... 0x....      BL       _Z9gcode_M24v
  13046          
  13047                    if(mksReprint.mks_printer_state == MKS_WORKING)
   \   000003A2   0x.... 0x....      LDR.W    R0,??DataTable165
   \   000003A6   0xF890 0x081C      LDRB     R0,[R0, #+2076]
   \   000003AA   0x28A7             CMP      R0,#+167
   \   000003AC   0xF040 0x81B9      BNE.W    ??process_parsed_command_15
  13048                    {
  13049                      clear_cur_ui();
   \   000003B0   0x.... 0x....      BL       clear_cur_ui
  13050                      reset_file_info();
   \   000003B4   0x.... 0x....      BL       reset_file_info
  13051                      reset_print_time();
   \   000003B8   0x.... 0x....      BL       reset_print_time
  13052                      start_print_time();
   \   000003BC   0x.... 0x....      BL       start_print_time
  13053                      #if defined(TFT35)
  13054                      preview_gcode_prehandle(curFileName);
   \   000003C0   0x.... 0x....      LDR.W    R0,??DataTable165_1
   \   000003C4   0x.... 0x....      BL       preview_gcode_prehandle
  13055                      #endif
  13056                      draw_printing();            
   \   000003C8   0x.... 0x....      BL       draw_printing
   \   000003CC   0xE1A9             B.N      ??process_parsed_command_15
  13057                     }
  13058                    break;
  13059                  case 25: // M25: Pause SD print
  13060                      gcode_M25(); 
   \                     ??process_parsed_command_28: (+1)
   \   000003CE   0x.... 0x....      BL       _Z9gcode_M25v
  13061                      if(mksReprint.mks_printer_state == MKS_PAUSING)
   \   000003D2   0x.... 0x....      LDR.W    R5,??DataTable165
   \   000003D6   0xF895 0x081C      LDRB     R0,[R5, #+2076]
   \   000003DA   0x28A9             CMP      R0,#+169
   \   000003DC   0xF040 0x81A1      BNE.W    ??process_parsed_command_15
  13062                      {
  13063                      	stop_print_time();							
   \   000003E0   0x.... 0x....      BL       stop_print_time
  13064                      	clear_cur_ui();
   \   000003E4   0x.... 0x....      BL       clear_cur_ui
  13065                      
  13066                      	card.pauseSDPrint();
   \   000003E8   0x4628             MOV      R0,R5
   \   000003EA   0x.... 0x....      BL       _ZN10CardReader12pauseSDPrintEv
  13067                      	print_job_timer.pause();
   \   000003EE   0xF605 0x20E8      ADDW     R0,R5,#+2792
   \   000003F2   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
  13068          		#if defined(TFT35)
  13069                      	if(from_flash_pic==1)
   \   000003F6   0x.... 0x....      LDR.W    R0,??DataTable165_2
   \   000003FA   0x7800             LDRB     R0,[R0, #+0]
   \   000003FC   0x2801             CMP      R0,#+1
   \   000003FE   0xD104             BNE.N    ??process_parsed_command_106
  13070                      		flash_preview_begin = 1;
   \   00000400   0x2001             MOVS     R0,#+1
   \   00000402   0x.... 0x....      LDR.W    R1,??DataTable165_3
   \   00000406   0x7008             STRB     R0,[R1, #+0]
   \   00000408   0xE003             B.N      ??process_parsed_command_107
  13071                      	else
  13072                      		default_preview_flg = 1;							
   \                     ??process_parsed_command_106: (+1)
   \   0000040A   0x2001             MOVS     R0,#+1
   \   0000040C   0x.... 0x....      LDR.W    R1,??DataTable165_4
   \   00000410   0x7008             STRB     R0,[R1, #+0]
  13073          
  13074                      	draw_printing();
   \                     ??process_parsed_command_107: (+1)
   \   00000412   0x.... 0x....      BL       draw_printing
   \   00000416   0xE184             B.N      ??process_parsed_command_15
  13075                         #else
  13076                         draw_pause();
  13077          		#endif
  13078                      }          
  13079                    break;
  13080                  case 998:	//M998: Stop SD print
  13081                    gcode_M998(); break;			  
   \                     ??process_parsed_command_104: (+1)
   \   00000418   0x.... 0x....      BL       _Z10gcode_M998v
   \   0000041C   0xE181             B.N      ??process_parsed_command_15
  13082                  case 26: // M26: Set SD index
  13083                    gcode_M26(); break;
   \                     ??process_parsed_command_29: (+1)
   \   0000041E   0x.... 0x....      BL       _Z9gcode_M26v
   \   00000422   0xE17E             B.N      ??process_parsed_command_15
  13084                  case 27: // M27: Get SD status
  13085                    gcode_M27(); break;
   \                     ??process_parsed_command_30: (+1)
   \   00000424   0x.... 0x....      BL       _Z9gcode_M27v
   \   00000428   0xE17B             B.N      ??process_parsed_command_15
  13086                  case 28: // M28: Start SD write
  13087                    gcode_M28(); break;
   \                     ??process_parsed_command_31: (+1)
   \   0000042A   0x.... 0x....      BL       _Z9gcode_M28v
   \   0000042E   0xE178             B.N      ??process_parsed_command_15
  13088                  case 29: // M29: Stop SD write
  13089                    gcode_M29(); break;
   \                     ??process_parsed_command_32: (+1)
   \   00000430   0x.... 0x....      BL       _Z9gcode_M29v
   \   00000434   0xE175             B.N      ??process_parsed_command_15
  13090                  case 30: // M30 <filename> Delete File
  13091                    gcode_M30(); break;
   \                     ??process_parsed_command_33: (+1)
   \   00000436   0x.... 0x....      BL       _Z9gcode_M30v
   \   0000043A   0xE172             B.N      ??process_parsed_command_15
  13092                  case 32: // M32: Select file and start SD print
  13093                    gcode_M32(); break;
   \                     ??process_parsed_command_35: (+1)
   \   0000043C   0x.... 0x....      BL       _Z9gcode_M32v
   \   00000440   0xE16F             B.N      ??process_parsed_command_15
  13094          
  13095                  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
  13096                    case 33: // M33: Get the long full path to a file or folder
  13097                      gcode_M33(); break;
  13098                  #endif
  13099          
  13100                  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
  13101                    case 34: // M34: Set SD card sorting options
  13102                      gcode_M34(); break;
  13103                  #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
  13104          
  13105                  case 928: // M928: Start SD write
  13106                    gcode_M928(); break;
   \                     ??process_parsed_command_103: (+1)
   \   00000442   0x.... 0x....      BL       _Z10gcode_M928v
   \   00000446   0xE16C             B.N      ??process_parsed_command_15
  13107                #endif // SDSUPPORT
  13108          
  13109                case 31: // M31: Report time since the start of SD print or last M109
  13110                  gcode_M31(); break;
   \                     ??process_parsed_command_34: (+1)
   \   00000448   0x.... 0x....      BL       _Z9gcode_M31v
   \   0000044C   0xE169             B.N      ??process_parsed_command_15
  13111          
  13112                case 42: // M42: Change pin state
  13113                  gcode_M42(); break;
   \                     ??process_parsed_command_36: (+1)
   \   0000044E   0x.... 0x....      BL       _Z9gcode_M42v
   \   00000452   0xE166             B.N      ??process_parsed_command_15
  13114          
  13115                #if ENABLED(PINS_DEBUGGING)
  13116                  case 43: // M43: Read pin state
  13117                    gcode_M43(); break;
  13118                #endif
  13119          
  13120          
  13121                #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
  13122                  case 48: // M48: Z probe repeatability test
  13123                    gcode_M48();
  13124                    break;
  13125                #endif // Z_MIN_PROBE_REPEATABILITY_TEST
  13126          
  13127                //#if ENABLED(G26_MESH_VALIDATION)
  13128                  case 49: // M49: Turn on or off G26 debug flag for verbose output
  13129                  if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
   \                     ??process_parsed_command_37: (+1)
   \   00000454   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   00000458   0x7B00             LDRB     R0,[R0, #+12]
   \   0000045A   0x06C0             LSLS     R0,R0,#+27
   \   0000045C   0xF140 0x8161      BPL.W    ??process_parsed_command_15
  13130                    gcode_M49();
   \   00000460   0x.... 0x....      BL       _Z9gcode_M49v
   \   00000464   0xE15D             B.N      ??process_parsed_command_15
  13131                    break;
  13132                //#endif // G26_MESH_VALIDATION
  13133          
  13134                #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
  13135                  case 73: // M73: Set print progress percentage
  13136                    gcode_M73(); break;
  13137                #endif
  13138          
  13139                case 75: // M75: Start print timer
  13140                  gcode_M75(); break;
   \                     ??process_parsed_command_38: (+1)
   \   00000466   0x.... 0x....      BL       _Z9gcode_M75v
   \   0000046A   0xE15A             B.N      ??process_parsed_command_15
  13141                case 76: // M76: Pause print timer
  13142                  gcode_M76(); break;
   \                     ??process_parsed_command_39: (+1)
   \   0000046C   0x.... 0x....      BL       _Z9gcode_M76v
   \   00000470   0xE157             B.N      ??process_parsed_command_15
  13143                case 77: // M77: Stop print timer
  13144                  gcode_M77(); break;
   \                     ??process_parsed_command_40: (+1)
   \   00000472   0x.... 0x....      BL       _Z9gcode_M77v
   \   00000476   0xE154             B.N      ??process_parsed_command_15
  13145          
  13146                #if ENABLED(PRINTCOUNTER)
  13147                  case 78: // M78: Show print statistics
  13148                    gcode_M78(); break;
  13149                #endif
  13150          
  13151                #if ENABLED(M100_FREE_MEMORY_WATCHER)
  13152                  case 100: // M100: Free Memory Report
  13153                    gcode_M100();
  13154                    break;
  13155                #endif
  13156          
  13157                case 104: // M104: Set hot end temperature
  13158                  gcode_M104();
   \                     ??process_parsed_command_46: (+1)
   \   00000478   0x.... 0x....      BL       _Z10gcode_M104v
  13159                  break;
   \   0000047C   0xE151             B.N      ??process_parsed_command_15
  13160          
  13161                case 110: // M110: Set Current Line Number
  13162                  gcode_M110();
   \                     ??process_parsed_command_52: (+1)
   \   0000047E   0x.... 0x....      BL       _Z10gcode_M110v
  13163                  break;
   \   00000482   0xE14E             B.N      ??process_parsed_command_15
  13164          
  13165                case 111: // M111: Set debug level
  13166                  gcode_M111();
   \                     ??process_parsed_command_53: (+1)
   \   00000484   0x.... 0x....      BL       _Z10gcode_M111v
  13167                  break;
   \   00000488   0xE14B             B.N      ??process_parsed_command_15
  13168          
  13169                #if DISABLED(EMERGENCY_PARSER)
  13170          
  13171                  case 108: // M108: Cancel Waiting
  13172                    gcode_M108();
   \                     ??process_parsed_command_50: (+1)
   \   0000048A   0x.... 0x....      BL       _Z10gcode_M108v
  13173                    break;
   \   0000048E   0xE148             B.N      ??process_parsed_command_15
  13174          
  13175                  case 112: // M112: Emergency Stop
  13176                    gcode_M112();
   \                     ??process_parsed_command_54: (+1)
   \   00000490   0x.... 0x....      BL       _Z10gcode_M112v
  13177                    break;
   \   00000494   0xE145             B.N      ??process_parsed_command_15
  13178          
  13179                  case 410: // M410 quickstop - Abort all the planned moves.
  13180                    gcode_M410();
   \                     ??process_parsed_command_91: (+1)
   \   00000496   0x.... 0x....      BL       _Z10gcode_M410v
  13181                    break;
   \   0000049A   0xE142             B.N      ??process_parsed_command_15
  13182          
  13183                #endif
  13184          
  13185                #if ENABLED(HOST_KEEPALIVE_FEATURE)
  13186                  case 113: // M113: Set Host Keepalive interval
  13187                    gcode_M113();
   \                     ??process_parsed_command_55: (+1)
   \   0000049C   0x.... 0x....      BL       _Z10gcode_M113v
  13188                    break;
   \   000004A0   0xE13F             B.N      ??process_parsed_command_15
  13189                #endif
  13190          
  13191                case 140: // M140: Set bed temperature
  13192                if(HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
   \                     ??process_parsed_command_63: (+1)
   \   000004A2   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   000004A6   0x7880             LDRB     R0,[R0, #+2]
   \   000004A8   0x2800             CMP      R0,#+0
   \   000004AA   0xD002             BEQ.N    ??process_parsed_command_108
  13193                  gcode_M140();
   \   000004AC   0x.... 0x....      BL       _Z10gcode_M140v
   \   000004B0   0xE137             B.N      ??process_parsed_command_15
  13194                  else
  13195                    SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!"); 	  
   \                     ??process_parsed_command_108: (+1)
   \   000004B2   0x.... 0x....      ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
   \   000004B6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000004BA   0xE132             B.N      ??process_parsed_command_15
  13196                  break;
  13197          
  13198                case 105: // M105: Report current temperature
  13199                  gcode_M105();
   \                     ??process_parsed_command_47: (+1)
   \   000004BC   0x.... 0x....      BL       _Z10gcode_M105v
  13200                  KEEPALIVE_STATE(NOT_BUSY);
   \   000004C0   0x2000             MOVS     R0,#+0
   \   000004C2   0x71A0             STRB     R0,[R4, #+6]
  13201                  return; // "ok" already printed
   \   000004C4   0xBD31             POP      {R0,R4,R5,PC}
  13202          
  13203               // #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
  13204               #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)
  13205                  case 155: // M155: Set temperature auto-report interval
  13206                    gcode_M155();
   \                     ??process_parsed_command_64: (+1)
   \   000004C6   0x.... 0x....      BL       _Z10gcode_M155v
  13207                    break;
   \   000004CA   0xE12A             B.N      ??process_parsed_command_15
  13208                #endif
  13209          
  13210                case 109: // M109: Wait for hotend temperature to reach target
  13211                  gcode_M109();
   \                     ??process_parsed_command_51: (+1)
   \   000004CC   0x.... 0x....      BL       _Z10gcode_M109v
  13212                  break;
   \   000004D0   0xE127             B.N      ??process_parsed_command_15
  13213          
  13214                //#if HAS_TEMP_BED
  13215                  case 190: // M190: Wait for bed temperature to reach target
  13216                  if(HAS_TEMP_BED) 
   \                     ??process_parsed_command_65: (+1)
   \   000004D2   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   000004D6   0x7880             LDRB     R0,[R0, #+2]
   \   000004D8   0x2800             CMP      R0,#+0
   \   000004DA   0xD002             BEQ.N    ??process_parsed_command_109
  13217                    gcode_M190();
   \   000004DC   0x.... 0x....      BL       _Z10gcode_M190v
   \   000004E0   0xE11F             B.N      ??process_parsed_command_15
  13218          		else
  13219                    SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!");
   \                     ??process_parsed_command_109: (+1)
   \   000004E2   0x.... 0x....      ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
   \   000004E6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000004EA   0xE11A             B.N      ??process_parsed_command_15
  13220                    break;
  13221                //#endif // HAS_TEMP_BED
  13222          
  13223                #if FAN_COUNT > 0
  13224                  case 106: // M106: Fan On
  13225                    gcode_M106();
   \                     ??process_parsed_command_48: (+1)
   \   000004EC   0x.... 0x....      BL       _Z10gcode_M106v
  13226                    break;
   \   000004F0   0xE117             B.N      ??process_parsed_command_15
  13227                  case 107: // M107: Fan Off
  13228                    gcode_M107();
   \                     ??process_parsed_command_49: (+1)
   \   000004F2   0x.... 0x....      BL       _Z10gcode_M107v
  13229                    break;
   \   000004F6   0xE114             B.N      ??process_parsed_command_15
  13230                #endif // FAN_COUNT > 0
  13231          
  13232                #if ENABLED(PARK_HEAD_ON_PAUSE)
  13233                  case 125: // M125: Store current position and move to filament change position
  13234                    gcode_M125(); break;
  13235                #endif
  13236          
  13237                #if ENABLED(BARICUDA)
  13238                  // PWM for HEATER_1_PIN
  13239                  #if HAS_HEATER_1
  13240                    case 126: // M126: valve open
  13241                      gcode_M126();
  13242                      break;
  13243                    case 127: // M127: valve closed
  13244                      gcode_M127();
  13245                      break;
  13246                  #endif // HAS_HEATER_1
  13247          
  13248                  // PWM for HEATER_2_PIN
  13249                  #if HAS_HEATER_2
  13250                    case 128: // M128: valve open
  13251                      gcode_M128();
  13252                      break;
  13253                    case 129: // M129: valve closed
  13254                      gcode_M129();
  13255                      break;
  13256                  #endif // HAS_HEATER_2
  13257                #endif // BARICUDA
  13258          
  13259                #if HAS_POWER_SWITCH
  13260          
  13261                  case 80: // M80: Turn on Power Supply
  13262                    gcode_M80();
  13263                    break;
  13264          
  13265                #endif // HAS_POWER_SWITCH
  13266          
  13267                case 81: // M81: Turn off Power, including Power Supply, if possible
  13268                  gcode_M81();
   \                     ??process_parsed_command_41: (+1)
   \   000004F8   0x.... 0x....      BL       _Z9gcode_M81v
  13269                  break;
   \   000004FC   0xE111             B.N      ??process_parsed_command_15
  13270          
  13271                case 82: // M82: Set E axis normal mode (same as other axes)
  13272                  gcode_M82();
   \                     ??process_parsed_command_42: (+1)
   \   000004FE   0x.... 0x....      BL       _Z9gcode_M82v
  13273                  break;
   \   00000502   0xE10E             B.N      ??process_parsed_command_15
  13274                case 83: // M83: Set E axis relative mode
  13275                  gcode_M83();
   \                     ??process_parsed_command_43: (+1)
   \   00000504   0x.... 0x....      BL       _Z9gcode_M83v
  13276                  break;
   \   00000508   0xE10B             B.N      ??process_parsed_command_15
  13277                case 18: // M18 => M84
  13278                case 84: // M84: Disable all steppers or set timeout
  13279                  gcode_M18_M84();
   \                     ??process_parsed_command_23: (+1)
   \   0000050A   0x.... 0x....      BL       _Z13gcode_M18_M84v
  13280                  break;
   \   0000050E   0xE108             B.N      ??process_parsed_command_15
  13281                case 85: // M85: Set inactivity stepper shutdown timeout
  13282                  gcode_M85();
   \                     ??process_parsed_command_44: (+1)
   \   00000510   0x.... 0x....      BL       _Z9gcode_M85v
  13283                  break;
   \   00000514   0xE105             B.N      ??process_parsed_command_15
  13284                case 92: // M92: Set the steps-per-unit for one or more axes
  13285                  gcode_M92();
   \                     ??process_parsed_command_45: (+1)
   \   00000516   0x.... 0x....      BL       _Z9gcode_M92v
  13286                  break;
   \   0000051A   0xE102             B.N      ??process_parsed_command_15
  13287                case 114: // M114: Report current position
  13288                  gcode_M114();
   \                     ??process_parsed_command_56: (+1)
   \   0000051C   0x.... 0x....      BL       _Z10gcode_M114v
  13289                  break;
   \   00000520   0xE0FF             B.N      ??process_parsed_command_15
  13290                case 115: // M115: Report capabilities
  13291                  gcode_M115();
   \                     ??process_parsed_command_57: (+1)
   \   00000522   0x.... 0x....      BL       _Z10gcode_M115v
  13292                  break;
   \   00000526   0xE0FC             B.N      ??process_parsed_command_15
  13293                case 117: // M117: Set LCD message text, if possible
  13294                  gcode_M117();
   \                     ??process_parsed_command_58: (+1)
   \   00000528   0x.... 0x....      BL       _Z10gcode_M117v
  13295                  break;
   \   0000052C   0xE0F9             B.N      ??process_parsed_command_15
  13296                case 118: // M118: Display a message in the host console
  13297                  gcode_M118();
   \                     ??process_parsed_command_59: (+1)
   \   0000052E   0x.... 0x....      BL       _Z10gcode_M118v
  13298                  break;
   \   00000532   0xE0F6             B.N      ??process_parsed_command_15
  13299                case 119: // M119: Report endstop states
  13300                  gcode_M119();
   \                     ??process_parsed_command_60: (+1)
   \   00000534   0x.... 0x....      BL       _Z10gcode_M119v
  13301                  break;
   \   00000538   0xE0F3             B.N      ??process_parsed_command_15
  13302                case 120: // M120: Enable endstops
  13303                  gcode_M120();
   \                     ??process_parsed_command_61: (+1)
   \   0000053A   0x.... 0x....      BL       _Z10gcode_M120v
  13304                  break;
   \   0000053E   0xE0F0             B.N      ??process_parsed_command_15
  13305                case 121: // M121: Disable endstops
  13306                  gcode_M121();
   \                     ??process_parsed_command_62: (+1)
   \   00000540   0x.... 0x....      BL       _Z10gcode_M121v
  13307                  break;
   \   00000544   0xE0ED             B.N      ??process_parsed_command_15
  13308          
  13309                #if ENABLED(ULTIPANEL)
  13310          
  13311                  case 145: // M145: Set material heatup parameters
  13312                    gcode_M145();
  13313                    break;
  13314          
  13315                #endif
  13316          
  13317                #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
  13318                  case 149: // M149: Set temperature units
  13319                    gcode_M149();
  13320                    break;
  13321                #endif
  13322          
  13323                #if HAS_COLOR_LEDS
  13324          
  13325                  case 150: // M150: Set Status LED Color
  13326                    gcode_M150();
  13327                    break;
  13328          
  13329                #endif // HAS_COLOR_LEDS
  13330          
  13331                #if ENABLED(MIXING_EXTRUDER)
  13332                  case 163: // M163: Set a component weight for mixing extruder
  13333                    gcode_M163();
  13334                    break;
  13335                  #if MIXING_VIRTUAL_TOOLS > 1
  13336                    case 164: // M164: Save current mix as a virtual extruder
  13337                      gcode_M164();
  13338                      break;
  13339                  #endif
  13340                  #if ENABLED(DIRECT_MIXING_IN_G1)
  13341                    case 165: // M165: Set multiple mix weights
  13342                      gcode_M165();
  13343                      break;
  13344                  #endif
  13345                #endif
  13346          
  13347                #if DISABLED(NO_VOLUMETRICS)
  13348                  case 200: // M200: Set filament diameter, E to cubic units
  13349                    gcode_M200();
   \                     ??process_parsed_command_66: (+1)
   \   00000546   0x.... 0x....      BL       _Z10gcode_M200v
  13350                    break;
   \   0000054A   0xE0EA             B.N      ??process_parsed_command_15
  13351                #endif
  13352          
  13353                case 201: // M201: Set max acceleration for print moves (units/s^2)
  13354                  gcode_M201();
   \                     ??process_parsed_command_67: (+1)
   \   0000054C   0x.... 0x....      BL       _Z10gcode_M201v
  13355                  break;
   \   00000550   0xE0E7             B.N      ??process_parsed_command_15
  13356                #if 0 // Not used for Sprinter/grbl gen6
  13357                  case 202: // M202
  13358                    gcode_M202();
  13359                    break;
  13360                #endif
  13361                case 203: // M203: Set max feedrate (units/sec)
  13362                  gcode_M203();
   \                     ??process_parsed_command_68: (+1)
   \   00000552   0x.... 0x....      BL       _Z10gcode_M203v
  13363                  break;
   \   00000556   0xE0E4             B.N      ??process_parsed_command_15
  13364                case 204: // M204: Set acceleration
  13365                  gcode_M204();
   \                     ??process_parsed_command_69: (+1)
   \   00000558   0x.... 0x....      BL       _Z10gcode_M204v
  13366                  break;
   \   0000055C   0xE0E1             B.N      ??process_parsed_command_15
  13367                case 205: // M205: Set advanced settings
  13368                  gcode_M205();
   \                     ??process_parsed_command_70: (+1)
   \   0000055E   0x.... 0x....      BL       _Z10gcode_M205v
  13369                  break;
   \   00000562   0xE0DE             B.N      ??process_parsed_command_15
  13370          
  13371                //#if HAS_M206_COMMAND
  13372                  case 206: // M206: Set home offsets
  13373                  if(MACHINETPYE != DELTA)
   \                     ??process_parsed_command_71: (+1)
   \   00000564   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   00000568   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   0000056C   0x2802             CMP      R0,#+2
   \   0000056E   0xF000 0x80D8      BEQ.W    ??process_parsed_command_15
  13374                    gcode_M206();
   \   00000572   0x.... 0x....      BL       _Z10gcode_M206v
   \   00000576   0xE0D4             B.N      ??process_parsed_command_15
  13375                    break;
  13376                //#endif
  13377          
  13378                //#if ENABLED(DELTA)
  13379                  case 665: // M665: Set delta configurations
  13380                  if(MACHINETPYE == DELTA)
   \                     ??process_parsed_command_99: (+1)
   \   00000578   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   0000057C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000580   0x2802             CMP      R0,#+2
   \   00000582   0xF040 0x80CE      BNE.W    ??process_parsed_command_15
  13381                    gcode_M665();
   \   00000586   0x.... 0x....      BL       _Z10gcode_M665v
   \   0000058A   0xE0CA             B.N      ??process_parsed_command_15
  13382                    break;
  13383                //#endif
  13384          
  13385                //#if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
  13386                  case 666: // M666: Set delta or dual endstop adjustment
  13387                  if(MACHINETPYE == DELTA)
   \                     ??process_parsed_command_100: (+1)
   \   0000058C   0x....             LDR.N    R0,??DataTable160
   \   0000058E   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000592   0xF9B1 0x1024      LDRSH    R1,[R1, #+36]
   \   00000596   0x2902             CMP      R1,#+2
   \   00000598   0xD102             BNE.N    ??process_parsed_command_110
  13388                    gcode_M666();
   \   0000059A   0x.... 0x....      BL       _Z10gcode_M666v
   \   0000059E   0xE0C0             B.N      ??process_parsed_command_15
  13389                  else if(Z_DUAL_ENDSTOPS==1)
   \                     ??process_parsed_command_110: (+1)
   \   000005A0   0xF890 0x0102      LDRB     R0,[R0, #+258]
   \   000005A4   0x2801             CMP      R0,#+1
   \   000005A6   0xF040 0x80BC      BNE.W    ??process_parsed_command_15
  13390                  {
  13391                    gcode_M666_dual();  
   \   000005AA   0x.... 0x....      BL       _Z15gcode_M666_dualv
   \   000005AE   0xE0B8             B.N      ??process_parsed_command_15
  13392                  }
  13393                    break;
  13394                //#endif
  13395          
  13396                #if ENABLED(FWRETRACT)
  13397                  case 207: // M207: Set Retract Length, Feedrate, and Z lift
  13398                    gcode_M207();
  13399                    break;
  13400                  case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
  13401                    gcode_M208();
  13402                    break;
  13403                  case 209: // M209: Turn Automatic Retract Detection on/off
  13404                    if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
  13405                    break;
  13406                #endif // FWRETRACT
  13407          
  13408                case 211: // M211: Enable, Disable, and/or Report software endstops
  13409                  gcode_M211();
   \                     ??process_parsed_command_72: (+1)
   \   000005B0   0x.... 0x....      BL       _Z10gcode_M211v
  13410                  break;
   \   000005B4   0xE0B5             B.N      ??process_parsed_command_15
  13411          
  13412                #if HOTENDS > 1
  13413                  case 218: // M218: Set a tool offset
  13414                    gcode_M218();
   \                     ??process_parsed_command_73: (+1)
   \   000005B6   0x.... 0x....      BL       _Z10gcode_M218v
  13415                    break;
   \   000005BA   0xE0B2             B.N      ??process_parsed_command_15
  13416                #endif // HOTENDS > 1
  13417          
  13418                case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
  13419                  gcode_M220();
   \                     ??process_parsed_command_74: (+1)
   \   000005BC   0x.... 0x....      BL       _Z10gcode_M220v
  13420                  break;
   \   000005C0   0xE0AF             B.N      ??process_parsed_command_15
  13421          
  13422                case 221: // M221: Set Flow Percentage
  13423                  gcode_M221();
   \                     ??process_parsed_command_75: (+1)
   \   000005C2   0x.... 0x....      BL       _Z10gcode_M221v
  13424                  break;
   \   000005C6   0xE0AC             B.N      ??process_parsed_command_15
  13425          
  13426                case 226: // M226: Wait until a pin reaches a state
  13427                  gcode_M226();
   \                     ??process_parsed_command_76: (+1)
   \   000005C8   0x.... 0x....      BL       _Z10gcode_M226v
  13428                  break;
   \   000005CC   0xE0A9             B.N      ??process_parsed_command_15
  13429          
  13430                //#if HAS_SERVOS
  13431                  case 280: // M280: Set servo position absolute
  13432                    gcode_M280();
   \                     ??process_parsed_command_77: (+1)
   \   000005CE   0x.... 0x....      BL       _Z10gcode_M280v
  13433                    break;
   \   000005D2   0xE0A6             B.N      ??process_parsed_command_15
  13434                //#endif // HAS_SERVOS
  13435          
  13436                #if ENABLED(BABYSTEPPING)
  13437                  case 290: // M290: Babystepping
  13438                    gcode_M290();
  13439                    break;
  13440                #endif // BABYSTEPPING
  13441          
  13442                #if HAS_BUZZER
  13443                  case 300: // M300: Play beep tone
  13444                    gcode_M300();
  13445                    break;
  13446                #endif // HAS_BUZZER
  13447          
  13448                //#if ENABLED(PIDTEMP)
  13449                  case 301: // M301: Set hotend PID parameters
  13450                  if(PIDTEMP) 
   \                     ??process_parsed_command_78: (+1)
   \   000005D4   0x....             LDR.N    R0,??DataTable160
   \   000005D6   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   000005DA   0x2800             CMP      R0,#+0
   \   000005DC   0xF000 0x80A1      BEQ.W    ??process_parsed_command_15
  13451                    gcode_M301();
   \   000005E0   0x.... 0x....      BL       _Z10gcode_M301v
   \   000005E4   0xE09D             B.N      ??process_parsed_command_15
  13452                    break;
  13453                //#endif // PIDTEMP
  13454          
  13455                //#if ENABLED(PIDTEMPBED)
  13456                  case 304: // M304: Set bed PID parameters
  13457                  if(PIDTEMPBED) 
   \                     ??process_parsed_command_81: (+1)
   \   000005E6   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   000005EA   0x7840             LDRB     R0,[R0, #+1]
   \   000005EC   0x2800             CMP      R0,#+0
   \   000005EE   0xF000 0x8098      BEQ.W    ??process_parsed_command_15
  13458                    gcode_M304();
   \   000005F2   0x.... 0x....      BL       _Z10gcode_M304v
   \   000005F6   0xE094             B.N      ??process_parsed_command_15
  13459                    break;
  13460                //#endif // PIDTEMPBED
  13461          
  13462                #if defined(CHDK) || HAS_PHOTOGRAPH
  13463                  case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
  13464                    gcode_M240();
  13465                    break;
  13466                #endif // CHDK || PHOTOGRAPH_PIN
  13467          
  13468                #if HAS_LCD_CONTRAST
  13469                  case 250: // M250: Set LCD contrast
  13470                    gcode_M250();
  13471                    break;
  13472                #endif // HAS_LCD_CONTRAST
  13473          
  13474                #if ENABLED(EXPERIMENTAL_I2CBUS)
  13475          
  13476                  case 260: // M260: Send data to an i2c slave
  13477                    gcode_M260();
  13478                    break;
  13479          
  13480                  case 261: // M261: Request data from an i2c slave
  13481                    gcode_M261();
  13482                    break;
  13483          
  13484                #endif // EXPERIMENTAL_I2CBUS
  13485          
  13486                #if ENABLED(PREVENT_COLD_EXTRUSION)
  13487                  case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
  13488                    gcode_M302();
   \                     ??process_parsed_command_79: (+1)
   \   000005F8   0x.... 0x....      BL       _Z10gcode_M302v
  13489                    break;
   \   000005FC   0xE091             B.N      ??process_parsed_command_15
  13490                #endif // PREVENT_COLD_EXTRUSION
  13491          
  13492                case 303: // M303: PID autotune
  13493                  gcode_M303();
   \                     ??process_parsed_command_80: (+1)
   \   000005FE   0x.... 0x....      BL       _Z10gcode_M303v
  13494                  break;
   \   00000602   0xE08E             B.N      ??process_parsed_command_15
  13495          
  13496                //#if ENABLED(MORGAN_SCARA)
  13497                  case 360:  // M360: SCARA Theta pos1
  13498                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_83: (+1)
   \   00000604   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   00000608   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   0000060C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000610   0xF040 0x8087      BNE.W    ??process_parsed_command_15
  13499                    if (gcode_M360()) return;
   \   00000614   0x.... 0x....      BL       _Z10gcode_M360v
   \   00000618   0x2800             CMP      R0,#+0
   \   0000061A   0xF000 0x8082      BEQ.W    ??process_parsed_command_15
   \   0000061E   0xBD31             POP      {R0,R4,R5,PC}
  13500                    break;
  13501                  case 361:  // M361: SCARA Theta pos2
  13502                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_84: (+1)
   \   00000620   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   00000624   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000628   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000062C   0xD179             BNE.N    ??process_parsed_command_15
  13503                    if (gcode_M361()) return;
   \   0000062E   0x.... 0x....      BL       _Z10gcode_M361v
   \   00000632   0x2800             CMP      R0,#+0
   \   00000634   0xD075             BEQ.N    ??process_parsed_command_15
   \   00000636   0xBD31             POP      {R0,R4,R5,PC}
  13504                    break;
  13505                  case 362:  // M362: SCARA Psi pos1
  13506                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_85: (+1)
   \   00000638   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   0000063C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000640   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000644   0xD16D             BNE.N    ??process_parsed_command_15
  13507                    if (gcode_M362()) return;
   \   00000646   0x.... 0x....      BL       _Z10gcode_M362v
   \   0000064A   0x2800             CMP      R0,#+0
   \   0000064C   0xD069             BEQ.N    ??process_parsed_command_15
   \   0000064E   0xBD31             POP      {R0,R4,R5,PC}
  13508                    break;
  13509                  case 363:  // M363: SCARA Psi pos2
  13510                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_86: (+1)
   \   00000650   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   00000654   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000658   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000065C   0xD161             BNE.N    ??process_parsed_command_15
  13511                    if (gcode_M363()) return;
   \   0000065E   0x.... 0x....      BL       _Z10gcode_M363v
   \   00000662   0x2800             CMP      R0,#+0
   \   00000664   0xD05D             BEQ.N    ??process_parsed_command_15
   \   00000666   0xBD31             POP      {R0,R4,R5,PC}
  13512                    break;
  13513                  case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
  13514                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_87: (+1)
   \   00000668   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   0000066C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000670   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000674   0xD155             BNE.N    ??process_parsed_command_15
  13515                    if (gcode_M364()) return;
   \   00000676   0x.... 0x....      BL       _Z10gcode_M364v
   \   0000067A   0x2800             CMP      R0,#+0
   \   0000067C   0xD051             BEQ.N    ??process_parsed_command_15
   \   0000067E   0xBD31             POP      {R0,R4,R5,PC}
  13516                    break;
  13517                //#endif // SCARA
  13518          
  13519                case 400: // M400: Finish all moves
  13520                  gcode_M400();
   \                     ??process_parsed_command_88: (+1)
   \   00000680   0x.... 0x....      BL       _Z10gcode_M400v
  13521                  break;
   \   00000684   0xE04D             B.N      ??process_parsed_command_15
  13522          
  13523                #if HAS_BED_PROBE
  13524                  case 401: // M401: Deploy probe
  13525                    gcode_M401();
   \                     ??process_parsed_command_89: (+1)
   \   00000686   0x.... 0x....      BL       _Z10gcode_M401v
  13526                    break;
   \   0000068A   0xE04A             B.N      ??process_parsed_command_15
  13527                  case 402: // M402: Stow probe
  13528                    gcode_M402();
   \                     ??process_parsed_command_90: (+1)
   \   0000068C   0x.... 0x....      BL       _Z10gcode_M402v
  13529                    break;
   \   00000690   0xE047             B.N      ??process_parsed_command_15
  13530                #endif // HAS_BED_PROBE
  13531          
  13532                #if ENABLED(FILAMENT_WIDTH_SENSOR)
  13533                  case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
  13534                    gcode_M404();
  13535                    break;
  13536                  case 405:  // M405: Turn on filament sensor for control
  13537                    gcode_M405();
  13538                    break;
  13539                  case 406:  // M406: Turn off filament sensor for control
  13540                    gcode_M406();
  13541                    break;
  13542                  case 407:   // M407: Display measured filament diameter
  13543                    gcode_M407();
  13544                    break;
  13545                #endif // FILAMENT_WIDTH_SENSOR
  13546          
  13547                //#if HAS_LEVELING
  13548                  case 420: // M420: Enable/Disable Bed Leveling
  13549                  if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??process_parsed_command_92: (+1)
   \   00000692   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   00000696   0x7B00             LDRB     R0,[R0, #+12]
   \   00000698   0x213E             MOVS     R1,#+62
   \   0000069A   0x4208             TST      R0,R1
   \   0000069C   0xD041             BEQ.N    ??process_parsed_command_15
  13550                    gcode_M420();
   \   0000069E   0x.... 0x....      BL       _Z10gcode_M420v
   \   000006A2   0xE03E             B.N      ??process_parsed_command_15
  13551                    break;
  13552                //#endif
  13553          
  13554                //#if HAS_MESH
  13555                  case 421: // M421: Set a Mesh Bed Leveling Z coordinate
  13556                    if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
   \                     ??process_parsed_command_93: (+1)
   \   000006A4   0x....             LDR.N    R0,??DataTable160
   \   000006A6   0xF100 0x0534      ADD      R5,R0,#+52
   \   000006AA   0x7B28             LDRB     R0,[R5, #+12]
   \   000006AC   0x0681             LSLS     R1,R0,#+26
   \   000006AE   0xD502             BPL.N    ??process_parsed_command_111
  13557                    	gcode_M421_MESH_BED_LEVELING();
   \   000006B0   0x.... 0x....      BL       _Z28gcode_M421_MESH_BED_LEVELINGv
   \   000006B4   0xE035             B.N      ??process_parsed_command_15
  13558          		  else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \                     ??process_parsed_command_111: (+1)
   \   000006B6   0x0701             LSLS     R1,R0,#+28
   \   000006B8   0xD502             BPL.N    ??process_parsed_command_112
  13559                    	gcode_M421_AUTO_BED_LEVELING_BILINEAR();
   \   000006BA   0x.... 0x....      BL       _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
   \   000006BE   0xE030             B.N      ??process_parsed_command_15
  13560                    else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
   \                     ??process_parsed_command_112: (+1)
   \   000006C0   0x06C0             LSLS     R0,R0,#+27
   \   000006C2   0xD52E             BPL.N    ??process_parsed_command_15
  13561                      gcode_M421_AUTO_BED_LEVELING_UBL();
   \   000006C4   0x.... 0x....      BL       _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
   \   000006C8   0xE02B             B.N      ??process_parsed_command_15
  13562                    break;
  13563                //#endif
  13564          
  13565                //#if HAS_M206_COMMAND
  13566                  case 428: // M428: Apply current_position to home_offset
  13567                  if(MACHINETPYE != DELTA)
   \                     ??process_parsed_command_94: (+1)
   \   000006CA   0x.... 0x....      LDR.W    R0,??DataTable163_3
   \   000006CE   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   000006D2   0x2802             CMP      R0,#+2
   \   000006D4   0xD025             BEQ.N    ??process_parsed_command_15
  13568                    gcode_M428();
   \   000006D6   0x.... 0x....      BL       _Z10gcode_M428v
   \   000006DA   0xE022             B.N      ??process_parsed_command_15
  13569                    break;
  13570                //#endif
  13571          
  13572                case 500: // M500: Store settings in EEPROM
  13573                  gcode_M500();
   \                     ??process_parsed_command_95: (+1)
   \   000006DC   0x.... 0x....      BL       _Z10gcode_M500v
  13574                  break;
   \   000006E0   0xE01F             B.N      ??process_parsed_command_15
  13575                case 501: // M501: Read settings from EEPROM
  13576                  gcode_M501();
   \                     ??process_parsed_command_96: (+1)
   \   000006E2   0x.... 0x....      BL       _Z10gcode_M501v
  13577                  break;
   \   000006E6   0xE01C             B.N      ??process_parsed_command_15
  13578                case 502: // M502: Revert to default settings
  13579                  gcode_M502();
   \                     ??process_parsed_command_97: (+1)
   \   000006E8   0x.... 0x....      BL       _Z10gcode_M502v
  13580                  break;
   \   000006EC   0xE019             B.N      ??process_parsed_command_15
  13581          
  13582                #if DISABLED(DISABLE_M503)
  13583                  case 503: // M503: print settings currently in memory
  13584                    gcode_M503();
   \                     ??process_parsed_command_98: (+1)
   \   000006EE   0x.... 0x....      BL       _Z10gcode_M503v
  13585                    break;
   \   000006F2   0xE016             B.N      ??process_parsed_command_15
  13586                #endif
  13587          
  13588                #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
  13589                  case 540: // M540: Set abort on endstop hit for SD printing
  13590                    gcode_M540();
  13591                    break;
  13592                #endif
  13593          
  13594                #if HAS_BED_PROBE
  13595                  case 851: // M851: Set Z Probe Z Offset
  13596                    gcode_M851();
   \                     ??process_parsed_command_101: (+1)
   \   000006F4   0x.... 0x....      BL       _Z10gcode_M851v
  13597                    break;
   \   000006F8   0xE013             B.N      ??process_parsed_command_15
  13598                #endif // HAS_BED_PROBE
  13599          
  13600                #if ENABLED(SKEW_CORRECTION_GCODE)
  13601                  case 852: // M852: Set Skew factors
  13602                    gcode_M852();
  13603                    break;
  13604                #endif
  13605          
  13606                #if ENABLED(ADVANCED_PAUSE_FEATURE)
  13607                  case 600: // M600: Pause for filament change
  13608                    gcode_M600();
  13609                    break;
  13610                #endif // ADVANCED_PAUSE_FEATURE
  13611          
  13612                #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
  13613                  case 605: // M605: Set Dual X Carriage movement mode
  13614                    gcode_M605();
  13615                    break;
  13616                #endif // DUAL_X_CARRIAGE
  13617          
  13618                #if ENABLED(MK2_MULTIPLEXER)
  13619                  case 702: // M702: Unload all extruders
  13620                    gcode_M702();
  13621                    break;
  13622                #endif
  13623          
  13624                #if ENABLED(LIN_ADVANCE)
  13625                  case 900: // M900: Set advance K factor.
  13626                    gcode_M900();
  13627                    break;
  13628                #endif
  13629          
  13630                case 907: // M907: Set digital trimpot motor current using axis codes.
  13631                  gcode_M907();
   \                     ??process_parsed_command_102: (+1)
   \   000006FA   0x.... 0x....      BL       _Z10gcode_M907v
  13632                  break;
   \   000006FE   0xE010             B.N      ??process_parsed_command_15
  13633          
  13634                #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  13635          
  13636                  case 908: // M908: Control digital trimpot directly.
  13637                    gcode_M908();
  13638                    break;
  13639          
  13640                  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  13641          
  13642                    case 909: // M909: Print digipot/DAC current value
  13643                      gcode_M909();
  13644                      break;
  13645          
  13646                    case 910: // M910: Commit digipot/DAC value to external EEPROM
  13647                      gcode_M910();
  13648                      break;
  13649          
  13650                  #endif
  13651          
  13652                #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  13653          
  13654                #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
  13655                  case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
  13656                    gcode_M906();
  13657                    break;
  13658          
  13659                  case 911: // M911: Report TMC prewarn triggered flags
  13660                    gcode_M911();
  13661                    break;
  13662          
  13663                  case 912: // M911: Clear TMC prewarn triggered flags
  13664                    gcode_M912();
  13665                    break;
  13666          
  13667                  #if ENABLED(TMC_DEBUG)
  13668                    case 122:  // Debug TMC steppers
  13669                      gcode_M122();
  13670                      break;
  13671                  #endif
  13672          
  13673                  #if ENABLED(HYBRID_THRESHOLD)
  13674                    case 913: // M913: Set HYBRID_THRESHOLD speed.
  13675                      gcode_M913();
  13676                      break;
  13677                  #endif
  13678          
  13679                  #if ENABLED(SENSORLESS_HOMING)
  13680                    case 914: // M914: Set SENSORLESS_HOMING sensitivity.
  13681                      gcode_M914();
  13682                      break;
  13683                  #endif
  13684          
  13685                  #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
  13686                    case 915: // M915: TMC Z axis calibration routine
  13687                      gcode_M915();
  13688                      break;
  13689                  #endif
  13690                #endif
  13691          
  13692                #if HAS_MICROSTEPS
  13693          
  13694                  case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  13695                    gcode_M350();
  13696                    break;
  13697          
  13698                  case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
  13699                    gcode_M351();
  13700                    break;
  13701          
  13702                #endif // HAS_MICROSTEPS
  13703          
  13704                case 355: // M355 set case light brightness
  13705                  gcode_M355();
   \                     ??process_parsed_command_82: (+1)
   \   00000700   0x.... 0x....      BL       _Z10gcode_M355v
  13706                  break;
   \   00000704   0xE00D             B.N      ??process_parsed_command_15
  13707          
  13708                #if ENABLED(DEBUG_GCODE_PARSER)
  13709                  case 800:
  13710                    parser.debug(); // GCode Parser Test for M
  13711                    break;
  13712                #endif
  13713          
  13714                #if ENABLED(I2C_POSITION_ENCODERS)
  13715          
  13716                  case 860: // M860 Report encoder module position
  13717                    gcode_M860();
  13718                    break;
  13719          
  13720                  case 861: // M861 Report encoder module status
  13721                    gcode_M861();
  13722                    break;
  13723          
  13724                  case 862: // M862 Perform axis test
  13725                    gcode_M862();
  13726                    break;
  13727          
  13728                  case 863: // M863 Calibrate steps/mm
  13729                    gcode_M863();
  13730                    break;
  13731          
  13732                  case 864: // M864 Change module address
  13733                    gcode_M864();
  13734                    break;
  13735          
  13736                  case 865: // M865 Check module firmware version
  13737                    gcode_M865();
  13738                    break;
  13739          
  13740                  case 866: // M866 Report axis error count
  13741                    gcode_M866();
  13742                    break;
  13743          
  13744                  case 867: // M867 Toggle error correction
  13745                    gcode_M867();
  13746                    break;
  13747          
  13748                  case 868: // M868 Set error correction threshold
  13749                    gcode_M868();
  13750                    break;
  13751          
  13752                  case 869: // M869 Report axis error
  13753                    gcode_M869();
  13754                    break;
  13755          
  13756                #endif // I2C_POSITION_ENCODERS
  13757          
  13758                case 999: // M999: Restart after being Stopped
  13759                  gcode_M999();
   \                     ??process_parsed_command_105: (+1)
   \   00000706   0x.... 0x....      BL       _Z10gcode_M999v
  13760                  break;
   \   0000070A   0xE00A             B.N      ??process_parsed_command_15
  13761              }
  13762              break;
  13763          
  13764              case 'T':
  13765                gcode_T(parser.codenum);
   \                     ??process_parsed_command_2: (+1)
   \   0000070C   0x.... 0x....      LDR.W    R0,??DataTable163_2
   \   00000710   0x6800             LDR      R0,[R0, #+0]
   \   00000712   0xB2C0             UXTB     R0,R0
   \   00000714   0x.... 0x....      BL       _Z7gcode_Th
  13766                break;
   \   00000718   0xE003             B.N      ??process_parsed_command_15
  13767          
  13768              default: parser.unknown_command_error();
   \                     ??process_parsed_command_3: (+1)
   \   0000071A   0x.... 0x....      LDR.W    R0,??DataTable168
   \   0000071E   0x.... 0x....      BL       _ZN11GCodeParser21unknown_command_errorEv
  13769            }
  13770          
  13771            KEEPALIVE_STATE(NOT_BUSY);
   \                     ??process_parsed_command_15: (+1)
   \   00000722   0x2000             MOVS     R0,#+0
   \   00000724   0x71A0             STRB     R0,[R4, #+6]
  13772          
  13773            ok_to_send();
   \   00000726   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000072A   0x....             B.N      _Z10ok_to_sendv
  13774          }
  13775          

   \                                 In section .text, align 2, keep-with-next
  13776          void process_next_command() 
  13777          {
   \                     _Z20process_next_commandv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  13778            char * const current_command = command_queue[cmd_queue_index_r];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable168_1
   \   00000006   0x79C0             LDRB     R0,[R0, #+7]
   \   00000008   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable168_2
   \   00000010   0xEB00 0x1441      ADD      R4,R0,R1, LSL #+5
  13779          
  13780            if (DEBUGGING(ECHO)) {
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable168_3
   \   00000018   0x7840             LDRB     R0,[R0, #+1]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD50D             BPL.N    ??process_next_command_0
  13781              SERIAL_ECHO_START();
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable162_6
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13782              SERIAL_ECHOLN(current_command);
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable163
   \   0000002A   0x4621             MOV      R1,R4
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000032   0x210A             MOVS     R1,#+10
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  13783              #if ENABLED(M100_FREE_MEMORY_WATCHER)
  13784                SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
  13785                M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
  13786              #endif
  13787            }
  13788          
  13789            // Parse the next command in the queue
  13790            parser.parse(current_command);
   \                     ??process_next_command_0: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
  13791            process_parsed_command();
   \   00000040   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000044   0x....             B.N      _Z22process_parsed_commandv
  13792          }
  13793          
  13794          /**
  13795           * Send a "Resend: nnn" message to the host to
  13796           * indicate that a command needs to be re-sent.
  13797           */

   \                                 In section .text, align 2, keep-with-next
  13798          void FlushSerialRequestResend() {
   \                     _Z24FlushSerialRequestResendv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  13799            //char command_queue[cmd_queue_index_r][100]="Resend:";
  13800            MYSERIAL.flush();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable163
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       _ZN10USARTClass5flushEv
  13801            SERIAL_PROTOCOLPGM(MSG_RESEND);
   \   0000000C   0x.... 0x....      ADR.W    R0,`?<Constant "Resend: ">`
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13802            SERIAL_PROTOCOLLN(gcode_LastN + 1);
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable163_1
   \   0000001A   0x6AC0             LDR      R0,[R0, #+44]
   \   0000001C   0x1C41             ADDS     R1,R0,#+1
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  13803            ok_to_send();
   \   0000002C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000030                      REQUIRE _Z10ok_to_sendv
   \   00000030                      ;; // Fall through to label ok_to_send()
  13804          }
  13805          
  13806          /**
  13807           * Send an "ok" message to the host, indicating
  13808           * that a command was successfully processed.
  13809           *
  13810           * If ADVANCED_OK is enabled also include:
  13811           *   N<int>  Line number of the command, if any
  13812           *   P<int>  Planner space remaining
  13813           *   B<int>  Block queue space remaining
  13814           */

   \                                 In section .text, align 2, keep-with-next
  13815          void ok_to_send() {
   \                     _Z10ok_to_sendv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  13816            refresh_cmd_timeout();
   \   00000002   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  13817            if (!send_ok[cmd_queue_index_r]) return;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable168_1
   \   0000000A   0x79C1             LDRB     R1,[R0, #+7]
   \   0000000C   0x1808             ADDS     R0,R1,R0
   \   0000000E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??ok_to_send_0
  13818            SERIAL_PROTOCOLPGM(MSG_OK);
   \   00000014   0x....             ADR.N    R0,??DataTable162  ;; 0x6F, 0x6B, 0x00, 0x00
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13819            #if ENABLED(ADVANCED_OK)
  13820              char* p = command_queue[cmd_queue_index_r];
  13821              if (*p == 'N') {
  13822                SERIAL_PROTOCOL(' ');
  13823                SERIAL_ECHO(*p++);
  13824                while (NUMERIC_SIGNED(*p))
  13825                  SERIAL_ECHO(*p++);
  13826              }
  13827              SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
  13828              SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
  13829            #endif
  13830            SERIAL_EOL();
   \   0000001A   0x210A             MOVS     R1,#+10
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable163
   \   00000020   0xE8BD 0x4004      POP      {R2,LR}
   \   00000024   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??ok_to_send_0: (+1)
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
  13831          }
  13832          
  13833          #if HAS_SOFTWARE_ENDSTOPS
  13834          
  13835            /**
  13836             * Constrain the given coordinates to the software endstops.
  13837             *
  13838             * For DELTA/SCARA the XY constraint is based on the smallest
  13839             * radius within the set software endstops.
  13840             */

   \                                 In section .text, align 2, keep-with-next
  13841            void clamp_to_software_endstops(float target[XYZ]) {
   \                     _Z26clamp_to_software_endstopsPf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
  13842              if (!soft_endstops_enabled) return;
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable168_4
   \   0000000A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x8088      BEQ.W    ??clamp_to_software_endstops_0
  13843              //#if IS_KINEMATIC
  13844              if(MACHINETPYE & IS_KINEMATIC )
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable168_5
   \   00000016   0xF106 0x0720      ADD      R7,R6,#+32
   \   0000001A   0x8F38             LDRH     R0,[R7, #+56]
   \   0000001C   0xF240 0x3102      MOVW     R1,#+770
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD048             BEQ.N    ??clamp_to_software_endstops_1
  13845              {
  13846                const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
   \   00000024   0xF8D4 0xA000      LDR      R10,[R4, #+0]
   \   00000028   0xF04F 0x0902      MOV      R9,#+2
   \   0000002C   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \   00000030   0x46D8             MOV      R8,R11
   \   00000032   0xE004             B.N      ??clamp_to_software_endstops_2
   \                     ??clamp_to_software_endstops_3: (+1)
   \   00000034   0x4650             MOV      R0,R10
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x4682             MOV      R10,R0
   \                     ??clamp_to_software_endstops_2: (+1)
   \   0000003E   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000042   0xD504             BPL.N    ??clamp_to_software_endstops_4
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x4651             MOV      R1,R10
   \   00000048   0x.... 0x....      BL       __aeabi_fmul
   \   0000004C   0x4680             MOV      R8,R0
   \                     ??clamp_to_software_endstops_4: (+1)
   \   0000004E   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000052   0xD1EF             BNE.N    ??clamp_to_software_endstops_3
   \   00000054   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \   00000058   0xF04F 0x0A02      MOV      R10,#+2
   \   0000005C   0xE004             B.N      ??clamp_to_software_endstops_5
   \                     ??clamp_to_software_endstops_6: (+1)
   \   0000005E   0x4648             MOV      R0,R9
   \   00000060   0x4649             MOV      R1,R9
   \   00000062   0x.... 0x....      BL       __aeabi_fmul
   \   00000066   0x4681             MOV      R9,R0
   \                     ??clamp_to_software_endstops_5: (+1)
   \   00000068   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000006C   0xD504             BPL.N    ??clamp_to_software_endstops_7
   \   0000006E   0x4658             MOV      R0,R11
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0x.... 0x....      BL       __aeabi_fmul
   \   00000076   0x4683             MOV      R11,R0
   \                     ??clamp_to_software_endstops_7: (+1)
   \   00000078   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   0000007C   0xD1EF             BNE.N    ??clamp_to_software_endstops_6
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x4659             MOV      R1,R11
   \   00000082   0x.... 0x....      BL       __aeabi_fadd
   \   00000086   0x4601             MOV      R1,R0
  13847                if (dist_2 > soft_endstop_radius_2) {
   \   00000088   0x6DA8             LDR      R0,[R5, #+88]
   \   0000008A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000008E   0xD233             BCS.N    ??clamp_to_software_endstops_8
  13848                  const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
   \   00000090   0x4608             MOV      R0,R1
   \   00000092   0x.... 0x....      BL       sqrtf
   \   00000096   0x4601             MOV      R1,R0
   \   00000098   0x6D68             LDR      R0,[R5, #+84]
   \   0000009A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000009E   0x4680             MOV      R8,R0
  13849                  target[X_AXIS] *= ratio;
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x4641             MOV      R1,R8
   \   000000A4   0x.... 0x....      BL       __aeabi_fmul
   \   000000A8   0x6020             STR      R0,[R4, #+0]
  13850                  target[Y_AXIS] *= ratio;
   \   000000AA   0x6860             LDR      R0,[R4, #+4]
   \   000000AC   0x4641             MOV      R1,R8
   \   000000AE   0x.... 0x....      BL       __aeabi_fmul
   \   000000B2   0x6060             STR      R0,[R4, #+4]
   \   000000B4   0xE020             B.N      ??clamp_to_software_endstops_8
  13851                }
  13852              }
  13853              //#else
  13854              else
  13855              {
  13856          		if(mksCfg.min_software_endstops)
   \                     ??clamp_to_software_endstops_1: (+1)
   \   000000B6   0xF896 0x0020      LDRB     R0,[R6, #+32]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD00D             BEQ.N    ??clamp_to_software_endstops_9
  13857          		{
  13858                		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
  13859                 	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
   \   000000BE   0x.... 0x....      LDR.W    R2,??DataTable168_3
   \   000000C2   0x6C51             LDR      R1,[R2, #+68]
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000CA   0xD200             BCS.N    ??clamp_to_software_endstops_10
   \   000000CC   0x6021             STR      R1,[R4, #+0]
  13860                		//#endif
  13861                		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
  13862                  	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
   \                     ??clamp_to_software_endstops_10: (+1)
   \   000000CE   0x6C91             LDR      R1,[R2, #+72]
   \   000000D0   0x6860             LDR      R0,[R4, #+4]
   \   000000D2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D6   0xD200             BCS.N    ??clamp_to_software_endstops_9
   \   000000D8   0x6061             STR      R1,[R4, #+4]
  13863                		//#endif
  13864          		}
  13865          		if(mksCfg.max_software_endstops)
   \                     ??clamp_to_software_endstops_9: (+1)
   \   000000DA   0x7878             LDRB     R0,[R7, #+1]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD00B             BEQ.N    ??clamp_to_software_endstops_8
  13866          		{	
  13867                		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
  13868                  	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
   \   000000E0   0x6A68             LDR      R0,[R5, #+36]
   \   000000E2   0x6821             LDR      R1,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E8   0xD200             BCS.N    ??clamp_to_software_endstops_11
   \   000000EA   0x6020             STR      R0,[R4, #+0]
  13869                		//#endif
  13870                		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
  13871                  	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
   \                     ??clamp_to_software_endstops_11: (+1)
   \   000000EC   0x6AA8             LDR      R0,[R5, #+40]
   \   000000EE   0x6861             LDR      R1,[R4, #+4]
   \   000000F0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F4   0xD200             BCS.N    ??clamp_to_software_endstops_8
   \   000000F6   0x6060             STR      R0,[R4, #+4]
  13872                		//#endif
  13873          		}
  13874              }
  13875              //#endif
  13876          	if(mksCfg.min_software_endstops)
   \                     ??clamp_to_software_endstops_8: (+1)
   \   000000F8   0xF896 0x0020      LDRB     R0,[R6, #+32]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD007             BEQ.N    ??clamp_to_software_endstops_12
  13877          	{
  13878              //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
  13879                NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
   \   00000100   0x.... 0x....      LDR.W    R2,??DataTable168_3
   \   00000104   0x6CD1             LDR      R1,[R2, #+76]
   \   00000106   0x68A0             LDR      R0,[R4, #+8]
   \   00000108   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000010C   0xD200             BCS.N    ??clamp_to_software_endstops_12
   \   0000010E   0x60A1             STR      R1,[R4, #+8]
  13880              //#endif
  13881          	}
  13882          	if(mksCfg.max_software_endstops)
   \                     ??clamp_to_software_endstops_12: (+1)
   \   00000110   0x7878             LDRB     R0,[R7, #+1]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD005             BEQ.N    ??clamp_to_software_endstops_0
  13883          	{
  13884              //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
  13885                NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
   \   00000116   0x6AE8             LDR      R0,[R5, #+44]
   \   00000118   0x68A1             LDR      R1,[R4, #+8]
   \   0000011A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011E   0xD200             BCS.N    ??clamp_to_software_endstops_0
   \   00000120   0x60A0             STR      R0,[R4, #+8]
  13886              //#endif
  13887          	}
  13888            }
   \                     ??clamp_to_software_endstops_0: (+1)
   \   00000122   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  13889          
  13890          #endif
  13891          
  13892          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
  13893          
  13894            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  13895              #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
  13896              #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
  13897              #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
  13898              #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
  13899              #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
  13900            #else
  13901              #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
  13902              #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
  13903              #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
  13904              #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
  13905              #define ABL_BG_GRID(X,Y)  z_values[X][Y]
  13906            #endif
  13907          
  13908            // Get the Z adjustment for non-linear bed leveling

   \                                 In section .text, align 2, keep-with-next
  13909            float bilinear_z_offset(const float raw[XYZ]) {
   \                     _Z17bilinear_z_offsetPKf: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
  13910          
  13911              static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
  13912                           last_x = -999.999, last_y = -999.999;
  13913          
  13914              // Whole units for the grid line indices. Constrained within bounds.
  13915              static int8_t gridx, gridy, nextx, nexty,
  13916                            last_gridx = -99, last_gridy = -99;
  13917          
  13918              // XY relative to the probed area
  13919              const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable163_1
   \   0000000A   0x69A0             LDR      R0,[R4, #+24]
   \   0000000C   0x.... 0x....      BL       __aeabi_i2f
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       __aeabi_fsub
   \   00000018   0x4606             MOV      R6,R0
  13920                          ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
   \   0000001A   0x69E0             LDR      R0,[R4, #+28]
   \   0000001C   0x.... 0x....      BL       __aeabi_i2f
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x.... 0x....      BL       __aeabi_fsub
   \   00000028   0x4605             MOV      R5,R0
  13921          
  13922              #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
  13923                // Keep using the last grid box
  13924                #define FAR_EDGE_OR_BOX 2
  13925              #else
  13926                // Just use the grid far edge
  13927                #define FAR_EDGE_OR_BOX 1
  13928              #endif
  13929          
  13930              if (last_x != rx) {
   \   0000002A   0x6E20             LDR      R0,[R4, #+96]
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000032   0xD03B             BEQ.N    ??bilinear_z_offset_0
  13931                last_x = rx;
   \   00000034   0x6626             STR      R6,[R4, #+96]
  13932                ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
   \   00000036   0x6A20             LDR      R0,[R4, #+32]
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x65A7             STR      R7,[R4, #+88]
  13933                const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
   \   00000040   0x.... 0x....      LDR.W    R6,??DataTable168_5
   \   00000044   0x.... 0x....      BL       floorf
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000004E   0xD201             BCS.N    ??bilinear_z_offset_1
   \   00000050   0x4688             MOV      R8,R1
   \   00000052   0xE011             B.N      ??bilinear_z_offset_2
   \                     ??bilinear_z_offset_1: (+1)
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       floorf
   \   0000005A   0x4681             MOV      R9,R0
   \   0000005C   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x.... 0x....      BL       __aeabi_i2f
   \   00000066   0x4680             MOV      R8,R0
   \   00000068   0x4649             MOV      R1,R9
   \   0000006A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000006E   0xD303             BCC.N    ??bilinear_z_offset_2
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0x.... 0x....      BL       floorf
   \   00000076   0x4680             MOV      R8,R0
  13934                ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
   \                     ??bilinear_z_offset_2: (+1)
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x.... 0x....      BL       __aeabi_fsub
   \   00000080   0x65A0             STR      R0,[R4, #+88]
  13935          
  13936                #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  13937                  // Beyond the grid maintain height at grid edges
  13938                  NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000088   0xD201             BCS.N    ??bilinear_z_offset_3
   \   0000008A   0x4608             MOV      R0,R1
   \   0000008C   0x65A0             STR      R0,[R4, #+88]
  13939                #endif
  13940          
  13941                gridx = gx;
                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??bilinear_z_offset_3: (+1)
   \   0000008E   0x4640             MOV      R0,R8
   \   00000090   0x.... 0x....      BL       __aeabi_f2iz
   \   00000094   0x72A0             STRB     R0,[R4, #+10]
  13942                nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
   \   00000096   0xF896 0x1060      LDRB     R1,[R6, #+96]
   \   0000009A   0xB240             SXTB     R0,R0
   \   0000009C   0x1C42             ADDS     R2,R0,#+1
   \   0000009E   0x1E4B             SUBS     R3,R1,#+1
   \   000000A0   0x429A             CMP      R2,R3
   \   000000A2   0xDA01             BGE.N    ??bilinear_z_offset_4
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \   000000A6   0xE000             B.N      ??bilinear_z_offset_5
   \                     ??bilinear_z_offset_4: (+1)
   \   000000A8   0x1E48             SUBS     R0,R1,#+1
   \                     ??bilinear_z_offset_5: (+1)
   \   000000AA   0x7320             STRB     R0,[R4, #+12]
  13943              }
  13944          
  13945              if (last_y != ry || last_gridx != gridx) {
   \                     ??bilinear_z_offset_0: (+1)
   \   000000AC   0x6E62             LDR      R2,[R4, #+100]
   \   000000AE   0x4610             MOV      R0,R2
   \   000000B0   0x4629             MOV      R1,R5
   \   000000B2   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000B6   0xD106             BNE.N    ??bilinear_z_offset_6
   \   000000B8   0xF994 0x000E      LDRSB    R0,[R4, #+14]
   \   000000BC   0xF994 0x100A      LDRSB    R1,[R4, #+10]
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xF000 0x8083      BEQ.W    ??bilinear_z_offset_7
  13946          
  13947                if (last_y != ry) {
   \                     ??bilinear_z_offset_6: (+1)
   \   000000C6   0x4610             MOV      R0,R2
   \   000000C8   0x4629             MOV      R1,R5
   \   000000CA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000CE   0xD03F             BEQ.N    ??bilinear_z_offset_8
  13948                  last_y = ry;
   \   000000D0   0x6665             STR      R5,[R4, #+100]
  13949                  ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
   \   000000D2   0x6A60             LDR      R0,[R4, #+36]
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x4605             MOV      R5,R0
   \   000000DA   0x65E5             STR      R5,[R4, #+92]
  13950                  const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
   \   000000DC   0x.... 0x....      BL       floorf
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E6   0xD201             BCS.N    ??bilinear_z_offset_9
   \   000000E8   0x460E             MOV      R6,R1
   \   000000EA   0xE014             B.N      ??bilinear_z_offset_10
   \                     ??bilinear_z_offset_9: (+1)
   \   000000EC   0x4628             MOV      R0,R5
   \   000000EE   0x.... 0x....      BL       floorf
   \   000000F2   0x4607             MOV      R7,R0
   \   000000F4   0x.... 0x....      LDR.W    R6,??DataTable168_5
   \   000000F8   0xF106 0x0160      ADD      R1,R6,#+96
   \   000000FC   0x7848             LDRB     R0,[R1, #+1]
   \   000000FE   0x1E40             SUBS     R0,R0,#+1
   \   00000100   0x.... 0x....      BL       __aeabi_i2f
   \   00000104   0x4606             MOV      R6,R0
   \   00000106   0x4639             MOV      R1,R7
   \   00000108   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000010C   0xD303             BCC.N    ??bilinear_z_offset_10
   \   0000010E   0x4628             MOV      R0,R5
   \   00000110   0x.... 0x....      BL       floorf
   \   00000114   0x4606             MOV      R6,R0
  13951                  ratio_y -= gy;
   \                     ??bilinear_z_offset_10: (+1)
   \   00000116   0x4628             MOV      R0,R5
   \   00000118   0x4631             MOV      R1,R6
   \   0000011A   0x.... 0x....      BL       __aeabi_fsub
   \   0000011E   0x65E0             STR      R0,[R4, #+92]
  13952          
  13953                  #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  13954                    // Beyond the grid maintain height at grid edges
  13955                    NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000126   0xD201             BCS.N    ??bilinear_z_offset_11
   \   00000128   0x4608             MOV      R0,R1
   \   0000012A   0x65E0             STR      R0,[R4, #+92]
  13956                  #endif
  13957          
  13958                  gridy = gy;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??bilinear_z_offset_11: (+1)
   \   0000012C   0x4630             MOV      R0,R6
   \   0000012E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000132   0x72E0             STRB     R0,[R4, #+11]
  13959                  nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
   \   00000134   0x.... 0x....      LDR.W    R6,??DataTable168_5
   \   00000138   0xF106 0x0160      ADD      R1,R6,#+96
   \   0000013C   0x7849             LDRB     R1,[R1, #+1]
   \   0000013E   0xB240             SXTB     R0,R0
   \   00000140   0x1C42             ADDS     R2,R0,#+1
   \   00000142   0x1E4B             SUBS     R3,R1,#+1
   \   00000144   0x429A             CMP      R2,R3
   \   00000146   0xDA01             BGE.N    ??bilinear_z_offset_12
   \   00000148   0x1C40             ADDS     R0,R0,#+1
   \   0000014A   0xE000             B.N      ??bilinear_z_offset_13
   \                     ??bilinear_z_offset_12: (+1)
   \   0000014C   0x1E48             SUBS     R0,R1,#+1
   \                     ??bilinear_z_offset_13: (+1)
   \   0000014E   0x7360             STRB     R0,[R4, #+13]
  13960                }
  13961          
  13962                if (last_gridx != gridx || last_gridy != gridy) {
   \                     ??bilinear_z_offset_8: (+1)
   \   00000150   0xF994 0x500B      LDRSB    R5,[R4, #+11]
   \   00000154   0xF994 0x000A      LDRSB    R0,[R4, #+10]
   \   00000158   0xF994 0x100E      LDRSB    R1,[R4, #+14]
   \   0000015C   0x4281             CMP      R1,R0
   \   0000015E   0xD103             BNE.N    ??bilinear_z_offset_14
   \   00000160   0xF994 0x100F      LDRSB    R1,[R4, #+15]
   \   00000164   0x42A9             CMP      R1,R5
   \   00000166   0xD01C             BEQ.N    ??bilinear_z_offset_15
  13963                  last_gridx = gridx;
   \                     ??bilinear_z_offset_14: (+1)
   \   00000168   0x73A0             STRB     R0,[R4, #+14]
  13964                  last_gridy = gridy;
   \   0000016A   0x73E5             STRB     R5,[R4, #+15]
  13965                  // Z at the box corners
  13966                  z1 = ABL_BG_GRID(gridx, gridy);       // left-front
   \   0000016C   0x2730             MOVS     R7,#+48
   \   0000016E   0x.... 0x....      LDR.W    R8,??DataTable170
   \   00000172   0xFB07 0x8000      MLA      R0,R7,R0,R8
   \   00000176   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \   0000017A   0x6421             STR      R1,[R4, #+64]
   \   0000017C   0xF994 0x600D      LDRSB    R6,[R4, #+13]
   \   00000180   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000184   0x.... 0x....      BL       __aeabi_fsub
   \   00000188   0x6460             STR      R0,[R4, #+68]
  13967                  d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
  13968                  z3 = ABL_BG_GRID(nextx, gridy);       // right-front
   \   0000018A   0xF994 0x000C      LDRSB    R0,[R4, #+12]
   \   0000018E   0xFB07 0x8000      MLA      R0,R7,R0,R8
   \   00000192   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \   00000196   0x64A1             STR      R1,[R4, #+72]
  13969                  d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
   \   00000198   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   0000019C   0x.... 0x....      BL       __aeabi_fsub
   \   000001A0   0x64E0             STR      R0,[R4, #+76]
  13970                }
  13971          
  13972                // Bilinear interpolate. Needed since ry or gridx has changed.
  13973                            L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
   \                     ??bilinear_z_offset_15: (+1)
   \   000001A2   0x6DE5             LDR      R5,[R4, #+92]
   \   000001A4   0x6C60             LDR      R0,[R4, #+68]
   \   000001A6   0x4629             MOV      R1,R5
   \   000001A8   0x.... 0x....      BL       __aeabi_fmul
   \   000001AC   0x6C21             LDR      R1,[R4, #+64]
   \   000001AE   0x.... 0x....      BL       __aeabi_fadd
   \   000001B2   0x4606             MOV      R6,R0
   \   000001B4   0x6526             STR      R6,[R4, #+80]
  13974                const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
  13975          
  13976                D = R - L;
   \   000001B6   0x6CE0             LDR      R0,[R4, #+76]
   \   000001B8   0x4629             MOV      R1,R5
   \   000001BA   0x.... 0x....      BL       __aeabi_fmul
   \   000001BE   0x6CA1             LDR      R1,[R4, #+72]
   \   000001C0   0x.... 0x....      BL       __aeabi_fadd
   \   000001C4   0x4631             MOV      R1,R6
   \   000001C6   0x.... 0x....      BL       __aeabi_fsub
   \   000001CA   0x6560             STR      R0,[R4, #+84]
  13977              }
  13978          
  13979              const float offset = L + ratio_x * D;   // the offset almost always changes
  13980          
  13981              /*
  13982              static float last_offset = 0;
  13983              if (FABS(last_offset - offset) > 0.2) {
  13984                SERIAL_ECHOPGM("Sudden Shift at ");
  13985                SERIAL_ECHOPAIR("x=", rx);
  13986                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
  13987                SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
  13988                SERIAL_ECHOPAIR(" y=", ry);
  13989                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
  13990                SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
  13991                SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
  13992                SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
  13993                SERIAL_ECHOPAIR(" z1=", z1);
  13994                SERIAL_ECHOPAIR(" z2=", z2);
  13995                SERIAL_ECHOPAIR(" z3=", z3);
  13996                SERIAL_ECHOLNPAIR(" z4=", z4);
  13997                SERIAL_ECHOPAIR(" L=", L);
  13998                SERIAL_ECHOPAIR(" R=", R);
  13999                SERIAL_ECHOLNPAIR(" offset=", offset);
  14000              }
  14001              last_offset = offset;
  14002              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  14003          
  14004              return offset;
   \                     ??bilinear_z_offset_7: (+1)
   \   000001CC   0x6DA1             LDR      R1,[R4, #+88]
   \   000001CE   0x6D60             LDR      R0,[R4, #+84]
   \   000001D0   0x.... 0x....      BL       __aeabi_fmul
   \   000001D4   0x6D21             LDR      R1,[R4, #+80]
   \   000001D6   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000001DA   0x.... 0x....      B.W      __aeabi_fadd
  14005            }

   \                                 In section .data, align 4
   \                     axis_relative_modes:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Running:
   \   00000004   0x01               DC8 1
   \   00000005   0x00               DC8 0
   \                     busy_state:
   \   00000006   0x00               DC8 0
   \                     host_keepalive_interval:
   \   00000007   0x02               DC8 2
   \                     serial_wait_tick:
   \   00000008   0x00               DC8 0
   \                     from_wifi_flag:
   \   00000009   0x00               DC8 0
   \   0000000A   0x00               DC8 0
   \   0000000B   0x00               DC8 0
   \   0000000C   0x00               DC8 0
   \   0000000D   0x00               DC8 0
   \   0000000E   0x9D               DC8 -99
   \   0000000F   0x9D               DC8 -99
   \                     bilinear_grid_spacing:
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     bilinear_start:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     bilinear_grid_factor:
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000030   0x00000000         DC32 0
   \   00000034   0x00000000         DC32 0
   \   00000038   0x00000000         DC32 0
   \   0000003C   0x00000000         DC32 0
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000004C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000060   0xC479FFF0         DC32 0C479FFF0H
   \   00000064   0xC479FFF0         DC32 0C479FFF0H

   \                                 In section .data, align 4
   \                     axis_homed:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     axis_known_position:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     soft_endstops_enabled:
   \   00000008   0x01               DC8 1
   \                     lcd_wait_for_move:
   \   00000009   0x00               DC8 0
   \   0000000A   0x00 0x00          DC8 0, 0
   \                     delta_tower:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_max:
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta_tower_angle_trim:
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta_diagonal_rod_2_tower:
   \   0000003C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     cartes:
   \   00000048   0x00000000         DC32 0H
   \   0000004C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_radius:
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     soft_endstop_radius_2:
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     previous_cmd_ms:
   \   0000005C   0x00000000         DC32 0
   \   00000060   0x00000000         DC32 0
   \   00000064   0x0001D4C0         DC32 120000
   \                     delta_radius:
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_diagonal_rod:
   \   0000006C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_calibration_radius:
   \   00000070   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_segments_per_second:
   \   00000074   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     home_bump_mm_P:
   \   00000000   0x40A00000         DC32 40A00000H, 40A00000H, 40A00000H
   \              0x40A00000   
   \              0x40A00000   

   \                                 In section .data, align 4
   \                     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index:
   \   00000000   0xFFFFFFFF         DC32 -1
  14006          
  14007          #endif // AUTO_BED_LEVELING_BILINEAR
  14008          
  14009          #if 1//ENABLED(DELTA)
  14010          
  14011            /**
  14012             * Recalculate factors used for delta kinematics whenever
  14013             * settings have been changed (e.g., by M665).
  14014             */

   \                                 In section .text, align 2, keep-with-next
  14015            void recalc_delta_settings() {
   \                     _Z21recalc_delta_settingsv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
  14016              const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
  14017                          drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
  14018              delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
   \   00000004   0x.... 0x....      LDR.W    R8,??DataTable170_1  ;; 0x54442d18
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable170_2  ;; 0x400921fb
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable170_3  ;; 0x43520000
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable168_4
   \   00000014   0x6B30             LDR      R0,[R6, #+48]
   \   00000016   0x4639             MOV      R1,R7
   \   00000018   0x.... 0x....      BL       __aeabi_fadd
   \   0000001C   0x.... 0x....      BL       __aeabi_f2d
   \   00000020   0x4642             MOV      R2,R8
   \   00000022   0x464B             MOV      R3,R9
   \   00000024   0x.... 0x....      BL       __aeabi_dmul
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable170_4  ;; 0x40668000
   \   0000002E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000032   0x.... 0x....      BL       cos
   \   00000036   0x4604             MOV      R4,R0
   \   00000038   0x460D             MOV      R5,R1
   \   0000003A   0x6EB1             LDR      R1,[R6, #+104]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       __aeabi_fadd
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x462B             MOV      R3,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_dmul
   \   0000004E   0x.... 0x....      BL       __aeabi_d2f
   \   00000052   0x60F0             STR      R0,[R6, #+12]
  14019              delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
   \   00000054   0x6B30             LDR      R0,[R6, #+48]
   \   00000056   0x4639             MOV      R1,R7
   \   00000058   0x.... 0x....      BL       __aeabi_fadd
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x4642             MOV      R2,R8
   \   00000062   0x464B             MOV      R3,R9
   \   00000064   0x.... 0x....      BL       __aeabi_dmul
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x.... 0x....      LDR.W    R3,??DataTable170_4  ;; 0x40668000
   \   0000006E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000072   0x.... 0x....      BL       sin
   \   00000076   0x4604             MOV      R4,R0
   \   00000078   0x460D             MOV      R5,R1
   \   0000007A   0x6EB1             LDR      R1,[R6, #+104]
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      BL       __aeabi_fadd
   \   00000082   0x.... 0x....      BL       __aeabi_f2d
   \   00000086   0x4622             MOV      R2,R4
   \   00000088   0x462B             MOV      R3,R5
   \   0000008A   0x.... 0x....      BL       __aeabi_dmul
   \   0000008E   0x.... 0x....      BL       __aeabi_d2f
   \   00000092   0x6130             STR      R0,[R6, #+16]
  14020              delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
   \   00000094   0x.... 0x....      LDR.W    R7,??DataTable170_5  ;; 0x43a50000
   \   00000098   0x6B70             LDR      R0,[R6, #+52]
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x.... 0x....      BL       __aeabi_f2d
   \   000000A4   0x4642             MOV      R2,R8
   \   000000A6   0x464B             MOV      R3,R9
   \   000000A8   0x.... 0x....      BL       __aeabi_dmul
   \   000000AC   0x2200             MOVS     R2,#+0
   \   000000AE   0x.... 0x....      LDR.W    R3,??DataTable170_4  ;; 0x40668000
   \   000000B2   0x.... 0x....      BL       __aeabi_ddiv
   \   000000B6   0x.... 0x....      BL       cos
   \   000000BA   0x4604             MOV      R4,R0
   \   000000BC   0x460D             MOV      R5,R1
   \   000000BE   0x6EB1             LDR      R1,[R6, #+104]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       __aeabi_fadd
   \   000000C6   0x.... 0x....      BL       __aeabi_f2d
   \   000000CA   0x4622             MOV      R2,R4
   \   000000CC   0x462B             MOV      R3,R5
   \   000000CE   0x.... 0x....      BL       __aeabi_dmul
   \   000000D2   0x.... 0x....      BL       __aeabi_d2f
   \   000000D6   0x6170             STR      R0,[R6, #+20]
  14021              delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
   \   000000D8   0x6B70             LDR      R0,[R6, #+52]
   \   000000DA   0x4639             MOV      R1,R7
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x.... 0x....      BL       __aeabi_f2d
   \   000000E4   0x4642             MOV      R2,R8
   \   000000E6   0x464B             MOV      R3,R9
   \   000000E8   0x.... 0x....      BL       __aeabi_dmul
   \   000000EC   0x2200             MOVS     R2,#+0
   \   000000EE   0x.... 0x....      LDR.W    R3,??DataTable170_4  ;; 0x40668000
   \   000000F2   0x.... 0x....      BL       __aeabi_ddiv
   \   000000F6   0x.... 0x....      BL       sin
   \   000000FA   0x4604             MOV      R4,R0
   \   000000FC   0x460D             MOV      R5,R1
   \   000000FE   0x6EB1             LDR      R1,[R6, #+104]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x.... 0x....      BL       __aeabi_fadd
   \   00000106   0x.... 0x....      BL       __aeabi_f2d
   \   0000010A   0x4622             MOV      R2,R4
   \   0000010C   0x462B             MOV      R3,R5
   \   0000010E   0x.... 0x....      BL       __aeabi_dmul
   \   00000112   0x.... 0x....      BL       __aeabi_d2f
   \   00000116   0x61B0             STR      R0,[R6, #+24]
  14022              delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
   \   00000118   0x.... 0x....      LDR.W    R7,??DataTable171  ;; 0x42b40000
   \   0000011C   0x6BB0             LDR      R0,[R6, #+56]
   \   0000011E   0x4639             MOV      R1,R7
   \   00000120   0x.... 0x....      BL       __aeabi_fadd
   \   00000124   0x.... 0x....      BL       __aeabi_f2d
   \   00000128   0x4642             MOV      R2,R8
   \   0000012A   0x464B             MOV      R3,R9
   \   0000012C   0x.... 0x....      BL       __aeabi_dmul
   \   00000130   0x2200             MOVS     R2,#+0
   \   00000132   0x.... 0x....      LDR.W    R3,??DataTable170_4  ;; 0x40668000
   \   00000136   0x.... 0x....      BL       __aeabi_ddiv
   \   0000013A   0x.... 0x....      BL       cos
   \   0000013E   0x4604             MOV      R4,R0
   \   00000140   0x460D             MOV      R5,R1
   \   00000142   0x6EB1             LDR      R1,[R6, #+104]
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x.... 0x....      BL       __aeabi_fadd
   \   0000014A   0x.... 0x....      BL       __aeabi_f2d
   \   0000014E   0x4622             MOV      R2,R4
   \   00000150   0x462B             MOV      R3,R5
   \   00000152   0x.... 0x....      BL       __aeabi_dmul
   \   00000156   0x.... 0x....      BL       __aeabi_d2f
   \   0000015A   0x61F0             STR      R0,[R6, #+28]
  14023              delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
   \   0000015C   0x6BB0             LDR      R0,[R6, #+56]
   \   0000015E   0x4639             MOV      R1,R7
   \   00000160   0x.... 0x....      BL       __aeabi_fadd
   \   00000164   0x.... 0x....      BL       __aeabi_f2d
   \   00000168   0x4642             MOV      R2,R8
   \   0000016A   0x464B             MOV      R3,R9
   \   0000016C   0x.... 0x....      BL       __aeabi_dmul
   \   00000170   0x2200             MOVS     R2,#+0
   \   00000172   0x.... 0x....      LDR.W    R3,??DataTable170_4  ;; 0x40668000
   \   00000176   0x.... 0x....      BL       __aeabi_ddiv
   \   0000017A   0x.... 0x....      BL       sin
   \   0000017E   0x4604             MOV      R4,R0
   \   00000180   0x460D             MOV      R5,R1
   \   00000182   0x6EB1             LDR      R1,[R6, #+104]
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x.... 0x....      BL       __aeabi_fadd
   \   0000018A   0x.... 0x....      BL       __aeabi_f2d
   \   0000018E   0x4622             MOV      R2,R4
   \   00000190   0x462B             MOV      R3,R5
   \   00000192   0x.... 0x....      BL       __aeabi_dmul
   \   00000196   0x.... 0x....      BL       __aeabi_d2f
   \   0000019A   0x6230             STR      R0,[R6, #+32]
  14024              delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
   \   0000019C   0x6EF1             LDR      R1,[R6, #+108]
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0x.... 0x....      BL       __aeabi_fadd
   \   000001A4   0x4604             MOV      R4,R0
   \   000001A6   0x4627             MOV      R7,R4
   \   000001A8   0xF04F 0x0802      MOV      R8,#+2
   \   000001AC   0xF04F 0x557E      MOV      R5,#+1065353216
   \   000001B0   0x46A9             MOV      R9,R5
   \   000001B2   0xE004             B.N      ??recalc_delta_settings_0
   \                     ??recalc_delta_settings_1: (+1)
   \   000001B4   0x4638             MOV      R0,R7
   \   000001B6   0x4639             MOV      R1,R7
   \   000001B8   0x.... 0x....      BL       __aeabi_fmul
   \   000001BC   0x4607             MOV      R7,R0
   \                     ??recalc_delta_settings_0: (+1)
   \   000001BE   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000001C2   0xD504             BPL.N    ??recalc_delta_settings_2
   \   000001C4   0x4648             MOV      R0,R9
   \   000001C6   0x4639             MOV      R1,R7
   \   000001C8   0x.... 0x....      BL       __aeabi_fmul
   \   000001CC   0x4681             MOV      R9,R0
   \                     ??recalc_delta_settings_2: (+1)
   \   000001CE   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   000001D2   0xD1EF             BNE.N    ??recalc_delta_settings_1
   \   000001D4   0xF8C6 0x903C      STR      R9,[R6, #+60]
  14025              delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
   \   000001D8   0x4627             MOV      R7,R4
   \   000001DA   0xF04F 0x0802      MOV      R8,#+2
   \   000001DE   0x46A9             MOV      R9,R5
   \   000001E0   0xE004             B.N      ??recalc_delta_settings_3
   \                     ??recalc_delta_settings_4: (+1)
   \   000001E2   0x4638             MOV      R0,R7
   \   000001E4   0x4639             MOV      R1,R7
   \   000001E6   0x.... 0x....      BL       __aeabi_fmul
   \   000001EA   0x4607             MOV      R7,R0
   \                     ??recalc_delta_settings_3: (+1)
   \   000001EC   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000001F0   0xD504             BPL.N    ??recalc_delta_settings_5
   \   000001F2   0x4648             MOV      R0,R9
   \   000001F4   0x4639             MOV      R1,R7
   \   000001F6   0x.... 0x....      BL       __aeabi_fmul
   \   000001FA   0x4681             MOV      R9,R0
   \                     ??recalc_delta_settings_5: (+1)
   \   000001FC   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000200   0xD1EF             BNE.N    ??recalc_delta_settings_4
   \   00000202   0xF8C6 0x9040      STR      R9,[R6, #+64]
  14026              delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
   \   00000206   0x2702             MOVS     R7,#+2
   \   00000208   0xE004             B.N      ??recalc_delta_settings_6
   \                     ??recalc_delta_settings_7: (+1)
   \   0000020A   0x4620             MOV      R0,R4
   \   0000020C   0x4621             MOV      R1,R4
   \   0000020E   0x.... 0x....      BL       __aeabi_fmul
   \   00000212   0x4604             MOV      R4,R0
   \                     ??recalc_delta_settings_6: (+1)
   \   00000214   0x07F8             LSLS     R0,R7,#+31
   \   00000216   0xD504             BPL.N    ??recalc_delta_settings_8
   \   00000218   0x4628             MOV      R0,R5
   \   0000021A   0x4621             MOV      R1,R4
   \   0000021C   0x.... 0x....      BL       __aeabi_fmul
   \   00000220   0x4605             MOV      R5,R0
   \                     ??recalc_delta_settings_8: (+1)
   \   00000222   0x087F             LSRS     R7,R7,#+1
   \   00000224   0xD1F1             BNE.N    ??recalc_delta_settings_7
   \   00000226   0x6475             STR      R5,[R6, #+68]
  14027              update_software_endstops(Z_AXIS);
   \   00000228   0x2002             MOVS     R0,#+2
   \   0000022A   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
  14028              axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
   \   0000022E   0x2000             MOVS     R0,#+0
   \   00000230   0x70B0             STRB     R0,[R6, #+2]
   \   00000232   0x8030             STRH     R0,[R6, #+0]
  14029            }
   \   00000234   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
  14030          
  14031            #if ENABLED(DELTA_FAST_SQRT)
  14032              /**
  14033               * Fast inverse sqrt from Quake III Arena
  14034               * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
  14035               */
  14036              float Q_rsqrt(const float number) {
  14037                long i;
  14038                float x2, y;
  14039                const float threehalfs = 1.5f;
  14040                x2 = number * 0.5f;
  14041                y  = number;
  14042                i  = * ( long * ) &y;                       // evil floating point bit level hacking
  14043                i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
  14044                y  = * ( float * ) &i;
  14045                y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
  14046                // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
  14047                return y;
  14048              }
  14049          
  14050            #endif
  14051          
  14052            /**
  14053             * Delta Inverse Kinematics
  14054             *
  14055             * Calculate the tower positions for a given machine
  14056             * position, storing the result in the delta[] array.
  14057             *
  14058             * This is an expensive calculation, requiring 3 square
  14059             * roots per segmented linear move, and strains the limits
  14060             * of a Mega2560 with a Graphical Display.
  14061             *
  14062             * Suggested optimizations include:
  14063             *
  14064             * - Disable the home_offset (M206) and/or position_shift (G92)
  14065             *   features to remove up to 12 float additions.
  14066             *
  14067             * - Use a fast-inverse-sqrt function and add the reciprocal.
  14068             *   (see above)
  14069             */
  14070          
  14071            #define DELTA_DEBUG() do { \
  14072                SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \
  14073                SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \
  14074                SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \
  14075                SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \
  14076                SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \
  14077                SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \
  14078              }while(0)
  14079          

   \                                 In section .text, align 2, keep-with-next
  14080            void inverse_kinematics(const float raw[XYZ]) {
   \                     _Z18inverse_kinematicsPKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
  14081              DELTA_IK(raw);
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable168_4
   \   0000000A   0x68F0             LDR      R0,[R6, #+12]
   \   0000000C   0x6829             LDR      R1,[R5, #+0]
   \   0000000E   0x.... 0x....      BL       __aeabi_fsub
   \   00000012   0x4680             MOV      R8,R0
   \   00000014   0xF04F 0x0902      MOV      R9,#+2
   \   00000018   0xF04F 0x547E      MOV      R4,#+1065353216
   \   0000001C   0x4627             MOV      R7,R4
   \   0000001E   0xE004             B.N      ??inverse_kinematics_0
   \                     ??inverse_kinematics_1: (+1)
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0x.... 0x....      BL       __aeabi_fmul
   \   00000028   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_0: (+1)
   \   0000002A   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000002E   0xD504             BPL.N    ??inverse_kinematics_2
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x4641             MOV      R1,R8
   \   00000034   0x.... 0x....      BL       __aeabi_fmul
   \   00000038   0x4607             MOV      R7,R0
   \                     ??inverse_kinematics_2: (+1)
   \   0000003A   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000003E   0xD1EF             BNE.N    ??inverse_kinematics_1
   \   00000040   0x6930             LDR      R0,[R6, #+16]
   \   00000042   0x6869             LDR      R1,[R5, #+4]
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0x4680             MOV      R8,R0
   \   0000004A   0xF04F 0x0902      MOV      R9,#+2
   \   0000004E   0x46A2             MOV      R10,R4
   \   00000050   0xE004             B.N      ??inverse_kinematics_3
   \                     ??inverse_kinematics_4: (+1)
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x4641             MOV      R1,R8
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_3: (+1)
   \   0000005C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000060   0xD504             BPL.N    ??inverse_kinematics_5
   \   00000062   0x4650             MOV      R0,R10
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_5: (+1)
   \   0000006C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000070   0xD1EF             BNE.N    ??inverse_kinematics_4
   \   00000072   0x4638             MOV      R0,R7
   \   00000074   0x4651             MOV      R1,R10
   \   00000076   0x.... 0x....      BL       __aeabi_fadd
   \   0000007A   0x4601             MOV      R1,R0
   \   0000007C   0x6BF0             LDR      R0,[R6, #+60]
   \   0000007E   0x.... 0x....      BL       __aeabi_fsub
   \   00000082   0x.... 0x....      BL       sqrtf
   \   00000086   0x.... 0x....      LDR.W    R7,??DataTable168_3
   \   0000008A   0x68A9             LDR      R1,[R5, #+8]
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
   \   00000090   0x6538             STR      R0,[R7, #+80]
   \   00000092   0x6970             LDR      R0,[R6, #+20]
   \   00000094   0x6829             LDR      R1,[R5, #+0]
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4681             MOV      R9,R0
   \   0000009C   0xF04F 0x0A02      MOV      R10,#+2
   \   000000A0   0x46A0             MOV      R8,R4
   \   000000A2   0xE004             B.N      ??inverse_kinematics_6
   \                     ??inverse_kinematics_7: (+1)
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x4649             MOV      R1,R9
   \   000000A8   0x.... 0x....      BL       __aeabi_fmul
   \   000000AC   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_6: (+1)
   \   000000AE   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000000B2   0xD504             BPL.N    ??inverse_kinematics_8
   \   000000B4   0x4640             MOV      R0,R8
   \   000000B6   0x4649             MOV      R1,R9
   \   000000B8   0x.... 0x....      BL       __aeabi_fmul
   \   000000BC   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_8: (+1)
   \   000000BE   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000000C2   0xD1EF             BNE.N    ??inverse_kinematics_7
   \   000000C4   0x69B0             LDR      R0,[R6, #+24]
   \   000000C6   0x6869             LDR      R1,[R5, #+4]
   \   000000C8   0x.... 0x....      BL       __aeabi_fsub
   \   000000CC   0x4683             MOV      R11,R0
   \   000000CE   0xF04F 0x0902      MOV      R9,#+2
   \   000000D2   0x46A2             MOV      R10,R4
   \   000000D4   0xE004             B.N      ??inverse_kinematics_9
   \                     ??inverse_kinematics_10: (+1)
   \   000000D6   0x4658             MOV      R0,R11
   \   000000D8   0x4659             MOV      R1,R11
   \   000000DA   0x.... 0x....      BL       __aeabi_fmul
   \   000000DE   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_9: (+1)
   \   000000E0   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000E4   0xD504             BPL.N    ??inverse_kinematics_11
   \   000000E6   0x4650             MOV      R0,R10
   \   000000E8   0x4659             MOV      R1,R11
   \   000000EA   0x.... 0x....      BL       __aeabi_fmul
   \   000000EE   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_11: (+1)
   \   000000F0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000F4   0xD1EF             BNE.N    ??inverse_kinematics_10
   \   000000F6   0x4640             MOV      R0,R8
   \   000000F8   0x4651             MOV      R1,R10
   \   000000FA   0x.... 0x....      BL       __aeabi_fadd
   \   000000FE   0x4601             MOV      R1,R0
   \   00000100   0x6C30             LDR      R0,[R6, #+64]
   \   00000102   0x.... 0x....      BL       __aeabi_fsub
   \   00000106   0x.... 0x....      BL       sqrtf
   \   0000010A   0x4601             MOV      R1,R0
   \   0000010C   0x68A8             LDR      R0,[R5, #+8]
   \   0000010E   0x.... 0x....      BL       __aeabi_fadd
   \   00000112   0x6578             STR      R0,[R7, #+84]
   \   00000114   0x69F0             LDR      R0,[R6, #+28]
   \   00000116   0x6829             LDR      R1,[R5, #+0]
   \   00000118   0x.... 0x....      BL       __aeabi_fsub
   \   0000011C   0x4681             MOV      R9,R0
   \   0000011E   0xF04F 0x0A02      MOV      R10,#+2
   \   00000122   0x46A0             MOV      R8,R4
   \   00000124   0xE004             B.N      ??inverse_kinematics_12
   \                     ??inverse_kinematics_13: (+1)
   \   00000126   0x4648             MOV      R0,R9
   \   00000128   0x4649             MOV      R1,R9
   \   0000012A   0x.... 0x....      BL       __aeabi_fmul
   \   0000012E   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_12: (+1)
   \   00000130   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000134   0xD504             BPL.N    ??inverse_kinematics_14
   \   00000136   0x4640             MOV      R0,R8
   \   00000138   0x4649             MOV      R1,R9
   \   0000013A   0x.... 0x....      BL       __aeabi_fmul
   \   0000013E   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_14: (+1)
   \   00000140   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000144   0xD1EF             BNE.N    ??inverse_kinematics_13
   \   00000146   0x6A30             LDR      R0,[R6, #+32]
   \   00000148   0x6869             LDR      R1,[R5, #+4]
   \   0000014A   0x.... 0x....      BL       __aeabi_fsub
   \   0000014E   0x4682             MOV      R10,R0
   \   00000150   0xF04F 0x0902      MOV      R9,#+2
   \   00000154   0xE004             B.N      ??inverse_kinematics_15
   \                     ??inverse_kinematics_16: (+1)
   \   00000156   0x4650             MOV      R0,R10
   \   00000158   0x4651             MOV      R1,R10
   \   0000015A   0x.... 0x....      BL       __aeabi_fmul
   \   0000015E   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_15: (+1)
   \   00000160   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000164   0xD504             BPL.N    ??inverse_kinematics_17
   \   00000166   0x4620             MOV      R0,R4
   \   00000168   0x4651             MOV      R1,R10
   \   0000016A   0x.... 0x....      BL       __aeabi_fmul
   \   0000016E   0x4604             MOV      R4,R0
   \                     ??inverse_kinematics_17: (+1)
   \   00000170   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000174   0xD1EF             BNE.N    ??inverse_kinematics_16
   \   00000176   0x4640             MOV      R0,R8
   \   00000178   0x4621             MOV      R1,R4
   \   0000017A   0x.... 0x....      BL       __aeabi_fadd
   \   0000017E   0x4601             MOV      R1,R0
   \   00000180   0x6C70             LDR      R0,[R6, #+68]
   \   00000182   0x.... 0x....      BL       __aeabi_fsub
   \   00000186   0x.... 0x....      BL       sqrtf
   \   0000018A   0x4601             MOV      R1,R0
   \   0000018C   0x68A8             LDR      R0,[R5, #+8]
   \   0000018E   0x.... 0x....      BL       __aeabi_fadd
   \   00000192   0x65B8             STR      R0,[R7, #+88]
  14082              // DELTA_DEBUG();
  14083            }
   \   00000194   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  14084          
  14085            /**
  14086             * Calculate the highest Z position where the
  14087             * effector has the full range of XY motion.
  14088             */

   \                                 In section .text, align 2, keep-with-next
  14089            float delta_safe_distance_from_top() {
   \                     _Z28delta_safe_distance_from_topv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
  14090              float cartesian[XYZ] = { 0, 0, 0 };
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x460B             MOV      R3,R1
   \   0000000C   0xC00E             STM      R0!,{R1-R3}
  14091          	if(MACHINETPYE == MORGAN_SCARA)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable168_5
   \   00000012   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000016   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0xD102             BNE.N    ??delta_safe_distance_from_top_0
  14092          		inverse_kinematics_MORGAN_SCARA(cartesian);
   \   0000001E   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   00000022   0xE001             B.N      ??delta_safe_distance_from_top_1
  14093          	else
  14094              	inverse_kinematics(cartesian);
   \                     ??delta_safe_distance_from_top_0: (+1)
   \   00000024   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
  14095          	
  14096              float distance = delta[A_AXIS];
   \                     ??delta_safe_distance_from_top_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable168_3
   \   0000002C   0x6D2E             LDR      R6,[R5, #+80]
  14097              cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
   \   0000002E   0x6D60             LDR      R0,[R4, #+84]
   \   00000030   0x9001             STR      R0,[SP, #+4]
  14098          	if(MACHINETPYE == MORGAN_SCARA)
   \   00000032   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0xD102             BNE.N    ??delta_safe_distance_from_top_2
  14099          		inverse_kinematics_MORGAN_SCARA(cartesian);
   \   0000003E   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   00000042   0xE001             B.N      ??delta_safe_distance_from_top_3
  14100          	else
  14101              	inverse_kinematics(cartesian);
   \                     ??delta_safe_distance_from_top_2: (+1)
   \   00000044   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
  14102              return FABS(distance - delta[A_AXIS]);
   \                     ??delta_safe_distance_from_top_3: (+1)
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x6D29             LDR      R1,[R5, #+80]
   \   0000004C   0x.... 0x....      BL       __aeabi_fsub
   \   00000050   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000054   0xB004             ADD      SP,SP,#+16
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
  14103            }
  14104          
  14105            /**
  14106             * Delta Forward Kinematics
  14107             *
  14108             * See the Wikipedia article "Trilateration"
  14109             * https://en.wikipedia.org/wiki/Trilateration
  14110             *
  14111             * Establish a new coordinate system in the plane of the
  14112             * three carriage points. This system has its origin at
  14113             * tower1, with tower2 on the X axis. Tower3 is in the X-Y
  14114             * plane with a Z component of zero.
  14115             * We will define unit vectors in this coordinate system
  14116             * in our original coordinate system. Then when we calculate
  14117             * the Xnew, Ynew and Znew values, we can translate back into
  14118             * the original system by moving along those unit vectors
  14119             * by the corresponding values.
  14120             *
  14121             * Variable names matched to Marlin, c-version, and avoid the
  14122             * use of any vector library.
  14123             *
  14124             * by Andreas Hardtung 2016-06-07
  14125             * based on a Java function from "Delta Robot Kinematics V3"
  14126             * by Steve Graves
  14127             *
  14128             * The result is stored in the cartes[] array.
  14129             */

   \                                 In section .text, align 2, keep-with-next
  14130            void forward_kinematics_DELTA(float z1, float z2, float z3) {
   \                     _Z24forward_kinematics_DELTAfff: (+1)
   \   00000000   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable168_4
   \   0000000C   0x6940             LDR      R0,[R0, #+20]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable168_4
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x.... 0x....      BL       __aeabi_fsub
   \   00000018   0x4606             MOV      R6,R0
  14131              // Create a vector in old coordinates along x axis of new coordinate
  14132              const float p12[] = {
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable168_4
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable168_4
   \   00000024   0x6909             LDR      R1,[R1, #+16]
   \   00000026   0x.... 0x....      BL       __aeabi_fsub
   \   0000002A   0x4605             MOV      R5,R0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x9909             LDR      R1,[SP, #+36]
   \   00000030   0x.... 0x....      BL       __aeabi_fsub
   \   00000034   0x4604             MOV      R4,R0
  14133                delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
  14134                delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
  14135                z2 - z1
  14136              },
  14137          
  14138              // Get the Magnitude of vector.
  14139              d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
   \   00000036   0x46B0             MOV      R8,R6
   \   00000038   0xF04F 0x0902      MOV      R9,#+2
   \   0000003C   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000040   0xE004             B.N      ??forward_kinematics_DELTA_0
   \                     ??forward_kinematics_DELTA_1: (+1)
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0x.... 0x....      BL       __aeabi_fmul
   \   0000004A   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_0: (+1)
   \   0000004C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000050   0xD504             BPL.N    ??forward_kinematics_DELTA_2
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0x4641             MOV      R1,R8
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x4607             MOV      R7,R0
   \                     ??forward_kinematics_DELTA_2: (+1)
   \   0000005C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000060   0xD1EF             BNE.N    ??forward_kinematics_DELTA_1
   \   00000062   0x46A9             MOV      R9,R5
   \   00000064   0xF04F 0x0A02      MOV      R10,#+2
   \   00000068   0xF04F 0x587E      MOV      R8,#+1065353216
   \   0000006C   0xE004             B.N      ??forward_kinematics_DELTA_3
   \                     ??forward_kinematics_DELTA_4: (+1)
   \   0000006E   0x4648             MOV      R0,R9
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0x.... 0x....      BL       __aeabi_fmul
   \   00000076   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_3: (+1)
   \   00000078   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000007C   0xD504             BPL.N    ??forward_kinematics_DELTA_5
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x4649             MOV      R1,R9
   \   00000082   0x.... 0x....      BL       __aeabi_fmul
   \   00000086   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_5: (+1)
   \   00000088   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   0000008C   0xD1EF             BNE.N    ??forward_kinematics_DELTA_4
   \   0000008E   0x46A3             MOV      R11,R4
   \   00000090   0xF04F 0x0902      MOV      R9,#+2
   \   00000094   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   00000098   0xE004             B.N      ??forward_kinematics_DELTA_6
   \                     ??forward_kinematics_DELTA_7: (+1)
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x4659             MOV      R1,R11
   \   0000009E   0x.... 0x....      BL       __aeabi_fmul
   \   000000A2   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_6: (+1)
   \   000000A4   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000A8   0xD504             BPL.N    ??forward_kinematics_DELTA_8
   \   000000AA   0x4650             MOV      R0,R10
   \   000000AC   0x4659             MOV      R1,R11
   \   000000AE   0x.... 0x....      BL       __aeabi_fmul
   \   000000B2   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_8: (+1)
   \   000000B4   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000B8   0xD1EF             BNE.N    ??forward_kinematics_DELTA_7
   \   000000BA   0x4638             MOV      R0,R7
   \   000000BC   0x4641             MOV      R1,R8
   \   000000BE   0x.... 0x....      BL       __aeabi_fadd
   \   000000C2   0x4651             MOV      R1,R10
   \   000000C4   0x.... 0x....      BL       __aeabi_fadd
   \   000000C8   0x.... 0x....      BL       sqrtf
   \   000000CC   0x9005             STR      R0,[SP, #+20]
  14140          
  14141              // Create unit vector by dividing by magnitude.
  14142              ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
   \   000000CE   0x4630             MOV      R0,R6
   \   000000D0   0x9905             LDR      R1,[SP, #+20]
   \   000000D2   0x.... 0x....      BL       __aeabi_fdiv
   \   000000D6   0x9004             STR      R0,[SP, #+16]
   \   000000D8   0x4628             MOV      R0,R5
   \   000000DA   0x9905             LDR      R1,[SP, #+20]
   \   000000DC   0x.... 0x....      BL       __aeabi_fdiv
   \   000000E0   0x9003             STR      R0,[SP, #+12]
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0x9905             LDR      R1,[SP, #+20]
   \   000000E6   0x.... 0x....      BL       __aeabi_fdiv
   \   000000EA   0x9002             STR      R0,[SP, #+8]
  14143          
  14144              // Get the vector from the origin of the new system to the third point.
  14145              p13[3] = {
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable168_4
   \   000000F0   0x69C0             LDR      R0,[R0, #+28]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable168_4
   \   000000F6   0x68C9             LDR      R1,[R1, #+12]
   \   000000F8   0x.... 0x....      BL       __aeabi_fsub
   \   000000FC   0x4605             MOV      R5,R0
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable168_4
   \   00000102   0x6A00             LDR      R0,[R0, #+32]
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable168_4
   \   00000108   0x6909             LDR      R1,[R1, #+16]
   \   0000010A   0x.... 0x....      BL       __aeabi_fsub
   \   0000010E   0x4606             MOV      R6,R0
   \   00000110   0x980A             LDR      R0,[SP, #+40]
   \   00000112   0x9909             LDR      R1,[SP, #+36]
   \   00000114   0x.... 0x....      BL       __aeabi_fsub
   \   00000118   0x4607             MOV      R7,R0
  14146                delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
  14147                delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
  14148                z3 - z1
  14149              },
  14150          
  14151              // Use the dot product to find the component of this vector on the X axis.
  14152              i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
   \   0000011A   0x9804             LDR      R0,[SP, #+16]
   \   0000011C   0x4629             MOV      R1,R5
   \   0000011E   0x.... 0x....      BL       __aeabi_fmul
   \   00000122   0x4604             MOV      R4,R0
   \   00000124   0x9803             LDR      R0,[SP, #+12]
   \   00000126   0x4631             MOV      R1,R6
   \   00000128   0x.... 0x....      BL       __aeabi_fmul
   \   0000012C   0x4621             MOV      R1,R4
   \   0000012E   0x.... 0x....      BL       __aeabi_fadd
   \   00000132   0x4604             MOV      R4,R0
   \   00000134   0x9802             LDR      R0,[SP, #+8]
   \   00000136   0x4639             MOV      R1,R7
   \   00000138   0x.... 0x....      BL       __aeabi_fmul
   \   0000013C   0x4621             MOV      R1,R4
   \   0000013E   0x.... 0x....      BL       __aeabi_fadd
   \   00000142   0x4604             MOV      R4,R0
  14153          
  14154              // Create a vector along the x axis that represents the x component of p13.
  14155              iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
  14156          
  14157              // Subtract the X component from the original vector leaving only Y. We use the
  14158              // variable that will be the unit vector after we scale it.
  14159              float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
   \   00000144   0x9804             LDR      R0,[SP, #+16]
   \   00000146   0x4621             MOV      R1,R4
   \   00000148   0x.... 0x....      BL       __aeabi_fmul
   \   0000014C   0x4601             MOV      R1,R0
   \   0000014E   0x4628             MOV      R0,R5
   \   00000150   0x.... 0x....      BL       __aeabi_fsub
   \   00000154   0x4605             MOV      R5,R0
   \   00000156   0x9803             LDR      R0,[SP, #+12]
   \   00000158   0x4621             MOV      R1,R4
   \   0000015A   0x.... 0x....      BL       __aeabi_fmul
   \   0000015E   0x4601             MOV      R1,R0
   \   00000160   0x4630             MOV      R0,R6
   \   00000162   0x.... 0x....      BL       __aeabi_fsub
   \   00000166   0x4606             MOV      R6,R0
   \   00000168   0x9802             LDR      R0,[SP, #+8]
   \   0000016A   0x4621             MOV      R1,R4
   \   0000016C   0x.... 0x....      BL       __aeabi_fmul
   \   00000170   0x4601             MOV      R1,R0
   \   00000172   0x4638             MOV      R0,R7
   \   00000174   0x.... 0x....      BL       __aeabi_fsub
   \   00000178   0x9006             STR      R0,[SP, #+24]
  14160          
  14161              // The magnitude of Y component
  14162              const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
   \   0000017A   0x46A8             MOV      R8,R5
   \   0000017C   0xF04F 0x0902      MOV      R9,#+2
   \   00000180   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000184   0xE004             B.N      ??forward_kinematics_DELTA_9
   \                     ??forward_kinematics_DELTA_10: (+1)
   \   00000186   0x4640             MOV      R0,R8
   \   00000188   0x4641             MOV      R1,R8
   \   0000018A   0x.... 0x....      BL       __aeabi_fmul
   \   0000018E   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_9: (+1)
   \   00000190   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000194   0xD504             BPL.N    ??forward_kinematics_DELTA_11
   \   00000196   0x4638             MOV      R0,R7
   \   00000198   0x4641             MOV      R1,R8
   \   0000019A   0x.... 0x....      BL       __aeabi_fmul
   \   0000019E   0x4607             MOV      R7,R0
   \                     ??forward_kinematics_DELTA_11: (+1)
   \   000001A0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000001A4   0xD1EF             BNE.N    ??forward_kinematics_DELTA_10
   \   000001A6   0x46B1             MOV      R9,R6
   \   000001A8   0xF04F 0x0A02      MOV      R10,#+2
   \   000001AC   0xF04F 0x587E      MOV      R8,#+1065353216
   \   000001B0   0xE004             B.N      ??forward_kinematics_DELTA_12
   \                     ??forward_kinematics_DELTA_13: (+1)
   \   000001B2   0x4648             MOV      R0,R9
   \   000001B4   0x4649             MOV      R1,R9
   \   000001B6   0x.... 0x....      BL       __aeabi_fmul
   \   000001BA   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_12: (+1)
   \   000001BC   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000001C0   0xD504             BPL.N    ??forward_kinematics_DELTA_14
   \   000001C2   0x4640             MOV      R0,R8
   \   000001C4   0x4649             MOV      R1,R9
   \   000001C6   0x.... 0x....      BL       __aeabi_fmul
   \   000001CA   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_14: (+1)
   \   000001CC   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000001D0   0xD1EF             BNE.N    ??forward_kinematics_DELTA_13
   \   000001D2   0xF8DD 0xB018      LDR      R11,[SP, #+24]
   \   000001D6   0xF04F 0x0902      MOV      R9,#+2
   \   000001DA   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000001DE   0xE004             B.N      ??forward_kinematics_DELTA_15
   \                     ??forward_kinematics_DELTA_16: (+1)
   \   000001E0   0x4658             MOV      R0,R11
   \   000001E2   0x4659             MOV      R1,R11
   \   000001E4   0x.... 0x....      BL       __aeabi_fmul
   \   000001E8   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_15: (+1)
   \   000001EA   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000001EE   0xD504             BPL.N    ??forward_kinematics_DELTA_17
   \   000001F0   0x4650             MOV      R0,R10
   \   000001F2   0x4659             MOV      R1,R11
   \   000001F4   0x.... 0x....      BL       __aeabi_fmul
   \   000001F8   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_17: (+1)
   \   000001FA   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000001FE   0xD1EF             BNE.N    ??forward_kinematics_DELTA_16
   \   00000200   0x4638             MOV      R0,R7
   \   00000202   0x4641             MOV      R1,R8
   \   00000204   0x.... 0x....      BL       __aeabi_fadd
   \   00000208   0x4651             MOV      R1,R10
   \   0000020A   0x.... 0x....      BL       __aeabi_fadd
   \   0000020E   0x.... 0x....      BL       sqrtf
   \   00000212   0x9001             STR      R0,[SP, #+4]
  14163          
  14164              // Convert to a unit vector
  14165              ey[0] /= j; ey[1] /= j;  ey[2] /= j;
   \   00000214   0x4628             MOV      R0,R5
   \   00000216   0x9901             LDR      R1,[SP, #+4]
   \   00000218   0x.... 0x....      BL       __aeabi_fdiv
   \   0000021C   0x4605             MOV      R5,R0
   \   0000021E   0x4630             MOV      R0,R6
   \   00000220   0x9901             LDR      R1,[SP, #+4]
   \   00000222   0x.... 0x....      BL       __aeabi_fdiv
   \   00000226   0x4606             MOV      R6,R0
   \   00000228   0x9806             LDR      R0,[SP, #+24]
   \   0000022A   0x9901             LDR      R1,[SP, #+4]
   \   0000022C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000230   0x4607             MOV      R7,R0
  14166          
  14167              // The cross product of the unit x and y is the unit z
  14168              // float[] ez = vectorCrossProd(ex, ey);
  14169              const float ez[3] = {
   \   00000232   0x9803             LDR      R0,[SP, #+12]
   \   00000234   0x4639             MOV      R1,R7
   \   00000236   0x.... 0x....      BL       __aeabi_fmul
   \   0000023A   0x4680             MOV      R8,R0
   \   0000023C   0x9802             LDR      R0,[SP, #+8]
   \   0000023E   0x4631             MOV      R1,R6
   \   00000240   0x.... 0x....      BL       __aeabi_fmul
   \   00000244   0x4601             MOV      R1,R0
   \   00000246   0x4640             MOV      R0,R8
   \   00000248   0x.... 0x....      BL       __aeabi_fsub
   \   0000024C   0x9006             STR      R0,[SP, #+24]
   \   0000024E   0x9802             LDR      R0,[SP, #+8]
   \   00000250   0x4629             MOV      R1,R5
   \   00000252   0x.... 0x....      BL       __aeabi_fmul
   \   00000256   0x4680             MOV      R8,R0
   \   00000258   0x9804             LDR      R0,[SP, #+16]
   \   0000025A   0x4639             MOV      R1,R7
   \   0000025C   0x.... 0x....      BL       __aeabi_fmul
   \   00000260   0x4601             MOV      R1,R0
   \   00000262   0x4640             MOV      R0,R8
   \   00000264   0x.... 0x....      BL       __aeabi_fsub
   \   00000268   0x9008             STR      R0,[SP, #+32]
   \   0000026A   0x9804             LDR      R0,[SP, #+16]
   \   0000026C   0x4631             MOV      R1,R6
   \   0000026E   0x.... 0x....      BL       __aeabi_fmul
   \   00000272   0x4680             MOV      R8,R0
   \   00000274   0x9803             LDR      R0,[SP, #+12]
   \   00000276   0x4629             MOV      R1,R5
   \   00000278   0x.... 0x....      BL       __aeabi_fmul
   \   0000027C   0x4601             MOV      R1,R0
   \   0000027E   0x4640             MOV      R0,R8
   \   00000280   0x.... 0x....      BL       __aeabi_fsub
   \   00000284   0x9007             STR      R0,[SP, #+28]
  14170                ex[1] * ey[2] - ex[2] * ey[1],
  14171                ex[2] * ey[0] - ex[0] * ey[2],
  14172                ex[0] * ey[1] - ex[1] * ey[0]
  14173              },
  14174              // We now have the d, i and j values defined in Wikipedia.
  14175              // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
  14176              Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
   \   00000286   0xF8DD 0x9014      LDR      R9,[SP, #+20]
   \   0000028A   0xF04F 0x0A02      MOV      R10,#+2
   \   0000028E   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000292   0xE004             B.N      ??forward_kinematics_DELTA_18
   \                     ??forward_kinematics_DELTA_19: (+1)
   \   00000294   0x4648             MOV      R0,R9
   \   00000296   0x4649             MOV      R1,R9
   \   00000298   0x.... 0x....      BL       __aeabi_fmul
   \   0000029C   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_18: (+1)
   \   0000029E   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000002A2   0xD504             BPL.N    ??forward_kinematics_DELTA_20
   \   000002A4   0x4640             MOV      R0,R8
   \   000002A6   0x4649             MOV      R1,R9
   \   000002A8   0x.... 0x....      BL       __aeabi_fmul
   \   000002AC   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_20: (+1)
   \   000002AE   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000002B2   0xD1EF             BNE.N    ??forward_kinematics_DELTA_19
   \   000002B4   0x....             LDR.N    R0,??DataTable168_4
   \   000002B6   0x6BC0             LDR      R0,[R0, #+60]
   \   000002B8   0x....             LDR.N    R1,??DataTable168_4
   \   000002BA   0x6C09             LDR      R1,[R1, #+64]
   \   000002BC   0x.... 0x....      BL       __aeabi_fsub
   \   000002C0   0x4641             MOV      R1,R8
   \   000002C2   0x.... 0x....      BL       __aeabi_fadd
   \   000002C6   0x4680             MOV      R8,R0
   \   000002C8   0x9905             LDR      R1,[SP, #+20]
   \   000002CA   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000002CE   0x.... 0x....      BL       __aeabi_fmul
   \   000002D2   0x4601             MOV      R1,R0
   \   000002D4   0x4640             MOV      R0,R8
   \   000002D6   0x.... 0x....      BL       __aeabi_fdiv
   \   000002DA   0x9000             STR      R0,[SP, #+0]
  14177              Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
   \   000002DC   0x46A1             MOV      R9,R4
   \   000002DE   0xF04F 0x0A02      MOV      R10,#+2
   \   000002E2   0xF04F 0x587E      MOV      R8,#+1065353216
   \   000002E6   0xE004             B.N      ??forward_kinematics_DELTA_21
   \                     ??forward_kinematics_DELTA_22: (+1)
   \   000002E8   0x4648             MOV      R0,R9
   \   000002EA   0x4649             MOV      R1,R9
   \   000002EC   0x.... 0x....      BL       __aeabi_fmul
   \   000002F0   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_21: (+1)
   \   000002F2   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000002F6   0xD504             BPL.N    ??forward_kinematics_DELTA_23
   \   000002F8   0x4640             MOV      R0,R8
   \   000002FA   0x4649             MOV      R1,R9
   \   000002FC   0x.... 0x....      BL       __aeabi_fmul
   \   00000300   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_23: (+1)
   \   00000302   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000306   0xD1EF             BNE.N    ??forward_kinematics_DELTA_22
   \   00000308   0xF8DD 0xB004      LDR      R11,[SP, #+4]
   \   0000030C   0xF04F 0x0902      MOV      R9,#+2
   \   00000310   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   00000314   0xE004             B.N      ??forward_kinematics_DELTA_24
   \                     ??forward_kinematics_DELTA_25: (+1)
   \   00000316   0x4658             MOV      R0,R11
   \   00000318   0x4659             MOV      R1,R11
   \   0000031A   0x.... 0x....      BL       __aeabi_fmul
   \   0000031E   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_24: (+1)
   \   00000320   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000324   0xD504             BPL.N    ??forward_kinematics_DELTA_26
   \   00000326   0x4650             MOV      R0,R10
   \   00000328   0x4659             MOV      R1,R11
   \   0000032A   0x.... 0x....      BL       __aeabi_fmul
   \   0000032E   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_26: (+1)
   \   00000330   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000334   0xD1EF             BNE.N    ??forward_kinematics_DELTA_25
   \   00000336   0x....             LDR.N    R0,??DataTable168_4
   \   00000338   0x6BC0             LDR      R0,[R0, #+60]
   \   0000033A   0x....             LDR.N    R1,??DataTable168_4
   \   0000033C   0x6C49             LDR      R1,[R1, #+68]
   \   0000033E   0x.... 0x....      BL       __aeabi_fsub
   \   00000342   0x4681             MOV      R9,R0
   \   00000344   0x4640             MOV      R0,R8
   \   00000346   0x4651             MOV      R1,R10
   \   00000348   0x.... 0x....      BL       __aeabi_fadd
   \   0000034C   0x4649             MOV      R1,R9
   \   0000034E   0x.... 0x....      BL       __aeabi_fadd
   \   00000352   0xF04F 0x517C      MOV      R1,#+1056964608
   \   00000356   0x.... 0x....      BL       __aeabi_fmul
   \   0000035A   0x4680             MOV      R8,R0
   \   0000035C   0x9800             LDR      R0,[SP, #+0]
   \   0000035E   0x4621             MOV      R1,R4
   \   00000360   0x.... 0x....      BL       __aeabi_fmul
   \   00000364   0x4601             MOV      R1,R0
   \   00000366   0x4640             MOV      R0,R8
   \   00000368   0x.... 0x....      BL       __aeabi_fsub
   \   0000036C   0x9901             LDR      R1,[SP, #+4]
   \   0000036E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000372   0x4604             MOV      R4,R0
  14178              Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
   \   00000374   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \   00000378   0xF04F 0x0A02      MOV      R10,#+2
   \   0000037C   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000380   0xE004             B.N      ??forward_kinematics_DELTA_27
   \                     ??forward_kinematics_DELTA_28: (+1)
   \   00000382   0x4648             MOV      R0,R9
   \   00000384   0x4649             MOV      R1,R9
   \   00000386   0x.... 0x....      BL       __aeabi_fmul
   \   0000038A   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_27: (+1)
   \   0000038C   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000390   0xD504             BPL.N    ??forward_kinematics_DELTA_29
   \   00000392   0x4640             MOV      R0,R8
   \   00000394   0x4649             MOV      R1,R9
   \   00000396   0x.... 0x....      BL       __aeabi_fmul
   \   0000039A   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_29: (+1)
   \   0000039C   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000003A0   0xD1EF             BNE.N    ??forward_kinematics_DELTA_28
   \   000003A2   0x46A3             MOV      R11,R4
   \   000003A4   0xF04F 0x0902      MOV      R9,#+2
   \   000003A8   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000003AC   0xE004             B.N      ??forward_kinematics_DELTA_30
   \                     ??forward_kinematics_DELTA_31: (+1)
   \   000003AE   0x4658             MOV      R0,R11
   \   000003B0   0x4659             MOV      R1,R11
   \   000003B2   0x.... 0x....      BL       __aeabi_fmul
   \   000003B6   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_30: (+1)
   \   000003B8   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000003BC   0xD504             BPL.N    ??forward_kinematics_DELTA_32
   \   000003BE   0x4650             MOV      R0,R10
   \   000003C0   0x4659             MOV      R1,R11
   \   000003C2   0x.... 0x....      BL       __aeabi_fmul
   \   000003C6   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_32: (+1)
   \   000003C8   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000003CC   0xD1EF             BNE.N    ??forward_kinematics_DELTA_31
   \   000003CE   0x4640             MOV      R0,R8
   \   000003D0   0x4651             MOV      R1,R10
   \   000003D2   0x.... 0x....      BL       __aeabi_fadd
   \   000003D6   0x4601             MOV      R1,R0
   \   000003D8   0x....             LDR.N    R0,??DataTable168_4
   \   000003DA   0x6BC0             LDR      R0,[R0, #+60]
   \   000003DC   0x.... 0x....      BL       __aeabi_fsub
   \   000003E0   0x.... 0x....      BL       sqrtf
   \   000003E4   0x4680             MOV      R8,R0
  14179          
  14180              // Start from the origin of the old coordinates and add vectors in the
  14181              // old coords that represent the Xnew, Ynew and Znew to find the point
  14182              // in the old system.
  14183              cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
   \   000003E6   0x9904             LDR      R1,[SP, #+16]
   \   000003E8   0x9800             LDR      R0,[SP, #+0]
   \   000003EA   0x.... 0x....      BL       __aeabi_fmul
   \   000003EE   0x....             LDR.N    R1,??DataTable168_4
   \   000003F0   0x68C9             LDR      R1,[R1, #+12]
   \   000003F2   0x.... 0x....      BL       __aeabi_fadd
   \   000003F6   0x4681             MOV      R9,R0
   \   000003F8   0x4628             MOV      R0,R5
   \   000003FA   0x4621             MOV      R1,R4
   \   000003FC   0x.... 0x....      BL       __aeabi_fmul
   \   00000400   0x4649             MOV      R1,R9
   \   00000402   0x.... 0x....      BL       __aeabi_fadd
   \   00000406   0x4605             MOV      R5,R0
   \   00000408   0x9806             LDR      R0,[SP, #+24]
   \   0000040A   0x4641             MOV      R1,R8
   \   0000040C   0x.... 0x....      BL       __aeabi_fmul
   \   00000410   0x4601             MOV      R1,R0
   \   00000412   0x4628             MOV      R0,R5
   \   00000414   0x.... 0x....      BL       __aeabi_fsub
   \   00000418   0x....             LDR.N    R1,??DataTable168_4
   \   0000041A   0x6488             STR      R0,[R1, #+72]
  14184              cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
   \   0000041C   0x9903             LDR      R1,[SP, #+12]
   \   0000041E   0x9800             LDR      R0,[SP, #+0]
   \   00000420   0x.... 0x....      BL       __aeabi_fmul
   \   00000424   0x....             LDR.N    R1,??DataTable168_4
   \   00000426   0x6909             LDR      R1,[R1, #+16]
   \   00000428   0x.... 0x....      BL       __aeabi_fadd
   \   0000042C   0x4605             MOV      R5,R0
   \   0000042E   0x4630             MOV      R0,R6
   \   00000430   0x4621             MOV      R1,R4
   \   00000432   0x.... 0x....      BL       __aeabi_fmul
   \   00000436   0x4629             MOV      R1,R5
   \   00000438   0x.... 0x....      BL       __aeabi_fadd
   \   0000043C   0x4605             MOV      R5,R0
   \   0000043E   0x9808             LDR      R0,[SP, #+32]
   \   00000440   0x4641             MOV      R1,R8
   \   00000442   0x.... 0x....      BL       __aeabi_fmul
   \   00000446   0x4601             MOV      R1,R0
   \   00000448   0x4628             MOV      R0,R5
   \   0000044A   0x.... 0x....      BL       __aeabi_fsub
   \   0000044E   0x....             LDR.N    R1,??DataTable168_4
   \   00000450   0x64C8             STR      R0,[R1, #+76]
  14185              cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
   \   00000452   0x9902             LDR      R1,[SP, #+8]
   \   00000454   0x9800             LDR      R0,[SP, #+0]
   \   00000456   0x.... 0x....      BL       __aeabi_fmul
   \   0000045A   0x9909             LDR      R1,[SP, #+36]
   \   0000045C   0x.... 0x....      BL       __aeabi_fadd
   \   00000460   0x4605             MOV      R5,R0
   \   00000462   0x4638             MOV      R0,R7
   \   00000464   0x4621             MOV      R1,R4
   \   00000466   0x.... 0x....      BL       __aeabi_fmul
   \   0000046A   0x4629             MOV      R1,R5
   \   0000046C   0x.... 0x....      BL       __aeabi_fadd
   \   00000470   0x4604             MOV      R4,R0
   \   00000472   0x9807             LDR      R0,[SP, #+28]
   \   00000474   0x4641             MOV      R1,R8
   \   00000476   0x.... 0x....      BL       __aeabi_fmul
   \   0000047A   0x4601             MOV      R1,R0
   \   0000047C   0x4620             MOV      R0,R4
   \   0000047E   0x.... 0x....      BL       __aeabi_fsub
   \   00000482   0x....             LDR.N    R1,??DataTable168_4
   \   00000484   0x6508             STR      R0,[R1, #+80]
  14186            }
   \   00000486   0xB00B             ADD      SP,SP,#+44
   \   00000488   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  14187          

   \                                 In section .text, align 2, keep-with-next
  14188            void forward_kinematics_DELTA(float point[ABC]) {
  14189              forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
   \                     _Z24forward_kinematics_DELTAPf: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x....             B.N      _Z24forward_kinematics_DELTAfff
  14190            }
  14191          
  14192          #endif // DELTA
  14193          
  14194          /**
  14195           * Get the stepper positions in the cartes[] array.
  14196           * Forward kinematics are applied for DELTA and SCARA.
  14197           *
  14198           * The result is in the current coordinate space with
  14199           * leveling applied. The coordinates need to be run through
  14200           * unapply_leveling to obtain machine coordinates suitable
  14201           * for current_position, etc.
  14202           */

   \                                 In section .text, align 2, keep-with-next
  14203          void get_cartesian_from_steppers() {
   \                     _Z27get_cartesian_from_steppersv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x....             LDR.N    R0,??DataTable168_5
   \   00000006   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD10F             BNE.N    ??get_cartesian_from_steppers_0
  14204            //#if ENABLED(DELTA)
  14205            if(MACHINETPYE == DELTA)  {
  14206              forward_kinematics_DELTA(
  14207                stepper.get_axis_position_mm(A_AXIS),
  14208                stepper.get_axis_position_mm(B_AXIS),
  14209                stepper.get_axis_position_mm(C_AXIS)
  14210              );
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000014   0x4604             MOV      R4,R0
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   0000001C   0x4605             MOV      R5,R0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x.... 0x....      BL       _Z24forward_kinematics_DELTAfff
   \   0000002C   0xBD37             POP      {R0-R2,R4,R5,PC}
  14211            	}
  14212            //#else
  14213            else
  14214            {
  14215              //#if IS_SCARA
  14216          	if(MACHINETPYE&IS_SCARA) {
   \                     ??get_cartesian_from_steppers_0: (+1)
   \   0000002E   0x....             LDR.N    R4,??DataTable168_4
   \   00000030   0xF44F 0x7140      MOV      R1,#+768
   \   00000034   0x4208             TST      R0,R1
   \   00000036   0xD00C             BEQ.N    ??get_cartesian_from_steppers_1
  14217                forward_kinematics_SCARA(
  14218                  stepper.get_axis_position_degrees(A_AXIS),
  14219                  stepper.get_axis_position_degrees(B_AXIS)
  14220                );
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   00000046   0x9001             STR      R0,[SP, #+4]
   \   00000048   0xA901             ADD      R1,SP,#+4
   \   0000004A   0xA800             ADD      R0,SP,#+0
   \   0000004C   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
   \   00000050   0xE007             B.N      ??get_cartesian_from_steppers_2
  14221          	}
  14222              //#else
  14223              else
  14224              {
  14225                cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
   \                     ??get_cartesian_from_steppers_1: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000058   0x64A0             STR      R0,[R4, #+72]
  14226                cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000060   0x64E0             STR      R0,[R4, #+76]
  14227              }
  14228              //#endif
  14229              cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
   \                     ??get_cartesian_from_steppers_2: (+1)
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000068   0x6520             STR      R0,[R4, #+80]
  14230            }
  14231            //#endif
  14232          }
   \   0000006A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
  14233          
  14234          /**
  14235           * Set the current_position for an axis based on
  14236           * the stepper positions, removing any leveling that
  14237           * may have been applied.
  14238           *
  14239           * To prevent small shifts in axis position always call
  14240           * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
  14241           *
  14242           * To keep hosts in sync, always call report_current_position
  14243           * after updating the current_position.
  14244           */

   \                                 In section .text, align 2, keep-with-next
  14245          void set_current_from_steppers_for_axis(const AxisEnum axis) {
   \                     _Z34set_current_from_steppers_for_axis8AxisEnum: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
  14246            get_cartesian_from_steppers();
   \   00000004   0x.... 0x....      BL       _Z27get_cartesian_from_steppersv
  14247            //#if PLANNER_LEVELING
  14248            if(BED_LEVELING_METHOD&PLANNER_LEVELING)
   \   00000008   0x....             LDR.N    R5,??DataTable168_4
   \   0000000A   0x....             LDR.N    R0,??DataTable168_5
   \   0000000C   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000010   0x212E             MOVS     R1,#+46
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD003             BEQ.N    ??set_current_from_steppers_for_axis_0
  14249              planner.unapply_leveling(cartes);
   \   00000016   0xF105 0x0048      ADD      R0,R5,#+72
   \   0000001A   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
  14250            //#endif
  14251            if (axis == ALL_AXES)
   \                     ??set_current_from_steppers_for_axis_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable179
   \   00000022   0x2C64             CMP      R4,#+100
   \   00000024   0xD107             BNE.N    ??set_current_from_steppers_for_axis_1
  14252              COPY(current_position, cartes);
   \   00000026   0x220C             MOVS     R2,#+12
   \   00000028   0xF105 0x0148      ADD      R1,R5,#+72
   \   0000002C   0x3008             ADDS     R0,R0,#+8
   \   0000002E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000032   0x.... 0x....      B.W      memcpy
  14253            else
  14254              current_position[axis] = cartes[axis];
   \                     ??set_current_from_steppers_for_axis_1: (+1)
   \   00000036   0xEB05 0x0184      ADD      R1,R5,R4, LSL #+2
   \   0000003A   0x6C89             LDR      R1,[R1, #+72]
   \   0000003C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000040   0x6081             STR      R1,[R0, #+8]
  14255          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  14256          
  14257          #if 1//IS_CARTESIAN
  14258          #if 1//ENABLED(SEGMENT_LEVELED_MOVES)
  14259          
  14260            /**
  14261             * Prepare a segmented move on a CARTESIAN setup.
  14262             *
  14263             * This calls planner.buffer_line several times, adding
  14264             * small incremental moves. This allows the planner to
  14265             * apply more detailed bed leveling to the full move.
  14266             */
  14267            inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
  14268          
  14269              const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
  14270                          ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
  14271          
  14272              // If the move is only in Z/E don't split up the move
  14273              if (!xdiff && !ydiff) {
  14274                planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
  14275                return;
  14276              }
  14277          
  14278              // Remaining cartesian distances
  14279              const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
  14280                          ediff = destination[E_AXIS] - current_position[E_AXIS];
  14281          
  14282              // Get the linear distance in XYZ
  14283              // If the move is very short, check the E move distance
  14284              // No E move either? Game over.
  14285              float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
  14286              if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
  14287              if (UNEAR_ZERO(cartesian_mm)) return;
  14288          
  14289              // The length divided by the segment size
  14290              // At least one segment is required
  14291              uint16_t segments = cartesian_mm / segment_size;
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
  14292              NOLESS(segments, 1);
  14293          
  14294              // The approximate length of each segment
  14295              const float inv_segments = 1.0 / float(segments),
  14296                          segment_distance[XYZE] = {
  14297                            xdiff * inv_segments,
  14298                            ydiff * inv_segments,
  14299                            zdiff * inv_segments,
  14300                            ediff * inv_segments
  14301                          };
  14302          
  14303              // SERIAL_ECHOPAIR("mm=", cartesian_mm);
  14304              // SERIAL_ECHOLNPAIR(" segments=", segments);
  14305          
  14306              // Get the raw current position as starting point
  14307              float raw[XYZE];
  14308              COPY(raw, current_position);
  14309          
  14310              // Calculate and execute the segments
  14311              while (--segments) {
  14312                static millis_t next_idle_ms = millis() + 200UL;
  14313                thermalManager.manage_heater();  // This returns immediately if not really needed.
  14314                if (ELAPSED(millis(), next_idle_ms)) {
  14315                  next_idle_ms = millis() + 200UL;
  14316                  idle();
  14317                }
  14318                LOOP_XYZE(i) raw[i] += segment_distance[i];
  14319                planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
  14320              }
  14321          
  14322              // Since segment_distance is only approximate,
  14323              // the final move must be to the exact destination.
  14324              planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
  14325            }
  14326          #endif
  14327          //#elif ENABLED(MESH_BED_LEVELING)
  14328          #if 1
  14329            /**
  14330             * Prepare a mesh-leveled linear move in a Cartesian setup,
  14331             * splitting the move where it crosses mesh borders.
  14332             */

   \                                 In section .text, align 2, keep-with-next
  14333            void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
   \                     _Z24mesh_line_to_destinationfhh: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
  14334              // Get current and destination cells for this line
  14335              int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable179
   \   0000000E   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000012   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \   00000016   0x4607             MOV      R7,R0
  14336                  cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
   \   00000018   0xF106 0x000C      ADD      R0,R6,#+12
   \   0000001C   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
   \   00000020   0x4680             MOV      R8,R0
  14337                  cx2 = mbl.cell_index_x(destination[X_AXIS]),
   \   00000022   0xF106 0x0018      ADD      R0,R6,#+24
   \   00000026   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \   0000002A   0x4681             MOV      R9,R0
  14338                  cy2 = mbl.cell_index_y(destination[Y_AXIS]);
   \   0000002C   0xF106 0x001C      ADD      R0,R6,#+28
   \   00000030   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
  14339              NOMORE(cx1, GRID_MAX_POINTS_X - 2);
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable179_1
   \   00000038   0xF891 0x2060      LDRB     R2,[R1, #+96]
   \   0000003C   0x1E92             SUBS     R2,R2,#+2
   \   0000003E   0x42BA             CMP      R2,R7
   \   00000040   0xDA00             BGE.N    ??mesh_line_to_destination_0
   \   00000042   0x4617             MOV      R7,R2
   \                     ??mesh_line_to_destination_0: (+1)
   \   00000044   0x3160             ADDS     R1,R1,#+96
   \   00000046   0x7849             LDRB     R1,[R1, #+1]
   \   00000048   0x1E89             SUBS     R1,R1,#+2
   \   0000004A   0x4541             CMP      R1,R8
   \   0000004C   0xDA00             BGE.N    ??mesh_line_to_destination_1
  14340              NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
   \   0000004E   0x4688             MOV      R8,R1
  14341              NOMORE(cx2, GRID_MAX_POINTS_X - 2);
   \                     ??mesh_line_to_destination_1: (+1)
   \   00000050   0x454A             CMP      R2,R9
   \   00000052   0xDA00             BGE.N    ??mesh_line_to_destination_2
   \   00000054   0x4691             MOV      R9,R2
  14342              NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
   \                     ??mesh_line_to_destination_2: (+1)
   \   00000056   0x4281             CMP      R1,R0
   \   00000058   0xDA00             BGE.N    ??mesh_line_to_destination_3
   \   0000005A   0x4608             MOV      R0,R1
  14343          
  14344              // Start and end in the same cell? No split needed.
  14345              if (cx1 == cx2 && cy1 == cy2) {
   \                     ??mesh_line_to_destination_3: (+1)
   \   0000005C   0x454F             CMP      R7,R9
   \   0000005E   0xD102             BNE.N    ??mesh_line_to_destination_4
   \   00000060   0x4580             CMP      R8,R0
   \   00000062   0xF000 0x8098      BEQ.W    ??mesh_line_to_destination_5
  14346                buffer_line_to_destination(fr_mm_s);
  14347                set_current_from_destination();
  14348                return;
  14349              }
  14350          
  14351              #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  14352          
  14353              float normalized_dist, end[XYZE];
  14354              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
   \                     ??mesh_line_to_destination_4: (+1)
   \   00000066   0x46CA             MOV      R10,R9
   \   00000068   0x45B9             CMP      R9,R7
   \   0000006A   0xDA00             BGE.N    ??mesh_line_to_destination_6
   \   0000006C   0x46BA             MOV      R10,R7
   \                     ??mesh_line_to_destination_6: (+1)
   \   0000006E   0x4683             MOV      R11,R0
   \   00000070   0x4540             CMP      R0,R8
   \   00000072   0xDA00             BGE.N    ??mesh_line_to_destination_7
   \   00000074   0x46C3             MOV      R11,R8
  14355          
  14356              // Crosses on the X and not already split on this X?
  14357              // The x_splits flags are insurance against rounding errors.
  14358              if (cx2 != cx1 && TEST(x_splits, gcx)) {
   \                     ??mesh_line_to_destination_7: (+1)
   \   00000076   0x45B9             CMP      R9,R7
   \   00000078   0xD05B             BEQ.N    ??mesh_line_to_destination_8
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0xFA01 0xF20A      LSL      R2,R1,R10
   \   00000080   0x4621             MOV      R1,R4
   \   00000082   0x4211             TST      R1,R2
   \   00000084   0xD055             BEQ.N    ??mesh_line_to_destination_8
  14359                // Split on the X grid line
  14360                CBI(x_splits, gcx);
   \   00000086   0x4394             BICS     R4,R4,R2
  14361                COPY(end, destination);
   \   00000088   0x2210             MOVS     R2,#+16
   \   0000008A   0xF106 0x0118      ADD      R1,R6,#+24
   \   0000008E   0xA800             ADD      R0,SP,#+0
   \   00000090   0x.... 0x....      BL       memcpy
  14362                destination[X_AXIS] = mbl.index_to_xpos[gcx];
   \   00000094   0xFA4F 0xFA8A      SXTB     R10,R10
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable179_2
   \   0000009C   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \   000000A0   0x61B0             STR      R0,[R6, #+24]
  14363                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
   \   000000A2   0x68B7             LDR      R7,[R6, #+8]
   \   000000A4   0x4639             MOV      R1,R7
   \   000000A6   0x.... 0x....      BL       __aeabi_fsub
   \   000000AA   0x4680             MOV      R8,R0
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x4639             MOV      R1,R7
   \   000000B0   0x.... 0x....      BL       __aeabi_fsub
   \   000000B4   0x4601             MOV      R1,R0
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x.... 0x....      BL       __aeabi_fdiv
   \   000000BC   0x4607             MOV      R7,R0
  14364                destination[Y_AXIS] = MBL_SEGMENT_END(Y);
   \   000000BE   0xF8D6 0x800C      LDR      R8,[R6, #+12]
   \   000000C2   0x69F0             LDR      R0,[R6, #+28]
   \   000000C4   0x4641             MOV      R1,R8
   \   000000C6   0x.... 0x....      BL       __aeabi_fsub
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4641             MOV      R1,R8
   \   000000D2   0x.... 0x....      BL       __aeabi_fadd
   \   000000D6   0x61F0             STR      R0,[R6, #+28]
  14365              }
  14366              // Crosses on the Y and not already split on this Y?
  14367              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  14368                // Split on the Y grid line
  14369                CBI(y_splits, gcy);
  14370                COPY(end, destination);
  14371                destination[Y_AXIS] = mbl.index_to_ypos[gcy];
  14372                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  14373                destination[X_AXIS] = MBL_SEGMENT_END(X);
  14374              }
  14375              else {
  14376                // Must already have been split on these border(s)
  14377                buffer_line_to_destination(fr_mm_s);
  14378                set_current_from_destination();
  14379                return;
  14380              }
  14381          
  14382              destination[Z_AXIS] = MBL_SEGMENT_END(Z);
   \                     ??mesh_line_to_destination_9: (+1)
   \   000000D8   0xF8D6 0x8010      LDR      R8,[R6, #+16]
   \   000000DC   0x6A30             LDR      R0,[R6, #+32]
   \   000000DE   0x4641             MOV      R1,R8
   \   000000E0   0x.... 0x....      BL       __aeabi_fsub
   \   000000E4   0x4639             MOV      R1,R7
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4641             MOV      R1,R8
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x6230             STR      R0,[R6, #+32]
  14383              destination[E_AXIS] = MBL_SEGMENT_END(E);
   \   000000F2   0xF8D6 0x8014      LDR      R8,[R6, #+20]
   \   000000F6   0x6A70             LDR      R0,[R6, #+36]
   \   000000F8   0x4641             MOV      R1,R8
   \   000000FA   0x.... 0x....      BL       __aeabi_fsub
   \   000000FE   0x4639             MOV      R1,R7
   \   00000100   0x.... 0x....      BL       __aeabi_fmul
   \   00000104   0x4641             MOV      R1,R8
   \   00000106   0x.... 0x....      BL       __aeabi_fadd
   \   0000010A   0x6270             STR      R0,[R6, #+36]
  14384          
  14385              // Do the split and look for more borders
  14386              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   0000010C   0x462A             MOV      R2,R5
   \   0000010E   0x4621             MOV      R1,R4
   \   00000110   0x9804             LDR      R0,[SP, #+16]
   \   00000112   0xF7FF 0xFF75      BL       _Z24mesh_line_to_destinationfhh
  14387          
  14388              // Restore destination from stack
  14389              COPY(destination, end);
   \   00000116   0x2210             MOVS     R2,#+16
   \   00000118   0xA900             ADD      R1,SP,#+0
   \   0000011A   0xF106 0x0018      ADD      R0,R6,#+24
   \   0000011E   0x.... 0x....      BL       memcpy
  14390              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   00000122   0x462A             MOV      R2,R5
   \   00000124   0x4621             MOV      R1,R4
   \   00000126   0x9804             LDR      R0,[SP, #+16]
   \   00000128   0xF7FF 0xFF6A      BL       _Z24mesh_line_to_destinationfhh
  14391            }
   \                     ??mesh_line_to_destination_10: (+1)
   \   0000012C   0xB005             ADD      SP,SP,#+20
   \   0000012E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??mesh_line_to_destination_8: (+1)
   \   00000132   0x4540             CMP      R0,R8
   \   00000134   0xD02F             BEQ.N    ??mesh_line_to_destination_5
   \   00000136   0x2101             MOVS     R1,#+1
   \   00000138   0xFA01 0xF00B      LSL      R0,R1,R11
   \   0000013C   0x4629             MOV      R1,R5
   \   0000013E   0x4201             TST      R1,R0
   \   00000140   0xD029             BEQ.N    ??mesh_line_to_destination_5
   \   00000142   0x4385             BICS     R5,R5,R0
   \   00000144   0x2210             MOVS     R2,#+16
   \   00000146   0xF106 0x0118      ADD      R1,R6,#+24
   \   0000014A   0xA800             ADD      R0,SP,#+0
   \   0000014C   0x.... 0x....      BL       memcpy
   \   00000150   0xFA4F 0xFB8B      SXTB     R11,R11
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable184
   \   00000158   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \   0000015C   0x61F0             STR      R0,[R6, #+28]
   \   0000015E   0x68F7             LDR      R7,[R6, #+12]
   \   00000160   0x4639             MOV      R1,R7
   \   00000162   0x.... 0x....      BL       __aeabi_fsub
   \   00000166   0x4680             MOV      R8,R0
   \   00000168   0x9801             LDR      R0,[SP, #+4]
   \   0000016A   0x4639             MOV      R1,R7
   \   0000016C   0x.... 0x....      BL       __aeabi_fsub
   \   00000170   0x4601             MOV      R1,R0
   \   00000172   0x4640             MOV      R0,R8
   \   00000174   0x.... 0x....      BL       __aeabi_fdiv
   \   00000178   0x4607             MOV      R7,R0
   \   0000017A   0xF8D6 0x8008      LDR      R8,[R6, #+8]
   \   0000017E   0x69B0             LDR      R0,[R6, #+24]
   \   00000180   0x4641             MOV      R1,R8
   \   00000182   0x.... 0x....      BL       __aeabi_fsub
   \   00000186   0x4639             MOV      R1,R7
   \   00000188   0x.... 0x....      BL       __aeabi_fmul
   \   0000018C   0x4641             MOV      R1,R8
   \   0000018E   0x.... 0x....      BL       __aeabi_fadd
   \   00000192   0x61B0             STR      R0,[R6, #+24]
   \   00000194   0xE7A0             B.N      ??mesh_line_to_destination_9
   \                     ??mesh_line_to_destination_5: (+1)
   \   00000196   0x9804             LDR      R0,[SP, #+16]
   \   00000198   0x.... 0x....      BL       _Z26buffer_line_to_destinationf
   \   0000019C   0x.... 0x....      BL       _Z28set_current_from_destinationv
   \   000001A0   0xE7C4             B.N      ??mesh_line_to_destination_10
  14392          #endif
  14393          //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  14394          #if 1
  14395            #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
  14396          
  14397            /**
  14398             * Prepare a bilinear-leveled linear move on Cartesian,
  14399             * splitting the move where it crosses grid borders.
  14400             */

   \                                 In section .text, align 2, keep-with-next
  14401            void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
   \                     _Z28bilinear_line_to_destinationftt: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
  14402              // Get current and destination cells for this line
  14403              int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000000C   0x.... 0x....      LDR.W    R8,??DataTable180
   \   00000010   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000014   0x.... 0x....      BL       __aeabi_i2f
   \   00000018   0x4683             MOV      R11,R0
   \   0000001A   0x.... 0x....      LDR.W    R7,??DataTable179
   \   0000001E   0x68B8             LDR      R0,[R7, #+8]
   \   00000020   0x4659             MOV      R1,R11
   \   00000022   0x.... 0x....      BL       __aeabi_fsub
   \   00000026   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \   0000002A   0x.... 0x....      BL       __aeabi_fmul
   \   0000002E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000032   0x4681             MOV      R9,R0
   \   00000034   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   00000038   0x.... 0x....      BL       __aeabi_i2f
   \   0000003C   0x4601             MOV      R1,R0
   \   0000003E   0x68F8             LDR      R0,[R7, #+12]
   \   00000040   0x.... 0x....      BL       __aeabi_fsub
   \   00000044   0xF8D8 0x1024      LDR      R1,[R8, #+36]
   \   00000048   0x.... 0x....      BL       __aeabi_fmul
   \   0000004C   0x.... 0x....      BL       __aeabi_f2iz
   \   00000050   0x4682             MOV      R10,R0
  14404                  cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
  14405                  cx2 = CELL_INDEX(X, destination[X_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000052   0x69B8             LDR      R0,[R7, #+24]
   \   00000054   0x4659             MOV      R1,R11
   \   00000056   0x.... 0x....      BL       __aeabi_fsub
   \   0000005A   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \   0000005E   0x.... 0x....      BL       __aeabi_fmul
   \   00000062   0x.... 0x....      BL       __aeabi_f2iz
   \   00000066   0x4683             MOV      R11,R0
  14406                  cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000068   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   0000006C   0x.... 0x....      BL       __aeabi_i2f
   \   00000070   0x4601             MOV      R1,R0
   \   00000072   0x69F8             LDR      R0,[R7, #+28]
   \   00000074   0x.... 0x....      BL       __aeabi_fsub
   \   00000078   0xF8D8 0x1024      LDR      R1,[R8, #+36]
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0x.... 0x....      BL       __aeabi_f2iz
  14407              cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable179_1
   \   00000088   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000008C   0xD502             BPL.N    ??bilinear_line_to_destination_0
   \   0000008E   0xF04F 0x0900      MOV      R9,#+0
   \   00000092   0xE005             B.N      ??bilinear_line_to_destination_1
   \                     ??bilinear_line_to_destination_0: (+1)
   \   00000094   0xF891 0x2060      LDRB     R2,[R1, #+96]
   \   00000098   0x1E92             SUBS     R2,R2,#+2
   \   0000009A   0x454A             CMP      R2,R9
   \   0000009C   0xDA00             BGE.N    ??bilinear_line_to_destination_1
   \   0000009E   0x4691             MOV      R9,R2
  14408              cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
   \                     ??bilinear_line_to_destination_1: (+1)
   \   000000A0   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000A4   0xD502             BPL.N    ??bilinear_line_to_destination_2
   \   000000A6   0xF04F 0x0A00      MOV      R10,#+0
   \   000000AA   0xE006             B.N      ??bilinear_line_to_destination_3
   \                     ??bilinear_line_to_destination_2: (+1)
   \   000000AC   0xF101 0x0260      ADD      R2,R1,#+96
   \   000000B0   0x7852             LDRB     R2,[R2, #+1]
   \   000000B2   0x1E92             SUBS     R2,R2,#+2
   \   000000B4   0x4552             CMP      R2,R10
   \   000000B6   0xDA00             BGE.N    ??bilinear_line_to_destination_3
   \   000000B8   0x4692             MOV      R10,R2
  14409              cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
   \                     ??bilinear_line_to_destination_3: (+1)
   \   000000BA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000BE   0xD502             BPL.N    ??bilinear_line_to_destination_4
   \   000000C0   0xF04F 0x0B00      MOV      R11,#+0
   \   000000C4   0xE005             B.N      ??bilinear_line_to_destination_5
   \                     ??bilinear_line_to_destination_4: (+1)
   \   000000C6   0xF891 0x2060      LDRB     R2,[R1, #+96]
   \   000000CA   0x1E92             SUBS     R2,R2,#+2
   \   000000CC   0x455A             CMP      R2,R11
   \   000000CE   0xDA00             BGE.N    ??bilinear_line_to_destination_5
   \   000000D0   0x4693             MOV      R11,R2
  14410              cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
   \                     ??bilinear_line_to_destination_5: (+1)
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD501             BPL.N    ??bilinear_line_to_destination_6
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xE006             B.N      ??bilinear_line_to_destination_7
   \                     ??bilinear_line_to_destination_6: (+1)
   \   000000DA   0xF101 0x0260      ADD      R2,R1,#+96
   \   000000DE   0x7851             LDRB     R1,[R2, #+1]
   \   000000E0   0x1E8A             SUBS     R2,R1,#+2
   \   000000E2   0x4282             CMP      R2,R0
   \   000000E4   0xDA00             BGE.N    ??bilinear_line_to_destination_7
   \   000000E6   0x4610             MOV      R0,R2
  14411          
  14412              // Start and end in the same cell? No split needed.
  14413              if (cx1 == cx2 && cy1 == cy2) {
   \                     ??bilinear_line_to_destination_7: (+1)
   \   000000E8   0x45D9             CMP      R9,R11
   \   000000EA   0xD102             BNE.N    ??bilinear_line_to_destination_8
   \   000000EC   0x4582             CMP      R10,R0
   \   000000EE   0xF000 0x80A8      BEQ.W    ??bilinear_line_to_destination_9
  14414                buffer_line_to_destination(fr_mm_s);
  14415                set_current_from_destination();
  14416                return;
  14417              }
  14418          
  14419              #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  14420          
  14421              float normalized_dist, end[XYZE];
  14422              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
   \                     ??bilinear_line_to_destination_8: (+1)
   \   000000F2   0x4659             MOV      R1,R11
   \   000000F4   0x45CB             CMP      R11,R9
   \   000000F6   0xDA00             BGE.N    ??bilinear_line_to_destination_10
   \   000000F8   0x4649             MOV      R1,R9
   \                     ??bilinear_line_to_destination_10: (+1)
   \   000000FA   0x9101             STR      R1,[SP, #+4]
   \   000000FC   0x4601             MOV      R1,R0
   \   000000FE   0x4550             CMP      R0,R10
   \   00000100   0xDA00             BGE.N    ??bilinear_line_to_destination_11
   \   00000102   0x4651             MOV      R1,R10
   \                     ??bilinear_line_to_destination_11: (+1)
   \   00000104   0x9100             STR      R1,[SP, #+0]
  14423          
  14424              // Crosses on the X and not already split on this X?
  14425              // The x_splits flags are insurance against rounding errors.
  14426              if (cx2 != cx1 && TEST(x_splits, gcx)) {
   \   00000106   0x45CB             CMP      R11,R9
   \   00000108   0xD062             BEQ.N    ??bilinear_line_to_destination_12
   \   0000010A   0x2101             MOVS     R1,#+1
   \   0000010C   0x9A01             LDR      R2,[SP, #+4]
   \   0000010E   0xFA01 0xF202      LSL      R2,R1,R2
   \   00000112   0x4629             MOV      R1,R5
   \   00000114   0x4211             TST      R1,R2
   \   00000116   0xD05B             BEQ.N    ??bilinear_line_to_destination_12
  14427                // Split on the X grid line
  14428                CBI(x_splits, gcx);
   \   00000118   0x4395             BICS     R5,R5,R2
  14429                COPY(end, destination);
   \   0000011A   0x2210             MOVS     R2,#+16
   \   0000011C   0xF107 0x0118      ADD      R1,R7,#+24
   \   00000120   0xA802             ADD      R0,SP,#+8
   \   00000122   0x.... 0x....      BL       memcpy
  14430                destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
   \   00000126   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000012A   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \   0000012E   0xAA01             ADD      R2,SP,#+4
   \   00000130   0xF992 0x2000      LDRSB    R2,[R2, #+0]
   \   00000134   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000138   0x.... 0x....      BL       __aeabi_i2f
   \   0000013C   0x61B8             STR      R0,[R7, #+24]
  14431                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
   \   0000013E   0xF8D7 0x8008      LDR      R8,[R7, #+8]
   \   00000142   0x4641             MOV      R1,R8
   \   00000144   0x.... 0x....      BL       __aeabi_fsub
   \   00000148   0x4681             MOV      R9,R0
   \   0000014A   0x9802             LDR      R0,[SP, #+8]
   \   0000014C   0x4641             MOV      R1,R8
   \   0000014E   0x.... 0x....      BL       __aeabi_fsub
   \   00000152   0x4601             MOV      R1,R0
   \   00000154   0x4648             MOV      R0,R9
   \   00000156   0x.... 0x....      BL       __aeabi_fdiv
   \   0000015A   0x4680             MOV      R8,R0
  14432                destination[Y_AXIS] = LINE_SEGMENT_END(Y);
   \   0000015C   0xF8D7 0x900C      LDR      R9,[R7, #+12]
   \   00000160   0x69F8             LDR      R0,[R7, #+28]
   \   00000162   0x4649             MOV      R1,R9
   \   00000164   0x.... 0x....      BL       __aeabi_fsub
   \   00000168   0x4641             MOV      R1,R8
   \   0000016A   0x.... 0x....      BL       __aeabi_fmul
   \   0000016E   0x4649             MOV      R1,R9
   \   00000170   0x.... 0x....      BL       __aeabi_fadd
   \   00000174   0x61F8             STR      R0,[R7, #+28]
  14433              }
  14434              // Crosses on the Y and not already split on this Y?
  14435              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  14436                // Split on the Y grid line
  14437                CBI(y_splits, gcy);
  14438                COPY(end, destination);
  14439                destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
  14440                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  14441                destination[X_AXIS] = LINE_SEGMENT_END(X);
  14442              }
  14443              else {
  14444                // Must already have been split on these border(s)
  14445                buffer_line_to_destination(fr_mm_s);
  14446                set_current_from_destination();
  14447                return;
  14448              }
  14449          
  14450              destination[Z_AXIS] = LINE_SEGMENT_END(Z);
   \                     ??bilinear_line_to_destination_13: (+1)
   \   00000176   0xF8D7 0x9010      LDR      R9,[R7, #+16]
   \   0000017A   0x6A38             LDR      R0,[R7, #+32]
   \   0000017C   0x4649             MOV      R1,R9
   \   0000017E   0x.... 0x....      BL       __aeabi_fsub
   \   00000182   0x4641             MOV      R1,R8
   \   00000184   0x.... 0x....      BL       __aeabi_fmul
   \   00000188   0x4649             MOV      R1,R9
   \   0000018A   0x.... 0x....      BL       __aeabi_fadd
   \   0000018E   0x6238             STR      R0,[R7, #+32]
  14451              destination[E_AXIS] = LINE_SEGMENT_END(E);
   \   00000190   0xF8D7 0x9014      LDR      R9,[R7, #+20]
   \   00000194   0x6A78             LDR      R0,[R7, #+36]
   \   00000196   0x4649             MOV      R1,R9
   \   00000198   0x.... 0x....      BL       __aeabi_fsub
   \   0000019C   0x4641             MOV      R1,R8
   \   0000019E   0x.... 0x....      BL       __aeabi_fmul
   \   000001A2   0x4649             MOV      R1,R9
   \   000001A4   0x.... 0x....      BL       __aeabi_fadd
   \   000001A8   0x6278             STR      R0,[R7, #+36]
  14452          
  14453              // Do the split and look for more borders
  14454              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   000001AA   0x4632             MOV      R2,R6
   \   000001AC   0x4629             MOV      R1,R5
   \   000001AE   0x4620             MOV      R0,R4
   \   000001B0   0xF7FF 0xFF26      BL       _Z28bilinear_line_to_destinationftt
  14455          
  14456              // Restore destination from stack
  14457              COPY(destination, end);
   \   000001B4   0x2210             MOVS     R2,#+16
   \   000001B6   0xA902             ADD      R1,SP,#+8
   \   000001B8   0xF107 0x0018      ADD      R0,R7,#+24
   \   000001BC   0x.... 0x....      BL       memcpy
  14458              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   000001C0   0x4632             MOV      R2,R6
   \   000001C2   0x4629             MOV      R1,R5
   \   000001C4   0x4620             MOV      R0,R4
   \   000001C6   0xF7FF 0xFF1B      BL       _Z28bilinear_line_to_destinationftt
  14459            }
   \                     ??bilinear_line_to_destination_14: (+1)
   \   000001CA   0xB007             ADD      SP,SP,#+28
   \   000001CC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??bilinear_line_to_destination_12: (+1)
   \   000001D0   0x4550             CMP      R0,R10
   \   000001D2   0xD036             BEQ.N    ??bilinear_line_to_destination_9
   \   000001D4   0x2101             MOVS     R1,#+1
   \   000001D6   0x9800             LDR      R0,[SP, #+0]
   \   000001D8   0xFA01 0xF000      LSL      R0,R1,R0
   \   000001DC   0x4631             MOV      R1,R6
   \   000001DE   0x4201             TST      R1,R0
   \   000001E0   0xD02F             BEQ.N    ??bilinear_line_to_destination_9
   \   000001E2   0x4386             BICS     R6,R6,R0
   \   000001E4   0x2210             MOVS     R2,#+16
   \   000001E6   0xF107 0x0118      ADD      R1,R7,#+24
   \   000001EA   0xA802             ADD      R0,SP,#+8
   \   000001EC   0x.... 0x....      BL       memcpy
   \   000001F0   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   000001F4   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \   000001F8   0xAA00             ADD      R2,SP,#+0
   \   000001FA   0xF992 0x2000      LDRSB    R2,[R2, #+0]
   \   000001FE   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000202   0x.... 0x....      BL       __aeabi_i2f
   \   00000206   0x61F8             STR      R0,[R7, #+28]
   \   00000208   0xF8D7 0x800C      LDR      R8,[R7, #+12]
   \   0000020C   0x4641             MOV      R1,R8
   \   0000020E   0x.... 0x....      BL       __aeabi_fsub
   \   00000212   0x4681             MOV      R9,R0
   \   00000214   0x9803             LDR      R0,[SP, #+12]
   \   00000216   0x4641             MOV      R1,R8
   \   00000218   0x.... 0x....      BL       __aeabi_fsub
   \   0000021C   0x4601             MOV      R1,R0
   \   0000021E   0x4648             MOV      R0,R9
   \   00000220   0x.... 0x....      BL       __aeabi_fdiv
   \   00000224   0x4680             MOV      R8,R0
   \   00000226   0xF8D7 0x9008      LDR      R9,[R7, #+8]
   \   0000022A   0x69B8             LDR      R0,[R7, #+24]
   \   0000022C   0x4649             MOV      R1,R9
   \   0000022E   0x.... 0x....      BL       __aeabi_fsub
   \   00000232   0x4641             MOV      R1,R8
   \   00000234   0x.... 0x....      BL       __aeabi_fmul
   \   00000238   0x4649             MOV      R1,R9
   \   0000023A   0x.... 0x....      BL       __aeabi_fadd
   \   0000023E   0x61B8             STR      R0,[R7, #+24]
   \   00000240   0xE799             B.N      ??bilinear_line_to_destination_13
   \                     ??bilinear_line_to_destination_9: (+1)
   \   00000242   0x4620             MOV      R0,R4
   \   00000244   0x.... 0x....      BL       _Z26buffer_line_to_destinationf
   \   00000248   0x.... 0x....      BL       _Z28set_current_from_destinationv
   \   0000024C   0xE7BD             B.N      ??bilinear_line_to_destination_14
  14460          
  14461          #endif // AUTO_BED_LEVELING_BILINEAR
  14462          #endif // IS_CARTESIAN
  14463          
  14464          #if 1//!UBL_SEGMENTED
  14465          #if 1//IS_KINEMATIC
  14466          
  14467            /**
  14468             * Prepare a linear move in a DELTA or SCARA setup.
  14469             *
  14470             * This calls planner.buffer_line several times, adding
  14471             * small incremental moves for DELTA or SCARA.
  14472             *
  14473             * For Unified Bed Leveling (Delta or Segmented Cartesian)
  14474             * the ubl.prepare_segmented_line_to method replaces this.
  14475             */

   \                                 In section .text, align 4
  14476            inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
   \                     _Z25prepare_kinematic_move_toRA4_Kf: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
  14477          
  14478              // Get the top feedrate of the move in the XY plane
  14479              const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
   \   00000006   0xF8DF 0x4448      LDR.W    R4,??prepare_kinematic_move_to_0
   \   0000000A   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   0000000E   0x.... 0x....      BL       __aeabi_i2f
   \   00000012   0x6DE1             LDR      R1,[R4, #+92]
   \   00000014   0x.... 0x....      BL       __aeabi_fmul
   \   00000018   0x.... 0x....      BL       __aeabi_f2d
   \   0000001C   0xF8DF 0x2434      LDR.W    R2,??prepare_kinematic_move_to_0+0x4  ;; 0x47ae147b
   \   00000020   0xF8DF 0x3434      LDR.W    R3,??prepare_kinematic_move_to_0+0x8  ;; 0x3f847ae1
   \   00000024   0x.... 0x....      BL       __aeabi_dmul
   \   00000028   0x.... 0x....      BL       __aeabi_d2f
   \   0000002C   0x9002             STR      R0,[SP, #+8]
  14480          
  14481              const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
   \   0000002E   0x980C             LDR      R0,[SP, #+48]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x68A1             LDR      R1,[R4, #+8]
   \   00000034   0x.... 0x....      BL       __aeabi_fsub
   \   00000038   0x4681             MOV      R9,R0
  14482                          ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
   \   0000003A   0x980C             LDR      R0,[SP, #+48]
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x68E1             LDR      R1,[R4, #+12]
   \   00000040   0x.... 0x....      BL       __aeabi_fsub
   \   00000044   0x4607             MOV      R7,R0
  14483          
  14484              // If the move is only in Z/E don't split up the move
  14485              if (!xdiff && !ydiff) {
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000004E   0xD104             BNE.N    ??prepare_kinematic_move_to_1
   \   00000050   0x4638             MOV      R0,R7
   \   00000052   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000056   0xF000 0x81F1      BEQ.W    ??prepare_kinematic_move_to_2
   \                     ??prepare_kinematic_move_to_1: (+1)
   \   0000005A   0xF8DF 0x0400      LDR.W    R0,??prepare_kinematic_move_to_0+0xC
   \   0000005E   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000062   0xF240 0x3102      MOVW     R1,#+770
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0x980C             LDR      R0,[SP, #+48]
   \   0000006A   0xD005             BEQ.N    ??prepare_kinematic_move_to_3
  14486                planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
  14487                return false; // caller will update current_position
  14488              }
  14489          
  14490              // Fail if attempting move outside printable radius
  14491              if(MACHINETPYE & IS_KINEMATIC)
  14492              {
  14493                  if (!position_is_reachable_IS_KINEMATIC(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
   \   0000006C   0x1D01             ADDS     R1,R0,#+4
   \   0000006E   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD105             BNE.N    ??prepare_kinematic_move_to_4
   \   00000076   0xE068             B.N      ??prepare_kinematic_move_to_5
  14494              }
  14495              else
  14496              {
  14497                  if (!position_is_reachable_IS_CARTESIAN(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
   \                     ??prepare_kinematic_move_to_3: (+1)
   \   00000078   0x1D01             ADDS     R1,R0,#+4
   \   0000007A   0x.... 0x....      BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD063             BEQ.N    ??prepare_kinematic_move_to_5
  14498              }
  14499              // Remaining cartesian distances
  14500              const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
   \                     ??prepare_kinematic_move_to_4: (+1)
   \   00000082   0x980C             LDR      R0,[SP, #+48]
   \   00000084   0x6880             LDR      R0,[R0, #+8]
   \   00000086   0x6921             LDR      R1,[R4, #+16]
   \   00000088   0x.... 0x....      BL       __aeabi_fsub
   \   0000008C   0x9001             STR      R0,[SP, #+4]
  14501                          ediff = rtarget[E_AXIS] - current_position[E_AXIS];
   \   0000008E   0x980C             LDR      R0,[SP, #+48]
   \   00000090   0x68C0             LDR      R0,[R0, #+12]
   \   00000092   0x6961             LDR      R1,[R4, #+20]
   \   00000094   0x.... 0x....      BL       __aeabi_fsub
   \   00000098   0x9000             STR      R0,[SP, #+0]
  14502          
  14503              // Get the linear distance in XYZ
  14504              // If the move is very short, check the E move distance
  14505              // No E move either? Game over.
  14506              float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
   \   0000009A   0x464E             MOV      R6,R9
   \   0000009C   0xF04F 0x0802      MOV      R8,#+2
   \   000000A0   0xF04F 0x557E      MOV      R5,#+1065353216
   \   000000A4   0xE004             B.N      ??prepare_kinematic_move_to_6
   \                     ??prepare_kinematic_move_to_7: (+1)
   \   000000A6   0x4630             MOV      R0,R6
   \   000000A8   0x4631             MOV      R1,R6
   \   000000AA   0x.... 0x....      BL       __aeabi_fmul
   \   000000AE   0x4606             MOV      R6,R0
   \                     ??prepare_kinematic_move_to_6: (+1)
   \   000000B0   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000000B4   0xD504             BPL.N    ??prepare_kinematic_move_to_8
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x4631             MOV      R1,R6
   \   000000BA   0x.... 0x....      BL       __aeabi_fmul
   \   000000BE   0x4605             MOV      R5,R0
   \                     ??prepare_kinematic_move_to_8: (+1)
   \   000000C0   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   000000C4   0xD1EF             BNE.N    ??prepare_kinematic_move_to_7
   \   000000C6   0x46B8             MOV      R8,R7
   \   000000C8   0xF04F 0x0A02      MOV      R10,#+2
   \   000000CC   0xF04F 0x567E      MOV      R6,#+1065353216
   \   000000D0   0xE004             B.N      ??prepare_kinematic_move_to_9
   \                     ??prepare_kinematic_move_to_10: (+1)
   \   000000D2   0x4640             MOV      R0,R8
   \   000000D4   0x4641             MOV      R1,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_fmul
   \   000000DA   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_9: (+1)
   \   000000DC   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000000E0   0xD504             BPL.N    ??prepare_kinematic_move_to_11
   \   000000E2   0x4630             MOV      R0,R6
   \   000000E4   0x4641             MOV      R1,R8
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4606             MOV      R6,R0
   \                     ??prepare_kinematic_move_to_11: (+1)
   \   000000EC   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000000F0   0xD1EF             BNE.N    ??prepare_kinematic_move_to_10
   \   000000F2   0xF8DD 0xB004      LDR      R11,[SP, #+4]
   \   000000F6   0xF04F 0x0802      MOV      R8,#+2
   \   000000FA   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000000FE   0xE004             B.N      ??prepare_kinematic_move_to_12
   \                     ??prepare_kinematic_move_to_13: (+1)
   \   00000100   0x4658             MOV      R0,R11
   \   00000102   0x4659             MOV      R1,R11
   \   00000104   0x.... 0x....      BL       __aeabi_fmul
   \   00000108   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_12: (+1)
   \   0000010A   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   0000010E   0xD504             BPL.N    ??prepare_kinematic_move_to_14
   \   00000110   0x4650             MOV      R0,R10
   \   00000112   0x4659             MOV      R1,R11
   \   00000114   0x.... 0x....      BL       __aeabi_fmul
   \   00000118   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_14: (+1)
   \   0000011A   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   0000011E   0xD1EF             BNE.N    ??prepare_kinematic_move_to_13
   \   00000120   0x4628             MOV      R0,R5
   \   00000122   0x4631             MOV      R1,R6
   \   00000124   0x.... 0x....      BL       __aeabi_fadd
   \   00000128   0x4651             MOV      R1,R10
   \   0000012A   0x.... 0x....      BL       __aeabi_fadd
   \   0000012E   0x.... 0x....      BL       sqrtf
   \   00000132   0x4680             MOV      R8,R0
  14507              if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
   \   00000134   0x49CA             LDR.N    R1,??prepare_kinematic_move_to_0+0x10  ;; 0x358637be
   \   00000136   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000013A   0xD202             BCS.N    ??prepare_kinematic_move_to_15
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0xF020 0x4800      BIC      R8,R0,#0x80000000
  14508              if (UNEAR_ZERO(cartesian_mm)) return true;
   \                     ??prepare_kinematic_move_to_15: (+1)
   \   00000142   0x4640             MOV      R0,R8
   \   00000144   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000148   0xD201             BCS.N    ??prepare_kinematic_move_to_16
   \                     ??prepare_kinematic_move_to_5: (+1)
   \   0000014A   0x2001             MOVS     R0,#+1
   \   0000014C   0xE17C             B.N      ??prepare_kinematic_move_to_17
  14509          
  14510              // Minimum number of seconds to move the given distance
  14511              const float seconds = cartesian_mm / _feedrate_mm_s;
  14512          
  14513              // The number of segments-per-second times the duration
  14514              // gives the number of segments
  14515              uint16_t segments = delta_segments_per_second * seconds;
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??prepare_kinematic_move_to_16: (+1)
   \   0000014E   0x4DC5             LDR.N    R5,??prepare_kinematic_move_to_0+0x14
   \   00000150   0x9902             LDR      R1,[SP, #+8]
   \   00000152   0x.... 0x....      BL       __aeabi_fdiv
   \   00000156   0x6F69             LDR      R1,[R5, #+116]
   \   00000158   0x.... 0x....      BL       __aeabi_fmul
   \   0000015C   0x.... 0x....      BL       __aeabi_f2iz
   \   00000160   0x4606             MOV      R6,R0
  14516          
  14517              // For SCARA minimum segment size is 0.25mm
  14518              //#if IS_SCARA
  14519          	if(MACHINETPYE&IS_SCARA)
   \   00000162   0x48BE             LDR.N    R0,??prepare_kinematic_move_to_0+0xC
   \   00000164   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000168   0xF44F 0x7140      MOV      R1,#+768
   \   0000016C   0x4208             TST      R0,R1
   \   0000016E   0xD011             BEQ.N    ??prepare_kinematic_move_to_18
  14520                NOMORE(segments, cartesian_mm * 4);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000170   0xF04F 0x4081      MOV      R0,#+1082130432
   \   00000174   0x4641             MOV      R1,R8
   \   00000176   0x.... 0x....      BL       __aeabi_fmul
   \   0000017A   0x4680             MOV      R8,R0
   \   0000017C   0xB2B6             UXTH     R6,R6
   \   0000017E   0x4630             MOV      R0,R6
   \   00000180   0x.... 0x....      BL       __aeabi_ui2f
   \   00000184   0x4601             MOV      R1,R0
   \   00000186   0x4640             MOV      R0,R8
   \   00000188   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000018C   0xD202             BCS.N    ??prepare_kinematic_move_to_18
   \   0000018E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000192   0x4606             MOV      R6,R0
  14521              //#endif
  14522          
  14523              // At least one segment is required
  14524              NOLESS(segments, 1);
   \                     ??prepare_kinematic_move_to_18: (+1)
   \   00000194   0xB2B6             UXTH     R6,R6
   \   00000196   0x2E00             CMP      R6,#+0
   \   00000198   0xD100             BNE.N    ??prepare_kinematic_move_to_19
   \   0000019A   0x2601             MOVS     R6,#+1
  14525          
  14526              // The approximate length of each segment
  14527              const float inv_segments = 1.0 / float(segments),
   \                     ??prepare_kinematic_move_to_19: (+1)
   \   0000019C   0x4630             MOV      R0,R6
   \   0000019E   0x.... 0x....      BL       __aeabi_ui2f
   \   000001A2   0x4601             MOV      R1,R0
   \   000001A4   0xF04F 0x507E      MOV      R0,#+1065353216
   \   000001A8   0x.... 0x....      BL       __aeabi_fdiv
   \   000001AC   0x4680             MOV      R8,R0
  14528                          segment_distance[XYZE] = {
   \   000001AE   0x4648             MOV      R0,R9
   \   000001B0   0x4641             MOV      R1,R8
   \   000001B2   0x.... 0x....      BL       __aeabi_fmul
   \   000001B6   0x9007             STR      R0,[SP, #+28]
   \   000001B8   0x4638             MOV      R0,R7
   \   000001BA   0x4641             MOV      R1,R8
   \   000001BC   0x.... 0x....      BL       __aeabi_fmul
   \   000001C0   0x9008             STR      R0,[SP, #+32]
   \   000001C2   0x9801             LDR      R0,[SP, #+4]
   \   000001C4   0x4641             MOV      R1,R8
   \   000001C6   0x.... 0x....      BL       __aeabi_fmul
   \   000001CA   0x9009             STR      R0,[SP, #+36]
   \   000001CC   0x9800             LDR      R0,[SP, #+0]
   \   000001CE   0x4641             MOV      R1,R8
   \   000001D0   0x.... 0x....      BL       __aeabi_fmul
   \   000001D4   0x900A             STR      R0,[SP, #+40]
  14529                            xdiff * inv_segments,
  14530                            ydiff * inv_segments,
  14531                            zdiff * inv_segments,
  14532                            ediff * inv_segments
  14533                          };
  14534          
  14535              // SERIAL_ECHOPAIR("mm=", cartesian_mm);
  14536              // SERIAL_ECHOPAIR(" seconds=", seconds);
  14537              // SERIAL_ECHOLNPAIR(" segments=", segments);
  14538          
  14539              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14540                // SCARA needs to scale the feed rate from mm/s to degrees/s
  14541                // i.e., Complete the angular vector in the given time.
  14542                const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
  14543                            inverse_secs = inv_segment_length * _feedrate_mm_s;
  14544                float oldA = stepper.get_axis_position_degrees(A_AXIS),
  14545                      oldB = stepper.get_axis_position_degrees(B_AXIS);
  14546              #endif
  14547          
  14548              // Get the current position as starting point
  14549              float raw[XYZE];
  14550              COPY(raw, current_position);
   \   000001D6   0x2210             MOVS     R2,#+16
   \   000001D8   0xF104 0x0108      ADD      R1,R4,#+8
   \   000001DC   0xA803             ADD      R0,SP,#+12
   \   000001DE   0x.... 0x....      BL       memcpy
   \   000001E2   0xE009             B.N      ??prepare_kinematic_move_to_20
  14551          
  14552          
  14553              // Calculate and execute the segments
  14554              while (--segments) {
  14555          
  14556                static millis_t next_idle_ms = millis() + 200UL;
  14557                thermalManager.manage_heater();  // This returns immediately if not really needed.
  14558                if (ELAPSED(millis(), next_idle_ms)) {
  14559                  next_idle_ms = millis() + 200UL;
  14560                  idle();
  14561                }
  14562          
  14563                LOOP_XYZE(i) raw[i] += segment_distance[i];
  14564                //#if ENABLED(DELTA)
  14565                if(MACHINETPYE&DELTA)
  14566                  DELTA_IK(raw); // Delta can inline its kinematics
  14567                //#else
  14568                else
  14569                  inverse_kinematics(raw);
  14570                //#endif
  14571          
  14572                ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
  14573          
  14574                #if ENABLED(SCARA_FEEDRATE_SCALING)
  14575                  // For SCARA scale the feed rate from mm/s to degrees/s
  14576                  // i.e., Complete the angular vector in the given time.
  14577                  planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14578                  oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
  14579                #else
  14580                    if (gCfgItems.breakpoint_reprint_flg == 1) 
  14581                    {
  14582                        if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
  14583                        {
  14584                            //current_position[Z_AXIS] = rtarget[Z_AXIS];
  14585                            //current_position[E_AXIS] = destination[E_AXIS];
  14586          
  14587                            gCfgItems.had_breakpoint=1;
  14588                            gCfgItems.breakpoint_e_position=LROUND(raw[E_AXIS] * planner.axis_steps_per_mm[E_AXIS]);
  14589                                              
  14590                            return false;
  14591                        }
  14592                    }
  14593                  //gCfgItems.breakpoint_reprint_flg = 0;
  14594                  planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
   \                     ??prepare_kinematic_move_to_21: (+1)
   \   000001E4   0x78E0             LDRB     R0,[R4, #+3]
   \   000001E6   0x9001             STR      R0,[SP, #+4]
   \   000001E8   0xA802             ADD      R0,SP,#+8
   \   000001EA   0x9000             STR      R0,[SP, #+0]
   \   000001EC   0xAB06             ADD      R3,SP,#+24
   \   000001EE   0x6DA2             LDR      R2,[R4, #+88]
   \   000001F0   0x6D61             LDR      R1,[R4, #+84]
   \   000001F2   0x6D20             LDR      R0,[R4, #+80]
   \   000001F4   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   \                     ??prepare_kinematic_move_to_20: (+1)
   \   000001F8   0x1E76             SUBS     R6,R6,#+1
   \   000001FA   0xB2B6             UXTH     R6,R6
   \   000001FC   0x2E00             CMP      R6,#+0
   \   000001FE   0xF000 0x811D      BEQ.W    ??prepare_kinematic_move_to_2
   \   00000202   0x4F99             LDR.N    R7,??prepare_kinematic_move_to_0+0x18
   \   00000204   0x4899             LDR.N    R0,??prepare_kinematic_move_to_0+0x1C
   \   00000206   0x7801             LDRB     R1,[R0, #+0]
   \   00000208   0x2900             CMP      R1,#+0
   \   0000020A   0xD105             BNE.N    ??prepare_kinematic_move_to_22
   \   0000020C   0x2101             MOVS     R1,#+1
   \   0000020E   0x7001             STRB     R1,[R0, #+0]
   \   00000210   0x.... 0x....      BL       HAL_GetTick
   \   00000214   0x30C8             ADDS     R0,R0,#+200
   \   00000216   0x6038             STR      R0,[R7, #+0]
   \                     ??prepare_kinematic_move_to_22: (+1)
   \   00000218   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   \   0000021C   0x.... 0x....      BL       HAL_GetTick
   \   00000220   0x6839             LDR      R1,[R7, #+0]
   \   00000222   0x1A40             SUBS     R0,R0,R1
   \   00000224   0xD405             BMI.N    ??prepare_kinematic_move_to_23
   \   00000226   0x.... 0x....      BL       HAL_GetTick
   \   0000022A   0x30C8             ADDS     R0,R0,#+200
   \   0000022C   0x6038             STR      R0,[R7, #+0]
   \   0000022E   0x.... 0x....      BL       _Z4idlev
   \                     ??prepare_kinematic_move_to_23: (+1)
   \   00000232   0xF04F 0x0800      MOV      R8,#+0
   \   00000236   0xAF03             ADD      R7,SP,#+12
   \   00000238   0xE00A             B.N      ??prepare_kinematic_move_to_24
   \                     ??prepare_kinematic_move_to_25: (+1)
   \   0000023A   0xF857 0x0028      LDR      R0,[R7, R8, LSL #+2]
   \   0000023E   0xA907             ADD      R1,SP,#+28
   \   00000240   0xF851 0x1028      LDR      R1,[R1, R8, LSL #+2]
   \   00000244   0x.... 0x....      BL       __aeabi_fadd
   \   00000248   0xF847 0x0028      STR      R0,[R7, R8, LSL #+2]
   \   0000024C   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??prepare_kinematic_move_to_24: (+1)
   \   00000250   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000254   0xDBF1             BLT.N    ??prepare_kinematic_move_to_25
   \   00000256   0x4881             LDR.N    R0,??prepare_kinematic_move_to_0+0xC
   \   00000258   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   0000025C   0x0780             LSLS     R0,R0,#+30
   \   0000025E   0xF140 0x80CB      BPL.W    ??prepare_kinematic_move_to_26
   \   00000262   0x68E8             LDR      R0,[R5, #+12]
   \   00000264   0x9903             LDR      R1,[SP, #+12]
   \   00000266   0x.... 0x....      BL       __aeabi_fsub
   \   0000026A   0x4607             MOV      R7,R0
   \   0000026C   0xF04F 0x0902      MOV      R9,#+2
   \   00000270   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000274   0xE004             B.N      ??prepare_kinematic_move_to_27
   \                     ??prepare_kinematic_move_to_28: (+1)
   \   00000276   0x4638             MOV      R0,R7
   \   00000278   0x4639             MOV      R1,R7
   \   0000027A   0x.... 0x....      BL       __aeabi_fmul
   \   0000027E   0x4607             MOV      R7,R0
   \                     ??prepare_kinematic_move_to_27: (+1)
   \   00000280   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000284   0xD504             BPL.N    ??prepare_kinematic_move_to_29
   \   00000286   0x4640             MOV      R0,R8
   \   00000288   0x4639             MOV      R1,R7
   \   0000028A   0x.... 0x....      BL       __aeabi_fmul
   \   0000028E   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_29: (+1)
   \   00000290   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000294   0xD1EF             BNE.N    ??prepare_kinematic_move_to_28
   \   00000296   0xAF03             ADD      R7,SP,#+12
   \   00000298   0x6928             LDR      R0,[R5, #+16]
   \   0000029A   0x6879             LDR      R1,[R7, #+4]
   \   0000029C   0x.... 0x....      BL       __aeabi_fsub
   \   000002A0   0x4683             MOV      R11,R0
   \   000002A2   0xF04F 0x0902      MOV      R9,#+2
   \   000002A6   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000002AA   0xE004             B.N      ??prepare_kinematic_move_to_30
   \                     ??prepare_kinematic_move_to_31: (+1)
   \   000002AC   0x4658             MOV      R0,R11
   \   000002AE   0x4659             MOV      R1,R11
   \   000002B0   0x.... 0x....      BL       __aeabi_fmul
   \   000002B4   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_30: (+1)
   \   000002B6   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000002BA   0xD504             BPL.N    ??prepare_kinematic_move_to_32
   \   000002BC   0x4650             MOV      R0,R10
   \   000002BE   0x4659             MOV      R1,R11
   \   000002C0   0x.... 0x....      BL       __aeabi_fmul
   \   000002C4   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_32: (+1)
   \   000002C6   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000002CA   0xD1EF             BNE.N    ??prepare_kinematic_move_to_31
   \   000002CC   0x4640             MOV      R0,R8
   \   000002CE   0x4651             MOV      R1,R10
   \   000002D0   0x.... 0x....      BL       __aeabi_fadd
   \   000002D4   0x4601             MOV      R1,R0
   \   000002D6   0x6BE8             LDR      R0,[R5, #+60]
   \   000002D8   0x.... 0x....      BL       __aeabi_fsub
   \   000002DC   0x.... 0x....      BL       sqrtf
   \   000002E0   0x4601             MOV      R1,R0
   \   000002E2   0x68B8             LDR      R0,[R7, #+8]
   \   000002E4   0x.... 0x....      BL       __aeabi_fadd
   \   000002E8   0x6520             STR      R0,[R4, #+80]
   \   000002EA   0x6968             LDR      R0,[R5, #+20]
   \   000002EC   0x9903             LDR      R1,[SP, #+12]
   \   000002EE   0x.... 0x....      BL       __aeabi_fsub
   \   000002F2   0x4681             MOV      R9,R0
   \   000002F4   0xF04F 0x0A02      MOV      R10,#+2
   \   000002F8   0xF04F 0x587E      MOV      R8,#+1065353216
   \   000002FC   0xE004             B.N      ??prepare_kinematic_move_to_33
   \                     ??prepare_kinematic_move_to_34: (+1)
   \   000002FE   0x4648             MOV      R0,R9
   \   00000300   0x4649             MOV      R1,R9
   \   00000302   0x.... 0x....      BL       __aeabi_fmul
   \   00000306   0x4681             MOV      R9,R0
   \                     ??prepare_kinematic_move_to_33: (+1)
   \   00000308   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000030C   0xD504             BPL.N    ??prepare_kinematic_move_to_35
   \   0000030E   0x4640             MOV      R0,R8
   \   00000310   0x4649             MOV      R1,R9
   \   00000312   0x.... 0x....      BL       __aeabi_fmul
   \   00000316   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_35: (+1)
   \   00000318   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   0000031C   0xD1EF             BNE.N    ??prepare_kinematic_move_to_34
   \   0000031E   0x69A8             LDR      R0,[R5, #+24]
   \   00000320   0x6879             LDR      R1,[R7, #+4]
   \   00000322   0x.... 0x....      BL       __aeabi_fsub
   \   00000326   0x4683             MOV      R11,R0
   \   00000328   0xF04F 0x0902      MOV      R9,#+2
   \   0000032C   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   00000330   0xE004             B.N      ??prepare_kinematic_move_to_36
   \                     ??prepare_kinematic_move_to_37: (+1)
   \   00000332   0x4658             MOV      R0,R11
   \   00000334   0x4659             MOV      R1,R11
   \   00000336   0x.... 0x....      BL       __aeabi_fmul
   \   0000033A   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_36: (+1)
   \   0000033C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000340   0xD504             BPL.N    ??prepare_kinematic_move_to_38
   \   00000342   0x4650             MOV      R0,R10
   \   00000344   0x4659             MOV      R1,R11
   \   00000346   0x.... 0x....      BL       __aeabi_fmul
   \   0000034A   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_38: (+1)
   \   0000034C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000350   0xD1EF             BNE.N    ??prepare_kinematic_move_to_37
   \   00000352   0x4640             MOV      R0,R8
   \   00000354   0x4651             MOV      R1,R10
   \   00000356   0x.... 0x....      BL       __aeabi_fadd
   \   0000035A   0x4601             MOV      R1,R0
   \   0000035C   0x6C28             LDR      R0,[R5, #+64]
   \   0000035E   0x.... 0x....      BL       __aeabi_fsub
   \   00000362   0x.... 0x....      BL       sqrtf
   \   00000366   0x4601             MOV      R1,R0
   \   00000368   0x68B8             LDR      R0,[R7, #+8]
   \   0000036A   0x.... 0x....      BL       __aeabi_fadd
   \   0000036E   0x6560             STR      R0,[R4, #+84]
   \   00000370   0x69E8             LDR      R0,[R5, #+28]
   \   00000372   0x9903             LDR      R1,[SP, #+12]
   \   00000374   0x.... 0x....      BL       __aeabi_fsub
   \   00000378   0x4681             MOV      R9,R0
   \   0000037A   0xF04F 0x0A02      MOV      R10,#+2
   \   0000037E   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000382   0xE004             B.N      ??prepare_kinematic_move_to_39
   \                     ??prepare_kinematic_move_to_40: (+1)
   \   00000384   0x4648             MOV      R0,R9
   \   00000386   0x4649             MOV      R1,R9
   \   00000388   0x.... 0x....      BL       __aeabi_fmul
   \   0000038C   0x4681             MOV      R9,R0
   \                     ??prepare_kinematic_move_to_39: (+1)
   \   0000038E   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000392   0xD504             BPL.N    ??prepare_kinematic_move_to_41
   \   00000394   0x4640             MOV      R0,R8
   \   00000396   0x4649             MOV      R1,R9
   \   00000398   0x.... 0x....      BL       __aeabi_fmul
   \   0000039C   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_41: (+1)
   \   0000039E   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000003A2   0xD1EF             BNE.N    ??prepare_kinematic_move_to_40
   \   000003A4   0x6A28             LDR      R0,[R5, #+32]
   \   000003A6   0x6879             LDR      R1,[R7, #+4]
   \   000003A8   0x.... 0x....      BL       __aeabi_fsub
   \   000003AC   0x4683             MOV      R11,R0
   \   000003AE   0xF04F 0x0902      MOV      R9,#+2
   \   000003B2   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000003B6   0xE004             B.N      ??prepare_kinematic_move_to_42
   \                     ??prepare_kinematic_move_to_43: (+1)
   \   000003B8   0x4658             MOV      R0,R11
   \   000003BA   0x4659             MOV      R1,R11
   \   000003BC   0x.... 0x....      BL       __aeabi_fmul
   \   000003C0   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_42: (+1)
   \   000003C2   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000003C6   0xD504             BPL.N    ??prepare_kinematic_move_to_44
   \   000003C8   0x4650             MOV      R0,R10
   \   000003CA   0x4659             MOV      R1,R11
   \   000003CC   0x.... 0x....      BL       __aeabi_fmul
   \   000003D0   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_44: (+1)
   \   000003D2   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000003D6   0xD1EF             BNE.N    ??prepare_kinematic_move_to_43
   \   000003D8   0x4640             MOV      R0,R8
   \   000003DA   0x4651             MOV      R1,R10
   \   000003DC   0x.... 0x....      BL       __aeabi_fadd
   \   000003E0   0x4601             MOV      R1,R0
   \   000003E2   0x6C68             LDR      R0,[R5, #+68]
   \   000003E4   0x.... 0x....      BL       __aeabi_fsub
   \   000003E8   0x.... 0x....      BL       sqrtf
   \   000003EC   0x4601             MOV      R1,R0
   \   000003EE   0x68B8             LDR      R0,[R7, #+8]
   \   000003F0   0x.... 0x....      BL       __aeabi_fadd
   \   000003F4   0x65A0             STR      R0,[R4, #+88]
   \   000003F6   0xE002             B.N      ??prepare_kinematic_move_to_45
   \                     ??prepare_kinematic_move_to_26: (+1)
   \   000003F8   0xA803             ADD      R0,SP,#+12
   \   000003FA   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   \                     ??prepare_kinematic_move_to_45: (+1)
   \   000003FE   0xA803             ADD      R0,SP,#+12
   \   00000400   0x.... 0x....      BL       _Z12ADJUST_DELTAPKf
   \   00000404   0x4A1A             LDR.N    R2,??prepare_kinematic_move_to_0+0x20
   \   00000406   0xF892 0x0148      LDRB     R0,[R2, #+328]
   \   0000040A   0x2801             CMP      R0,#+1
   \   0000040C   0xF47F 0xAEEA      BNE.W    ??prepare_kinematic_move_to_21
   \   00000410   0x980C             LDR      R0,[SP, #+48]
   \   00000412   0x6880             LDR      R0,[R0, #+8]
   \   00000414   0xF8D2 0x1298      LDR      R1,[R2, #+664]
   \   00000418   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000041C   0xF4BF 0xAEE2      BCS.W    ??prepare_kinematic_move_to_21
   \   00000420   0xF502 0x74A4      ADD      R4,R2,#+328
   \   00000424   0x2001             MOVS     R0,#+1
   \   00000426   0x7320             STRB     R0,[R4, #+12]
   \   00000428   0x9906             LDR      R1,[SP, #+24]
   \   0000042A   0x4812             LDR.N    R0,??prepare_kinematic_move_to_0+0x24
   \   0000042C   0x68C0             LDR      R0,[R0, #+12]
   \   0000042E   0x.... 0x....      BL       __aeabi_fmul
   \   00000432   0x.... 0x....      BL       lroundf
   \   00000436   0x60A0             STR      R0,[R4, #+8]
   \   00000438   0x2000             MOVS     R0,#+0
   \   0000043A   0xE005             B.N      ??prepare_kinematic_move_to_17
  14595                #endif
  14596              }
  14597          
  14598              // Ensure last segment arrives at target location.
  14599              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14600                inverse_kinematics(rtarget);
  14601                ADJUST_DELTA(rtarget);
  14602                planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14603              #else
  14604                planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
   \                     ??prepare_kinematic_move_to_2: (+1)
   \   0000043C   0x78E2             LDRB     R2,[R4, #+3]
   \   0000043E   0xA902             ADD      R1,SP,#+8
   \   00000440   0x980C             LDR      R0,[SP, #+48]
   \   00000442   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
  14605              #endif
  14606          
  14607              return false; // caller will update current_position
   \   00000446   0x2000             MOVS     R0,#+0
   \                     ??prepare_kinematic_move_to_17: (+1)
   \   00000448   0xB00D             ADD      SP,SP,#+52
   \   0000044A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \   0000044E   0xBF00             Nop      
   \                     ??prepare_kinematic_move_to_0:
   \   00000450   0x........         DC32     mks_heating_busy
   \   00000454   0x47AE147B         DC32     0x47ae147b
   \   00000458   0x3F847AE1         DC32     0x3f847ae1
   \   0000045C   0x........         DC32     mksCfg
   \   00000460   0x358637BE         DC32     0x358637be
   \   00000464   0x........         DC32     axis_homed
   \   00000468   0x........         DC32     _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
   \   0000046C   0x........         DC32     _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
   \   00000470   0x........         DC32     gCfgItems
   \   00000474   0x........         DC32     _ZN7Planner17axis_steps_per_mmE
  14608            }
  14609          #endif
  14610          //#else // !IS_KINEMATIC
  14611          #if 1
  14612            /**
  14613             * Prepare a linear move in a Cartesian setup.
  14614             *
  14615             * When a mesh-based leveling system is active, moves are segmented
  14616             * according to the configuration of the leveling system.
  14617             *
  14618             * Returns true if current_position[] was set to destination[]
  14619             */

   \                                 In section .text, align 4
  14620            inline bool prepare_move_to_destination_cartesian() {
   \                     _Z37prepare_move_to_destination_cartesianv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
  14621              #if 1//HAS_MESH
  14622                if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
   \   00000004   0x4C3B             LDR.N    R4,??prepare_move_to_destination_cartesian_0
   \   00000006   0x483C             LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x4
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD05F             BEQ.N    ??prepare_move_to_destination_cartesian_1
   \   0000000E   0xF104 0x0020      ADD      R0,R4,#+32
   \   00000012   0x.... 0x....      BL       _ZN7Planner20leveling_active_at_zERKf
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD059             BEQ.N    ??prepare_move_to_destination_cartesian_1
   \   0000001A   0x4838             LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x8
   \   0000001C   0xF890 0x2040      LDRB     R2,[R0, #+64]
   \   00000020   0x2A10             CMP      R2,#+16
   \   00000022   0xD115             BNE.N    ??prepare_move_to_destination_cartesian_2
  14623                  //#if ENABLED(AUTO_BED_LEVELING_UBL)
  14624                  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
  14625                  {
  14626                    ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
   \   00000024   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000028   0x.... 0x....      BL       __aeabi_i2f
   \   0000002C   0x6DE1             LDR      R1,[R4, #+92]
   \   0000002E   0x.... 0x....      BL       __aeabi_fmul
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4A32             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   00000038   0x4B32             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   0000003A   0x.... 0x....      BL       __aeabi_dmul
   \   0000003E   0x.... 0x....      BL       __aeabi_d2f
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x78E1             LDRB     R1,[R4, #+3]
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x.... 0x....      BL       _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
  14627                    return true;     
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xBD76             POP      {R1,R2,R4-R6,PC}
  14628          		 }// all moves, including Z-only moves.
  14629                  //#elif ENABLED(SEGMENT_LEVELED_MOVES)
  14630          		//{
  14631                  //  segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
  14632                  //  return false; // caller will update current_position
  14633          		//}
  14634                  //#else
  14635                  else
  14636                  {
  14637                    #if ENABLED(SEGMENT_LEVELED_MOVES)
  14638                      segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
  14639                      return false; // caller will update current_position
  14640                    #else
  14641                    /**
  14642                     * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
  14643                     * Otherwise fall through to do a direct single move.
  14644                     */
  14645                    if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
   \                     ??prepare_move_to_destination_cartesian_2: (+1)
   \   00000050   0x68A0             LDR      R0,[R4, #+8]
   \   00000052   0x69A1             LDR      R1,[R4, #+24]
   \   00000054   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000058   0xD104             BNE.N    ??prepare_move_to_destination_cartesian_3
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0x69E1             LDR      R1,[R4, #+28]
   \   0000005E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000062   0xD034             BEQ.N    ??prepare_move_to_destination_cartesian_1
  14646                      //#if ENABLED(MESH_BED_LEVELING)
  14647                      if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??prepare_move_to_destination_cartesian_3: (+1)
   \   00000064   0x2A20             CMP      R2,#+32
   \   00000066   0xD117             BNE.N    ??prepare_move_to_destination_cartesian_4
  14648                        mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \   00000068   0x22FF             MOVS     R2,#+255
   \   0000006A   0x4611             MOV      R1,R2
   \   0000006C   0x460D             MOV      R5,R1
   \   0000006E   0x4616             MOV      R6,R2
   \   00000070   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000074   0x.... 0x....      BL       __aeabi_i2f
   \   00000078   0x6DE1             LDR      R1,[R4, #+92]
   \   0000007A   0x.... 0x....      BL       __aeabi_fmul
   \   0000007E   0x.... 0x....      BL       __aeabi_f2d
   \   00000082   0x4A1F             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   00000084   0x4B1F             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   00000086   0x.... 0x....      BL       __aeabi_dmul
   \   0000008A   0x.... 0x....      BL       __aeabi_d2f
   \   0000008E   0x4632             MOV      R2,R6
   \   00000090   0x4629             MOV      R1,R5
   \   00000092   0x.... 0x....      BL       _Z24mesh_line_to_destinationfhh
   \   00000096   0xE018             B.N      ??prepare_move_to_destination_cartesian_5
  14649                      //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  14650                      else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??prepare_move_to_destination_cartesian_4: (+1)
   \   00000098   0x2A08             CMP      R2,#+8
   \   0000009A   0xD116             BNE.N    ??prepare_move_to_destination_cartesian_5
  14651                        bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \   0000009C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000A0   0x460A             MOV      R2,R1
   \   000000A2   0x4615             MOV      R5,R2
   \   000000A4   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   000000A8   0x.... 0x....      BL       __aeabi_i2f
   \   000000AC   0x6DE1             LDR      R1,[R4, #+92]
   \   000000AE   0x.... 0x....      BL       __aeabi_fmul
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x4A12             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   000000B8   0x4B12             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   000000BA   0x.... 0x....      BL       __aeabi_dmul
   \   000000BE   0x.... 0x....      BL       __aeabi_d2f
   \   000000C2   0x462A             MOV      R2,R5
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0x.... 0x....      BL       _Z28bilinear_line_to_destinationftt
  14652                      //#endif
  14653                      return true;
   \                     ??prepare_move_to_destination_cartesian_5: (+1)
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xBD76             POP      {R1,R2,R4-R6,PC}
  14654                    }
  14655                    #endif
  14656                  }
  14657                  //#endif
  14658                }
  14659              #endif // HAS_MESH
  14660          
  14661              buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \                     ??prepare_move_to_destination_cartesian_1: (+1)
   \   000000CE   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   000000D2   0x.... 0x....      BL       __aeabi_i2f
   \   000000D6   0x6DE1             LDR      R1,[R4, #+92]
   \   000000D8   0x.... 0x....      BL       __aeabi_fmul
   \   000000DC   0x.... 0x....      BL       __aeabi_f2d
   \   000000E0   0x4A07             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   000000E2   0x4B08             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   000000E4   0x.... 0x....      BL       __aeabi_dmul
   \   000000E8   0x.... 0x....      BL       __aeabi_d2f
   \   000000EC   0x.... 0x....      BL       _Z26buffer_line_to_destinationf
  14662              return false; // caller will update current_position
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??prepare_move_to_destination_cartesian_0:
   \   000000F4   0x........         DC32     mks_heating_busy
   \   000000F8   0x........         DC32     _ZN7Planner15leveling_activeE
   \   000000FC   0x........         DC32     mksCfg
   \   00000100   0x47AE147B         DC32     0x47ae147b
   \   00000104   0x3F847AE1         DC32     0x3f847ae1
  14663            }
  14664          
  14665          #endif // !IS_KINEMATIC
  14666          #endif // !UBL_SEGMENTED
  14667          
  14668          #if ENABLED(DUAL_X_CARRIAGE)
  14669          
  14670            /**
  14671             * Unpark the carriage, if needed
  14672             */
  14673            inline bool dual_x_carriage_unpark() {
  14674              if (active_extruder_parked)
  14675                switch (dual_x_carriage_mode) {
  14676          
  14677                  case DXC_FULL_CONTROL_MODE: break;
  14678          
  14679                  case DXC_AUTO_PARK_MODE:
  14680                    if (current_position[E_AXIS] == destination[E_AXIS]) {
  14681                      // This is a travel move (with no extrusion)
  14682                      // Skip it, but keep track of the current position
  14683                      // (so it can be used as the start of the next non-travel move)
  14684                      if (delayed_move_time != 0xFFFFFFFFUL) {
  14685                        set_current_from_destination();
  14686                        NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
  14687                        delayed_move_time = millis();
  14688                        return true;
  14689                      }
  14690                    }
  14691                    // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
  14692                    for (uint8_t i = 0; i < 3; i++)
  14693                      planner.buffer_line(
  14694                        i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
  14695                        i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
  14696                        i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
  14697                        current_position[E_AXIS],
  14698                        i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
  14699                        active_extruder
  14700                      );
  14701                    delayed_move_time = 0;
  14702                    active_extruder_parked = false;
  14703                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  14704                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
  14705                    #endif
  14706                    break;
  14707          
  14708                  case DXC_DUPLICATION_MODE:
  14709                    if (active_extruder == 0) {
  14710                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  14711                        if (DEBUGGING(LEVELING)) {
  14712                          SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
  14713                          SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
  14714                        }
  14715                      #endif
  14716                      // move duplicate extruder into correct duplication position.
  14717                      planner.set_position_mm(
  14718                        inactive_extruder_x_pos,
  14719                        current_position[Y_AXIS],
  14720                        current_position[Z_AXIS],
  14721                        current_position[E_AXIS]
  14722                      );
  14723                      planner.buffer_line(
  14724                        current_position[X_AXIS] + duplicate_extruder_x_offset,
  14725                        current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
  14726                        planner.max_feedrate_mm_s[X_AXIS], 1
  14727                      );
  14728                      SYNC_PLAN_POSITION_KINEMATIC();
  14729                      stepper.synchronize();
  14730                      extruder_duplication_enabled = true;
  14731                      active_extruder_parked = false;
  14732                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  14733                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
  14734                      #endif
  14735                    }
  14736                    else {
  14737                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  14738                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
  14739                      #endif
  14740                    }
  14741                    break;
  14742                }
  14743              return false;
  14744            }
  14745          
  14746          #endif // DUAL_X_CARRIAGE
  14747          
  14748          /**
  14749           * Prepare a single move and get ready for the next one
  14750           *
  14751           * This may result in several calls to planner.buffer_line to
  14752           * do smaller moves for DELTA, SCARA, mesh moves, etc.
  14753           *
  14754           * Make sure current_position[E] and destination[E] are good
  14755           * before calling or cold/lengthy extrusion may get missed.
  14756           */

   \                                 In section .text, align 2, keep-with-next
  14757          void prepare_move_to_destination() {
   \                     _Z27prepare_move_to_destinationv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  14758            clamp_to_software_endstops(destination);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable179
   \   00000006   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000000A   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  14759            refresh_cmd_timeout();
   \   0000000E   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  14760          
  14761            #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
  14762          
  14763              if (!DEBUGGING(DRYRUN)) {
   \   00000012   0x7860             LDRB     R0,[R4, #+1]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD42F             BMI.N    ??prepare_move_to_destination_0
  14764                if (destination[E_AXIS] != current_position[E_AXIS]) {
   \   00000018   0x6A65             LDR      R5,[R4, #+36]
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x6961             LDR      R1,[R4, #+20]
   \   0000001E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000022   0xD029             BEQ.N    ??prepare_move_to_destination_0
  14765                  #if ENABLED(PREVENT_COLD_EXTRUSION)
  14766                    if (thermalManager.tooColdToExtrude(active_extruder)) {
   \   00000024   0x78E0             LDRB     R0,[R4, #+3]
   \   00000026   0x.... 0x....      BL       _ZN11Temperature16tooColdToExtrudeEh
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD008             BEQ.N    ??prepare_move_to_destination_1
  14767                      current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   0000002E   0x6165             STR      R5,[R4, #+20]
  14768                      SERIAL_ECHO_START();
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable187
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14769                      SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   \   00000038   0x.... 0x....      ADR.W    R0,`?<Constant " cold extrusion preve...">`
   \   0000003C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14770                    }
  14771                  #endif // PREVENT_COLD_EXTRUSION
  14772                  #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
  14773                    if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
   \                     ??prepare_move_to_destination_1: (+1)
   \   00000040   0x6A60             LDR      R0,[R4, #+36]
   \   00000042   0x6961             LDR      R1,[R4, #+20]
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0xF020 0x4100      BIC      R1,R0,#0x80000000
   \   0000004C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable187_1
   \   00000052   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable187_2  ;; 0x447a0001
   \   0000005E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000062   0xD809             BHI.N    ??prepare_move_to_destination_0
  14774                      current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   00000064   0x6A60             LDR      R0,[R4, #+36]
   \   00000066   0x6160             STR      R0,[R4, #+20]
  14775                      SERIAL_ECHO_START();
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable187
   \   0000006C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14776                      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \   00000070   0x.... 0x....      ADR.W    R0,`?<Constant " too long extrusion p...">`
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14777                    }
  14778                  #endif // PREVENT_LENGTHY_EXTRUDE
  14779                }
  14780              }
  14781          
  14782            #endif
  14783          
  14784            #if ENABLED(DUAL_X_CARRIAGE)
  14785              if (dual_x_carriage_unpark()) return;
  14786            #endif
  14787            
  14788          #if 0
  14789            if (
  14790              #if UBL_SEGMENTED
  14791                ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
  14792              #elif IS_KINEMATIC
  14793                prepare_kinematic_move_to(destination)
  14794              #else
  14795                prepare_move_to_destination_cartesian()
  14796              #endif
  14797            ) return;
  14798          #endif
  14799          
  14800            if((BED_LEVELING_METHOD &AUTO_BED_LEVELING_UBL) && (MACHINETPYE == DELTA /*|| ENABLED(SEGMENT_LEVELED_MOVES)*/))
   \                     ??prepare_move_to_destination_0: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable179_1
   \   0000007C   0xF100 0x0140      ADD      R1,R0,#+64
   \   00000080   0xF9B1 0x1018      LDRSH    R1,[R1, #+24]
   \   00000084   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000088   0x06C0             LSLS     R0,R0,#+27
   \   0000008A   0xD51B             BPL.N    ??prepare_move_to_destination_2
   \   0000008C   0x2902             CMP      R1,#+2
   \   0000008E   0xD119             BNE.N    ??prepare_move_to_destination_2
  14801            {
  14802              if(ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s)))return;
   \   00000090   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000094   0x.... 0x....      BL       __aeabi_i2f
   \   00000098   0x6DE1             LDR      R1,[R4, #+92]
   \   0000009A   0x.... 0x....      BL       __aeabi_fmul
   \   0000009E   0x.... 0x....      BL       __aeabi_f2d
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable187_3  ;; 0x47ae147b
   \   000000A6   0x.... 0x....      LDR.W    R3,??DataTable188  ;; 0x3f847ae1
   \   000000AA   0x.... 0x....      BL       __aeabi_dmul
   \   000000AE   0x.... 0x....      BL       __aeabi_d2f
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0xA900             ADD      R1,SP,#+0
   \   000000B6   0xF104 0x0018      ADD      R0,R4,#+24
   \   000000BA   0x.... 0x....      BL       _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD00F             BEQ.N    ??prepare_move_to_destination_3
   \   000000C2   0xBD31             POP      {R0,R4,R5,PC}
  14803            } 
  14804            else if(MACHINETPYE & IS_KINEMATIC)
   \                     ??prepare_move_to_destination_2: (+1)
   \   000000C4   0xF240 0x3002      MOVW     R0,#+770
   \   000000C8   0x4201             TST      R1,R0
   \   000000CA   0xD006             BEQ.N    ??prepare_move_to_destination_4
  14805            {
  14806              if(prepare_kinematic_move_to(destination))return;
   \   000000CC   0xF104 0x0018      ADD      R0,R4,#+24
   \   000000D0   0x.... 0x....      BL       _Z25prepare_kinematic_move_toRA4_Kf
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD004             BEQ.N    ??prepare_move_to_destination_3
   \   000000D8   0xBD31             POP      {R0,R4,R5,PC}
  14807            }  
  14808            else//if(MACHINETPYE & IS_CARTESIAN)
  14809            {
  14810              if(prepare_move_to_destination_cartesian())return;
   \                     ??prepare_move_to_destination_4: (+1)
   \   000000DA   0x.... 0x....      BL       _Z37prepare_move_to_destination_cartesianv
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD101             BNE.N    ??prepare_move_to_destination_5
  14811            }
  14812          
  14813            set_current_from_destination();
   \                     ??prepare_move_to_destination_3: (+1)
   \   000000E2   0x.... 0x....      BL       _Z28set_current_from_destinationv
  14814          }
   \                     ??prepare_move_to_destination_5: (+1)
   \   000000E6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  14815          
  14816          #if ENABLED(ARC_SUPPORT)
  14817          
  14818            #if N_ARC_CORRECTION < 1
  14819              #undef N_ARC_CORRECTION
  14820              #define N_ARC_CORRECTION 1
  14821            #endif
  14822          
  14823            /**
  14824             * Plan an arc in 2 dimensions
  14825             *
  14826             * The arc is approximated by generating many small linear segments.
  14827             * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  14828             * Arcs should only be made relatively large (over 5mm), as larger arcs with
  14829             * larger segments will tend to be more efficient. Your slicer should have
  14830             * options for G2/G3 arc generation. In future these options may be GCode tunable.
  14831             */

   \                                 In section .text, align 2, keep-with-next
  14832            void plan_arc(
  14833              const float (&cart)[XYZE], // Destination position
  14834              const float (&offset)[2], // Center of rotation relative to current_position
  14835              const bool clockwise      // Clockwise?
  14836            ) {
   \                     _Z8plan_arcRA4_KfRA2_S_b: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x4614             MOV      R4,R2
  14837              #if ENABLED(CNC_WORKSPACE_PLANES)
  14838                AxisEnum p_axis, q_axis, l_axis;
  14839                switch (workspace_plane) {
  14840                  default:
  14841                  case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
  14842                  case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
  14843                  case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
  14844                }
  14845              #else
  14846                constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
  14847              #endif
  14848          
  14849              // Radius vector from center to current location
  14850              float r_P = -offset[0], r_Q = -offset[1];
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x6805             LDR      R5,[R0, #+0]
   \   0000000C   0xF085 0x4500      EOR      R5,R5,#0x80000000
   \   00000010   0x6846             LDR      R6,[R0, #+4]
   \   00000012   0xF086 0x4600      EOR      R6,R6,#0x80000000
  14851          
  14852              const float radius = HYPOT(r_P, r_Q),
   \   00000016   0x46A9             MOV      R9,R5
   \   00000018   0xF04F 0x0A02      MOV      R10,#+2
   \   0000001C   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000020   0x46B8             MOV      R8,R7
   \   00000022   0xE004             B.N      ??plan_arc_0
   \                     ??plan_arc_1: (+1)
   \   00000024   0x4648             MOV      R0,R9
   \   00000026   0x4649             MOV      R1,R9
   \   00000028   0x.... 0x....      BL       __aeabi_fmul
   \   0000002C   0x4681             MOV      R9,R0
   \                     ??plan_arc_0: (+1)
   \   0000002E   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000032   0xD504             BPL.N    ??plan_arc_2
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x4649             MOV      R1,R9
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x4680             MOV      R8,R0
   \                     ??plan_arc_2: (+1)
   \   0000003E   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000042   0xD1EF             BNE.N    ??plan_arc_1
   \   00000044   0x46B3             MOV      R11,R6
   \   00000046   0xF04F 0x0902      MOV      R9,#+2
   \   0000004A   0x46BA             MOV      R10,R7
   \   0000004C   0xE004             B.N      ??plan_arc_3
   \                     ??plan_arc_4: (+1)
   \   0000004E   0x4658             MOV      R0,R11
   \   00000050   0x4659             MOV      R1,R11
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4683             MOV      R11,R0
   \                     ??plan_arc_3: (+1)
   \   00000058   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000005C   0xD504             BPL.N    ??plan_arc_5
   \   0000005E   0x4650             MOV      R0,R10
   \   00000060   0x4659             MOV      R1,R11
   \   00000062   0x.... 0x....      BL       __aeabi_fmul
   \   00000066   0x4682             MOV      R10,R0
   \                     ??plan_arc_5: (+1)
   \   00000068   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000006C   0xD1EF             BNE.N    ??plan_arc_4
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x4651             MOV      R1,R10
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
   \   00000076   0x.... 0x....      BL       sqrtf
   \   0000007A   0x4680             MOV      R8,R0
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable179
   \   00000080   0x6880             LDR      R0,[R0, #+8]
   \   00000082   0x4629             MOV      R1,R5
   \   00000084   0x.... 0x....      BL       __aeabi_fsub
   \   00000088   0x9006             STR      R0,[SP, #+24]
  14853                          center_P = current_position[p_axis] - r_P,
  14854                          center_Q = current_position[q_axis] - r_Q,
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable179
   \   0000008E   0x68C0             LDR      R0,[R0, #+12]
   \   00000090   0x4631             MOV      R1,R6
   \   00000092   0x.... 0x....      BL       __aeabi_fsub
   \   00000096   0x9005             STR      R0,[SP, #+20]
  14855                          rt_X = cart[p_axis] - center_P,
   \   00000098   0x980D             LDR      R0,[SP, #+52]
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x9906             LDR      R1,[SP, #+24]
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4681             MOV      R9,R0
  14856                          rt_Y = cart[q_axis] - center_Q,
   \   000000A4   0x980D             LDR      R0,[SP, #+52]
   \   000000A6   0x6840             LDR      R0,[R0, #+4]
   \   000000A8   0x9905             LDR      R1,[SP, #+20]
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x4682             MOV      R10,R0
  14857                          linear_travel = cart[l_axis] - current_position[l_axis],
   \   000000B0   0x980D             LDR      R0,[SP, #+52]
   \   000000B2   0x6880             LDR      R0,[R0, #+8]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable179
   \   000000B8   0x6909             LDR      R1,[R1, #+16]
   \   000000BA   0x.... 0x....      BL       __aeabi_fsub
   \   000000BE   0x9000             STR      R0,[SP, #+0]
  14858                          extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
   \   000000C0   0x980D             LDR      R0,[SP, #+52]
   \   000000C2   0x68C0             LDR      R0,[R0, #+12]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable179
   \   000000C8   0x6949             LDR      R1,[R1, #+20]
   \   000000CA   0x.... 0x....      BL       __aeabi_fsub
   \   000000CE   0x9001             STR      R0,[SP, #+4]
  14859          
  14860              // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
  14861              float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0x4649             MOV      R1,R9
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x4683             MOV      R11,R0
   \   000000DA   0x4630             MOV      R0,R6
   \   000000DC   0x4651             MOV      R1,R10
   \   000000DE   0x.... 0x....      BL       __aeabi_fmul
   \   000000E2   0x4659             MOV      R1,R11
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x4601             MOV      R1,R0
   \   000000EA   0x468B             MOV      R11,R1
   \   000000EC   0x4628             MOV      R0,R5
   \   000000EE   0x4651             MOV      R1,R10
   \   000000F0   0x.... 0x....      BL       __aeabi_fmul
   \   000000F4   0x4682             MOV      R10,R0
   \   000000F6   0x4630             MOV      R0,R6
   \   000000F8   0x4649             MOV      R1,R9
   \   000000FA   0x.... 0x....      BL       __aeabi_fmul
   \   000000FE   0x4601             MOV      R1,R0
   \   00000100   0x4650             MOV      R0,R10
   \   00000102   0x.... 0x....      BL       __aeabi_fsub
   \   00000106   0x4659             MOV      R1,R11
   \   00000108   0x.... 0x....      BL       atan2f
   \   0000010C   0x4681             MOV      R9,R0
  14862              if (angular_travel < 0) angular_travel += RADIANS(360);
   \   0000010E   0x2100             MOVS     R1,#+0
   \   00000110   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000114   0xD20A             BCS.N    ??plan_arc_6
   \   00000116   0x.... 0x....      BL       __aeabi_f2d
   \   0000011A   0x.... 0x....      LDR.W    R2,??DataTable188_1  ;; 0x54442d18
   \   0000011E   0x.... 0x....      LDR.W    R3,??DataTable188_2  ;; 0x401921fb
   \   00000122   0x.... 0x....      BL       __aeabi_dadd
   \   00000126   0x.... 0x....      BL       __aeabi_d2f
   \   0000012A   0x4681             MOV      R9,R0
  14863              if (clockwise) angular_travel -= RADIANS(360);
   \                     ??plan_arc_6: (+1)
   \   0000012C   0x2C00             CMP      R4,#+0
   \   0000012E   0xD00B             BEQ.N    ??plan_arc_7
   \   00000130   0x4648             MOV      R0,R9
   \   00000132   0x.... 0x....      BL       __aeabi_f2d
   \   00000136   0x.... 0x....      LDR.W    R2,??DataTable188_1  ;; 0x54442d18
   \   0000013A   0x.... 0x....      LDR.W    R3,??DataTable188_3  ;; 0xc01921fb
   \   0000013E   0x.... 0x....      BL       __aeabi_dadd
   \   00000142   0x.... 0x....      BL       __aeabi_d2f
   \   00000146   0x4681             MOV      R9,R0
  14864          
  14865              // Make a circle if the angular rotation is 0 and the target is current position
  14866              if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
   \                     ??plan_arc_7: (+1)
   \   00000148   0x4648             MOV      R0,R9
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000150   0xD111             BNE.N    ??plan_arc_8
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable179
   \   00000156   0x6880             LDR      R0,[R0, #+8]
   \   00000158   0x990D             LDR      R1,[SP, #+52]
   \   0000015A   0x6809             LDR      R1,[R1, #+0]
   \   0000015C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000160   0xD109             BNE.N    ??plan_arc_8
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable179
   \   00000166   0x68C0             LDR      R0,[R0, #+12]
   \   00000168   0x990D             LDR      R1,[SP, #+52]
   \   0000016A   0x6849             LDR      R1,[R1, #+4]
   \   0000016C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000170   0xD101             BNE.N    ??plan_arc_8
  14867                angular_travel = RADIANS(360);
   \   00000172   0x.... 0x....      LDR.W    R9,??DataTable188_4  ;; 0x40c90fdb
  14868          
  14869              const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
   \                     ??plan_arc_8: (+1)
   \   00000176   0x4648             MOV      R0,R9
   \   00000178   0x4641             MOV      R1,R8
   \   0000017A   0x.... 0x....      BL       __aeabi_fmul
   \   0000017E   0x4680             MOV      R8,R0
   \   00000180   0xF04F 0x0A02      MOV      R10,#+2
   \   00000184   0x463C             MOV      R4,R7
   \   00000186   0xE004             B.N      ??plan_arc_9
   \                     ??plan_arc_10: (+1)
   \   00000188   0x4640             MOV      R0,R8
   \   0000018A   0x4641             MOV      R1,R8
   \   0000018C   0x.... 0x....      BL       __aeabi_fmul
   \   00000190   0x4680             MOV      R8,R0
   \                     ??plan_arc_9: (+1)
   \   00000192   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000196   0xD504             BPL.N    ??plan_arc_11
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x4641             MOV      R1,R8
   \   0000019C   0x.... 0x....      BL       __aeabi_fmul
   \   000001A0   0x4604             MOV      R4,R0
   \                     ??plan_arc_11: (+1)
   \   000001A2   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000001A6   0xD1EF             BNE.N    ??plan_arc_10
   \   000001A8   0x9800             LDR      R0,[SP, #+0]
   \   000001AA   0xF020 0x4B00      BIC      R11,R0,#0x80000000
   \   000001AE   0xF04F 0x0802      MOV      R8,#+2
   \   000001B2   0x46BA             MOV      R10,R7
   \   000001B4   0xE004             B.N      ??plan_arc_12
   \                     ??plan_arc_13: (+1)
   \   000001B6   0x4658             MOV      R0,R11
   \   000001B8   0x4659             MOV      R1,R11
   \   000001BA   0x.... 0x....      BL       __aeabi_fmul
   \   000001BE   0x4683             MOV      R11,R0
   \                     ??plan_arc_12: (+1)
   \   000001C0   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000001C4   0xD504             BPL.N    ??plan_arc_14
   \   000001C6   0x4650             MOV      R0,R10
   \   000001C8   0x4659             MOV      R1,R11
   \   000001CA   0x.... 0x....      BL       __aeabi_fmul
   \   000001CE   0x4682             MOV      R10,R0
   \                     ??plan_arc_14: (+1)
   \   000001D0   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   000001D4   0xD1EF             BNE.N    ??plan_arc_13
   \   000001D6   0x4620             MOV      R0,R4
   \   000001D8   0x4651             MOV      R1,R10
   \   000001DA   0x.... 0x....      BL       __aeabi_fadd
   \   000001DE   0x.... 0x....      BL       sqrtf
  14870              if (mm_of_travel < 0.001) return;
   \   000001E2   0x.... 0x....      LDR.W    R1,??DataTable189  ;; 0x3a83126f
   \   000001E6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001EA   0xF0C0 0x80FE      BCC.W    ??plan_arc_15
  14871          
  14872              uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000001EE   0x.... 0x....      BL       floorf
   \   000001F2   0x.... 0x....      BL       __aeabi_f2iz
   \   000001F6   0xB280             UXTH     R0,R0
   \   000001F8   0x9003             STR      R0,[SP, #+12]
  14873              NOLESS(segments, 1);
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD101             BNE.N    ??plan_arc_16
   \   000001FE   0x2001             MOVS     R0,#+1
   \   00000200   0x9003             STR      R0,[SP, #+12]
  14874          
  14875              /**
  14876               * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
  14877               * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
  14878               *     r_T = [cos(phi) -sin(phi);
  14879               *            sin(phi)  cos(phi)] * r ;
  14880               *
  14881               * For arc generation, the center of the circle is the axis of rotation and the radius vector is
  14882               * defined from the circle center to the initial position. Each line segment is formed by successive
  14883               * vector rotations. This requires only two cos() and sin() computations to form the rotation
  14884               * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
  14885               * all double numbers are single precision on the Arduino. (True double precision will not have
  14886               * round off issues for CNC applications.) Single precision error can accumulate to be greater than
  14887               * tool precision in some cases. Therefore, arc path correction is implemented.
  14888               *
  14889               * Small angle approximation may be used to reduce computation overhead further. This approximation
  14890               * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
  14891               * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
  14892               * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
  14893               * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
  14894               * issue for CNC machines with the single precision Arduino calculations.
  14895               *
  14896               * This approximation also allows plan_arc to immediately insert a line segment into the planner
  14897               * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
  14898               * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
  14899               * This is important when there are successive arc motions.
  14900               */
  14901              // Vector rotation matrix values
  14902              float raw[XYZE];
  14903              const float theta_per_segment = angular_travel / segments,
   \                     ??plan_arc_16: (+1)
   \   00000202   0xA803             ADD      R0,SP,#+12
   \   00000204   0x8800             LDRH     R0,[R0, #+0]
   \   00000206   0x.... 0x....      BL       __aeabi_ui2f
   \   0000020A   0x4604             MOV      R4,R0
   \   0000020C   0x4648             MOV      R0,R9
   \   0000020E   0x4621             MOV      R1,R4
   \   00000210   0x.... 0x....      BL       __aeabi_fdiv
   \   00000214   0x9002             STR      R0,[SP, #+8]
  14904                          linear_per_segment = linear_travel / segments,
   \   00000216   0x9800             LDR      R0,[SP, #+0]
   \   00000218   0x4621             MOV      R1,R4
   \   0000021A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000021E   0x9008             STR      R0,[SP, #+32]
  14905                          extruder_per_segment = extruder_travel / segments,
   \   00000220   0x9801             LDR      R0,[SP, #+4]
   \   00000222   0x4621             MOV      R1,R4
   \   00000224   0x.... 0x....      BL       __aeabi_fdiv
   \   00000228   0x9007             STR      R0,[SP, #+28]
  14906                          sin_T = theta_per_segment,
  14907                          cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
   \   0000022A   0x9C02             LDR      R4,[SP, #+8]
   \   0000022C   0xF04F 0x0802      MOV      R8,#+2
   \   00000230   0xE004             B.N      ??plan_arc_17
   \                     ??plan_arc_18: (+1)
   \   00000232   0x4620             MOV      R0,R4
   \   00000234   0x4621             MOV      R1,R4
   \   00000236   0x.... 0x....      BL       __aeabi_fmul
   \   0000023A   0x4604             MOV      R4,R0
   \                     ??plan_arc_17: (+1)
   \   0000023C   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000240   0xD504             BPL.N    ??plan_arc_19
   \   00000242   0x4638             MOV      R0,R7
   \   00000244   0x4621             MOV      R1,R4
   \   00000246   0x.... 0x....      BL       __aeabi_fmul
   \   0000024A   0x4607             MOV      R7,R0
   \                     ??plan_arc_19: (+1)
   \   0000024C   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000250   0xD1EF             BNE.N    ??plan_arc_18
   \   00000252   0x4638             MOV      R0,R7
   \   00000254   0x.... 0x....      BL       __aeabi_f2d
   \   00000258   0x2200             MOVS     R2,#+0
   \   0000025A   0x.... 0x....      LDR.W    R3,??DataTable190  ;; 0x3fe00000
   \   0000025E   0x.... 0x....      BL       __aeabi_dmul
   \   00000262   0x4602             MOV      R2,R0
   \   00000264   0x460B             MOV      R3,R1
   \   00000266   0x2000             MOVS     R0,#+0
   \   00000268   0x.... 0x....      LDR.W    R1,??DataTable190_1  ;; 0x3ff00000
   \   0000026C   0x.... 0x....      BL       __aeabi_dsub
   \   00000270   0x.... 0x....      BL       __aeabi_d2f
   \   00000274   0x9001             STR      R0,[SP, #+4]
  14908          
  14909              // Initialize the linear axis
  14910              raw[l_axis] = current_position[l_axis];
   \   00000276   0xAC09             ADD      R4,SP,#+36
   \   00000278   0x.... 0x....      LDR.W    R0,??DataTable179
   \   0000027C   0x6900             LDR      R0,[R0, #+16]
   \   0000027E   0x60A0             STR      R0,[R4, #+8]
  14911          
  14912              // Initialize the extruder axis
  14913              raw[E_AXIS] = current_position[E_AXIS];
   \   00000280   0x.... 0x....      LDR.W    R0,??DataTable179
   \   00000284   0x6940             LDR      R0,[R0, #+20]
   \   00000286   0x60E0             STR      R0,[R4, #+12]
  14914          
  14915              const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable179
   \   0000028C   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \   00000290   0x.... 0x....      BL       __aeabi_i2f
   \   00000294   0x.... 0x....      LDR.W    R1,??DataTable179
   \   00000298   0x6DC9             LDR      R1,[R1, #+92]
   \   0000029A   0x.... 0x....      BL       __aeabi_fmul
   \   0000029E   0x.... 0x....      BL       __aeabi_f2d
   \   000002A2   0x.... 0x....      LDR.W    R2,??DataTable187_3  ;; 0x47ae147b
   \   000002A6   0x.... 0x....      LDR.W    R3,??DataTable188  ;; 0x3f847ae1
   \   000002AA   0x.... 0x....      BL       __aeabi_dmul
   \   000002AE   0x.... 0x....      BL       __aeabi_d2f
   \   000002B2   0x9004             STR      R0,[SP, #+16]
  14916          
  14917              millis_t next_idle_ms = millis() + 200UL;
   \   000002B4   0x.... 0x....      BL       HAL_GetTick
   \   000002B8   0xF100 0x07C8      ADD      R7,R0,#+200
  14918          
  14919              #if N_ARC_CORRECTION > 1
  14920                int8_t arc_recalc_count = N_ARC_CORRECTION;
   \   000002BC   0xF04F 0x0919      MOV      R9,#+25
  14921              #endif
  14922          
  14923              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14924                // SCARA needs to scale the feed rate from mm/s to degrees/s
  14925                const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
  14926                            inverse_secs = inv_segment_length * fr_mm_s;
  14927                float oldA = stepper.get_axis_position_degrees(A_AXIS),
  14928                      oldB = stepper.get_axis_position_degrees(B_AXIS);
  14929              #endif
  14930          
  14931              for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
   \   000002C0   0xF04F 0x0801      MOV      R8,#+1
   \   000002C4   0xE055             B.N      ??plan_arc_20
  14932          
  14933                thermalManager.manage_heater();
  14934                if (ELAPSED(millis(), next_idle_ms)) {
  14935                  next_idle_ms = millis() + 200UL;
  14936                  idle();
  14937                }
  14938          
  14939                #if N_ARC_CORRECTION > 1
  14940                  if (--arc_recalc_count) {
  14941                    // Apply vector rotation matrix to previous r_P / 1
  14942                    const float r_new_Y = r_P * sin_T + r_Q * cos_T;
  14943                    r_P = r_P * cos_T - r_Q * sin_T;
  14944                    r_Q = r_new_Y;
  14945                  }
  14946                  else
  14947                #endif
  14948                {
  14949                  #if N_ARC_CORRECTION > 1
  14950                    arc_recalc_count = N_ARC_CORRECTION;
   \                     ??plan_arc_21: (+1)
   \   000002C6   0xF04F 0x0919      MOV      R9,#+25
  14951                  #endif
  14952          
  14953                  // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
  14954                  // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
  14955                  // To reduce stuttering, the sin and cos could be computed at different times.
  14956                  // For now, compute both at the same time.
  14957                  const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
   \   000002CA   0x4640             MOV      R0,R8
   \   000002CC   0x.... 0x....      BL       __aeabi_ui2f
   \   000002D0   0x9902             LDR      R1,[SP, #+8]
   \   000002D2   0x.... 0x....      BL       __aeabi_fmul
   \   000002D6   0x4605             MOV      R5,R0
   \   000002D8   0x.... 0x....      BL       cosf
   \   000002DC   0x4606             MOV      R6,R0
   \   000002DE   0x4628             MOV      R0,R5
   \   000002E0   0x.... 0x....      BL       sinf
   \   000002E4   0x4682             MOV      R10,R0
  14958                  r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
   \   000002E6   0x980E             LDR      R0,[SP, #+56]
   \   000002E8   0x6840             LDR      R0,[R0, #+4]
   \   000002EA   0x9000             STR      R0,[SP, #+0]
   \   000002EC   0x980E             LDR      R0,[SP, #+56]
   \   000002EE   0xF8D0 0xB000      LDR      R11,[R0, #+0]
   \   000002F2   0x9800             LDR      R0,[SP, #+0]
   \   000002F4   0x4651             MOV      R1,R10
   \   000002F6   0x.... 0x....      BL       __aeabi_fmul
   \   000002FA   0x4605             MOV      R5,R0
   \   000002FC   0x4658             MOV      R0,R11
   \   000002FE   0x4631             MOV      R1,R6
   \   00000300   0x.... 0x....      BL       __aeabi_fmul
   \   00000304   0x4601             MOV      R1,R0
   \   00000306   0x4628             MOV      R0,R5
   \   00000308   0x.... 0x....      BL       __aeabi_fsub
   \   0000030C   0x4605             MOV      R5,R0
  14959                  r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
   \   0000030E   0x4658             MOV      R0,R11
   \   00000310   0x4651             MOV      R1,R10
   \   00000312   0x.... 0x....      BL       __aeabi_fmul
   \   00000316   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \   0000031A   0x4682             MOV      R10,R0
   \   0000031C   0x9800             LDR      R0,[SP, #+0]
   \   0000031E   0x4631             MOV      R1,R6
   \   00000320   0x.... 0x....      BL       __aeabi_fmul
   \   00000324   0x4601             MOV      R1,R0
   \   00000326   0x4650             MOV      R0,R10
   \   00000328   0x.... 0x....      BL       __aeabi_fsub
   \   0000032C   0x4606             MOV      R6,R0
  14960                }
  14961          
  14962                // Update raw location
  14963                raw[p_axis] = center_P + r_P;
   \                     ??plan_arc_22: (+1)
   \   0000032E   0x9806             LDR      R0,[SP, #+24]
   \   00000330   0x4629             MOV      R1,R5
   \   00000332   0x.... 0x....      BL       __aeabi_fadd
   \   00000336   0x9009             STR      R0,[SP, #+36]
  14964                raw[q_axis] = center_Q + r_Q;
   \   00000338   0x9805             LDR      R0,[SP, #+20]
   \   0000033A   0x4631             MOV      R1,R6
   \   0000033C   0x.... 0x....      BL       __aeabi_fadd
   \   00000340   0x6060             STR      R0,[R4, #+4]
  14965                raw[l_axis] += linear_per_segment;
   \   00000342   0x68A0             LDR      R0,[R4, #+8]
   \   00000344   0x9908             LDR      R1,[SP, #+32]
   \   00000346   0x.... 0x....      BL       __aeabi_fadd
   \   0000034A   0x60A0             STR      R0,[R4, #+8]
  14966                raw[E_AXIS] += extruder_per_segment;
   \   0000034C   0x68E0             LDR      R0,[R4, #+12]
   \   0000034E   0x9907             LDR      R1,[SP, #+28]
   \   00000350   0x.... 0x....      BL       __aeabi_fadd
   \   00000354   0x60E0             STR      R0,[R4, #+12]
  14967          
  14968                clamp_to_software_endstops(raw);
   \   00000356   0xA809             ADD      R0,SP,#+36
   \   00000358   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  14969          
  14970                #if ENABLED(SCARA_FEEDRATE_SCALING)
  14971                  // For SCARA scale the feed rate from mm/s to degrees/s
  14972                  // i.e., Complete the angular vector in the given time.
  14973                  inverse_kinematics(raw);
  14974                  ADJUST_DELTA(raw);
  14975                  planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14976                  oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
  14977                #else
  14978                  planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
   \   0000035C   0x.... 0x....      LDR.W    R0,??DataTable179
   \   00000360   0x78C2             LDRB     R2,[R0, #+3]
   \   00000362   0xA904             ADD      R1,SP,#+16
   \   00000364   0xA809             ADD      R0,SP,#+36
   \   00000366   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
   \   0000036A   0xF108 0x0801      ADD      R8,R8,#+1
   \   0000036E   0xFA1F 0xF888      UXTH     R8,R8
   \                     ??plan_arc_20: (+1)
   \   00000372   0x9803             LDR      R0,[SP, #+12]
   \   00000374   0x4580             CMP      R8,R0
   \   00000376   0xDA2F             BGE.N    ??plan_arc_23
   \   00000378   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   \   0000037C   0x.... 0x....      BL       HAL_GetTick
   \   00000380   0x1BC0             SUBS     R0,R0,R7
   \   00000382   0xD405             BMI.N    ??plan_arc_24
   \   00000384   0x.... 0x....      BL       HAL_GetTick
   \   00000388   0xF100 0x07C8      ADD      R7,R0,#+200
   \   0000038C   0x.... 0x....      BL       _Z4idlev
   \                     ??plan_arc_24: (+1)
   \   00000390   0xF1A9 0x0901      SUB      R9,R9,#+1
   \   00000394   0xFA4F 0xF989      SXTB     R9,R9
   \   00000398   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000039C   0xD093             BEQ.N    ??plan_arc_21
   \   0000039E   0x9802             LDR      R0,[SP, #+8]
   \   000003A0   0x4629             MOV      R1,R5
   \   000003A2   0x.... 0x....      BL       __aeabi_fmul
   \   000003A6   0x4682             MOV      R10,R0
   \   000003A8   0x9801             LDR      R0,[SP, #+4]
   \   000003AA   0x4631             MOV      R1,R6
   \   000003AC   0x.... 0x....      BL       __aeabi_fmul
   \   000003B0   0x4651             MOV      R1,R10
   \   000003B2   0x.... 0x....      BL       __aeabi_fadd
   \   000003B6   0x4682             MOV      R10,R0
   \   000003B8   0x9801             LDR      R0,[SP, #+4]
   \   000003BA   0x4629             MOV      R1,R5
   \   000003BC   0x.... 0x....      BL       __aeabi_fmul
   \   000003C0   0x4605             MOV      R5,R0
   \   000003C2   0x9802             LDR      R0,[SP, #+8]
   \   000003C4   0x4631             MOV      R1,R6
   \   000003C6   0x.... 0x....      BL       __aeabi_fmul
   \   000003CA   0x4601             MOV      R1,R0
   \   000003CC   0x4628             MOV      R0,R5
   \   000003CE   0x.... 0x....      BL       __aeabi_fsub
   \   000003D2   0x4605             MOV      R5,R0
   \   000003D4   0x4656             MOV      R6,R10
   \   000003D6   0xE7AA             B.N      ??plan_arc_22
  14979                #endif
  14980              }
  14981          
  14982              // Ensure last segment arrives at target location.
  14983              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14984                inverse_kinematics(cart);
  14985                ADJUST_DELTA(cart);
  14986                planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14987              #else
  14988                planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   \                     ??plan_arc_23: (+1)
   \   000003D8   0x.... 0x....      LDR.W    R0,??DataTable179
   \   000003DC   0x78C2             LDRB     R2,[R0, #+3]
   \   000003DE   0xA904             ADD      R1,SP,#+16
   \   000003E0   0x980D             LDR      R0,[SP, #+52]
   \   000003E2   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
  14989              #endif
  14990          
  14991              // As far as the parser is concerned, the position is now == target. In reality the
  14992              // motion control system might still be processing the action and the real tool position
  14993              // in any intermediate location.
  14994              set_current_from_destination();
   \   000003E6   0x.... 0x....      BL       _Z28set_current_from_destinationv
  14995            } // plan_arc
   \                     ??plan_arc_15: (+1)
   \   000003EA   0xB00F             ADD      SP,SP,#+60
   \   000003EC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  14996          
  14997          #endif // ARC_SUPPORT
  14998          
  14999          #if ENABLED(BEZIER_CURVE_SUPPORT)
  15000          
  15001            void plan_cubic_move(const float (&offset)[4]) {
  15002              cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
  15003          
  15004              // As far as the parser is concerned, the position is now == destination. In reality the
  15005              // motion control system might still be processing the action and the real tool position
  15006              // in any intermediate location.
  15007              set_current_from_destination();
  15008            }
  15009          
  15010          #endif // BEZIER_CURVE_SUPPORT
  15011          
  15012          #if ENABLED(USE_CONTROLLER_FAN)
  15013          
  15014            void controllerFan() {
  15015              static millis_t lastMotorOn = 0, // Last time a motor was turned on
  15016                              nextMotorCheck = 0; // Last time the state was checked
  15017              const millis_t ms = millis();
  15018              if (ELAPSED(ms, nextMotorCheck)) {
  15019                nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
  15020                if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
  15021                    || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
  15022                    #if E_STEPPERS > 1
  15023                      || E1_ENABLE_READ == E_ENABLE_ON
  15024                      #if HAS_X2_ENABLE
  15025                        || X2_ENABLE_READ == X_ENABLE_ON
  15026                      #endif
  15027                      #if E_STEPPERS > 2
  15028                        || E2_ENABLE_READ == E_ENABLE_ON
  15029                        #if E_STEPPERS > 3
  15030                          || E3_ENABLE_READ == E_ENABLE_ON
  15031                          #if E_STEPPERS > 4
  15032                            || E4_ENABLE_READ == E_ENABLE_ON
  15033                          #endif // E_STEPPERS > 4
  15034                        #endif // E_STEPPERS > 3
  15035                      #endif // E_STEPPERS > 2
  15036                    #endif // E_STEPPERS > 1
  15037                ) {
  15038                  lastMotorOn = ms; //... set time to NOW so the fan will turn on
  15039                }
  15040          
  15041                // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
  15042                uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
  15043          
  15044                // allows digital or PWM fan output to be used (see M42 handling)
  15045                WRITE(CONTROLLER_FAN_PIN, speed);
  15046                analogWrite(CONTROLLER_FAN_PIN, speed);
  15047              }
  15048            }
  15049          
  15050          #endif // USE_CONTROLLER_FAN
  15051          
  15052          #if 1//ENABLED(MORGAN_SCARA)
  15053          
  15054            /**
  15055             * Morgan SCARA Forward Kinematics. Results in cartes[].
  15056             * Maths and first version by QHARLEY.
  15057             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  15058             */

   \                                 In section .text, align 2, keep-with-next
  15059            void forward_kinematics_SCARA(const float &a, const float &b) {
   \                     _Z24forward_kinematics_SCARARKfS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x468A             MOV      R10,R1
  15060          
  15061              float a_sin = sin(RADIANS(a)) * L1,
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable190_3  ;; 0x4062c000
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable188_1  ;; 0x54442d18
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable190_4  ;; 0x400921fb
   \   00000016   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_f2d
   \   0000001E   0x4622             MOV      R2,R4
   \   00000020   0x462B             MOV      R3,R5
   \   00000022   0x.... 0x....      BL       __aeabi_dmul
   \   00000026   0x4632             MOV      R2,R6
   \   00000028   0x.... 0x....      LDR.W    R3,??DataTable190_5  ;; 0x40668000
   \   0000002C   0x.... 0x....      BL       __aeabi_ddiv
   \   00000030   0x.... 0x....      BL       sin
   \   00000034   0x4632             MOV      R2,R6
   \   00000036   0x463B             MOV      R3,R7
   \   00000038   0x.... 0x....      BL       __aeabi_dmul
   \   0000003C   0x.... 0x....      BL       __aeabi_d2f
   \   00000040   0x4681             MOV      R9,R0
  15062                    a_cos = cos(RADIANS(a)) * L1,
   \   00000042   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0x4622             MOV      R2,R4
   \   0000004C   0x462B             MOV      R3,R5
   \   0000004E   0x.... 0x....      BL       __aeabi_dmul
   \   00000052   0x4632             MOV      R2,R6
   \   00000054   0x.... 0x....      LDR.W    R3,??DataTable190_5  ;; 0x40668000
   \   00000058   0x.... 0x....      BL       __aeabi_ddiv
   \   0000005C   0x.... 0x....      BL       cos
   \   00000060   0x4632             MOV      R2,R6
   \   00000062   0x463B             MOV      R3,R7
   \   00000064   0x.... 0x....      BL       __aeabi_dmul
   \   00000068   0x.... 0x....      BL       __aeabi_d2f
   \   0000006C   0x4680             MOV      R8,R0
  15063                    b_sin = sin(RADIANS(b)) * L2,
   \   0000006E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000072   0x.... 0x....      BL       __aeabi_f2d
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x4632             MOV      R2,R6
   \   00000080   0x.... 0x....      LDR.W    R3,??DataTable190_5  ;; 0x40668000
   \   00000084   0x.... 0x....      BL       __aeabi_ddiv
   \   00000088   0x.... 0x....      BL       sin
   \   0000008C   0x4632             MOV      R2,R6
   \   0000008E   0x463B             MOV      R3,R7
   \   00000090   0x.... 0x....      BL       __aeabi_dmul
   \   00000094   0x.... 0x....      BL       __aeabi_d2f
   \   00000098   0x4683             MOV      R11,R0
  15064                    b_cos = cos(RADIANS(b)) * L2;
   \   0000009A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000009E   0x.... 0x....      BL       __aeabi_f2d
   \   000000A2   0x4622             MOV      R2,R4
   \   000000A4   0x462B             MOV      R3,R5
   \   000000A6   0x.... 0x....      BL       __aeabi_dmul
   \   000000AA   0x4632             MOV      R2,R6
   \   000000AC   0x.... 0x....      LDR.W    R3,??DataTable190_5  ;; 0x40668000
   \   000000B0   0x.... 0x....      BL       __aeabi_ddiv
   \   000000B4   0x.... 0x....      BL       cos
   \   000000B8   0x4632             MOV      R2,R6
   \   000000BA   0x463B             MOV      R3,R7
   \   000000BC   0x.... 0x....      BL       __aeabi_dmul
   \   000000C0   0x.... 0x....      BL       __aeabi_d2f
  15065          
  15066              cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
   \   000000C4   0x.... 0x....      LDR.W    R4,??DataTable190_6
   \   000000C8   0x4641             MOV      R1,R8
   \   000000CA   0x.... 0x....      BL       __aeabi_fadd
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable190_7  ;; 0x42c80000
   \   000000D2   0x.... 0x....      BL       __aeabi_fadd
   \   000000D6   0x64A0             STR      R0,[R4, #+72]
  15067              cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
   \   000000D8   0x4648             MOV      R0,R9
   \   000000DA   0x4659             MOV      R1,R11
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable191  ;; 0xc2600000
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x64E0             STR      R0,[R4, #+76]
  15068          
  15069              /*
  15070                SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
  15071                SERIAL_ECHOPAIR(" b=", b);
  15072                SERIAL_ECHOPAIR(" a_sin=", a_sin);
  15073                SERIAL_ECHOPAIR(" a_cos=", a_cos);
  15074                SERIAL_ECHOPAIR(" b_sin=", b_sin);
  15075                SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
  15076                SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
  15077                SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
  15078              //
  15079              */
  15080            }
   \   000000EA   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  15081          
  15082            /**
  15083             * Morgan SCARA Inverse Kinematics. Results in delta[].
  15084             *
  15085             * See http://forums.reprap.org/read.php?185,283327
  15086             *
  15087             * Maths and first version by QHARLEY.
  15088             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  15089             */

   \                                 In section .text, align 2, keep-with-next
  15090            void inverse_kinematics_MORGAN_SCARA(const float raw[XYZ]) {
   \                     _Z31inverse_kinematics_MORGAN_SCARAPKf: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
  15091          
  15092              static float C2, S2, SK1, SK2, THETA, PSI;
  15093          
  15094              float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable190_8  ;; 0xc2c80000
   \   0000000A   0x.... 0x....      BL       __aeabi_fadd
   \   0000000E   0x4605             MOV      R5,R0
  15095                    sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable190_9  ;; 0x42600000
   \   00000018   0x.... 0x....      BL       __aeabi_fadd
   \   0000001C   0x4606             MOV      R6,R0
  15096          
  15097              if (L1 == L2)
  15098                C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
   \   0000001E   0x462F             MOV      R7,R5
   \   00000020   0xF04F 0x0802      MOV      R8,#+2
   \   00000024   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \   00000028   0x465C             MOV      R4,R11
   \   0000002A   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_0
   \                     ??inverse_kinematics_MORGAN_SCARA_1: (+1)
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0x4639             MOV      R1,R7
   \   00000030   0x.... 0x....      BL       __aeabi_fmul
   \   00000034   0x4607             MOV      R7,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_0: (+1)
   \   00000036   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   0000003A   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_2
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x4639             MOV      R1,R7
   \   00000040   0x.... 0x....      BL       __aeabi_fmul
   \   00000044   0x4604             MOV      R4,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_2: (+1)
   \   00000046   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   0000004A   0xD1EF             BNE.N    ??inverse_kinematics_MORGAN_SCARA_1
   \   0000004C   0x4637             MOV      R7,R6
   \   0000004E   0xF04F 0x0902      MOV      R9,#+2
   \   00000052   0x46D8             MOV      R8,R11
   \   00000054   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_3
   \                     ??inverse_kinematics_MORGAN_SCARA_4: (+1)
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0x4639             MOV      R1,R7
   \   0000005A   0x.... 0x....      BL       __aeabi_fmul
   \   0000005E   0x4607             MOV      R7,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_3: (+1)
   \   00000060   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000064   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_5
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x4639             MOV      R1,R7
   \   0000006A   0x.... 0x....      BL       __aeabi_fmul
   \   0000006E   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_5: (+1)
   \   00000070   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000074   0xD1EF             BNE.N    ??inverse_kinematics_MORGAN_SCARA_4
   \   00000076   0x....             LDR.N    R7,??DataTable179
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x.... 0x....      BL       __aeabi_fadd
   \   00000080   0xF8D7 0x1080      LDR      R1,[R7, #+128]
   \   00000084   0x.... 0x....      BL       __aeabi_fdiv
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable190_10  ;; 0xbf800000
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
   \   00000090   0x4680             MOV      R8,R0
   \   00000092   0x.... 0x....      LDR.W    R4,??DataTable190_11
   \   00000096   0xF8C4 0x8000      STR      R8,[R4, #+0]
  15099              else
  15100                C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
  15101          
  15102              S2 = SQRT(1 - sq(C2));
   \   0000009A   0x46C1             MOV      R9,R8
   \   0000009C   0xF04F 0x0A02      MOV      R10,#+2
   \   000000A0   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_6
   \                     ??inverse_kinematics_MORGAN_SCARA_7: (+1)
   \   000000A2   0x4648             MOV      R0,R9
   \   000000A4   0x4649             MOV      R1,R9
   \   000000A6   0x.... 0x....      BL       __aeabi_fmul
   \   000000AA   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_6: (+1)
   \   000000AC   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000000B0   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_8
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0x4649             MOV      R1,R9
   \   000000B6   0x.... 0x....      BL       __aeabi_fmul
   \   000000BA   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_8: (+1)
   \   000000BC   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000000C0   0xD1EF             BNE.N    ??inverse_kinematics_MORGAN_SCARA_7
   \   000000C2   0xF04F 0x507E      MOV      R0,#+1065353216
   \   000000C6   0x4659             MOV      R1,R11
   \   000000C8   0x.... 0x....      BL       __aeabi_fsub
   \   000000CC   0x.... 0x....      BL       sqrtf
   \   000000D0   0x4681             MOV      R9,R0
   \   000000D2   0xF8C4 0x9004      STR      R9,[R4, #+4]
  15103          
  15104              // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
  15105              SK1 = L1 + L2 * C2;
   \   000000D6   0x.... 0x....      LDR.W    R10,??DataTable191_1  ;; 0x43160000
   \   000000DA   0x4640             MOV      R0,R8
   \   000000DC   0x4651             MOV      R1,R10
   \   000000DE   0x.... 0x....      BL       __aeabi_fmul
   \   000000E2   0x4651             MOV      R1,R10
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x4683             MOV      R11,R0
   \   000000EA   0xF8C4 0xB008      STR      R11,[R4, #+8]
  15106          
  15107              // Rotated Arm2 gives the distance from Arm1 to Arm2
  15108              SK2 = L2 * S2;
   \   000000EE   0x4648             MOV      R0,R9
   \   000000F0   0x4651             MOV      R1,R10
   \   000000F2   0x.... 0x....      BL       __aeabi_fmul
   \   000000F6   0x60E0             STR      R0,[R4, #+12]
  15109          
  15110              // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
  15111              THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
   \   000000F8   0x4601             MOV      R1,R0
   \   000000FA   0x4658             MOV      R0,R11
   \   000000FC   0x.... 0x....      BL       atan2f
   \   00000100   0x4682             MOV      R10,R0
   \   00000102   0x4631             MOV      R1,R6
   \   00000104   0x4628             MOV      R0,R5
   \   00000106   0x.... 0x....      BL       atan2f
   \   0000010A   0x4601             MOV      R1,R0
   \   0000010C   0x4650             MOV      R0,R10
   \   0000010E   0x.... 0x....      BL       __aeabi_fsub
   \   00000112   0x6120             STR      R0,[R4, #+16]
  15112          
  15113              // Angle of Arm2
  15114              PSI = ATAN2(S2, C2);
   \   00000114   0x4641             MOV      R1,R8
   \   00000116   0x4648             MOV      R0,R9
   \   00000118   0x.... 0x....      BL       atan2f
   \   0000011C   0x4606             MOV      R6,R0
   \   0000011E   0x6166             STR      R6,[R4, #+20]
  15115          
  15116              delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
   \   00000120   0xF8D4 0x8010      LDR      R8,[R4, #+16]
   \   00000124   0x2400             MOVS     R4,#+0
   \   00000126   0x.... 0x....      LDR.W    R5,??DataTable190_5  ;; 0x40668000
   \   0000012A   0x4640             MOV      R0,R8
   \   0000012C   0x.... 0x....      BL       __aeabi_f2d
   \   00000130   0x4622             MOV      R2,R4
   \   00000132   0x462B             MOV      R3,R5
   \   00000134   0x.... 0x....      BL       __aeabi_dmul
   \   00000138   0x.... 0x....      LDR.W    R2,??DataTable188_1  ;; 0x54442d18
   \   0000013C   0x.... 0x....      LDR.W    R3,??DataTable190_4  ;; 0x400921fb
   \   00000140   0x.... 0x....      BL       __aeabi_ddiv
   \   00000144   0x.... 0x....      BL       __aeabi_d2f
   \   00000148   0x6538             STR      R0,[R7, #+80]
  15117              delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
   \   0000014A   0x4640             MOV      R0,R8
   \   0000014C   0x4631             MOV      R1,R6
   \   0000014E   0x.... 0x....      BL       __aeabi_fadd
   \   00000152   0x.... 0x....      BL       __aeabi_f2d
   \   00000156   0x4622             MOV      R2,R4
   \   00000158   0x462B             MOV      R3,R5
   \   0000015A   0x.... 0x....      BL       __aeabi_dmul
   \   0000015E   0x.... 0x....      LDR.W    R2,??DataTable188_1  ;; 0x54442d18
   \   00000162   0x.... 0x....      LDR.W    R3,??DataTable190_4  ;; 0x400921fb
   \   00000166   0x.... 0x....      BL       __aeabi_ddiv
   \   0000016A   0x.... 0x....      BL       __aeabi_d2f
   \   0000016E   0x6578             STR      R0,[R7, #+84]
  15118              delta[C_AXIS] = raw[Z_AXIS];
   \   00000170   0x9800             LDR      R0,[SP, #+0]
   \   00000172   0x6880             LDR      R0,[R0, #+8]
   \   00000174   0x65B8             STR      R0,[R7, #+88]
  15119          
  15120              /*
  15121                DEBUG_POS("SCARA IK", raw);
  15122                DEBUG_POS("SCARA IK", delta);
  15123                SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
  15124                SERIAL_ECHOPAIR(",", sy);
  15125                SERIAL_ECHOPAIR(" C2=", C2);
  15126                SERIAL_ECHOPAIR(" S2=", S2);
  15127                SERIAL_ECHOPAIR(" Theta=", THETA);
  15128                SERIAL_ECHOLNPAIR(" Phi=", PHI);
  15129              //
  15130              */
  15131            }
   \   00000176   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  15132          
  15133          #endif // MORGAN_SCARA
  15134          
  15135          #if ENABLED(TEMP_STAT_LEDS)
  15136          
  15137            static bool red_led = false;
  15138            static millis_t next_status_led_update_ms = 0;
  15139          
  15140            void handle_status_leds(void) {
  15141              if (ELAPSED(millis(), next_status_led_update_ms)) {
  15142                next_status_led_update_ms += 500; // Update every 0.5s
  15143                float max_temp = 0.0;
  15144                //#if HAS_TEMP_BED
  15145                if(HAS_TEMP_BED)
  15146                  max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
  15147                //#endif
  15148                HOTEND_LOOP()
  15149                  max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
  15150                const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
  15151                if (new_led != red_led) {
  15152                  red_led = new_led;
  15153                  #if PIN_EXISTS(STAT_LED_RED)
  15154                    WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
  15155                    #if PIN_EXISTS(STAT_LED_BLUE)
  15156                      WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
  15157                    #endif
  15158                  #else
  15159                    WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
  15160                  #endif
  15161                }
  15162              }
  15163            }
  15164          
  15165          #endif
  15166          
  15167          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  15168          

   \                                 In section .text, align 2, keep-with-next
  15169            void handle_filament_runout() {
   \                     _Z22handle_filament_runoutv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15170              if (!filament_ran_out) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable192
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD109             BNE.N    ??handle_filament_runout_0
  15171                filament_ran_out = true;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
  15172                enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   \   00000010   0x.... 0x....      ADR.W    R0,`?<Constant "M600">`
   \   00000014   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
  15173                stepper.synchronize();
   \   00000018   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001C   0x.... 0x....      B.W      _ZN7Stepper11synchronizeEv
  15174              }
  15175            }
   \                     ??handle_filament_runout_0: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
  15176          
  15177          #endif // FILAMENT_RUNOUT_SENSOR
  15178          
  15179          #if ENABLED(FAST_PWM_FAN)
  15180          
  15181            void setPwmFrequency(uint8_t pin, int val) {
  15182              val &= 0x07;
  15183              switch (digitalPinToTimer(pin)) {
  15184                #ifdef TCCR0A
  15185                  #if !AVR_AT90USB1286_FAMILY
  15186                    case TIMER0A:
  15187                  #endif
  15188                  case TIMER0B:                           //_SET_CS(0, val);
  15189                                                            break;
  15190                #endif
  15191                #ifdef TCCR1A
  15192                  case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
  15193                                                            break;
  15194                #endif
  15195                #if defined(TCCR2) || defined(TCCR2A)
  15196                  #ifdef TCCR2
  15197                    case TIMER2:
  15198                  #endif
  15199                  #ifdef TCCR2A
  15200                    case TIMER2A: case TIMER2B:
  15201                  #endif
  15202                                                            _SET_CS(2, val); break;
  15203                #endif
  15204                #ifdef TCCR3A
  15205                  case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
  15206                #endif
  15207                #ifdef TCCR4A
  15208                  case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
  15209                #endif
  15210                #ifdef TCCR5A
  15211                  case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
  15212                #endif
  15213              }
  15214            }
  15215          
  15216          #endif // FAST_PWM_FAN
  15217          

   \                                 In section .text, align 2, keep-with-next
  15218          void enable_all_steppers() {
   \                     _Z19enable_all_steppersv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  15219            enable_X();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable191_2
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable191_3
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable192_1
   \   0000000E   0xF996 0x2104      LDRSB    R2,[R6, #+260]
   \   00000012   0x88A9             LDRH     R1,[R5, #+4]
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x.... 0x....      BL       HAL_GPIO_WritePin
  15220            enable_Y();
   \   0000001A   0xF506 0x7682      ADD      R6,R6,#+260
   \   0000001E   0xF996 0x2001      LDRSB    R2,[R6, #+1]
   \   00000022   0x89E9             LDRH     R1,[R5, #+14]
   \   00000024   0x69E0             LDR      R0,[R4, #+28]
   \   00000026   0x.... 0x....      BL       HAL_GPIO_WritePin
  15221            enable_Z();
   \   0000002A   0xF996 0x2002      LDRSB    R2,[R6, #+2]
   \   0000002E   0x8B29             LDRH     R1,[R5, #+24]
   \   00000030   0x6B20             LDR      R0,[R4, #+48]
   \   00000032   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000036   0xF996 0x2002      LDRSB    R2,[R6, #+2]
   \   0000003A   0x8D29             LDRH     R1,[R5, #+40]
   \   0000003C   0x6D20             LDR      R0,[R4, #+80]
   \   0000003E   0x.... 0x....      BL       HAL_GPIO_WritePin
  15222            enable_E0();
   \   00000042   0xF996 0x2003      LDRSB    R2,[R6, #+3]
   \   00000046   0x8C69             LDRH     R1,[R5, #+34]
   \   00000048   0x6C60             LDR      R0,[R4, #+68]
   \   0000004A   0x.... 0x....      BL       HAL_GPIO_WritePin
  15223            enable_E1();
   \   0000004E   0xF996 0x2003      LDRSB    R2,[R6, #+3]
   \   00000052   0x8D29             LDRH     R1,[R5, #+40]
   \   00000054   0x6D20             LDR      R0,[R4, #+80]
   \   00000056   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000005A   0x.... 0x....      B.W      HAL_GPIO_WritePin
  15224            enable_E2();
  15225            enable_E3();
  15226            enable_E4();
  15227          }
  15228          

   \                                 In section .text, align 2, keep-with-next
  15229          void disable_e_steppers() {
   \                     _Z18disable_e_steppersv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  15230            disable_E0();
   \   00000002   0x....             LDR.N    R4,??DataTable179_1
   \   00000004   0xF204 0x1501      ADDW     R5,R4,#+257
   \   00000008   0x79A8             LDRB     R0,[R5, #+6]
   \   0000000A   0x1E42             SUBS     R2,R0,#+1
   \   0000000C   0x4192             SBCS     R2,R2,R2
   \   0000000E   0x0FD2             LSRS     R2,R2,#+31
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable191_2
   \   00000014   0x.... 0x....      LDR.W    R7,??DataTable191_3
   \   00000018   0xB252             SXTB     R2,R2
   \   0000001A   0x8C79             LDRH     R1,[R7, #+34]
   \   0000001C   0x6C70             LDR      R0,[R6, #+68]
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_WritePin
  15231            if(!Z_DUAL_STEPPER_DRIVERS)disable_E1();
   \   00000022   0xF894 0x0101      LDRB     R0,[R4, #+257]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD10A             BNE.N    ??disable_e_steppers_0
   \   0000002A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002C   0x1E42             SUBS     R2,R0,#+1
   \   0000002E   0x4192             SBCS     R2,R2,R2
   \   00000030   0x0FD2             LSRS     R2,R2,#+31
   \   00000032   0xB252             SXTB     R2,R2
   \   00000034   0x8D39             LDRH     R1,[R7, #+40]
   \   00000036   0x6D30             LDR      R0,[R6, #+80]
   \   00000038   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   0000003C   0x.... 0x....      B.W      HAL_GPIO_WritePin
  15232            disable_E2();
  15233            disable_E3();
  15234            disable_E4();
  15235          }
   \                     ??disable_e_steppers_0: (+1)
   \   00000040   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
  15236          

   \                                 In section .text, align 2, keep-with-next
  15237          void disable_all_steppers() {
   \                     _Z20disable_all_steppersv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  15238            disable_X();
   \   00000002   0x....             LDR.N    R7,??DataTable179_1
   \   00000004   0xF897 0x0104      LDRB     R0,[R7, #+260]
   \   00000008   0x1E42             SUBS     R2,R0,#+1
   \   0000000A   0x4192             SBCS     R2,R2,R2
   \   0000000C   0x0FD2             LSRS     R2,R2,#+31
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable191_2
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable191_3
   \   00000016   0xB252             SXTB     R2,R2
   \   00000018   0x88A9             LDRH     R1,[R5, #+4]
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable190_6
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7130             STRB     R0,[R6, #+4]
  15239            disable_Y();
   \   00000028   0xF507 0x7782      ADD      R7,R7,#+260
   \   0000002C   0x7878             LDRB     R0,[R7, #+1]
   \   0000002E   0x1E42             SUBS     R2,R0,#+1
   \   00000030   0x4192             SBCS     R2,R2,R2
   \   00000032   0x0FD2             LSRS     R2,R2,#+31
   \   00000034   0xB252             SXTB     R2,R2
   \   00000036   0x89E9             LDRH     R1,[R5, #+14]
   \   00000038   0x69E0             LDR      R0,[R4, #+28]
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7170             STRB     R0,[R6, #+5]
  15240            disable_Z();
   \   00000042   0x78B8             LDRB     R0,[R7, #+2]
   \   00000044   0x1E42             SUBS     R2,R0,#+1
   \   00000046   0x4192             SBCS     R2,R2,R2
   \   00000048   0x0FD2             LSRS     R2,R2,#+31
   \   0000004A   0xB252             SXTB     R2,R2
   \   0000004C   0x8B29             LDRH     R1,[R5, #+24]
   \   0000004E   0x6B20             LDR      R0,[R4, #+48]
   \   00000050   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000054   0x78B8             LDRB     R0,[R7, #+2]
   \   00000056   0x1E42             SUBS     R2,R0,#+1
   \   00000058   0x4192             SBCS     R2,R2,R2
   \   0000005A   0x0FD2             LSRS     R2,R2,#+31
   \   0000005C   0xB252             SXTB     R2,R2
   \   0000005E   0x8D29             LDRH     R1,[R5, #+40]
   \   00000060   0x6D20             LDR      R0,[R4, #+80]
   \   00000062   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x71B0             STRB     R0,[R6, #+6]
  15241            disable_e_steppers();
   \   0000006A   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   0000006E   0x....             B.N      _Z18disable_e_steppersv
  15242          }

   \                                 In section .text, align 2, keep-with-next
  15243          void disable_noZ_steppers() {
   \                     _Z20disable_noZ_steppersv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  15244            disable_X();
   \   00000002   0x....             LDR.N    R4,??DataTable179_1
   \   00000004   0xF894 0x0104      LDRB     R0,[R4, #+260]
   \   00000008   0x1E42             SUBS     R2,R0,#+1
   \   0000000A   0x4192             SBCS     R2,R2,R2
   \   0000000C   0x0FD2             LSRS     R2,R2,#+31
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable191_2
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable191_3
   \   00000016   0xB252             SXTB     R2,R2
   \   00000018   0x88B1             LDRH     R1,[R6, #+4]
   \   0000001A   0x68A8             LDR      R0,[R5, #+8]
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000020   0x.... 0x....      LDR.W    R7,??DataTable190_6
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7138             STRB     R0,[R7, #+4]
  15245            disable_Y();
   \   00000028   0xF894 0x0105      LDRB     R0,[R4, #+261]
   \   0000002C   0x1E42             SUBS     R2,R0,#+1
   \   0000002E   0x4192             SBCS     R2,R2,R2
   \   00000030   0x0FD2             LSRS     R2,R2,#+31
   \   00000032   0xB252             SXTB     R2,R2
   \   00000034   0x89F1             LDRH     R1,[R6, #+14]
   \   00000036   0x69E8             LDR      R0,[R5, #+28]
   \   00000038   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7178             STRB     R0,[R7, #+5]
  15246            //disable_Z();
  15247            disable_e_steppers();
   \   00000040   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000044   0x....             B.N      _Z18disable_e_steppersv
  15248          }
  15249          
  15250          #if ENABLED(MONITOR_DRIVER_STATUS)
  15251            /*
  15252             * Check for over temperature or short to ground error flags.
  15253             * Report and log warning of overtemperature condition.
  15254             * Reduce driver current in a persistent otpw condition.
  15255             * Keep track of otpw counter so we don't reduce current on a single instance,
  15256             * and so we don't repeatedly report warning before the condition is cleared.
  15257             */
  15258          
  15259            struct TMC_driver_data {
  15260              uint32_t drv_status;
  15261              bool is_otpw;
  15262              bool is_ot;
  15263              bool is_error;
  15264            };
  15265            #if ENABLED(HAVE_TMC2130)
  15266              static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
  15267              static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
  15268              static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
  15269                constexpr uint32_t OTPW_bm = 0x4000000UL;
  15270                constexpr uint8_t OTPW_bp = 26;
  15271                constexpr uint32_t OT_bm = 0x2000000UL;
  15272                constexpr uint8_t OT_bp = 25;
  15273                constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
  15274                constexpr uint8_t DRIVER_ERROR_bp = 1;
  15275                TMC_driver_data data;
  15276                data.drv_status = st.DRV_STATUS();
  15277                data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
  15278                data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
  15279                data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
  15280                return data;
  15281              }
  15282            #endif
  15283            #if ENABLED(HAVE_TMC2208)
  15284              static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
  15285              static uint8_t get_status_response(TMC2208Stepper &st) {
  15286                uint32_t drv_status = st.DRV_STATUS();
  15287                uint8_t gstat = st.GSTAT();
  15288                uint8_t response = 0;
  15289                response |= (drv_status >> (31-3)) & 0b1000;
  15290                response |= gstat & 0b11;
  15291                return response;
  15292              }
  15293              static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
  15294                constexpr uint32_t OTPW_bm = 0b1ul;
  15295                constexpr uint8_t OTPW_bp = 0;
  15296                constexpr uint32_t OT_bm = 0b10ul;
  15297                constexpr uint8_t OT_bp = 1;
  15298                TMC_driver_data data;
  15299                data.drv_status = st.DRV_STATUS();
  15300                data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
  15301                data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
  15302                data.is_error = st.drv_err();
  15303                return data;
  15304              }
  15305            #endif
  15306          
  15307            template<typename TMC>
  15308            uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
  15309              TMC_driver_data data = get_driver_data(st);
  15310          
  15311              #if ENABLED(STOP_ON_ERROR)
  15312                if (data.is_error) {
  15313                  SERIAL_EOL();
  15314                  SERIAL_ECHO(axisID);
  15315                  SERIAL_ECHO(" driver error detected:");
  15316                  if (data.is_ot) SERIAL_ECHO("\novertemperature");
  15317                  if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
  15318                  if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
  15319                  SERIAL_EOL();
  15320                  #if ENABLED(TMC_DEBUG)
  15321                    gcode_M122();
  15322                  #endif
  15323                  kill(PSTR("Driver error"));
  15324                }
  15325              #endif
  15326          
  15327              // Report if a warning was triggered
  15328              if (data.is_otpw && otpw_cnt==0) {
  15329                char timestamp[10];
  15330                duration_t elapsed = print_job_timer.duration();
  15331                const bool has_days = (elapsed.value > 60*60*24L);
  15332                (void)elapsed.toDigital(timestamp, has_days);
  15333                SERIAL_EOL();
  15334                SERIAL_ECHO(timestamp);
  15335                SERIAL_ECHOPGM(": ");
  15336                SERIAL_ECHO(axisID);
  15337                SERIAL_ECHOPGM(" driver overtemperature warning! (");
  15338                SERIAL_ECHO(st.getCurrent());
  15339                SERIAL_ECHOLN("mA)");
  15340              }
  15341              #if CURRENT_STEP_DOWN > 0
  15342                // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
  15343                if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
  15344                  st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
  15345                  #if ENABLED(REPORT_CURRENT_CHANGE)
  15346                    SERIAL_ECHO(axisID);
  15347                    SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
  15348                  #endif
  15349                }
  15350              #endif
  15351          
  15352              if (data.is_otpw) {
  15353                otpw_cnt++;
  15354                st.flag_otpw = true;
  15355              }
  15356              else if (otpw_cnt>0) otpw_cnt--;
  15357          
  15358              if (report_tmc_status) {
  15359                const uint32_t pwm_scale = get_pwm_scale(st);
  15360                SERIAL_ECHO(axisID);
  15361                SERIAL_ECHOPAIR(":", pwm_scale);
  15362                SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
  15363                SERIAL_ECHO("| ");
  15364                if (data.is_error) SERIAL_ECHO('E');
  15365                else if (data.is_ot) SERIAL_ECHO('O');
  15366                else if (data.is_otpw) SERIAL_ECHO('W');
  15367                else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
  15368                else if (st.flag_otpw) SERIAL_ECHO('F');
  15369                SERIAL_ECHO("\t");
  15370              }
  15371          
  15372              return otpw_cnt;
  15373            }
  15374          
  15375            void monitor_tmc_driver() {
  15376              static millis_t next_cOT = 0;
  15377              if (ELAPSED(millis(), next_cOT)) {
  15378                next_cOT = millis() + 500;
  15379                #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15380                  static uint8_t x_otpw_cnt = 0;
  15381                  x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
  15382                #endif
  15383                #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15384                  static uint8_t y_otpw_cnt = 0;
  15385                  y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
  15386                #endif
  15387                #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15388                  static uint8_t z_otpw_cnt = 0;
  15389                  z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
  15390                #endif
  15391                #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
  15392                  static uint8_t x2_otpw_cnt = 0;
  15393                  x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
  15394                #endif
  15395                #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
  15396                  static uint8_t y2_otpw_cnt = 0;
  15397                  y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
  15398                #endif
  15399                #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
  15400                  static uint8_t z2_otpw_cnt = 0;
  15401                  z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
  15402                #endif
  15403                #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15404                  static uint8_t e0_otpw_cnt = 0;
  15405                  e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
  15406                #endif
  15407                #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
  15408                  static uint8_t e1_otpw_cnt = 0;
  15409                  e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
  15410                #endif
  15411                #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
  15412                  static uint8_t e2_otpw_cnt = 0;
  15413                  e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
  15414                #endif
  15415                #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
  15416                  static uint8_t e3_otpw_cnt = 0;
  15417                  e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
  15418                #endif
  15419                #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
  15420                  static uint8_t e4_otpw_cnt = 0;
  15421                  e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
  15422                #endif
  15423          
  15424                if (report_tmc_status) SERIAL_EOL();
  15425              }
  15426            }
  15427          
  15428          #endif // MONITOR_DRIVER_STATUS
  15429          
  15430          /**
  15431           * Manage several activities:
  15432           *  - Check for Filament Runout
  15433           *  - Keep the command buffer full
  15434           *  - Check for maximum inactive time between commands
  15435           *  - Check for maximum inactive time between stepper commands
  15436           *  - Check if pin CHDK needs to go LOW
  15437           *  - Check for KILL button held down
  15438           *  - Check for HOME button held down
  15439           *  - Check if cooling fan needs to be switched on
  15440           *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  15441           */

   \                                 In section .text, align 2, keep-with-next
  15442          void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   \                     _Z17manage_inactivityb: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
  15443          
  15444            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  15445              if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable192_2
   \   00000008   0xF890 0x1760      LDRB     R1,[R0, #+1888]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD105             BNE.N    ??manage_inactivity_0
   \   00000010   0xF600 0x20E8      ADDW     R0,R0,#+2792
   \   00000014   0x.... 0x....      BL       _ZN9Stopwatch9isRunningEv
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00F             BEQ.N    ??manage_inactivity_1
   \                     ??manage_inactivity_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable191_3
   \   00000020   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable191_2
   \   00000026   0x6EC0             LDR      R0,[R0, #+108]
   \   00000028   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable192_1
   \   00000030   0xF891 0x10D0      LDRB     R1,[R1, #+208]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD101             BNE.N    ??manage_inactivity_1
  15446                handle_filament_runout();
   \   00000038   0x.... 0x....      BL       _Z22handle_filament_runoutv
  15447            #endif
  15448          
  15449            if (commands_in_queue < BUFSIZE) get_available_commands();
   \                     ??manage_inactivity_1: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable192_3
   \   00000040   0x7880             LDRB     R0,[R0, #+2]
   \   00000042   0x2804             CMP      R0,#+4
   \   00000044   0xDA01             BGE.N    ??manage_inactivity_2
   \   00000046   0x.... 0x....      BL       _Z22get_available_commandsv
  15450          
  15451            const millis_t ms = millis();
   \                     ??manage_inactivity_2: (+1)
   \   0000004A   0x.... 0x....      BL       HAL_GetTick
   \   0000004E   0x4606             MOV      R6,R0
  15452          
  15453            if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
   \   00000050   0x.... 0x....      LDR.W    R4,??DataTable190_6
   \   00000054   0x6E20             LDR      R0,[R4, #+96]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD017             BEQ.N    ??manage_inactivity_3
   \   0000005A   0x6DE1             LDR      R1,[R4, #+92]
   \   0000005C   0x1A71             SUBS     R1,R6,R1
   \   0000005E   0x1A08             SUBS     R0,R1,R0
   \   00000060   0xD413             BMI.N    ??manage_inactivity_3
  15454              SERIAL_ERROR_START();
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable192_4
   \   00000066   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15455              SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable192_5
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0x.... 0x....      ADR.W    R0,`?<Constant "KILL caused by too mu...">`
   \   00000074   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000078   0x210A             MOVS     R1,#+10
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable192_6
   \   0000007E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15456              kill(PSTR(MSG_KILLED));
   \   00000082   0x.... 0x....      ADR.W    R0,`?<Constant "KILLED. ">`
   \   00000086   0x.... 0x....      BL       _Z4killPKc
  15457            }
  15458          
  15459            // Prevent steppers timing-out in the middle of M600
  15460            #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
  15461              #define MOVE_AWAY_TEST !move_away_flag
  15462            #else
  15463              #define MOVE_AWAY_TEST true
  15464            #endif
  15465          
  15466            if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
  15467                && !ignore_stepper_queue && !planner.blocks_queued()) {
   \                     ??manage_inactivity_3: (+1)
   \   0000008A   0x6E60             LDR      R0,[R4, #+100]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD03E             BEQ.N    ??manage_inactivity_4
   \   00000090   0x6DE1             LDR      R1,[R4, #+92]
   \   00000092   0x1A71             SUBS     R1,R6,R1
   \   00000094   0x1A08             SUBS     R0,R1,R0
   \   00000096   0xD43A             BMI.N    ??manage_inactivity_4
   \   00000098   0x2D00             CMP      R5,#+0
   \   0000009A   0xD138             BNE.N    ??manage_inactivity_4
   \   0000009C   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD134             BNE.N    ??manage_inactivity_4
  15468              #if ENABLED(DISABLE_INACTIVE_X)
  15469                disable_X();
   \   000000A4   0x.... 0x....      LDR.W    R7,??DataTable192_1
   \   000000A8   0xF897 0x0104      LDRB     R0,[R7, #+260]
   \   000000AC   0x1E42             SUBS     R2,R0,#+1
   \   000000AE   0x4192             SBCS     R2,R2,R2
   \   000000B0   0x0FD2             LSRS     R2,R2,#+31
   \   000000B2   0x.... 0x....      LDR.W    R5,??DataTable191_2
   \   000000B6   0x.... 0x....      LDR.W    R6,??DataTable191_3
   \   000000BA   0xB252             SXTB     R2,R2
   \   000000BC   0x88B1             LDRH     R1,[R6, #+4]
   \   000000BE   0x68A8             LDR      R0,[R5, #+8]
   \   000000C0   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x7120             STRB     R0,[R4, #+4]
  15470              #endif
  15471              #if ENABLED(DISABLE_INACTIVE_Y)
  15472                disable_Y();
   \   000000C8   0xF507 0x7782      ADD      R7,R7,#+260
   \   000000CC   0x7878             LDRB     R0,[R7, #+1]
   \   000000CE   0x1E42             SUBS     R2,R0,#+1
   \   000000D0   0x4192             SBCS     R2,R2,R2
   \   000000D2   0x0FD2             LSRS     R2,R2,#+31
   \   000000D4   0xB252             SXTB     R2,R2
   \   000000D6   0x89F1             LDRH     R1,[R6, #+14]
   \   000000D8   0x69E8             LDR      R0,[R5, #+28]
   \   000000DA   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x7160             STRB     R0,[R4, #+5]
  15473              #endif
  15474              #if ENABLED(DISABLE_INACTIVE_Z)
  15475                disable_Z();
   \   000000E2   0x78B8             LDRB     R0,[R7, #+2]
   \   000000E4   0x1E42             SUBS     R2,R0,#+1
   \   000000E6   0x4192             SBCS     R2,R2,R2
   \   000000E8   0x0FD2             LSRS     R2,R2,#+31
   \   000000EA   0xB252             SXTB     R2,R2
   \   000000EC   0x8B31             LDRH     R1,[R6, #+24]
   \   000000EE   0x6B28             LDR      R0,[R5, #+48]
   \   000000F0   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000F4   0x78B8             LDRB     R0,[R7, #+2]
   \   000000F6   0x1E42             SUBS     R2,R0,#+1
   \   000000F8   0x4192             SBCS     R2,R2,R2
   \   000000FA   0x0FD2             LSRS     R2,R2,#+31
   \   000000FC   0xB252             SXTB     R2,R2
   \   000000FE   0x8D31             LDRH     R1,[R6, #+40]
   \   00000100   0x6D28             LDR      R0,[R5, #+80]
   \   00000102   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x71A0             STRB     R0,[R4, #+6]
  15476              #endif
  15477              #if ENABLED(DISABLE_INACTIVE_E)
  15478                disable_e_steppers();
   \   0000010A   0x.... 0x....      BL       _Z18disable_e_steppersv
  15479              #endif
  15480              #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
  15481                ubl.lcd_map_control = defer_return_to_status = false;
  15482              #endif
  15483            }
  15484          
  15485            #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
  15486              if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
  15487                chdkActive = false;
  15488                WRITE(CHDK, LOW);
  15489              }
  15490            #endif
  15491          
  15492            #if HAS_KILL
  15493          
  15494              // Check if the kill button was pressed and wait just in case it was an accidental
  15495              // key kill key press
  15496              // -------------------------------------------------------------------------------
  15497              static int killCount = 0;   // make the inactivity button a bit less responsive
  15498              const int KILL_DELAY = 750;
  15499              if (!READ(KILL_PIN))
  15500                killCount++;
  15501              else if (killCount > 0)
  15502                killCount--;
  15503          
  15504              // Exceeded threshold and we can confirm that it was not accidental
  15505              // KILL the machine
  15506              // ----------------------------------------------------------------
  15507              if (killCount >= KILL_DELAY) {
  15508                SERIAL_ERROR_START();
  15509                SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
  15510                kill(PSTR(MSG_KILLED));
  15511              }
  15512            #endif
  15513          
  15514            #if HAS_HOME
  15515              // Check to see if we have to home, use poor man's debouncer
  15516              // ---------------------------------------------------------
  15517              static int homeDebounceCount = 0;   // poor man's debouncing count
  15518              const int HOME_DEBOUNCE_DELAY = 2500;
  15519              if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
  15520                if (!homeDebounceCount) {
  15521                  enqueue_and_echo_commands_P(PSTR("G28"));
  15522                  LCD_MESSAGEPGM(MSG_AUTO_HOME);
  15523                }
  15524                if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
  15525                  homeDebounceCount++;
  15526                else
  15527                  homeDebounceCount = 0;
  15528              }
  15529            #endif
  15530          
  15531            #if ENABLED(USE_CONTROLLER_FAN)
  15532              controllerFan(); // Check if fan should be turned on to cool stepper drivers down
  15533            #endif
  15534          
  15535            #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
  15536              if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
  15537                && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
  15538                #if ENABLED(SWITCHING_EXTRUDER)
  15539                  const bool oldstatus = E0_ENABLE_READ;
  15540                  enable_E0();
  15541                #else // !SWITCHING_EXTRUDER
  15542                  bool oldstatus;
  15543                  switch (active_extruder) {
  15544                    default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
  15545                    #if E_STEPPERS > 1
  15546                      case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
  15547                      #if E_STEPPERS > 2
  15548                        case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
  15549                        #if E_STEPPERS > 3
  15550                          case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
  15551                          #if E_STEPPERS > 4
  15552                            case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
  15553                          #endif // E_STEPPERS > 4
  15554                        #endif // E_STEPPERS > 3
  15555                      #endif // E_STEPPERS > 2
  15556                    #endif // E_STEPPERS > 1
  15557                  }
  15558                #endif // !SWITCHING_EXTRUDER
  15559          
  15560                previous_cmd_ms = ms; // refresh_cmd_timeout()
  15561          
  15562                const float olde = current_position[E_AXIS];
  15563                current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
  15564                planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
  15565                current_position[E_AXIS] = olde;
  15566                planner.set_e_position_mm(olde);
  15567                stepper.synchronize();
  15568                #if ENABLED(SWITCHING_EXTRUDER)
  15569                  E0_ENABLE_WRITE(oldstatus);
  15570                #else
  15571                  switch (active_extruder) {
  15572                    case 0: E0_ENABLE_WRITE(oldstatus); break;
  15573                    #if E_STEPPERS > 1
  15574                      case 1: E1_ENABLE_WRITE(oldstatus); break;
  15575                      #if E_STEPPERS > 2
  15576                        case 2: E2_ENABLE_WRITE(oldstatus); break;
  15577                        #if E_STEPPERS > 3
  15578                          case 3: E3_ENABLE_WRITE(oldstatus); break;
  15579                          #if E_STEPPERS > 4
  15580                            case 4: E4_ENABLE_WRITE(oldstatus); break;
  15581                          #endif // E_STEPPERS > 4
  15582                        #endif // E_STEPPERS > 3
  15583                      #endif // E_STEPPERS > 2
  15584                    #endif // E_STEPPERS > 1
  15585                  }
  15586                #endif // !SWITCHING_EXTRUDER
  15587              }
  15588            #endif // EXTRUDER_RUNOUT_PREVENT
  15589          
  15590            #if ENABLED(DUAL_X_CARRIAGE)
  15591              // handle delayed move timeout
  15592              if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
  15593                // travel moves have been received so enact them
  15594                delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
  15595                set_destination_from_current();
  15596                prepare_move_to_destination();
  15597              }
  15598            #endif
  15599          
  15600            #if ENABLED(TEMP_STAT_LEDS)
  15601              handle_status_leds();
  15602            #endif
  15603          
  15604            #if ENABLED(MONITOR_DRIVER_STATUS)
  15605              monitor_tmc_driver();
  15606            #endif
  15607          
  15608            planner.check_axes_activity();
   \                     ??manage_inactivity_4: (+1)
   \   0000010E   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000112   0x.... 0x....      B.W      _ZN7Planner19check_axes_activityEv
  15609          }
  15610          
  15611          /**
  15612           * Standard idle routine keeps the machine alive
  15613           */
  15614          //extern uint8_t display_hold;
  15615          //extern uint32_t display_hold_cnt;
  15616          //extern uint8_t display_hold_release;
  15617          
  15618          uint8_t display_hold=0;
  15619          uint32_t display_hold_cnt=0;
  15620          uint8_t display_hold_release=0;
  15621          uint8_t button_disp_pause_state=0;
  15622          

   \                                 In section .text, align 2, keep-with-next
  15623          void lcd_reInit()
  15624          {
   \                     _Z10lcd_reInitv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  15625             GUI_Init();
   \   00000002   0x.... 0x....      BL       GUI_Init
  15626             GUI_UC_SetEncodeUTF8();
   \   00000006   0x.... 0x....      BL       GUI_UC_SetEncodeUTF8
  15627             gui_view_init(); 
   \   0000000A   0x.... 0x....      BL       gui_view_init
  15628             clear_cur_ui();
   \   0000000E   0x.... 0x....      BL       clear_cur_ui
  15629             disp_state_stack._disp_index += 1;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable192_7
   \   00000016   0xF890 0x1064      LDRB     R1,[R0, #+100]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xF880 0x1064      STRB     R1,[R0, #+100]
  15630             if(mksReprint.mks_printer_state == MKS_REPRINTED)
   \   00000020   0x.... 0x....      LDR.W    R4,??DataTable192_8
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable192_2
   \   00000028   0xF890 0x081C      LDRB     R0,[R0, #+2076]
   \   0000002C   0x28AC             CMP      R0,#+172
   \   0000002E   0xD101             BNE.N    ??lcd_reInit_0
  15631             {
  15632             	button_disp_pause_state=1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7020             STRB     R0,[R4, #+0]
  15633             }
  15634             draw_return_ui();
   \                     ??lcd_reInit_0: (+1)
   \   00000034   0x.... 0x....      BL       draw_return_ui
  15635             button_disp_pause_state=0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
  15636             Lcd_Light_ON;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable192_9  ;; 0x422281b4
   \   00000042   0x6008             STR      R0,[R1, #+0]
  15637          }
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
  15638          

   \                                 In section .text, align 2, keep-with-next
  15639          void idle(
  15640            #if ENABLED(ADVANCED_PAUSE_FEATURE)
  15641              bool no_stepper_sleep/*=false*/
  15642            #endif
  15643          ) {
   \                     _Z4idlev: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15644            #if ENABLED(MAX7219_DEBUG)
  15645              Max7219_idle_tasks();
  15646            #endif  // MAX7219_DEBUG
  15647          
  15648             if(gCfgItems.standby_mode==1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable193
   \   00000006   0xF890 0x12A2      LDRB     R1,[R0, #+674]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD118             BNE.N    ??idle_0
  15649              {
  15650                  if(display_hold_cnt>=gCfgItems.standby_time)
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable193_1
   \   00000012   0x6B8A             LDR      R2,[R1, #+56]
   \   00000014   0xF8D0 0x32A4      LDR      R3,[R0, #+676]
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xD309             BCC.N    ??idle_1
  15651                  {
  15652                      display_hold_cnt -= gCfgItems.standby_time;
   \   0000001C   0xF8D0 0x02A4      LDR      R0,[R0, #+676]
   \   00000020   0x1A10             SUBS     R0,R2,R0
   \   00000022   0x6388             STR      R0,[R1, #+56]
  15653                      display_hold=1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x72C8             STRB     R0,[R1, #+11]
  15654                      Lcd_Light_OFF;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable192_9  ;; 0x422281b4
   \   0000002E   0x6010             STR      R0,[R2, #+0]
  15655                  }
  15656                  if(display_hold_release==1)
   \                     ??idle_1: (+1)
   \   00000030   0x7B08             LDRB     R0,[R1, #+12]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD104             BNE.N    ??idle_0
  15657                  {
  15658                      display_hold=0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x72C8             STRB     R0,[R1, #+11]
  15659                      display_hold_release=0;
   \   0000003A   0x7308             STRB     R0,[R1, #+12]
  15660                      lcd_reInit();
   \   0000003C   0x.... 0x....      BL       _Z10lcd_reInitv
  15661                  }
  15662              }
  15663          
  15664            lcd_update();
   \                     ??idle_0: (+1)
   \   00000040   0x.... 0x....      BL       _Z10lcd_updatev
  15665          
  15666            host_keepalive();
   \   00000044   0x.... 0x....      BL       _Z14host_keepalivev
  15667          
  15668            //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
  15669             #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)	
  15670              thermalManager.auto_report_temperatures();
   \   00000048   0x.... 0x....      BL       _ZN11Temperature24auto_report_temperaturesEv
  15671            #endif
  15672          
  15673            manage_inactivity(
  15674              #if ENABLED(ADVANCED_PAUSE_FEATURE)
  15675                no_stepper_sleep
  15676              #endif
  15677            );
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      BL       _Z17manage_inactivityb
  15678          
  15679            thermalManager.manage_heater();
   \   00000052   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
  15680          
  15681            #if ENABLED(PRINTCOUNTER)
  15682              print_job_timer.tick();
  15683            #endif
  15684          
  15685            #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
  15686              buzzer.tick();
  15687            #endif
  15688            #if 1
  15689            display_temper_error();
   \   00000056   0x.... 0x....      BL       _Z20display_temper_errorv
  15690            
  15691            wifi_looping();
   \   0000005A   0x.... 0x....      BL       _Z12wifi_loopingv
  15692            
  15693            if(wifi_link_state != WIFI_TRANS_FILE)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable192_10
   \   00000062   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000066   0x2810             CMP      R0,#+16
   \   00000068   0xD001             BEQ.N    ??idle_2
  15694            {
  15695          	  GUI_RefreshPage();
   \   0000006A   0x.... 0x....      BL       GUI_RefreshPage
  15696            }
  15697            #if defined(TFT70)
  15698            disp_pre_gcode(3,40);
  15699            #elif defined(TFT35)
  15700            //#if defined(MKS_ROBIN2)
  15701            if(preview_no_display != 1)
   \                     ??idle_2: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable193_1
   \   00000072   0x7940             LDRB     R0,[R0, #+5]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD003             BEQ.N    ??idle_3
  15702            {
  15703          	  disp_pre_gcode(2,36);
   \   00000078   0x2124             MOVS     R1,#+36
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0x.... 0x....      BL       disp_pre_gcode
  15704            }
  15705            //#endif
  15706            #endif
  15707            
  15708            GUI_TOUCH_Exec(); 	  
   \                     ??idle_3: (+1)
   \   00000080   0x.... 0x....      BL       GUI_TOUCH_Exec
  15709            GUI_Exec(); 
   \   00000084   0xE8BD 0x4001      POP      {R0,LR}
   \   00000088   0x.... 0x....      B.W      GUI_Exec
  15710          
  15711          #endif
  15712            #if ENABLED(I2C_POSITION_ENCODERS)
  15713              if (planner.blocks_queued() &&
  15714                  ( (blockBufferIndexRef != planner.block_buffer_head) ||
  15715                    ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
  15716                blockBufferIndexRef = planner.block_buffer_head;
  15717                I2CPEM.update();
  15718                lastUpdateMillis = millis();
  15719              }
  15720            #endif
  15721          }
  15722          
  15723          extern "C" void kill_c(const char* lcd_msg);

   \                                 In section .text, align 4, keep-with-next
  15724          void kill_c(const char* lcd_msg) {
   \                     kill_c: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15725            SERIAL_ERROR_START();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable192_4
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15726            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15727          
  15728            thermalManager.disable_all_heaters();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15729            disable_all_steppers();
   \   00000016   0x.... 0x....      BL       _Z20disable_all_steppersv
  15730          
  15731            #if ENABLED(ULTRA_LCD)
  15732              kill_screen(lcd_msg);
  15733            #else
  15734              UNUSED(lcd_msg);
  15735            #endif
  15736          
  15737            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \   0000001A   0xF44F 0x7016      MOV      R0,#+600
   \   0000001E   0x.... 0x....      BL       HAL_Delay
  15738            cli(); // Stop interrupts
   \   00000022   0xB672             cpsid i
  15739          
  15740            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \   00000024   0x20FA             MOVS     R0,#+250
   \   00000026   0x.... 0x....      BL       HAL_Delay
  15741            thermalManager.disable_all_heaters(); //turn off heaters again
   \   0000002A   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15742          
  15743            #if HAS_POWER_SWITCH
  15744              SET_INPUT(PS_ON_PIN);
  15745            #endif
  15746          
  15747            suicide();
   \   0000002E   0x.... 0x....      BL       _Z7suicidev
  15748            while (1) {
   \                     ??kill_c_0: (+1)
   \   00000032   0xE7FE             B.N      ??kill_c_0
  15749              #if ENABLED(USE_WATCHDOG)
  15750                watchdog_reset();
  15751              #endif
  15752            } // Wait for reset
  15753          }
  15754          #if 1

   \                                 In section .text, align 2, keep-with-next
  15755          void temper_error_kill()
  15756          {
   \                     _Z17temper_error_killv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15757            SERIAL_ERROR_START();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable192_4
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15758            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15759          
  15760            thermalManager.disable_all_heaters();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15761            disable_all_steppers();	
   \   00000016   0x.... 0x....      BL       _Z20disable_all_steppersv
  15762          
  15763            _delay_ms(600);
   \   0000001A   0xF44F 0x7016      MOV      R0,#+600
   \   0000001E   0x.... 0x....      BL       HAL_Delay
  15764          
  15765            temper_error_flg = 1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable193_2
   \   00000028   0x7008             STRB     R0,[R1, #+0]
  15766          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
  15767          

   \                                 In section .text, align 2, keep-with-next
  15768          void display_temper_error()
  15769          {
   \                     _Z20display_temper_errorv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
  15770              char buf_err[30]={0};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
  15771              
  15772          	if(temper_error_flg == 1)
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable193_2
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD121             BNE.N    ??display_temper_error_0
  15773          	{
  15774          		card.sdprinting = false;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable192_2
   \   0000001C   0xF881 0x0760      STRB     R0,[R1, #+1888]
  15775          		wait_for_heatup = false;
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable192_3
   \   00000024   0x7108             STRB     R0,[R1, #+4]
  15776          
  15777          		GUI_SetBkColor(gCfgItems.background_color);
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable193
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x.... 0x....      BL       GUI_SetBkColor
  15778          		GUI_SetColor(0X0000ff);//	o®¨®¶?°¡?®¨?
   \   00000030   0x20FF             MOVS     R0,#+255
   \   00000032   0x.... 0x....      BL       GUI_SetColor
  15779                  sprintf(buf_err,"Err%d",temper_error_type);
   \   00000036   0x7862             LDRB     R2,[R4, #+1]
   \   00000038   0x.... 0x....      ADR.W    R1,`?<Constant "Err%d">`
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       sprintf
  15780          		GUI_DispStringAt(buf_err,380, TITLE_YPOS);
   \   00000042   0x2205             MOVS     R2,#+5
   \   00000044   0xF44F 0x71BE      MOV      R1,#+380
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       GUI_DispStringAt
  15781          		GUI_SetBkColor(gCfgItems.background_color);
   \   0000004E   0x6868             LDR      R0,[R5, #+4]
   \   00000050   0x.... 0x....      BL       GUI_SetBkColor
  15782          		GUI_SetColor(gCfgItems.title_color);			
   \   00000054   0x68A8             LDR      R0,[R5, #+8]
   \   00000056   0x.... 0x....      BL       GUI_SetColor
  15783          	}
  15784          }
   \                     ??display_temper_error_0: (+1)
   \   0000005A   0xB009             ADD      SP,SP,#+36
   \   0000005C   0xBD30             POP      {R4,R5,PC}       ;; return
  15785          
  15786          #endif
  15787          
  15788          /**
  15789           * Kill all activity and lock the machine.
  15790           * After this the machine will need to be reset.
  15791           */

   \                                 In section .text, align 4, keep-with-next
  15792          void kill(const char* lcd_msg) {
   \                     _Z4killPKc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15793            SERIAL_ERROR_START();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable192_4
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15794            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15795          
  15796            thermalManager.disable_all_heaters();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15797            disable_all_steppers();
   \   00000016   0x.... 0x....      BL       _Z20disable_all_steppersv
  15798          
  15799            #if ENABLED(ULTRA_LCD)
  15800              kill_screen(lcd_msg);
  15801            #else
  15802              UNUSED(lcd_msg);
  15803            #endif
  15804          
  15805            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \   0000001A   0xF44F 0x7016      MOV      R0,#+600
   \   0000001E   0x.... 0x....      BL       HAL_Delay
  15806           
  15807          
  15808            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \   00000022   0x20FA             MOVS     R0,#+250
   \   00000024   0x.... 0x....      BL       HAL_Delay
  15809             cli(); // Stop interrupts
   \   00000028   0xB672             cpsid i
  15810            thermalManager.disable_all_heaters(); //turn off heaters again
   \   0000002A   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15811          
  15812            #ifdef ACTION_ON_KILL
  15813              SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
  15814            #endif
  15815          
  15816            #if HAS_POWER_SWITCH
  15817              SET_INPUT(PS_ON_PIN);
  15818            #endif
  15819          
  15820            suicide();
   \   0000002E   0x.... 0x....      BL       _Z7suicidev
  15821            while (1) {
   \                     ??kill_0: (+1)
   \   00000032   0xE7FE             B.N      ??kill_0
  15822              #if ENABLED(USE_WATCHDOG)
  15823                watchdog_reset();
  15824              #endif
  15825            } // Wait for reset
  15826          }
  15827          
  15828          /**
  15829           * Turn off heaters and stop the print in progress
  15830           * After a stop the machine may be resumed with M999
  15831           */

   \                                 In section .text, align 2, keep-with-next
  15832          void stop() {
   \                     _Z4stopv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  15833            thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   \   00000002   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15834          
  15835            #if ENABLED(PROBING_FANS_OFF)
  15836              if (fans_paused) fans_pause(false); // put things back the way they were
  15837            #endif
  15838          
  15839            if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD016             BEQ.N    ??stop_0
  15840              Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable193_3
   \   00000012   0x6AE0             LDR      R0,[R4, #+44]
   \   00000014   0x6320             STR      R0,[R4, #+48]
  15841              SERIAL_ERROR_START();
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable192_4
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15842              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   0000001E   0x.... 0x....      ADR.W    R0,`?<Constant "Printer stopped due t...">`
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15843              LCD_MESSAGEPGM(MSG_STOPPED);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x.... 0x....      ADR.W    R0,`?<Constant "STOPPED. ">`
   \   0000002C   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
  15844              safe_delay(350);       // allow enough time for messages to get out before stopping
   \   00000030   0xF44F 0x70AF      MOV      R0,#+350
   \   00000034   0x.... 0x....      BL       _Z10safe_delaym
  15845              Running = false;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7120             STRB     R0,[R4, #+4]
  15846            }
  15847          }
   \                     ??stop_0: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
  15848          
  15849          /**
  15850           * Marlin entry-point: Set up before the program loop
  15851           *  - Set up the kill pin, filament runout, power hold
  15852           *  - Start the serial port
  15853           *  - Print startup messages and diagnostics
  15854           *  - Get EEPROM or default settings
  15855           *  - Initialize managers for:
  15856           *    ‚Ä¢ temperature
  15857           *    ‚Ä¢ planner
  15858           *    ‚Ä¢ watchdog
  15859           *    ‚Ä¢ stepper
  15860           *    ‚Ä¢ photo pin
  15861           *    ‚Ä¢ servos
  15862           *    ‚Ä¢ LCD controller
  15863           *    ‚Ä¢ Digipot I2C
  15864           *    ‚Ä¢ Z probe sled
  15865           *    ‚Ä¢ status LEDs
  15866           */

   \                                 In section .text, align 2, keep-with-next
  15867          void setup() {
   \                     setup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  15868          
  15869            #if ENABLED(MAX7219_DEBUG)
  15870              Max7219_init();
  15871            #endif
  15872          /*
  15873            #if ENABLED(DISABLE_JTAG)
  15874              // Disable JTAG on AT90USB chips to free up pins for IO
  15875              MCUCR = 0x80;
  15876              MCUCR = 0x80;
  15877            #endif
  15878            */
  15879          
  15880            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  15881              setup_filrunoutpin();
   \   00000002   0x.... 0x....      BL       _Z18setup_filrunoutpinv
  15882            #endif
  15883          
  15884            setup_killpin();
   \   00000006   0x.... 0x....      BL       _Z13setup_killpinv
  15885          
  15886            //setup_powerhold();
  15887          
  15888            #if HAS_STEPPER_RESET
  15889              disableStepperDrivers();
  15890            #endif
  15891          
  15892            //MYSERIAL.begin(BAUDRATE);
  15893            //SERIAL_PROTOCOLLNPGM("start");
  15894            //SERIAL_ECHO_START();
  15895          
  15896            #if ENABLED(HAVE_TMC2208)
  15897              tmc2208_serial_begin();
  15898            #endif
  15899          
  15900            // Check startup - does nothing if bootloader sets MCUSR to 0
  15901            byte mcu = MCUSR;
  15902            if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
  15903            if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
  15904            if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
  15905            if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
  15906            if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
  15907            //MCUSR = 0;
  15908          
  15909            SERIAL_ECHOPGM(MSG_MARLIN);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "MKS Robin Nano">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15910            SERIAL_CHAR(' ');
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable192_6
   \   00000016   0x2120             MOVS     R1,#+32
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15911            SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
   \   0000001E   0x.... 0x....      ADR.W    R0,`?<Constant "1.0.0\\n">`
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15912            SERIAL_EOL();
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15913          
  15914            #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
  15915              SERIAL_ECHO_START();
   \   0000002E   0x.... 0x....      LDR.W    R5,??DataTable193_4
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15916              SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
   \   00000038   0x.... 0x....      ADR.W    R0,`?<Constant " Last Updated: ">`
   \   0000003C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15917              SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
   \   00000040   0x.... 0x....      ADR.W    R0,`?<Constant "2017-12-25 12:00">`
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15918              SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
   \   00000048   0x.... 0x....      ADR.W    R0,`?<Constant " | Author: (none, def...">`
   \   0000004C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15919              SERIAL_ECHO_START();
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15920              SERIAL_ECHOLNPGM("Compiled: " __DATE__);
   \   00000056   0x.... 0x....      ADR.W    R0,`?<Constant "Compiled: Feb 25 2020\\n">`
   \   0000005A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15921            #endif
  15922          
  15923            SERIAL_ECHO_START();
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15924            SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   \   00000064   0x.... 0x....      BL       _Z10freeMemoryv
   \   00000068   0x4601             MOV      R1,R0
   \   0000006A   0x.... 0x....      ADR.W    R0,`?<Constant " Free Memory: ">`
   \   0000006E   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  15925            SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
   \   00000072   0xF44F 0x61A8      MOV      R1,#+1344
   \   00000076   0x.... 0x....      ADR.W    R0,`?<Constant "  PlannerBufferBytes: ">`
   \   0000007A   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   0000007E   0x210A             MOVS     R1,#+10
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15926          
  15927            // Send "ok" after commands by default
  15928            for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x2201             MOVS     R2,#+1
   \   0000008A   0x.... 0x....      LDR.W    R4,??DataTable193_1
   \   0000008E   0xE002             B.N      ??setup_0
   \                     ??setup_1: (+1)
   \   00000090   0x1909             ADDS     R1,R1,R4
   \   00000092   0x750A             STRB     R2,[R1, #+20]
   \   00000094   0x1C40             ADDS     R0,R0,#+1
   \                     ??setup_0: (+1)
   \   00000096   0xB240             SXTB     R0,R0
   \   00000098   0x4601             MOV      R1,R0
   \   0000009A   0x2904             CMP      R1,#+4
   \   0000009C   0xDBF8             BLT.N    ??setup_1
  15929          
  15930            // Load data from EEPROM if available (or use defaults)
  15931            // This also updates variables in the planner, elsewhere
  15932            (void)settings.load();
   \   0000009E   0x.... 0x....      BL       _ZN14MarlinSettings4loadEv
  15933          
  15934            //#if HAS_M206_COMMAND
  15935              // Initialize current position based on home_offset
  15936              if(MACHINETPYE != DELTA)
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable192_3
   \   000000A6   0x.... 0x....      LDR.W    R5,??DataTable192_1
   \   000000AA   0xF9B5 0x1058      LDRSH    R1,[R5, #+88]
   \   000000AE   0x2902             CMP      R1,#+2
   \   000000B0   0xD006             BEQ.N    ??setup_2
  15937              	COPY(current_position, home_offset);
   \   000000B2   0x220C             MOVS     R2,#+12
   \   000000B4   0xF104 0x012C      ADD      R1,R4,#+44
   \   000000B8   0x3008             ADDS     R0,R0,#+8
   \   000000BA   0x.... 0x....      BL       memcpy
   \   000000BE   0xE004             B.N      ??setup_3
  15938          	else
  15939            //#else
  15940              	ZERO(current_position);
   \                     ??setup_2: (+1)
   \   000000C0   0x2210             MOVS     R2,#+16
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x3008             ADDS     R0,R0,#+8
   \   000000C6   0x.... 0x....      BL       memset
  15941            //#endif
  15942          
  15943            // Vital to init stepper/planner equivalent for current_position
  15944            SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??setup_3: (+1)
   \   000000CA   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
  15945          
  15946            thermalManager.init();    // Initialize temperature loop
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable195
   \   000000D2   0x.... 0x....      BL       _ZN11Temperature4initEv
  15947          
  15948            #if ENABLED(USE_WATCHDOG)
  15949              watchdog_init();
  15950            #endif
  15951            //tan add
  15952            soft_endstop_min_init();
   \   000000D6   0x.... 0x....      BL       _Z21soft_endstop_min_initv
  15953          
  15954            stepper.init();    // Initialize stepper, this enables interrupts!
   \   000000DA   0x.... 0x....      BL       _ZN7Stepper4initEv
  15955            servo_init();
   \   000000DE   0x.... 0x....      BL       _Z10servo_initv
  15956          
  15957            #if HAS_PHOTOGRAPH
  15958              OUT_WRITE(PHOTOGRAPH_PIN, LOW);
  15959            #endif
  15960          
  15961            #if HAS_CASE_LIGHT
  15962              case_light_on = CASE_LIGHT_DEFAULT_ON;
  15963              case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
  15964              update_case_light();
  15965            #endif
  15966          
  15967            #if ENABLED(SPINDLE_LASER_ENABLE)
  15968              OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
  15969              #if SPINDLE_DIR_CHANGE
  15970                OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
  15971              #endif
  15972              #if ENABLED(SPINDLE_LASER_PWM)
  15973                SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
  15974                analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
  15975              #endif
  15976            #endif
  15977          
  15978            #if HAS_BED_PROBE
  15979              endstops.enable_z_probe(false);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x.... 0x....      BL       _ZN8Endstops14enable_z_probeEb
  15980            #endif
  15981          
  15982            #if ENABLED(USE_CONTROLLER_FAN)
  15983              SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
  15984            #endif
  15985          
  15986            #if HAS_STEPPER_RESET
  15987              enableStepperDrivers();
  15988            #endif
  15989          
  15990            #if ENABLED(DIGIPOT_I2C)
  15991              digipot_i2c_init();
  15992            #endif
  15993          
  15994            #if ENABLED(DAC_STEPPER_CURRENT)
  15995              dac_init();
  15996            #endif
  15997          
  15998            #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
  15999              OUT_WRITE(SOL1_PIN, LOW); // turn it off
  16000            #endif
  16001          
  16002            #if HAS_HOME
  16003              SET_INPUT_PULLUP(HOME_PIN);
  16004            #endif
  16005          
  16006            #if PIN_EXISTS(STAT_LED_RED)
  16007              OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
  16008            #endif
  16009          
  16010            #if PIN_EXISTS(STAT_LED_BLUE)
  16011              OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
  16012            #endif
  16013          
  16014            #if HAS_COLOR_LEDS
  16015              leds.setup();
  16016            #endif
  16017          
  16018            #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
  16019              SET_OUTPUT(RGB_LED_R_PIN);
  16020              SET_OUTPUT(RGB_LED_G_PIN);
  16021              SET_OUTPUT(RGB_LED_B_PIN);
  16022              #if ENABLED(RGBW_LED)
  16023                SET_OUTPUT(RGB_LED_W_PIN);
  16024              #endif
  16025            #endif
  16026          
  16027            #if ENABLED(MK2_MULTIPLEXER)
  16028              SET_OUTPUT(E_MUX0_PIN);
  16029              SET_OUTPUT(E_MUX1_PIN);
  16030              SET_OUTPUT(E_MUX2_PIN);
  16031            #endif
  16032          
  16033            #if HAS_FANMUX
  16034              fanmux_init();
  16035            #endif
  16036          
  16037            lcd_init();
   \   000000E8   0x.... 0x....      BL       _Z8lcd_initv
  16038          
  16039            #if ENABLED(SHOW_BOOTSCREEN)
  16040              lcd_bootscreen();
  16041            #endif
  16042          
  16043            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  16044              // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
  16045              for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
  16046                for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  16047                  mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
  16048          
  16049              // Remaining virtual tools are 100% filament 1
  16050              #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
  16051                for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
  16052                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  16053                    mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
  16054              #endif
  16055          
  16056              // Initialize mixing to tool 0 color
  16057              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  16058                mixing_factor[i] = mixing_virtual_tool_mix[0][i];
  16059            #endif
  16060            mksCfg.mkstouch=1;
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xF885 0x0100      STRB     R0,[R5, #+256]
  16061            //#if ENABLED(BLTOUCH)
  16062            if(MKSTOUCH == 1)
  16063            {
  16064              // Make sure any BLTouch error condition is cleared
  16065              bltouch_command(BLTOUCH_RESET);
   \   000000F2   0x20A0             MOVS     R0,#+160
   \   000000F4   0x.... 0x....      BL       _Z15bltouch_commandi
  16066              set_bltouch_deployed(true);
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0x.... 0x....      BL       _Z20set_bltouch_deployedb
  16067              set_bltouch_deployed(false);
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x.... 0x....      BL       _Z20set_bltouch_deployedb
  16068            }
  16069            //#endif
  16070          
  16071            #if ENABLED(I2C_POSITION_ENCODERS)
  16072              I2CPEM.init();
  16073            #endif
  16074          
  16075            #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
  16076              i2c.onReceive(i2c_on_receive);
  16077              i2c.onRequest(i2c_on_request);
  16078            #endif
  16079          
  16080            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
  16081              setup_endstop_interrupts();
  16082            #endif
  16083          
  16084            #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
  16085              move_extruder_servo(0);  // Initialize extruder servo
  16086            #endif
  16087          
  16088            #if ENABLED(SWITCHING_NOZZLE)
  16089              move_nozzle_servo(0);  // Initialize nozzle servo
  16090            #endif
  16091          
  16092            #if ENABLED(PARKING_EXTRUDER)
  16093              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  16094                pe_activate_magnet(0);
  16095                pe_activate_magnet(1);
  16096              #else
  16097                pe_deactivate_magnet(0);
  16098                pe_deactivate_magnet(1);
  16099              #endif
  16100            #endif
  16101            #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
  16102              SET_OUTPUT(LCD_PINS_DC);
  16103              OUT_WRITE(LCD_PINS_RS, LOW);
  16104              delay(1000);
  16105              WRITE(LCD_PINS_RS, HIGH);
  16106            #endif
  16107              display_hold=0;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x72E0             STRB     R0,[R4, #+11]
  16108              display_hold_cnt=0;
   \   00000108   0x63A0             STR      R0,[R4, #+56]
  16109          }
   \   0000010A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  16110          
  16111          /**
  16112           * The main Marlin program loop
  16113           *
  16114           *  - Save or log commands to SD
  16115           *  - Process available commands (if not saving)
  16116           *  - Call heater manager
  16117           *  - Call inactivity manager
  16118           *  - Call endstop manager
  16119           *  - Call LCD update
  16120           */

   \                                 In section .text, align 2, keep-with-next
  16121          void loop() {
   \                     loop: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  16122          #if 1
  16123              //display_sd_error();
  16124          
  16125          	display_temper_error();
   \   00000002   0x.... 0x....      BL       _Z20display_temper_errorv
  16126          	
  16127          	PowerOff_Filament_Check();
   \   00000006   0x.... 0x....      BL       _Z23PowerOff_Filament_Checkv
  16128          	
  16129          	MYSERIAL.MoremenuCmd();
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable192_6
   \   0000000E   0x.... 0x....      BL       _ZN10USARTClass11MoremenuCmdEv
  16130          
  16131          #endif
  16132            if (commands_in_queue < BUFSIZE) get_available_commands();
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable192_3
   \   00000016   0x78A0             LDRB     R0,[R4, #+2]
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xDA01             BGE.N    ??loop_0
   \   0000001C   0x.... 0x....      BL       _Z22get_available_commandsv
  16133          
  16134            #if 0//ENABLED(SDSUPPORT)
  16135              card.checkautostart(false);
  16136            #endif
  16137            card.checkFilesys(gCfgItems.fileSysType);
   \                     ??loop_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable192_2
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable193
   \   00000028   0xF890 0x10BA      LDRB     R1,[R0, #+186]
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       _ZN10CardReader12checkFilesysEh
  16138          
  16139            if (commands_in_queue) {
   \   00000032   0x.... 0x....      LDR.W    R5,??DataTable193_1
   \   00000036   0x78A0             LDRB     R0,[R4, #+2]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD038             BEQ.N    ??loop_1
  16140          
  16141              #if ENABLED(SDSUPPORT)
  16142          
  16143                if (card.saving) {
   \   0000003C   0xF896 0x0761      LDRB     R0,[R6, #+1889]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD025             BEQ.N    ??loop_2
  16144                  char* command = command_queue[cmd_queue_index_r];
   \   00000044   0x79E8             LDRB     R0,[R5, #+7]
   \   00000046   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable195_1
   \   0000004E   0xEB00 0x1741      ADD      R7,R0,R1, LSL #+5
  16145                  if (strstr_P(command, PSTR("M29"))) {
   \   00000052   0x....             ADR.N    R1,??DataTable190_2  ;; "M29"
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       _Z6strstrPcPKc
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD00A             BEQ.N    ??loop_3
  16146                    // M29 closes the file
  16147                    card.closefile();
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x4630             MOV      R0,R6
   \   00000062   0x.... 0x....      BL       _ZN10CardReader9closefileEb
  16148                    SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
   \   00000066   0x.... 0x....      ADR.W    R0,`?<Constant "Done saving file.\\n">`
   \   0000006A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  16149          
  16150                    #if ENABLED(SERIAL_STATS_DROPPED_RX)
  16151                      SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
  16152                    #endif
  16153          
  16154                    #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
  16155                      SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
  16156                    #endif
  16157          
  16158                    ok_to_send();
   \   0000006E   0x.... 0x....      BL       _Z10ok_to_sendv
   \   00000072   0xE00F             B.N      ??loop_4
  16159                  }
  16160                  else {
  16161                    // Write the string from the read buffer to SD
  16162                    card.write_command(command);
   \                     ??loop_3: (+1)
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
  16163                    if (card.logging)
   \   0000007C   0xF896 0x0762      LDRB     R0,[R6, #+1890]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ.N    ??loop_5
  16164                      process_next_command(); // The card is saving because it's logging
   \   00000084   0x.... 0x....      BL       _Z20process_next_commandv
   \   00000088   0xE004             B.N      ??loop_4
  16165                    else
  16166                      ok_to_send();
   \                     ??loop_5: (+1)
   \   0000008A   0x.... 0x....      BL       _Z10ok_to_sendv
   \   0000008E   0xE001             B.N      ??loop_4
  16167                  }
  16168                }
  16169                else
  16170                  process_next_command();
   \                     ??loop_2: (+1)
   \   00000090   0x.... 0x....      BL       _Z20process_next_commandv
  16171          
  16172              #else
  16173          
  16174                process_next_command();
  16175          
  16176              #endif // SDSUPPORT
  16177          
  16178              // The queue may be reset by a command handler or by code invoked by idle() within a handler
  16179              if (commands_in_queue) {
   \                     ??loop_4: (+1)
   \   00000094   0x78A0             LDRB     R0,[R4, #+2]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD009             BEQ.N    ??loop_1
  16180                --commands_in_queue;
   \   0000009A   0x1E40             SUBS     R0,R0,#+1
   \   0000009C   0x70A0             STRB     R0,[R4, #+2]
  16181                if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
   \   0000009E   0x79E8             LDRB     R0,[R5, #+7]
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0x71E8             STRB     R0,[R5, #+7]
   \   000000A4   0xB2C0             UXTB     R0,R0
   \   000000A6   0x2804             CMP      R0,#+4
   \   000000A8   0xDB01             BLT.N    ??loop_1
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x71E8             STRB     R0,[R5, #+7]
  16182              }
  16183            }
  16184            endstops.report_state();
   \                     ??loop_1: (+1)
   \   000000AE   0x.... 0x....      BL       _ZN8Endstops12report_stateEv
  16185            idle();
   \   000000B2   0x.... 0x....      BL       _Z4idlev
  16186            loop_start=1;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x71A8             STRB     R0,[R5, #+6]
  16187            
  16188            mks_PrintStatePolling();
   \   000000BA   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   000000BE   0x.... 0x....      B.W      mks_PrintStatePolling
  16189          }
  16190          #if 1
  16191          uint16_t z_high_count;
  16192          
  16193          extern uint8_t poweroff_det_flg;
  16194          extern uint32_t poweroff_det_cnt;
  16195          extern uint8_t poweroff_det_low_flg;
  16196          extern uint32_t poweroff_det_low_cnt;
  16197          extern uint8_t poweroff_det_high_flg;
  16198          extern uint32_t poweroff_det_high_cnt;
  16199          
  16200          extern uint8_t filament_det1_flg;
  16201          extern uint32_t filament_det1_cnt;
  16202          extern uint8_t filament_det1_low_flg;
  16203          extern uint32_t filament_det1_low_cnt;
  16204          extern uint8_t filament_det1_high_flg;
  16205          extern uint32_t filament_det1_high_cnt;
  16206          extern uint8_t filament_det1_check;
  16207          
  16208          extern uint8_t filament_det2_flg;
  16209          extern uint32_t filament_det2_cnt;
  16210          extern uint8_t filament_det2_low_flg;
  16211          extern uint32_t filament_det2_low_cnt;
  16212          extern uint8_t filament_det2_high_flg;
  16213          extern uint32_t filament_det2_high_cnt;
  16214          extern uint8_t filament_det2_check;
  16215          

   \                                 In section .data, align 4
  16216          uint32_t wifi_loop_cycle = 500;
   \                     wifi_loop_cycle:
   \   00000000   0x000001F4         DC32 500
  16217          extern char wifi_check_time;
  16218          uint8_t wifi_init_flg = 0;
  16219          uint8_t wifi_init_state = 0;
  16220          uint8_t wifi_refresh_flg = 0, cloud_refresh_flg = 0;
  16221          uint8_t waiting_wifi_time = 0;
  16222          
  16223          uint8_t beep_flg = 0;
  16224          uint32_t beep_cnt = 0;
  16225          extern uint8_t print_finish_start_timer;
  16226          extern uint32_t print_finish_timer_count;
  16227          extern uint8_t print_finish_close_machine;
  16228          
  16229          #if 0
  16230          uint8_t btn_flg = 0;
  16231          uint32_t btn_beep_cnt = 0;
  16232          #endif
  16233          extern void mksBeeperAlarm(void);
  16234          

   \                                 In section .text, align 2, keep-with-next
  16235          void Beeper(uint32_t cnt)
  16236          {
  16237              beep_flg = 1;
   \                     _Z6Beeperj: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable193_1
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x744A             STRB     R2,[R1, #+17]
  16238              beep_cnt = cnt;
   \   00000008   0x63C8             STR      R0,[R1, #+60]
  16239              BEEPER_OP = 1;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable196  ;; 0x42220194
   \   00000010   0x6008             STR      R0,[R1, #+0]
  16240          }
   \   00000012   0x4770             BX       LR               ;; return
  16241          

   \                                 In section .text, align 2, keep-with-next
  16242          void SysTick_Handler_User()
  16243          {
   \                     _Z20SysTick_Handler_Userv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
  16244          		TimeIncrease++;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable193_1
   \   00000008   0x6AA0             LDR      R0,[R4, #+40]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \   0000000C   0x62A0             STR      R0,[R4, #+40]
  16245          
  16246          
  16247          		if(filament_loading_time_flg == 1)
   \   0000000E   0xF44F 0x757A      MOV      R5,#+1000
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD131             BNE.N    ??SysTick_Handler_User_0
  16248          		{
  16249          			filament_loading_time_cnt++;
   \   00000018   0x6A20             LDR      R0,[R4, #+32]
   \   0000001A   0x1C46             ADDS     R6,R0,#+1
   \   0000001C   0x6226             STR      R6,[R4, #+32]
  16250          			filament_rate = (uint32_t)(((filament_loading_time_cnt/(gCfgItems.filament_loading_time*1000.0))*100.0)+0.5);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable194
   \   00000022   0xF8D0 0x70F4      LDR      R7,[R0, #+244]
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       __aeabi_ui2d
   \   0000002C   0x4680             MOV      R8,R0
   \   0000002E   0x4689             MOV      R9,R1
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       __aeabi_ui2d
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x.... 0x....      LDR.W    R3,??DataTable196_1  ;; 0x408f4000
   \   0000003C   0x.... 0x....      BL       __aeabi_dmul
   \   00000040   0x4602             MOV      R2,R0
   \   00000042   0x460B             MOV      R3,R1
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x4649             MOV      R1,R9
   \   00000048   0x.... 0x....      BL       __aeabi_ddiv
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x.... 0x....      LDR.W    R3,??DataTable196_2  ;; 0x40590000
   \   00000052   0x.... 0x....      BL       __aeabi_dmul
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x.... 0x....      LDR.W    R3,??DataTable196_3  ;; 0x3fe00000
   \   0000005C   0x.... 0x....      BL       __aeabi_dadd
   \   00000060   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable196_4
   \   00000068   0x6008             STR      R0,[R1, #+0]
  16251          			if(filament_loading_time_cnt >= (gCfgItems.filament_loading_time*1000))
   \   0000006A   0xFB05 0xF007      MUL      R0,R5,R7
   \   0000006E   0x4286             CMP      R6,R0
   \   00000070   0xD304             BCC.N    ??SysTick_Handler_User_0
  16252          			{
  16253          				filament_loading_time_cnt = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6220             STR      R0,[R4, #+32]
  16254          				filament_loading_time_flg = 0;
   \   00000076   0x7020             STRB     R0,[R4, #+0]
  16255          				filament_loading_completed = 1;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7060             STRB     R0,[R4, #+1]
  16256          			}
  16257          		}
  16258          		if(filament_unloading_time_flg == 1)
   \                     ??SysTick_Handler_User_0: (+1)
   \   0000007C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD134             BNE.N    ??SysTick_Handler_User_1
  16259          		{
  16260          			filament_unloading_time_cnt++;
   \   00000082   0x6A60             LDR      R0,[R4, #+36]
   \   00000084   0x1C46             ADDS     R6,R0,#+1
   \   00000086   0x6266             STR      R6,[R4, #+36]
  16261          			filament_rate = (uint32_t)(((filament_unloading_time_cnt/(gCfgItems.filament_unloading_time*1000.0))*100.0)+0.5);
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable194
   \   0000008C   0x30F4             ADDS     R0,R0,#+244
   \   0000008E   0xF8D0 0x8004      LDR      R8,[R0, #+4]
   \   00000092   0x.... 0x....      LDR.W    R7,??DataTable196_4
   \   00000096   0x4630             MOV      R0,R6
   \   00000098   0x.... 0x....      BL       __aeabi_ui2d
   \   0000009C   0x4682             MOV      R10,R0
   \   0000009E   0x468B             MOV      R11,R1
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       __aeabi_ui2d
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x.... 0x....      LDR.W    R3,??DataTable196_1  ;; 0x408f4000
   \   000000AC   0x.... 0x....      BL       __aeabi_dmul
   \   000000B0   0x4602             MOV      R2,R0
   \   000000B2   0x460B             MOV      R3,R1
   \   000000B4   0x4650             MOV      R0,R10
   \   000000B6   0x4659             MOV      R1,R11
   \   000000B8   0x.... 0x....      BL       __aeabi_ddiv
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x.... 0x....      LDR.W    R3,??DataTable196_2  ;; 0x40590000
   \   000000C2   0x.... 0x....      BL       __aeabi_dmul
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0x.... 0x....      LDR.W    R3,??DataTable196_3  ;; 0x3fe00000
   \   000000CC   0x.... 0x....      BL       __aeabi_dadd
   \   000000D0   0x.... 0x....      BL       __aeabi_d2uiz
   \   000000D4   0x6038             STR      R0,[R7, #+0]
  16262          			if(filament_unloading_time_cnt >= (gCfgItems.filament_unloading_time*1000))
   \   000000D6   0xFB05 0xF008      MUL      R0,R5,R8
   \   000000DA   0x4286             CMP      R6,R0
   \   000000DC   0xD306             BCC.N    ??SysTick_Handler_User_1
  16263          			{
  16264          				filament_unloading_time_cnt = 0;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x6260             STR      R0,[R4, #+36]
  16265          				filament_unloading_time_flg = 0;
   \   000000E2   0x70A0             STRB     R0,[R4, #+2]
  16266          				filament_unloading_completed = 1;
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x70E0             STRB     R0,[R4, #+3]
  16267          				filament_rate = 100;
   \   000000E8   0x2064             MOVS     R0,#+100
   \   000000EA   0x6038             STR      R0,[R7, #+0]
  16268          			}
  16269          		}	
  16270          	
  16271          		temperature_change_frequency_cnt++;
   \                     ??SysTick_Handler_User_1: (+1)
   \   000000EC   0x69E0             LDR      R0,[R4, #+28]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x61E0             STR      R0,[R4, #+28]
  16272          		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
   \   000000F2   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   000000F6   0xD308             BCC.N    ??SysTick_Handler_User_2
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable196_5
   \   000000FC   0x7801             LDRB     R1,[R0, #+0]
   \   000000FE   0x2901             CMP      R1,#+1
   \   00000100   0xD003             BEQ.N    ??SysTick_Handler_User_2
  16273          		{
  16274          			temperature_change_frequency_cnt = 0;
   \   00000102   0x2100             MOVS     R1,#+0
   \   00000104   0x61E1             STR      R1,[R4, #+28]
  16275          			temperature_change_frequency = 1;
   \   00000106   0x2101             MOVS     R1,#+1
   \   00000108   0x7001             STRB     R1,[R0, #+0]
  16276          		}
  16277          		
  16278          		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
   \                     ??SysTick_Handler_User_2: (+1)
   \   0000010A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000010C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000110   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000114   0xF640 0x32B8      MOVW     R2,#+3000
   \   00000118   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD101             BNE.N    ??SysTick_Handler_User_3
  16279          		{		
  16280          			printing_rate_update_flag = 1;
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x7120             STRB     R0,[R4, #+4]
  16281          		}	
  16282          
  16283          		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
   \                     ??SysTick_Handler_User_3: (+1)
   \   00000124   0x6AA0             LDR      R0,[R4, #+40]
   \   00000126   0x4629             MOV      R1,R5
   \   00000128   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000012C   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD10B             BNE.N    ??SysTick_Handler_User_4
  16284          		{		
  16285          			if(print_time.start == 1)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable196_6
   \   00000138   0xF990 0x1007      LDRSB    R1,[R0, #+7]
   \   0000013C   0x2901             CMP      R1,#+1
   \   0000013E   0xD102             BNE.N    ??SysTick_Handler_User_5
  16286          			{
  16287          				print_time.seconds++;
   \   00000140   0x7941             LDRB     R1,[R0, #+5]
   \   00000142   0x1C49             ADDS     R1,R1,#+1
   \   00000144   0x7141             STRB     R1,[R0, #+5]
  16288          			}
  16289          			display_hold_cnt++;
   \                     ??SysTick_Handler_User_5: (+1)
   \   00000146   0x6BA0             LDR      R0,[R4, #+56]
   \   00000148   0x1C40             ADDS     R0,R0,#+1
   \   0000014A   0x63A0             STR      R0,[R4, #+56]
  16290          		}
  16291          		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
   \                     ??SysTick_Handler_User_4: (+1)
   \   0000014C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000014E   0x4629             MOV      R1,R5
   \   00000150   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000154   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD101             BNE.N    ??SysTick_Handler_User_6
  16292          		{
  16293          			z_high_count=1;
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0x8320             STRH     R0,[R4, #+24]
  16294          		}
  16295          
  16296          	if(poweroff_det_flg==1)
   \                     ??SysTick_Handler_User_6: (+1)
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable196_7
   \   00000164   0x7800             LDRB     R0,[R0, #+0]
   \   00000166   0x2801             CMP      R0,#+1
   \   00000168   0xD104             BNE.N    ??SysTick_Handler_User_7
  16297          	{
  16298          		poweroff_det_cnt++;
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable196_8
   \   0000016E   0x6801             LDR      R1,[R0, #+0]
   \   00000170   0x1C49             ADDS     R1,R1,#+1
   \   00000172   0x6001             STR      R1,[R0, #+0]
  16299          	}
  16300          		
  16301          	if(filament_det1_flg==1)
   \                     ??SysTick_Handler_User_7: (+1)
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable196_9
   \   00000178   0x7800             LDRB     R0,[R0, #+0]
   \   0000017A   0x2801             CMP      R0,#+1
   \   0000017C   0xD104             BNE.N    ??SysTick_Handler_User_8
  16302          	{
  16303          		filament_det1_cnt++;
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable197
   \   00000182   0x6801             LDR      R1,[R0, #+0]
   \   00000184   0x1C49             ADDS     R1,R1,#+1
   \   00000186   0x6001             STR      R1,[R0, #+0]
  16304          	}
  16305          
  16306          	if(filament_det1_low_flg==1)
   \                     ??SysTick_Handler_User_8: (+1)
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable197_1
   \   0000018C   0x7800             LDRB     R0,[R0, #+0]
   \   0000018E   0x2801             CMP      R0,#+1
   \   00000190   0xD104             BNE.N    ??SysTick_Handler_User_9
  16307          	{
  16308          		filament_det1_low_cnt++;
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable197_2
   \   00000196   0x6801             LDR      R1,[R0, #+0]
   \   00000198   0x1C49             ADDS     R1,R1,#+1
   \   0000019A   0x6001             STR      R1,[R0, #+0]
  16309          	}
  16310          
  16311          	if(filament_det1_high_flg==1)
   \                     ??SysTick_Handler_User_9: (+1)
   \   0000019C   0x.... 0x....      LDR.W    R0,??DataTable197_3
   \   000001A0   0x7800             LDRB     R0,[R0, #+0]
   \   000001A2   0x2801             CMP      R0,#+1
   \   000001A4   0xD104             BNE.N    ??SysTick_Handler_User_10
  16312          	{
  16313          		filament_det1_high_cnt++;
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable197_4
   \   000001AA   0x6801             LDR      R1,[R0, #+0]
   \   000001AC   0x1C49             ADDS     R1,R1,#+1
   \   000001AE   0x6001             STR      R1,[R0, #+0]
  16314          	}
  16315          	if(filament_det2_flg==1)
   \                     ??SysTick_Handler_User_10: (+1)
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable198
   \   000001B4   0x7800             LDRB     R0,[R0, #+0]
   \   000001B6   0x2801             CMP      R0,#+1
   \   000001B8   0xD104             BNE.N    ??SysTick_Handler_User_11
  16316          	{
  16317          		filament_det2_cnt++;
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable198_1
   \   000001BE   0x6801             LDR      R1,[R0, #+0]
   \   000001C0   0x1C49             ADDS     R1,R1,#+1
   \   000001C2   0x6001             STR      R1,[R0, #+0]
  16318          	}
  16319          
  16320          	if(filament_det2_low_flg==1)
   \                     ??SysTick_Handler_User_11: (+1)
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable198_2
   \   000001C8   0x7800             LDRB     R0,[R0, #+0]
   \   000001CA   0x2801             CMP      R0,#+1
   \   000001CC   0xD104             BNE.N    ??SysTick_Handler_User_12
  16321          	{
  16322          		filament_det2_low_cnt++;
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable198_3
   \   000001D2   0x6801             LDR      R1,[R0, #+0]
   \   000001D4   0x1C49             ADDS     R1,R1,#+1
   \   000001D6   0x6001             STR      R1,[R0, #+0]
  16323          	}
  16324          
  16325          	if(filament_det2_high_flg==1)
   \                     ??SysTick_Handler_User_12: (+1)
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable198_4
   \   000001DC   0x7800             LDRB     R0,[R0, #+0]
   \   000001DE   0x2801             CMP      R0,#+1
   \   000001E0   0xD104             BNE.N    ??SysTick_Handler_User_13
  16326          	{
  16327          		filament_det2_high_cnt++;
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable198_5
   \   000001E6   0x6801             LDR      R1,[R0, #+0]
   \   000001E8   0x1C49             ADDS     R1,R1,#+1
   \   000001EA   0x6001             STR      R1,[R0, #+0]
  16328          	}
  16329          
  16330          	if(poweroff_det_low_flg==1)
   \                     ??SysTick_Handler_User_13: (+1)
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable199
   \   000001F0   0x7800             LDRB     R0,[R0, #+0]
   \   000001F2   0x2801             CMP      R0,#+1
   \   000001F4   0xD104             BNE.N    ??SysTick_Handler_User_14
  16331          	{
  16332          		poweroff_det_low_cnt++;
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable199_1
   \   000001FA   0x6801             LDR      R1,[R0, #+0]
   \   000001FC   0x1C49             ADDS     R1,R1,#+1
   \   000001FE   0x6001             STR      R1,[R0, #+0]
  16333          	}
  16334          	
  16335          	if(poweroff_det_high_flg==1)
   \                     ??SysTick_Handler_User_14: (+1)
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable199_2
   \   00000204   0x7800             LDRB     R0,[R0, #+0]
   \   00000206   0x2801             CMP      R0,#+1
   \   00000208   0xD104             BNE.N    ??SysTick_Handler_User_15
  16336          	{
  16337          		poweroff_det_high_cnt++;
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable199_3
   \   0000020E   0x6801             LDR      R1,[R0, #+0]
   \   00000210   0x1C49             ADDS     R1,R1,#+1
   \   00000212   0x6001             STR      R1,[R0, #+0]
  16338          	}		
  16339          
  16340          	if(!(TimeIncrease * TICK_CYCLE % 5000))	//5s
   \                     ??SysTick_Handler_User_15: (+1)
   \   00000214   0x6AA0             LDR      R0,[R4, #+40]
   \   00000216   0xF241 0x3188      MOVW     R1,#+5000
   \   0000021A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000021E   0xF241 0x3288      MOVW     R2,#+5000
   \   00000222   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD11E             BNE.N    ??SysTick_Handler_User_16
  16341          	{
  16342          		wifi_check_time = 1;
   \   0000022A   0x2001             MOVS     R0,#+1
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable199_4
   \   00000230   0x7008             STRB     R0,[R1, #+0]
  16343          		waiting_wifi_time ++;
   \   00000232   0x7C20             LDRB     R0,[R4, #+16]
   \   00000234   0x1C40             ADDS     R0,R0,#+1
   \   00000236   0x7420             STRB     R0,[R4, #+16]
  16344          		if((waiting_wifi_time == 8) || (gCfgItems.wifi_type == ESP_WIFI))//40s
   \   00000238   0xB2C0             UXTB     R0,R0
   \   0000023A   0x2808             CMP      R0,#+8
   \   0000023C   0xD005             BEQ.N    ??SysTick_Handler_User_17
   \   0000023E   0x.... 0x....      LDR.W    R0,??DataTable194
   \   00000242   0xF890 0x022C      LDRB     R0,[R0, #+556]
   \   00000246   0x2802             CMP      R0,#+2
   \   00000248   0xD104             BNE.N    ??SysTick_Handler_User_18
  16345          		{
  16346          			if(wifi_init_flg == 0)
   \                     ??SysTick_Handler_User_17: (+1)
   \   0000024A   0x7B60             LDRB     R0,[R4, #+13]
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xD101             BNE.N    ??SysTick_Handler_User_18
  16347          			{
  16348          				wifi_init_flg = 1;
   \   00000250   0x2001             MOVS     R0,#+1
   \   00000252   0x7360             STRB     R0,[R4, #+13]
  16349          			}
  16350          			
  16351          		}
  16352          		if(wifi_refresh_flg == 0)
   \                     ??SysTick_Handler_User_18: (+1)
   \   00000254   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000256   0x2800             CMP      R0,#+0
   \   00000258   0xD101             BNE.N    ??SysTick_Handler_User_19
  16353          			wifi_refresh_flg = 1;
   \   0000025A   0x2001             MOVS     R0,#+1
   \   0000025C   0x73A0             STRB     R0,[R4, #+14]
  16354          		
  16355          		if(cloud_refresh_flg == 0)
   \                     ??SysTick_Handler_User_19: (+1)
   \   0000025E   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xD101             BNE.N    ??SysTick_Handler_User_16
  16356          			cloud_refresh_flg = 1;
   \   00000264   0x2001             MOVS     R0,#+1
   \   00000266   0x73E0             STRB     R0,[R4, #+15]
  16357          
  16358          	}
  16359          	
  16360          
  16361          	mksBeeperAlarm();
   \                     ??SysTick_Handler_User_16: (+1)
   \   00000268   0x.... 0x....      BL       _Z14mksBeeperAlarmv
  16362          
  16363              if(beep_flg == 1)
   \   0000026C   0x7C60             LDRB     R0,[R4, #+17]
   \   0000026E   0x2801             CMP      R0,#+1
   \   00000270   0xD108             BNE.N    ??SysTick_Handler_User_20
  16364              {
  16365                  beep_cnt--;
   \   00000272   0x6BE0             LDR      R0,[R4, #+60]
   \   00000274   0x1E40             SUBS     R0,R0,#+1
   \   00000276   0x63E0             STR      R0,[R4, #+60]
  16366                  if(beep_cnt<=0)
   \   00000278   0xD104             BNE.N    ??SysTick_Handler_User_20
  16367                  {
  16368                     beep_flg = 0;
   \   0000027A   0x2000             MOVS     R0,#+0
   \   0000027C   0x7460             STRB     R0,[R4, #+17]
  16369                     BEEPER_OP = 0; 
   \   0000027E   0x.... 0x....      LDR.W    R1,??DataTable196  ;; 0x42220194
   \   00000282   0x6008             STR      R0,[R1, #+0]
  16370                  }
  16371              }    
  16372          #if 0
  16373              if(btn_flg == 1)
  16374              {
  16375                  btn_beep_cnt--;
  16376                  if(btn_beep_cnt<=0)
  16377                  {
  16378                     btn_flg = 0;
  16379                     BEEPER_OP = 0; 
  16380                  }
  16381              }
  16382              #endif
  16383          	if(print_finish_start_timer==TIMER_START)
   \                     ??SysTick_Handler_User_20: (+1)
   \   00000284   0x7CA0             LDRB     R0,[R4, #+18]
   \   00000286   0x2801             CMP      R0,#+1
   \   00000288   0xD10E             BNE.N    ??SysTick_Handler_User_21
  16384          	{
  16385          		print_finish_timer_count++;
   \   0000028A   0x6C20             LDR      R0,[R4, #+64]
   \   0000028C   0x1C40             ADDS     R0,R0,#+1
   \   0000028E   0x6420             STR      R0,[R4, #+64]
  16386          		if(print_finish_timer_count>=gCfgItems.print_finish_count*1000)
   \   00000290   0x.... 0x....      LDR.W    R1,??DataTable194
   \   00000294   0xF8B1 0x12A0      LDRH     R1,[R1, #+672]
   \   00000298   0x4369             MULS     R1,R5,R1
   \   0000029A   0x4288             CMP      R0,R1
   \   0000029C   0xD304             BCC.N    ??SysTick_Handler_User_21
  16387          		{
  16388          			print_finish_start_timer=TIMER_STOP;
   \   0000029E   0x2000             MOVS     R0,#+0
   \   000002A0   0x74A0             STRB     R0,[R4, #+18]
  16389          			print_finish_timer_count=0;
   \   000002A2   0x6420             STR      R0,[R4, #+64]
  16390          			print_finish_close_machine=true;
   \   000002A4   0x2001             MOVS     R0,#+1
   \   000002A6   0x74E0             STRB     R0,[R4, #+19]
  16391          		}
  16392          	}
  16393          }
   \                     ??SysTick_Handler_User_21: (+1)
   \   000002A8   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  16394          #endif
  16395          
  16396          #include "mks_reprint.cpp"

   \                                 In section .data, align 4
   \   __absolute char *mks_pft_name
   \                     mks_pft_name:
   \   00000000   0x........         DC32 `?<Constant "mks_pft.sys">`

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_load()
   \                     mkstft_ui_load: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable194
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x1D21             ADDS     R1,R4,#+4
   \   0000000A   0xF240 0x609E      MOVW     R0,#+1694
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000018   0xF240 0x60A2      MOVW     R0,#+1698
   \   0000001C   0x.... 0x....      BL       epr_read_data
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF104 0x010C      ADD      R1,R4,#+12
   \   00000026   0xF240 0x60A6      MOVW     R0,#+1702
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xF104 0x0110      ADD      R1,R4,#+16
   \   00000034   0xF240 0x60AA      MOVW     R0,#+1706
   \   00000038   0x.... 0x....      BL       epr_read_data
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000042   0xF240 0x60AE      MOVW     R0,#+1710
   \   00000046   0x.... 0x....      BL       epr_read_data
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF104 0x0114      ADD      R1,R4,#+20
   \   00000050   0xF240 0x60B2      MOVW     R0,#+1714
   \   00000054   0x.... 0x....      BL       epr_read_data
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0xF104 0x0124      ADD      R1,R4,#+36
   \   0000005E   0xF240 0x60B6      MOVW     R0,#+1718
   \   00000062   0x.... 0x....      BL       epr_read_data
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0xF104 0x0128      ADD      R1,R4,#+40
   \   0000006C   0xF240 0x60BA      MOVW     R0,#+1722
   \   00000070   0x.... 0x....      BL       epr_read_data
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000007A   0xF240 0x60BE      MOVW     R0,#+1726
   \   0000007E   0x.... 0x....      BL       epr_read_data
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xF104 0x0130      ADD      R1,R4,#+48
   \   00000088   0xF240 0x60C2      MOVW     R0,#+1730
   \   0000008C   0x.... 0x....      BL       epr_read_data
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF104 0x013C      ADD      R1,R4,#+60
   \   00000096   0xF240 0x60C6      MOVW     R0,#+1734
   \   0000009A   0x.... 0x....      BL       epr_read_data
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0xF104 0x0140      ADD      R1,R4,#+64
   \   000000A4   0xF240 0x60CA      MOVW     R0,#+1738
   \   000000A8   0x.... 0x....      BL       epr_read_data
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xF104 0x0134      ADD      R1,R4,#+52
   \   000000B2   0xF240 0x60CE      MOVW     R0,#+1742
   \   000000B6   0x.... 0x....      BL       epr_read_data
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xF104 0x0138      ADD      R1,R4,#+56
   \   000000C0   0xF240 0x60D2      MOVW     R0,#+1746
   \   000000C4   0x.... 0x....      BL       epr_read_data
   \   000000C8   0x2204             MOVS     R2,#+4
   \   000000CA   0xF104 0x0154      ADD      R1,R4,#+84
   \   000000CE   0xF240 0x60D6      MOVW     R0,#+1750
   \   000000D2   0x.... 0x....      BL       epr_read_data
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF104 0x0158      ADD      R1,R4,#+88
   \   000000DC   0xF240 0x60DA      MOVW     R0,#+1754
   \   000000E0   0x.... 0x....      BL       epr_read_data
   \   000000E4   0x2201             MOVS     R2,#+1
   \   000000E6   0xF204 0x11BF      ADDW     R1,R4,#+447
   \   000000EA   0xF240 0x60DE      MOVW     R0,#+1758
   \   000000EE   0x.... 0x....      BL       epr_read_data
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0xF104 0x01B8      ADD      R1,R4,#+184
   \   000000F8   0xF240 0x60DF      MOVW     R0,#+1759
   \   000000FC   0x.... 0x....      BL       epr_read_data
   \   00000100   0x2201             MOVS     R2,#+1
   \   00000102   0xF104 0x01D4      ADD      R1,R4,#+212
   \   00000106   0xF240 0x7002      MOVW     R0,#+1794
   \   0000010A   0x.... 0x....      BL       epr_read_data
   \   0000010E   0x2204             MOVS     R2,#+4
   \   00000110   0xF104 0x01E4      ADD      R1,R4,#+228
   \   00000114   0xF44F 0x60DD      MOV      R0,#+1768
   \   00000118   0x.... 0x....      BL       epr_read_data
   \   0000011C   0x2204             MOVS     R2,#+4
   \   0000011E   0xF104 0x01DC      ADD      R1,R4,#+220
   \   00000122   0xF240 0x60EC      MOVW     R0,#+1772
   \   00000126   0x.... 0x....      BL       epr_read_data
   \   0000012A   0x2204             MOVS     R2,#+4
   \   0000012C   0xF104 0x01EC      ADD      R1,R4,#+236
   \   00000130   0xF44F 0x60DE      MOV      R0,#+1776
   \   00000134   0x.... 0x....      BL       epr_read_data
   \   00000138   0x2204             MOVS     R2,#+4
   \   0000013A   0xF104 0x01E8      ADD      R1,R4,#+232
   \   0000013E   0xF240 0x60F4      MOVW     R0,#+1780
   \   00000142   0x.... 0x....      BL       epr_read_data
   \   00000146   0x2204             MOVS     R2,#+4
   \   00000148   0xF104 0x01E0      ADD      R1,R4,#+224
   \   0000014C   0xF44F 0x60DF      MOV      R0,#+1784
   \   00000150   0x.... 0x....      BL       epr_read_data
   \   00000154   0x2204             MOVS     R2,#+4
   \   00000156   0xF104 0x01F0      ADD      R1,R4,#+240
   \   0000015A   0xF240 0x60FC      MOVW     R0,#+1788
   \   0000015E   0x.... 0x....      BL       epr_read_data
   \   00000162   0x2201             MOVS     R2,#+1
   \   00000164   0xF104 0x01D5      ADD      R1,R4,#+213
   \   00000168   0xF240 0x7001      MOVW     R0,#+1793
   \   0000016C   0x.... 0x....      BL       epr_read_data
   \   00000170   0x2201             MOVS     R2,#+1
   \   00000172   0xF204 0x2195      ADDW     R1,R4,#+661
   \   00000176   0xF240 0x7005      MOVW     R0,#+1797
   \   0000017A   0x.... 0x....      BL       epr_read_data
   \   0000017E   0x2201             MOVS     R2,#+1
   \   00000180   0xF504 0x71DE      ADD      R1,R4,#+444
   \   00000184   0xF240 0x7007      MOVW     R0,#+1799
   \   00000188   0x.... 0x....      BL       epr_read_data
   \   0000018C   0x2201             MOVS     R2,#+1
   \   0000018E   0xF104 0x01CD      ADD      R1,R4,#+205
   \   00000192   0xF44F 0x60E1      MOV      R0,#+1800
   \   00000196   0x.... 0x....      BL       epr_read_data
   \   0000019A   0x2201             MOVS     R2,#+1
   \   0000019C   0xF204 0x11BD      ADDW     R1,R4,#+445
   \   000001A0   0xF240 0x7009      MOVW     R0,#+1801
   \   000001A4   0x.... 0x....      BL       epr_read_data
   \   000001A8   0x2201             MOVS     R2,#+1
   \   000001AA   0xF504 0x71DF      ADD      R1,R4,#+446
   \   000001AE   0xF240 0x700A      MOVW     R0,#+1802
   \   000001B2   0x.... 0x....      BL       epr_read_data
   \   000001B6   0x2201             MOVS     R2,#+1
   \   000001B8   0xF504 0x71E5      ADD      R1,R4,#+458
   \   000001BC   0xF240 0x700B      MOVW     R0,#+1803
   \   000001C0   0x.... 0x....      BL       epr_read_data
   \   000001C4   0x2201             MOVS     R2,#+1
   \   000001C6   0xF104 0x01FC      ADD      R1,R4,#+252
   \   000001CA   0xF240 0x700C      MOVW     R0,#+1804
   \   000001CE   0x.... 0x....      BL       epr_read_data
   \   000001D2   0x2201             MOVS     R2,#+1
   \   000001D4   0xF104 0x01FD      ADD      R1,R4,#+253
   \   000001D8   0xF240 0x700D      MOVW     R0,#+1805
   \   000001DC   0x.... 0x....      BL       epr_read_data
   \   000001E0   0x2202             MOVS     R2,#+2
   \   000001E2   0xF104 0x01FE      ADD      R1,R4,#+254
   \   000001E6   0xF240 0x700E      MOVW     R0,#+1806
   \   000001EA   0x.... 0x....      BL       epr_read_data
   \   000001EE   0x2202             MOVS     R2,#+2
   \   000001F0   0xF504 0x7180      ADD      R1,R4,#+256
   \   000001F4   0xF44F 0x60E2      MOV      R0,#+1808
   \   000001F8   0x.... 0x....      BL       epr_read_data
   \   000001FC   0x2202             MOVS     R2,#+2
   \   000001FE   0xF504 0x7181      ADD      R1,R4,#+258
   \   00000202   0xF240 0x7012      MOVW     R0,#+1810
   \   00000206   0x.... 0x....      BL       epr_read_data
   \   0000020A   0x2202             MOVS     R2,#+2
   \   0000020C   0xF504 0x7182      ADD      R1,R4,#+260
   \   00000210   0xF240 0x7014      MOVW     R0,#+1812
   \   00000214   0x.... 0x....      BL       epr_read_data
   \   00000218   0x2202             MOVS     R2,#+2
   \   0000021A   0xF504 0x7183      ADD      R1,R4,#+262
   \   0000021E   0xF240 0x7016      MOVW     R0,#+1814
   \   00000222   0x.... 0x....      BL       epr_read_data
   \   00000226   0x2202             MOVS     R2,#+2
   \   00000228   0xF504 0x7184      ADD      R1,R4,#+264
   \   0000022C   0xF44F 0x60E3      MOV      R0,#+1816
   \   00000230   0x.... 0x....      BL       epr_read_data
   \   00000234   0x2202             MOVS     R2,#+2
   \   00000236   0xF504 0x7185      ADD      R1,R4,#+266
   \   0000023A   0xF240 0x701A      MOVW     R0,#+1818
   \   0000023E   0x.... 0x....      BL       epr_read_data
   \   00000242   0x2202             MOVS     R2,#+2
   \   00000244   0xF504 0x7186      ADD      R1,R4,#+268
   \   00000248   0xF240 0x701C      MOVW     R0,#+1820
   \   0000024C   0x.... 0x....      BL       epr_read_data
   \   00000250   0x2202             MOVS     R2,#+2
   \   00000252   0xF504 0x7187      ADD      R1,R4,#+270
   \   00000256   0xF240 0x701E      MOVW     R0,#+1822
   \   0000025A   0x.... 0x....      BL       epr_read_data
   \   0000025E   0x2202             MOVS     R2,#+2
   \   00000260   0xF504 0x7188      ADD      R1,R4,#+272
   \   00000264   0xF44F 0x60E4      MOV      R0,#+1824
   \   00000268   0x.... 0x....      BL       epr_read_data
   \   0000026C   0x2201             MOVS     R2,#+1
   \   0000026E   0xF104 0x01D9      ADD      R1,R4,#+217
   \   00000272   0xF240 0x7022      MOVW     R0,#+1826
   \   00000276   0x.... 0x....      BL       epr_read_data
   \   0000027A   0x2201             MOVS     R2,#+1
   \   0000027C   0xF204 0x212D      ADDW     R1,R4,#+557
   \   00000280   0xF240 0x7023      MOVW     R0,#+1827
   \   00000284   0x.... 0x....      BL       epr_read_data
   \   00000288   0x2201             MOVS     R2,#+1
   \   0000028A   0xF504 0x7127      ADD      R1,R4,#+668
   \   0000028E   0xF240 0x702C      MOVW     R0,#+1836
   \   00000292   0x.... 0x....      BL       epr_read_data
   \   00000296   0x2201             MOVS     R2,#+1
   \   00000298   0xF204 0x219D      ADDW     R1,R4,#+669
   \   0000029C   0xF240 0x702D      MOVW     R0,#+1837
   \   000002A0   0x.... 0x....      BL       epr_read_data
   \   000002A4   0x2201             MOVS     R2,#+1
   \   000002A6   0xF204 0x219E      ADDW     R1,R4,#+670
   \   000002AA   0xF240 0x702E      MOVW     R0,#+1838
   \   000002AE   0x.... 0x....      BL       epr_read_data
   \   000002B2   0x2201             MOVS     R2,#+1
   \   000002B4   0xF204 0x21A2      ADDW     R1,R4,#+674
   \   000002B8   0xF240 0x7031      MOVW     R0,#+1841
   \   000002BC   0x.... 0x....      BL       epr_read_data
   \   000002C0   0x2204             MOVS     R2,#+4
   \   000002C2   0xF504 0x7129      ADD      R1,R4,#+676
   \   000002C6   0xF240 0x7032      MOVW     R0,#+1842
   \   000002CA   0x.... 0x....      BL       epr_read_data
   \   000002CE   0x2202             MOVS     R2,#+2
   \   000002D0   0xF504 0x7128      ADD      R1,R4,#+672
   \   000002D4   0xF240 0x702F      MOVW     R0,#+1839
   \   000002D8   0xE8BD 0x4010      POP      {R4,LR}
   \   000002DC   0x.... 0x....      B.W      epr_read_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_set_epr()
   \                     _Z17mkstft_ui_set_eprv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0xF240 0x54AA      MOVW     R4,#+1450
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable200  ;; 0x76313030
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x42A8             CMP      R0,R5
   \   0000001A   0xF000 0x8173      BEQ.W    ??mkstft_ui_set_epr_0
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable194
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x1D31             ADDS     R1,R6,#+4
   \   00000026   0xF240 0x609E      MOVW     R0,#+1694
   \   0000002A   0x.... 0x....      BL       epr_write_data
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xF106 0x0108      ADD      R1,R6,#+8
   \   00000034   0xF240 0x60A2      MOVW     R0,#+1698
   \   00000038   0x.... 0x....      BL       epr_write_data
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0xF106 0x010C      ADD      R1,R6,#+12
   \   00000042   0xF240 0x60A6      MOVW     R0,#+1702
   \   00000046   0x.... 0x....      BL       epr_write_data
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF106 0x0110      ADD      R1,R6,#+16
   \   00000050   0xF240 0x60AA      MOVW     R0,#+1706
   \   00000054   0x.... 0x....      BL       epr_write_data
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0xF106 0x0118      ADD      R1,R6,#+24
   \   0000005E   0xF240 0x60AE      MOVW     R0,#+1710
   \   00000062   0x.... 0x....      BL       epr_write_data
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0xF106 0x0114      ADD      R1,R6,#+20
   \   0000006C   0xF240 0x60B2      MOVW     R0,#+1714
   \   00000070   0x.... 0x....      BL       epr_write_data
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xF106 0x0124      ADD      R1,R6,#+36
   \   0000007A   0xF240 0x60B6      MOVW     R0,#+1718
   \   0000007E   0x.... 0x....      BL       epr_write_data
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xF106 0x0128      ADD      R1,R6,#+40
   \   00000088   0xF240 0x60BA      MOVW     R0,#+1722
   \   0000008C   0x.... 0x....      BL       epr_write_data
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF106 0x012C      ADD      R1,R6,#+44
   \   00000096   0xF240 0x60BE      MOVW     R0,#+1726
   \   0000009A   0x.... 0x....      BL       epr_write_data
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0xF106 0x0130      ADD      R1,R6,#+48
   \   000000A4   0xF240 0x60C2      MOVW     R0,#+1730
   \   000000A8   0x.... 0x....      BL       epr_write_data
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xF106 0x013C      ADD      R1,R6,#+60
   \   000000B2   0xF240 0x60C6      MOVW     R0,#+1734
   \   000000B6   0x.... 0x....      BL       epr_write_data
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xF106 0x0140      ADD      R1,R6,#+64
   \   000000C0   0xF240 0x60CA      MOVW     R0,#+1738
   \   000000C4   0x.... 0x....      BL       epr_write_data
   \   000000C8   0x2204             MOVS     R2,#+4
   \   000000CA   0xF106 0x0134      ADD      R1,R6,#+52
   \   000000CE   0xF240 0x60CE      MOVW     R0,#+1742
   \   000000D2   0x.... 0x....      BL       epr_write_data
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF106 0x0138      ADD      R1,R6,#+56
   \   000000DC   0xF240 0x60D2      MOVW     R0,#+1746
   \   000000E0   0x.... 0x....      BL       epr_write_data
   \   000000E4   0x2204             MOVS     R2,#+4
   \   000000E6   0xF106 0x0154      ADD      R1,R6,#+84
   \   000000EA   0xF240 0x60D6      MOVW     R0,#+1750
   \   000000EE   0x.... 0x....      BL       epr_write_data
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0xF106 0x0158      ADD      R1,R6,#+88
   \   000000F8   0xF240 0x60DA      MOVW     R0,#+1754
   \   000000FC   0x.... 0x....      BL       epr_write_data
   \   00000100   0x2201             MOVS     R2,#+1
   \   00000102   0xF206 0x11BF      ADDW     R1,R6,#+447
   \   00000106   0xF240 0x60DE      MOVW     R0,#+1758
   \   0000010A   0x.... 0x....      BL       epr_write_data
   \   0000010E   0x2201             MOVS     R2,#+1
   \   00000110   0xF106 0x01B8      ADD      R1,R6,#+184
   \   00000114   0xF240 0x60DF      MOVW     R0,#+1759
   \   00000118   0x.... 0x....      BL       epr_write_data
   \   0000011C   0x2201             MOVS     R2,#+1
   \   0000011E   0xF106 0x01D4      ADD      R1,R6,#+212
   \   00000122   0xF240 0x7002      MOVW     R0,#+1794
   \   00000126   0x.... 0x....      BL       epr_write_data
   \   0000012A   0x2204             MOVS     R2,#+4
   \   0000012C   0xF106 0x01E4      ADD      R1,R6,#+228
   \   00000130   0xF44F 0x60DD      MOV      R0,#+1768
   \   00000134   0x.... 0x....      BL       epr_write_data
   \   00000138   0x2204             MOVS     R2,#+4
   \   0000013A   0xF106 0x01DC      ADD      R1,R6,#+220
   \   0000013E   0xF240 0x60EC      MOVW     R0,#+1772
   \   00000142   0x.... 0x....      BL       epr_write_data
   \   00000146   0x2204             MOVS     R2,#+4
   \   00000148   0xF106 0x01EC      ADD      R1,R6,#+236
   \   0000014C   0xF44F 0x60DE      MOV      R0,#+1776
   \   00000150   0x.... 0x....      BL       epr_write_data
   \   00000154   0x2204             MOVS     R2,#+4
   \   00000156   0xF106 0x01E8      ADD      R1,R6,#+232
   \   0000015A   0xF240 0x60F4      MOVW     R0,#+1780
   \   0000015E   0x.... 0x....      BL       epr_write_data
   \   00000162   0x2204             MOVS     R2,#+4
   \   00000164   0xF106 0x01E0      ADD      R1,R6,#+224
   \   00000168   0xF44F 0x60DF      MOV      R0,#+1784
   \   0000016C   0x.... 0x....      BL       epr_write_data
   \   00000170   0x2204             MOVS     R2,#+4
   \   00000172   0xF106 0x01F0      ADD      R1,R6,#+240
   \   00000176   0xF240 0x60FC      MOVW     R0,#+1788
   \   0000017A   0x.... 0x....      BL       epr_write_data
   \   0000017E   0x2201             MOVS     R2,#+1
   \   00000180   0xF106 0x01D5      ADD      R1,R6,#+213
   \   00000184   0xF240 0x7001      MOVW     R0,#+1793
   \   00000188   0x.... 0x....      BL       epr_write_data
   \   0000018C   0x2201             MOVS     R2,#+1
   \   0000018E   0xF206 0x2195      ADDW     R1,R6,#+661
   \   00000192   0xF240 0x7005      MOVW     R0,#+1797
   \   00000196   0x.... 0x....      BL       epr_write_data
   \   0000019A   0x2201             MOVS     R2,#+1
   \   0000019C   0xF506 0x71DE      ADD      R1,R6,#+444
   \   000001A0   0xF240 0x7007      MOVW     R0,#+1799
   \   000001A4   0x.... 0x....      BL       epr_write_data
   \   000001A8   0x2201             MOVS     R2,#+1
   \   000001AA   0xF106 0x01CD      ADD      R1,R6,#+205
   \   000001AE   0xF44F 0x60E1      MOV      R0,#+1800
   \   000001B2   0x.... 0x....      BL       epr_write_data
   \   000001B6   0x2201             MOVS     R2,#+1
   \   000001B8   0xF206 0x11BD      ADDW     R1,R6,#+445
   \   000001BC   0xF240 0x7009      MOVW     R0,#+1801
   \   000001C0   0x.... 0x....      BL       epr_write_data
   \   000001C4   0x2201             MOVS     R2,#+1
   \   000001C6   0xF506 0x71DF      ADD      R1,R6,#+446
   \   000001CA   0xF240 0x700A      MOVW     R0,#+1802
   \   000001CE   0x.... 0x....      BL       epr_write_data
   \   000001D2   0x2201             MOVS     R2,#+1
   \   000001D4   0xF506 0x71E5      ADD      R1,R6,#+458
   \   000001D8   0xF240 0x700B      MOVW     R0,#+1803
   \   000001DC   0x.... 0x....      BL       epr_write_data
   \   000001E0   0x2201             MOVS     R2,#+1
   \   000001E2   0xF106 0x01FC      ADD      R1,R6,#+252
   \   000001E6   0xF240 0x700C      MOVW     R0,#+1804
   \   000001EA   0x.... 0x....      BL       epr_write_data
   \   000001EE   0x2201             MOVS     R2,#+1
   \   000001F0   0xF106 0x01FD      ADD      R1,R6,#+253
   \   000001F4   0xF240 0x700D      MOVW     R0,#+1805
   \   000001F8   0x.... 0x....      BL       epr_write_data
   \   000001FC   0x2202             MOVS     R2,#+2
   \   000001FE   0xF106 0x01FE      ADD      R1,R6,#+254
   \   00000202   0xF240 0x700E      MOVW     R0,#+1806
   \   00000206   0x.... 0x....      BL       epr_write_data
   \   0000020A   0x2202             MOVS     R2,#+2
   \   0000020C   0xF506 0x7180      ADD      R1,R6,#+256
   \   00000210   0xF44F 0x60E2      MOV      R0,#+1808
   \   00000214   0x.... 0x....      BL       epr_write_data
   \   00000218   0x2202             MOVS     R2,#+2
   \   0000021A   0xF506 0x7181      ADD      R1,R6,#+258
   \   0000021E   0xF240 0x7012      MOVW     R0,#+1810
   \   00000222   0x.... 0x....      BL       epr_write_data
   \   00000226   0x2202             MOVS     R2,#+2
   \   00000228   0xF506 0x7182      ADD      R1,R6,#+260
   \   0000022C   0xF240 0x7014      MOVW     R0,#+1812
   \   00000230   0x.... 0x....      BL       epr_write_data
   \   00000234   0x2202             MOVS     R2,#+2
   \   00000236   0xF506 0x7183      ADD      R1,R6,#+262
   \   0000023A   0xF240 0x7016      MOVW     R0,#+1814
   \   0000023E   0x.... 0x....      BL       epr_write_data
   \   00000242   0x2202             MOVS     R2,#+2
   \   00000244   0xF506 0x7184      ADD      R1,R6,#+264
   \   00000248   0xF44F 0x60E3      MOV      R0,#+1816
   \   0000024C   0x.... 0x....      BL       epr_write_data
   \   00000250   0x2202             MOVS     R2,#+2
   \   00000252   0xF506 0x7185      ADD      R1,R6,#+266
   \   00000256   0xF240 0x701A      MOVW     R0,#+1818
   \   0000025A   0x.... 0x....      BL       epr_write_data
   \   0000025E   0x2202             MOVS     R2,#+2
   \   00000260   0xF506 0x7186      ADD      R1,R6,#+268
   \   00000264   0xF240 0x701C      MOVW     R0,#+1820
   \   00000268   0x.... 0x....      BL       epr_write_data
   \   0000026C   0x2202             MOVS     R2,#+2
   \   0000026E   0xF506 0x7187      ADD      R1,R6,#+270
   \   00000272   0xF240 0x701E      MOVW     R0,#+1822
   \   00000276   0x.... 0x....      BL       epr_write_data
   \   0000027A   0x2202             MOVS     R2,#+2
   \   0000027C   0xF506 0x7188      ADD      R1,R6,#+272
   \   00000280   0xF44F 0x60E4      MOV      R0,#+1824
   \   00000284   0x.... 0x....      BL       epr_write_data
   \   00000288   0x2201             MOVS     R2,#+1
   \   0000028A   0xF106 0x01D9      ADD      R1,R6,#+217
   \   0000028E   0xF240 0x7022      MOVW     R0,#+1826
   \   00000292   0x.... 0x....      BL       epr_write_data
   \   00000296   0x2201             MOVS     R2,#+1
   \   00000298   0xF206 0x212D      ADDW     R1,R6,#+557
   \   0000029C   0xF240 0x7023      MOVW     R0,#+1827
   \   000002A0   0x.... 0x....      BL       epr_write_data
   \   000002A4   0x2201             MOVS     R2,#+1
   \   000002A6   0xF506 0x7127      ADD      R1,R6,#+668
   \   000002AA   0xF240 0x702C      MOVW     R0,#+1836
   \   000002AE   0x.... 0x....      BL       epr_write_data
   \   000002B2   0x2201             MOVS     R2,#+1
   \   000002B4   0xF206 0x219D      ADDW     R1,R6,#+669
   \   000002B8   0xF240 0x702D      MOVW     R0,#+1837
   \   000002BC   0x.... 0x....      BL       epr_write_data
   \   000002C0   0x2201             MOVS     R2,#+1
   \   000002C2   0xF206 0x219E      ADDW     R1,R6,#+670
   \   000002C6   0xF240 0x702E      MOVW     R0,#+1838
   \   000002CA   0x.... 0x....      BL       epr_write_data
   \   000002CE   0x2201             MOVS     R2,#+1
   \   000002D0   0xF206 0x21A2      ADDW     R1,R6,#+674
   \   000002D4   0xF240 0x7031      MOVW     R0,#+1841
   \   000002D8   0x.... 0x....      BL       epr_write_data
   \   000002DC   0x2204             MOVS     R2,#+4
   \   000002DE   0xF506 0x7129      ADD      R1,R6,#+676
   \   000002E2   0xF240 0x7032      MOVW     R0,#+1842
   \   000002E6   0x.... 0x....      BL       epr_write_data
   \   000002EA   0x2202             MOVS     R2,#+2
   \   000002EC   0xF506 0x7128      ADD      R1,R6,#+672
   \   000002F0   0xF240 0x702F      MOVW     R0,#+1839
   \   000002F4   0x.... 0x....      BL       epr_write_data
   \   000002F8   0x9500             STR      R5,[SP, #+0]
   \   000002FA   0x2204             MOVS     R2,#+4
   \   000002FC   0xA900             ADD      R1,SP,#+0
   \   000002FE   0x4620             MOV      R0,R4
   \   00000300   0x.... 0x....      BL       epr_write_data
   \                     ??mkstft_ui_set_epr_0: (+1)
   \   00000304   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_init()
   \                     mkstft_ui_init: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x....             LDR.N    R4,??DataTable194
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable205  ;; 0x494949
   \   0000000A   0x6060             STR      R0,[R4, #+4]
   \   0000000C   0x1D21             ADDS     R1,R4,#+4
   \   0000000E   0xF06F 0x427F      MVN      R2,#-16777216
   \   00000012   0x604A             STR      R2,[R1, #+4]
   \   00000014   0x6088             STR      R0,[R1, #+8]
   \   00000016   0x60CA             STR      R2,[R1, #+12]
   \   00000018   0x6208             STR      R0,[R1, #+32]
   \   0000001A   0x624A             STR      R2,[R1, #+36]
   \   0000001C   0x6288             STR      R0,[R1, #+40]
   \   0000001E   0x62CA             STR      R2,[R1, #+44]
   \   00000020   0x6308             STR      R0,[R1, #+48]
   \   00000022   0x634A             STR      R2,[R1, #+52]
   \   00000024   0x6388             STR      R0,[R1, #+56]
   \   00000026   0x63CA             STR      R2,[R1, #+60]
   \   00000028   0xF44F 0x407F      MOV      R0,#+65280
   \   0000002C   0x6408             STR      R0,[R1, #+64]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable206_1  ;; 0xaaaaaa
   \   00000032   0x6448             STR      R0,[R1, #+68]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6488             STR      R0,[R1, #+72]
   \   00000038   0x64C8             STR      R0,[R1, #+76]
   \   0000003A   0xF44F 0x007F      MOV      R0,#+16711680
   \   0000003E   0x6508             STR      R0,[R1, #+80]
   \   00000040   0x654A             STR      R2,[R1, #+84]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6588             STR      R0,[R1, #+88]
   \   00000046   0x65CA             STR      R2,[R1, #+92]
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x01BF      STRB     R0,[R4, #+447]
   \   0000004E   0xF104 0x059C      ADD      R5,R4,#+156
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x7728             STRB     R0,[R5, #+28]
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x77A8             STRB     R0,[R5, #+30]
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0x70E8             STRB     R0,[R5, #+3]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x009C      STRB     R0,[R4, #+156]
   \   00000064   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000068   0x61A8             STR      R0,[R5, #+24]
   \   0000006A   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000006E   0x8268             STRH     R0,[R5, #+18]
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x7429             STRB     R1,[R5, #+16]
   \   00000074   0x2105             MOVS     R1,#+5
   \   00000076   0x73E9             STRB     R1,[R5, #+15]
   \   00000078   0x73A9             STRB     R1,[R5, #+14]
   \   0000007A   0x2164             MOVS     R1,#+100
   \   0000007C   0x8129             STRH     R1,[R5, #+8]
   \   0000007E   0x8169             STRH     R1,[R5, #+10]
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xF884 0x10FC      STRB     R1,[R4, #+252]
   \   00000086   0xF104 0x01FC      ADD      R1,R4,#+252
   \   0000008A   0x2204             MOVS     R2,#+4
   \   0000008C   0x704A             STRB     R2,[R1, #+1]
   \   0000008E   0x2232             MOVS     R2,#+50
   \   00000090   0x804A             STRH     R2,[R1, #+2]
   \   00000092   0x808A             STRH     R2,[R1, #+4]
   \   00000094   0x22B4             MOVS     R2,#+180
   \   00000096   0x80CA             STRH     R2,[R1, #+6]
   \   00000098   0x2232             MOVS     R2,#+50
   \   0000009A   0x810A             STRH     R2,[R1, #+8]
   \   0000009C   0x22B4             MOVS     R2,#+180
   \   0000009E   0x814A             STRH     R2,[R1, #+10]
   \   000000A0   0x818A             STRH     R2,[R1, #+12]
   \   000000A2   0x2232             MOVS     R2,#+50
   \   000000A4   0x81CA             STRH     R2,[R1, #+14]
   \   000000A6   0x22B4             MOVS     R2,#+180
   \   000000A8   0x820A             STRH     R2,[R1, #+16]
   \   000000AA   0x61C8             STR      R0,[R1, #+28]
   \   000000AC   0xF240 0x50DC      MOVW     R0,#+1500
   \   000000B0   0x6188             STR      R0,[R1, #+24]
   \   000000B2   0xF204 0x109F      ADDW     R0,R4,#+415
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x7741             STRB     R1,[R0, #+29]
   \   000000BA   0xF884 0x10CD      STRB     R1,[R4, #+205]
   \   000000BE   0x7781             STRB     R1,[R0, #+30]
   \   000000C0   0x77C1             STRB     R1,[R0, #+31]
   \   000000C2   0x4608             MOV      R0,R1
   \   000000C4   0xF884 0x01CA      STRB     R0,[R4, #+458]
   \   000000C8   0xF204 0x06CD      ADDW     R6,R4,#+205
   \   000000CC   0x7330             STRB     R0,[R6, #+12]
   \   000000CE   0x2206             MOVS     R2,#+6
   \   000000D0   0x.... 0x....      ADR.W    R1,`?<Constant "0.000">`
   \   000000D4   0xF504 0x70B0      ADD      R0,R4,#+352
   \   000000D8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xF884 0x0129      STRB     R0,[R4, #+297]
   \   000000E2   0xF104 0x00DC      ADD      R0,R4,#+220
   \   000000E6   0x21C8             MOVS     R1,#+200
   \   000000E8   0x6101             STR      R1,[R0, #+16]
   \   000000EA   0xF44F 0x717A      MOV      R1,#+1000
   \   000000EE   0xF8C4 0x10DC      STR      R1,[R4, #+220]
   \   000000F2   0x2264             MOVS     R2,#+100
   \   000000F4   0x6082             STR      R2,[R0, #+8]
   \   000000F6   0x22C8             MOVS     R2,#+200
   \   000000F8   0x6142             STR      R2,[R0, #+20]
   \   000000FA   0x6041             STR      R1,[R0, #+4]
   \   000000FC   0x2164             MOVS     R1,#+100
   \   000000FE   0x60C1             STR      R1,[R0, #+12]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x71F0             STRB     R0,[R6, #+7]
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0x7230             STRB     R0,[R6, #+8]
   \   00000108   0xF884 0x022B      STRB     R0,[R4, #+555]
   \   0000010C   0x.... 0x....      LDR.W    R8,??DataTable207
   \   00000110   0x226C             MOVS     R2,#+108
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0x4640             MOV      R0,R8
   \   00000116   0x.... 0x....      BL       memset
   \   0000011A   0x.... 0x....      LDR.W    R6,??DataTable207_1
   \   0000011E   0x22A2             MOVS     R2,#+162
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x4630             MOV      R0,R6
   \   00000124   0x.... 0x....      BL       memset
   \   00000128   0x270C             MOVS     R7,#+12
   \   0000012A   0x463A             MOV      R2,R7
   \   0000012C   0x.... 0x....      ADR.W    R1,`?<Constant "TP-LINK_MKS">`
   \   00000130   0x4640             MOV      R0,R8
   \   00000132   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000136   0x220A             MOVS     R2,#+10
   \   00000138   0x.... 0x....      ADR.W    R1,`?<Constant "makerbase">`
   \   0000013C   0xF108 0x0020      ADD      R0,R8,#+32
   \   00000140   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000144   0x.... 0x....      ADR.W    R8,`?<Constant "192.168.3.100">`
   \   00000148   0xF04F 0x090E      MOV      R9,#+14
   \   0000014C   0x464A             MOV      R2,R9
   \   0000014E   0x4641             MOV      R1,R8
   \   00000150   0x1C70             ADDS     R0,R6,#+1
   \   00000152   0x.... 0x....      BL       __aeabi_memcpy
   \   00000156   0x.... 0x....      ADR.W    R10,`?<Constant "255.255.255.0">`
   \   0000015A   0x464A             MOV      R2,R9
   \   0000015C   0x4651             MOV      R1,R10
   \   0000015E   0xF106 0x0011      ADD      R0,R6,#+17
   \   00000162   0x.... 0x....      BL       __aeabi_memcpy
   \   00000166   0x.... 0x....      ADR.W    R11,`?<Constant "192.168.3.1">`
   \   0000016A   0x463A             MOV      R2,R7
   \   0000016C   0x4659             MOV      R1,R11
   \   0000016E   0xF106 0x0021      ADD      R0,R6,#+33
   \   00000172   0x.... 0x....      BL       __aeabi_memcpy
   \   00000176   0x463A             MOV      R2,R7
   \   00000178   0x4659             MOV      R1,R11
   \   0000017A   0xF106 0x0031      ADD      R0,R6,#+49
   \   0000017E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000182   0x2001             MOVS     R0,#+1
   \   00000184   0x7030             STRB     R0,[R6, #+0]
   \   00000186   0x464A             MOV      R2,R9
   \   00000188   0x4641             MOV      R1,R8
   \   0000018A   0xF106 0x0042      ADD      R0,R6,#+66
   \   0000018E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000192   0x464A             MOV      R2,R9
   \   00000194   0x4651             MOV      R1,R10
   \   00000196   0xF106 0x0052      ADD      R0,R6,#+82
   \   0000019A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000019E   0x463A             MOV      R2,R7
   \   000001A0   0x4659             MOV      R1,R11
   \   000001A2   0xF106 0x0062      ADD      R0,R6,#+98
   \   000001A6   0x.... 0x....      BL       __aeabi_memcpy
   \   000001AA   0x463A             MOV      R2,R7
   \   000001AC   0x4659             MOV      R1,R11
   \   000001AE   0xF106 0x0072      ADD      R0,R6,#+114
   \   000001B2   0x.... 0x....      BL       __aeabi_memcpy
   \   000001B6   0x463A             MOV      R2,R7
   \   000001B8   0x4659             MOV      R1,R11
   \   000001BA   0xF106 0x0082      ADD      R0,R6,#+130
   \   000001BE   0x.... 0x....      BL       __aeabi_memcpy
   \   000001C2   0x464A             MOV      R2,R9
   \   000001C4   0x.... 0x....      ADR.W    R1,`?<Constant "192.168.3.255">`
   \   000001C8   0xF106 0x0092      ADD      R0,R6,#+146
   \   000001CC   0x.... 0x....      BL       __aeabi_memcpy
   \   000001D0   0x2001             MOVS     R0,#+1
   \   000001D2   0xF886 0x0041      STRB     R0,[R6, #+65]
   \   000001D6   0xF204 0x262B      ADDW     R6,R4,#+555
   \   000001DA   0x2002             MOVS     R0,#+2
   \   000001DC   0x7070             STRB     R0,[R6, #+1]
   \   000001DE   0x220F             MOVS     R2,#+15
   \   000001E0   0x.... 0x....      ADR.W    R1,`?<Constant "baizhongyun.cn">`
   \   000001E4   0xF204 0x202E      ADDW     R0,R4,#+558
   \   000001E8   0x.... 0x....      BL       __aeabi_memcpy
   \   000001EC   0xF242 0x7066      MOVW     R0,#+10086
   \   000001F0   0xF8C4 0x0290      STR      R0,[R4, #+656]
   \   000001F4   0x2001             MOVS     R0,#+1
   \   000001F6   0x70B0             STRB     R0,[R6, #+2]
   \   000001F8   0xF504 0x7024      ADD      R0,R4,#+656
   \   000001FC   0x2117             MOVS     R1,#+23
   \   000001FE   0x7101             STRB     R1,[R0, #+4]
   \   00000200   0x2100             MOVS     R1,#+0
   \   00000202   0x7141             STRB     R1,[R0, #+5]
   \   00000204   0xF884 0x119F      STRB     R1,[R4, #+415]
   \   00000208   0xF884 0x1148      STRB     R1,[R4, #+328]
   \   0000020C   0xF884 0x1155      STRB     R1,[R4, #+341]
   \   00000210   0x7341             STRB     R1,[R0, #+13]
   \   00000212   0x2101             MOVS     R1,#+1
   \   00000214   0x7381             STRB     R1,[R0, #+14]
   \   00000216   0x2100             MOVS     R1,#+0
   \   00000218   0x7481             STRB     R1,[R0, #+18]
   \   0000021A   0x6141             STR      R1,[R0, #+20]
   \   0000021C   0x21B4             MOVS     R1,#+180
   \   0000021E   0x8201             STRH     R1,[R0, #+16]
   \   00000220   0x.... 0x....      BL       _Z17mkstft_ui_set_eprv
   \   00000224   0xF640 0x50BE      MOVW     R0,#+3518
   \   00000228   0x6228             STR      R0,[R5, #+32]
   \   0000022A   0xF240 0x1185      MOVW     R1,#+389
   \   0000022E   0x6269             STR      R1,[R5, #+36]
   \   00000230   0xF44F 0x728E      MOV      R2,#+284
   \   00000234   0x62AA             STR      R2,[R5, #+40]
   \   00000236   0xF640 0x63BA      MOVW     R3,#+3770
   \   0000023A   0x62EB             STR      R3,[R5, #+44]
   \   0000023C   0x.... 0x....      LDR.W    R4,??DataTable210
   \   00000240   0x8824             LDRH     R4,[R4, #+0]
   \   00000242   0xF249 0x3641      MOVW     R6,#+37697
   \   00000246   0x42B4             CMP      R4,R6
   \   00000248   0xD10B             BNE.N    ??mkstft_ui_init_0
   \   0000024A   0xF44F 0x70C8      MOV      R0,#+400
   \   0000024E   0x6228             STR      R0,[R5, #+32]
   \   00000250   0xF640 0x60FC      MOVW     R0,#+3836
   \   00000254   0x6268             STR      R0,[R5, #+36]
   \   00000256   0xF640 0x60DD      MOVW     R0,#+3805
   \   0000025A   0x62A8             STR      R0,[R5, #+40]
   \   0000025C   0x20D4             MOVS     R0,#+212
   \   0000025E   0x62E8             STR      R0,[R5, #+44]
   \   00000260   0xE035             B.N      ??mkstft_ui_init_1
   \                     ??mkstft_ui_init_0: (+1)
   \   00000262   0xF648 0x1689      MOVW     R6,#+35209
   \   00000266   0x42B4             CMP      R4,R6
   \   00000268   0xD104             BNE.N    ??mkstft_ui_init_2
   \   0000026A   0x6229             STR      R1,[R5, #+32]
   \   0000026C   0x6268             STR      R0,[R5, #+36]
   \   0000026E   0x62AA             STR      R2,[R5, #+40]
   \   00000270   0x62EB             STR      R3,[R5, #+44]
   \   00000272   0xE02C             B.N      ??mkstft_ui_init_1
   \                     ??mkstft_ui_init_2: (+1)
   \   00000274   0xF241 0x5005      MOVW     R0,#+5381
   \   00000278   0x4284             CMP      R4,R0
   \   0000027A   0xD10A             BNE.N    ??mkstft_ui_init_3
   \   0000027C   0xF44F 0x7098      MOV      R0,#+304
   \   00000280   0x6228             STR      R0,[R5, #+32]
   \   00000282   0xF640 0x7023      MOVW     R0,#+3875
   \   00000286   0x6268             STR      R0,[R5, #+36]
   \   00000288   0xF240 0x1139      MOVW     R1,#+313
   \   0000028C   0x62A9             STR      R1,[R5, #+40]
   \   0000028E   0x62E8             STR      R0,[R5, #+44]
   \   00000290   0xE01D             B.N      ??mkstft_ui_init_1
   \                     ??mkstft_ui_init_3: (+1)
   \   00000292   0xF248 0x5052      MOVW     R0,#+34130
   \   00000296   0x4284             CMP      R4,R0
   \   00000298   0xD10B             BNE.N    ??mkstft_ui_init_4
   \   0000029A   0xF44F 0x70B0      MOV      R0,#+352
   \   0000029E   0x6228             STR      R0,[R5, #+32]
   \   000002A0   0xF640 0x7054      MOVW     R0,#+3924
   \   000002A4   0x6268             STR      R0,[R5, #+36]
   \   000002A6   0xF44F 0x6070      MOV      R0,#+3840
   \   000002AA   0x62A8             STR      R0,[R5, #+40]
   \   000002AC   0x20C9             MOVS     R0,#+201
   \   000002AE   0x62E8             STR      R0,[R5, #+44]
   \   000002B0   0xE00D             B.N      ??mkstft_ui_init_1
   \                     ??mkstft_ui_init_4: (+1)
   \   000002B2   0xF249 0x4088      MOVW     R0,#+38024
   \   000002B6   0x4284             CMP      R4,R0
   \   000002B8   0xD109             BNE.N    ??mkstft_ui_init_1
   \   000002BA   0x20C9             MOVS     R0,#+201
   \   000002BC   0x6228             STR      R0,[R5, #+32]
   \   000002BE   0xF640 0x704F      MOVW     R0,#+3919
   \   000002C2   0x6268             STR      R0,[R5, #+36]
   \   000002C4   0xF44F 0x606C      MOV      R0,#+3776
   \   000002C8   0x62A8             STR      R0,[R5, #+40]
   \   000002CA   0x20A4             MOVS     R0,#+164
   \   000002CC   0x62E8             STR      R0,[R5, #+44]
   \                     ??mkstft_ui_init_1: (+1)
   \   000002CE   0x2000             MOVS     R0,#+0
   \   000002D0   0x.... 0x....      LDR.W    R1,??DataTable211
   \   000002D4   0x7008             STRB     R0,[R1, #+0]
   \   000002D6   0x.... 0x....      LDR.W    R1,??DataTable213
   \   000002DA   0x7008             STRB     R0,[R1, #+0]
   \   000002DC   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_initPrint()
   \                     mks_initPrint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable212_1
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable212_2
   \   0000000A   0xF8D0 0x10D4      LDR      R1,[R0, #+212]
   \   0000000E   0xF8C4 0x17E0      STR      R1,[R4, #+2016]
   \   00000012   0xF204 0x71E0      ADDW     R1,R4,#+2016
   \   00000016   0x30D4             ADDS     R0,R0,#+212
   \   00000018   0x6842             LDR      R2,[R0, #+4]
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x6088             STR      R0,[R1, #+8]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable214  ;; 0x40a00000
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6108             STR      R0,[R1, #+16]
   \   0000002A   0x20A6             MOVS     R0,#+166
   \   0000002C   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   00000030   0xF604 0x051C      ADDW     R5,R4,#+2076
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6068             STR      R0,[R5, #+4]
   \   00000038   0x2214             MOVS     R2,#+20
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0xF504 0x60ED      ADD      R0,R4,#+1896
   \   00000040   0x.... 0x....      BL       memset
   \   00000044   0x2264             MOVS     R2,#+100
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF204 0x707C      ADDW     R0,R4,#+1916
   \   0000004C   0x.... 0x....      BL       memset
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x86A8             STRH     R0,[R5, #+52]
   \   00000054   0x82E8             STRH     R0,[R5, #+22]
   \   00000056   0x8368             STRH     R0,[R5, #+26]
   \   00000058   0xF884 0x0AE4      STRB     R0,[R4, #+2788]
   \   0000005C   0x7528             STRB     R0,[R5, #+20]
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToEpr()
   \                     _Z14mks_WriteToEprv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable212_1
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   0000000C   0xF8C4 0x0820      STR      R0,[R4, #+2080]
   \   00000010   0xF604 0x0520      ADDW     R5,R4,#+2080
   \   00000014   0x2204             MOVS     R2,#+4
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0xF240 0x40B1      MOVW     R0,#+1201
   \   0000001C   0x.... 0x....      BL       epr_write_data
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable213_1
   \   00000024   0x6830             LDR      R0,[R6, #+0]
   \   00000026   0x8268             STRH     R0,[R5, #+18]
   \   00000028   0x2202             MOVS     R2,#+2
   \   0000002A   0xF604 0x0132      ADDW     R1,R4,#+2098
   \   0000002E   0xF240 0x40B5      MOVW     R0,#+1205
   \   00000032   0x.... 0x....      BL       epr_write_data
   \   00000036   0x.... 0x....      LDR.W    R7,??DataTable212_2
   \   0000003A   0xF897 0x00F7      LDRB     R0,[R7, #+247]
   \   0000003E   0x2802             CMP      R0,#+2
   \   00000040   0xD108             BNE.N    ??mks_WriteToEpr_0
   \   00000042   0x6870             LDR      R0,[R6, #+4]
   \   00000044   0x82A8             STRH     R0,[R5, #+20]
   \   00000046   0x2202             MOVS     R2,#+2
   \   00000048   0xF604 0x0134      ADDW     R1,R4,#+2100
   \   0000004C   0xF240 0x40B7      MOVW     R0,#+1207
   \   00000050   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_0: (+1)
   \   00000054   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD00A             BEQ.N    ??mks_WriteToEpr_1
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable213_2
   \   00000060   0x8800             LDRH     R0,[R0, #+0]
   \   00000062   0x82E8             STRH     R0,[R5, #+22]
   \   00000064   0x2202             MOVS     R2,#+2
   \   00000066   0xF604 0x0136      ADDW     R1,R4,#+2102
   \   0000006A   0xF240 0x40B9      MOVW     R0,#+1209
   \   0000006E   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_1: (+1)
   \   00000072   0x2204             MOVS     R2,#+4
   \   00000074   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   00000078   0xF240 0x40BB      MOVW     R0,#+1211
   \   0000007C   0x.... 0x....      BL       epr_write_data
   \   00000080   0x2204             MOVS     R2,#+4
   \   00000082   0xF504 0x61FF      ADD      R1,R4,#+2040
   \   00000086   0xF240 0x40BF      MOVW     R0,#+1215
   \   0000008A   0x.... 0x....      BL       epr_write_data
   \   0000008E   0x2204             MOVS     R2,#+4
   \   00000090   0xF204 0x71FC      ADDW     R1,R4,#+2044
   \   00000094   0xF240 0x40C3      MOVW     R0,#+1219
   \   00000098   0x.... 0x....      BL       epr_write_data
   \   0000009C   0x2204             MOVS     R2,#+4
   \   0000009E   0xF504 0x6100      ADD      R1,R4,#+2048
   \   000000A2   0xF240 0x40C7      MOVW     R0,#+1223
   \   000000A6   0x.... 0x....      BL       epr_write_data
   \   000000AA   0x2204             MOVS     R2,#+4
   \   000000AC   0xF604 0x0104      ADDW     R1,R4,#+2052
   \   000000B0   0xF240 0x40CB      MOVW     R0,#+1227
   \   000000B4   0x.... 0x....      BL       epr_write_data
   \   000000B8   0x2204             MOVS     R2,#+4
   \   000000BA   0xF604 0x0108      ADDW     R1,R4,#+2056
   \   000000BE   0xF240 0x40CF      MOVW     R0,#+1231
   \   000000C2   0x.... 0x....      BL       epr_write_data
   \   000000C6   0x2204             MOVS     R2,#+4
   \   000000C8   0xF604 0x010C      ADDW     R1,R4,#+2060
   \   000000CC   0xF240 0x40D3      MOVW     R0,#+1235
   \   000000D0   0x.... 0x....      BL       epr_write_data
   \   000000D4   0x2204             MOVS     R2,#+4
   \   000000D6   0xF504 0x6101      ADD      R1,R4,#+2064
   \   000000DA   0xF240 0x40D7      MOVW     R0,#+1239
   \   000000DE   0x.... 0x....      BL       epr_write_data
   \   000000E2   0x....             LDR.N    R5,??DataTable196_6
   \   000000E4   0x2202             MOVS     R2,#+2
   \   000000E6   0x1CA9             ADDS     R1,R5,#+2
   \   000000E8   0xF44F 0x609E      MOV      R0,#+1264
   \   000000EC   0x.... 0x....      BL       epr_write_data
   \   000000F0   0x2201             MOVS     R2,#+1
   \   000000F2   0x1D29             ADDS     R1,R5,#+4
   \   000000F4   0xF240 0x40F2      MOVW     R0,#+1266
   \   000000F8   0x.... 0x....      BL       epr_write_data
   \   000000FC   0x2201             MOVS     R2,#+1
   \   000000FE   0x1D69             ADDS     R1,R5,#+5
   \   00000100   0xF240 0x40F3      MOVW     R0,#+1267
   \   00000104   0x.... 0x....      BL       epr_write_data
   \   00000108   0x2201             MOVS     R2,#+1
   \   0000010A   0xF604 0x013C      ADDW     R1,R4,#+2108
   \   0000010E   0xF240 0x40DF      MOVW     R0,#+1247
   \   00000112   0x.... 0x....      BL       epr_write_data
   \   00000116   0x2204             MOVS     R2,#+4
   \   00000118   0xF604 0x0138      ADDW     R1,R4,#+2104
   \   0000011C   0xF240 0x40DB      MOVW     R0,#+1243
   \   00000120   0x.... 0x....      BL       epr_write_data
   \   00000124   0x2201             MOVS     R2,#+1
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable216
   \   0000012A   0xF240 0x40F4      MOVW     R0,#+1268
   \   0000012E   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000132   0x.... 0x....      B.W      epr_write_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ReadFromEpr()
   \                     mks_ReadFromEpr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable212_1
   \   00000006   0x2264             MOVS     R2,#+100
   \   00000008   0xF205 0x717C      ADDW     R1,R5,#+1916
   \   0000000C   0xF240 0x40FD      MOVW     R0,#+1277
   \   00000010   0x.... 0x....      BL       epr_read_data
   \   00000014   0xF240 0x40B1      MOVW     R0,#+1201
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable215_1
   \   0000001C   0xF894 0x119F      LDRB     R1,[R4, #+415]
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xD005             BEQ.N    ??mks_ReadFromEpr_0
   \   00000024   0x2204             MOVS     R2,#+4
   \   00000026   0xF505 0x6102      ADD      R1,R5,#+2080
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0xE00B             B.N      ??mks_ReadFromEpr_1
   \                     ??mks_ReadFromEpr_0: (+1)
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF605 0x0128      ADDW     R1,R5,#+2088
   \   00000036   0x.... 0x....      BL       epr_read_data
   \   0000003A   0x2204             MOVS     R2,#+4
   \   0000003C   0xF605 0x0124      ADDW     R1,R5,#+2084
   \   00000040   0xF240 0x40F5      MOVW     R0,#+1269
   \   00000044   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_1: (+1)
   \   00000048   0x2202             MOVS     R2,#+2
   \   0000004A   0xF605 0x0132      ADDW     R1,R5,#+2098
   \   0000004E   0xF240 0x40B5      MOVW     R0,#+1205
   \   00000052   0x.... 0x....      BL       epr_read_data
   \   00000056   0x.... 0x....      LDR.W    R6,??DataTable212_2
   \   0000005A   0xF896 0x00F7      LDRB     R0,[R6, #+247]
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xD106             BNE.N    ??mks_ReadFromEpr_2
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0xF605 0x0134      ADDW     R1,R5,#+2100
   \   00000068   0xF240 0x40B7      MOVW     R0,#+1207
   \   0000006C   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_2: (+1)
   \   00000070   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD006             BEQ.N    ??mks_ReadFromEpr_3
   \   00000078   0x2202             MOVS     R2,#+2
   \   0000007A   0xF605 0x0136      ADDW     R1,R5,#+2102
   \   0000007E   0xF240 0x40B9      MOVW     R0,#+1209
   \   00000082   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_3: (+1)
   \   00000086   0x2204             MOVS     R2,#+4
   \   00000088   0xF205 0x71F4      ADDW     R1,R5,#+2036
   \   0000008C   0xF240 0x40BB      MOVW     R0,#+1211
   \   00000090   0x.... 0x....      BL       epr_read_data
   \   00000094   0x2204             MOVS     R2,#+4
   \   00000096   0xF505 0x61FF      ADD      R1,R5,#+2040
   \   0000009A   0xF240 0x40BF      MOVW     R0,#+1215
   \   0000009E   0x.... 0x....      BL       epr_read_data
   \   000000A2   0x2204             MOVS     R2,#+4
   \   000000A4   0xF205 0x71FC      ADDW     R1,R5,#+2044
   \   000000A8   0xF240 0x40C3      MOVW     R0,#+1219
   \   000000AC   0x.... 0x....      BL       epr_read_data
   \   000000B0   0x2204             MOVS     R2,#+4
   \   000000B2   0xF505 0x6100      ADD      R1,R5,#+2048
   \   000000B6   0xF240 0x40C7      MOVW     R0,#+1223
   \   000000BA   0x.... 0x....      BL       epr_read_data
   \   000000BE   0x2204             MOVS     R2,#+4
   \   000000C0   0xF605 0x0104      ADDW     R1,R5,#+2052
   \   000000C4   0xF240 0x40CB      MOVW     R0,#+1227
   \   000000C8   0x.... 0x....      BL       epr_read_data
   \   000000CC   0x2204             MOVS     R2,#+4
   \   000000CE   0xF605 0x0108      ADDW     R1,R5,#+2056
   \   000000D2   0xF240 0x40CF      MOVW     R0,#+1231
   \   000000D6   0x.... 0x....      BL       epr_read_data
   \   000000DA   0x2204             MOVS     R2,#+4
   \   000000DC   0xF605 0x010C      ADDW     R1,R5,#+2060
   \   000000E0   0xF240 0x40D3      MOVW     R0,#+1235
   \   000000E4   0x.... 0x....      BL       epr_read_data
   \   000000E8   0x2204             MOVS     R2,#+4
   \   000000EA   0xF505 0x6101      ADD      R1,R5,#+2064
   \   000000EE   0xF240 0x40D7      MOVW     R0,#+1239
   \   000000F2   0x.... 0x....      BL       epr_read_data
   \   000000F6   0x.... 0x....      LDR.W    R6,??DataTable216_1
   \   000000FA   0x2202             MOVS     R2,#+2
   \   000000FC   0x1CB1             ADDS     R1,R6,#+2
   \   000000FE   0xF44F 0x609E      MOV      R0,#+1264
   \   00000102   0x.... 0x....      BL       epr_read_data
   \   00000106   0x2201             MOVS     R2,#+1
   \   00000108   0x1D31             ADDS     R1,R6,#+4
   \   0000010A   0xF240 0x40F2      MOVW     R0,#+1266
   \   0000010E   0x.... 0x....      BL       epr_read_data
   \   00000112   0x2201             MOVS     R2,#+1
   \   00000114   0x1D71             ADDS     R1,R6,#+5
   \   00000116   0xF240 0x40F3      MOVW     R0,#+1267
   \   0000011A   0x.... 0x....      BL       epr_read_data
   \   0000011E   0x2201             MOVS     R2,#+1
   \   00000120   0xF605 0x013C      ADDW     R1,R5,#+2108
   \   00000124   0xF240 0x40DF      MOVW     R0,#+1247
   \   00000128   0x.... 0x....      BL       epr_read_data
   \   0000012C   0x2204             MOVS     R2,#+4
   \   0000012E   0xF605 0x0138      ADDW     R1,R5,#+2104
   \   00000132   0xF240 0x40DB      MOVW     R0,#+1243
   \   00000136   0x.... 0x....      BL       epr_read_data
   \   0000013A   0x.... 0x....      LDR.W    R5,??DataTable217_1
   \   0000013E   0x2201             MOVS     R2,#+1
   \   00000140   0x1CE9             ADDS     R1,R5,#+3
   \   00000142   0xF240 0x40F4      MOVW     R0,#+1268
   \   00000146   0x.... 0x....      BL       epr_read_data
   \   0000014A   0xF995 0x0003      LDRSB    R0,[R5, #+3]
   \   0000014E   0xF884 0x009C      STRB     R0,[R4, #+156]
   \   00000152   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_resumePrint()
   \                     mks_resumePrint: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable212_1
   \   00000006   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   0000000A   0x28AA             CMP      R0,#+170
   \   0000000C   0xD114             BNE.N    ??mks_resumePrint_0
   \   0000000E   0x20A7             MOVS     R0,#+167
   \   00000010   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   00000014   0xF8D4 0x07EC      LDR      R0,[R4, #+2028]
   \   00000018   0x.... 0x....      BL       mks_preExtrude
   \   0000001C   0xF204 0x70EC      ADDW     R0,R4,#+2028
   \   00000020   0x69C1             LDR      R1,[R0, #+28]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x.... 0x....      BL       mks_moveXY
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       mks_moveZ
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF204 0x707C      ADDW     R0,R4,#+1916
   \   00000034   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \                     ??mks_resumePrint_0: (+1)
   \   00000038   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   0000003C   0x28AB             CMP      R0,#+171
   \   0000003E   0xD102             BNE.N    ??mks_resumePrint_1
   \   00000040   0x20AC             MOVS     R0,#+172
   \   00000042   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \                     ??mks_resumePrint_1: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_pausePrint()
   \                     mks_pausePrint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable212_1
   \   0000000A   0xF204 0x75E0      ADDW     R5,R4,#+2016
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable217_1
   \   00000012   0x6881             LDR      R1,[R0, #+8]
   \   00000014   0x6169             STR      R1,[R5, #+20]
   \   00000016   0x68C1             LDR      R1,[R0, #+12]
   \   00000018   0x61A9             STR      R1,[R5, #+24]
   \   0000001A   0x6901             LDR      R1,[R0, #+16]
   \   0000001C   0x61E9             STR      R1,[R5, #+28]
   \   0000001E   0x6941             LDR      R1,[R0, #+20]
   \   00000020   0x6229             STR      R1,[R5, #+32]
   \   00000022   0x6981             LDR      R1,[R0, #+24]
   \   00000024   0x6269             STR      R1,[R5, #+36]
   \   00000026   0x69C1             LDR      R1,[R0, #+28]
   \   00000028   0x62A9             STR      R1,[R5, #+40]
   \   0000002A   0x6A01             LDR      R1,[R0, #+32]
   \   0000002C   0x62E9             STR      R1,[R5, #+44]
   \   0000002E   0x6A41             LDR      R1,[R0, #+36]
   \   00000030   0x6329             STR      R1,[R5, #+48]
   \   00000032   0x6EC1             LDR      R1,[R0, #+108]
   \   00000034   0xF884 0x183C      STRB     R1,[R4, #+2108]
   \   00000038   0x6DC0             LDR      R0,[R0, #+92]
   \   0000003A   0x65A8             STR      R0,[R5, #+88]
   \   0000003C   0xF04F 0x4040      MOV      R0,#-1073741824
   \   00000040   0x.... 0x....      BL       mks_preExtrude
   \   00000044   0x68A8             LDR      R0,[R5, #+8]
   \   00000046   0x.... 0x....      BL       mks_moveZ
   \   0000004A   0x6869             LDR      R1,[R5, #+4]
   \   0000004C   0xF8D4 0x07E0      LDR      R0,[R4, #+2016]
   \   00000050   0x.... 0x....      BL       mks_moveXY
   \   00000054   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000058   0x....             B.N      _Z14mks_WriteToEprv

   \                                 In section .bss, align 4
   \                     filament_loading_time_flg:
   \   00000000                      DS8 1
   \                     filament_loading_completed:
   \   00000001                      DS8 1
   \                     filament_unloading_time_flg:
   \   00000002                      DS8 1
   \                     filament_unloading_completed:
   \   00000003                      DS8 1
   \                     printing_rate_update_flag:
   \   00000004                      DS8 1
   \                     preview_no_display:
   \   00000005                      DS8 1
   \                     loop_start:
   \   00000006                      DS8 1
   \   00000007                      DS8 1
   \   00000008                      DS8 1
   \                     sd_read_error_flg:
   \   00000009                      DS8 1
   \                     sd_read_cnt:
   \   0000000A                      DS8 1
   \                     display_hold:
   \   0000000B                      DS8 1
   \                     display_hold_release:
   \   0000000C                      DS8 1
   \                     wifi_init_flg:
   \   0000000D                      DS8 1
   \                     wifi_refresh_flg:
   \   0000000E                      DS8 1
   \                     cloud_refresh_flg:
   \   0000000F                      DS8 1
   \                     waiting_wifi_time:
   \   00000010                      DS8 1
   \                     beep_flg:
   \   00000011                      DS8 1
   \   __absolute uint8_t print_finish_start_timer
   \                     print_finish_start_timer:
   \   00000012                      DS8 1
   \   __absolute uint8_t print_finish_close_machine
   \                     print_finish_close_machine:
   \   00000013                      DS8 1
   \   00000014                      DS8 4
   \                     z_high_count:
   \   00000018                      DS8 2
   \   0000001A                      DS8 2
   \   0000001C                      DS8 4
   \                     filament_loading_time_cnt:
   \   00000020                      DS8 4
   \                     filament_unloading_time_cnt:
   \   00000024                      DS8 4
   \                     TimeIncrease:
   \   00000028                      DS8 4
   \                     home_offset:
   \   0000002C                      DS8 12
   \                     display_hold_cnt:
   \   00000038                      DS8 4
   \                     beep_cnt:
   \   0000003C                      DS8 4
   \   __absolute uint32_t print_finish_timer_count
   \                     print_finish_timer_count:
   \   00000040                      DS8 4

   \                                 In section .bss, align 1
   \                     filament_heat_completed_load:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     filament_heat_completed_unload:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     g26_debug_flag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     card:
   \   00000000                      DS8 1896
   \   __absolute DATA_REPRINT_ITMES mksReprint
   \                     mksReprint:
   \   00000768                      DS8 896
   \                     print_job_timer:
   \   00000AE8                      DS8 16

   \                                 In section .bss, align 4
   \                     command_queue:
   \   00000000                      DS8 384

   \                                 In section .bss, align 4
   \                     injected_commands_P:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     saved_feedrate_percentage:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
   \                     z_endstop_adj:
   \   00000000                      DS8 4
   \                     delta_endstop_adj:
   \   00000004                      DS8 12

   \                                 In section .bss, align 4
   \                     hotend_offset:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
   \                     z_values:
   \   00000000                      DS8 576

   \                                 In section .bss, align 4
   \                     home_dir_P:
   \   00000000                      DS8 4
   \                     base_min_pos_P:
   \   00000004                      DS8 12
   \                     base_max_pos_P:
   \   00000010                      DS8 12
   \                     base_home_pos_P:
   \   0000001C                      DS8 12
   \                     max_length_P:
   \   00000028                      DS8 12
   \   00000034                      DS8 4
   \   00000038                      DS8 4

   \                                 In section .bss, align 1
   \                     filament_ran_out:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE18serial_line_buffer:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ19get_serial_commandsvE19serial_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE14last_wait_time:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \                     _ZZ19get_sdcard_commandsvE14stop_buffering:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     _ZZ19get_sdcard_commandsvE15sd_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ17get_wifi_commandsvE16wifi_line_buffer:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ17get_wifi_commandsvE17wifi_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??C2:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \   00000014                      DS8 4

   \                                 In section .bss, align 1
   \                     button_disp_pause_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     wifi_init_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute uint8_t continue_print_error_flg
   \                     continue_print_error_flg:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute uint32_t t1
   \                     t1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint32_t t2
   \                     t2:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute char t12[10]
   \                     t12:
   \   00000000                      DS8 12

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_PrintStatePolling()
   \                     mks_PrintStatePolling: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable212_1
   \   00000008   0xF204 0x76E8      ADDW     R6,R4,#+2024
   \   0000000C   0xF604 0x051C      ADDW     R5,R4,#+2076
   \   00000010   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000014   0x28A9             CMP      R0,#+169
   \   00000016   0xD122             BNE.N    ??mks_PrintStatePolling_0
   \   00000018   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD107             BNE.N    ??mks_PrintStatePolling_1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000026   0x2865             CMP      R0,#+101
   \   00000028   0xD302             BCC.N    ??mks_PrintStatePolling_1
   \   0000002A   0x68B0             LDR      R0,[R6, #+8]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x60B0             STR      R0,[R6, #+8]
   \                     ??mks_PrintStatePolling_1: (+1)
   \   00000030   0x68B0             LDR      R0,[R6, #+8]
   \   00000032   0x2815             CMP      R0,#+21
   \   00000034   0xDB15             BLT.N    ??mks_PrintStatePolling_2
   \   00000036   0x20AA             MOVS     R0,#+170
   \   00000038   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable215_1
   \   00000040   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD005             BEQ.N    ??mks_PrintStatePolling_3
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0xF44F 0x6096      MOV      R0,#+1200
   \   00000050   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_3: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x60B0             STR      R0,[R6, #+8]
   \   00000058   0x.... 0x....      BL       mks_pausePrint
   \   0000005C   0xE001             B.N      ??mks_PrintStatePolling_2
   \                     ??mks_PrintStatePolling_0: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x60B0             STR      R0,[R6, #+8]
   \                     ??mks_PrintStatePolling_2: (+1)
   \   00000062   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000066   0x28AA             CMP      R0,#+170
   \   00000068   0xD13C             BNE.N    ??mks_PrintStatePolling_4
   \   0000006A   0x.... 0x....      LDR.W    R8,??DataTable217_3  ;; 0x38d1b718
   \   0000006E   0x.... 0x....      LDR.W    R7,??DataTable217_1
   \   00000072   0x68F0             LDR      R0,[R6, #+12]
   \   00000074   0x68B9             LDR      R1,[R7, #+8]
   \   00000076   0x.... 0x....      BL       __aeabi_fsub
   \   0000007A   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   0000007E   0x4641             MOV      R1,R8
   \   00000080   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000084   0xD808             BHI.N    ??mks_PrintStatePolling_5
   \   00000086   0x68B8             LDR      R0,[R7, #+8]
   \   00000088   0x60F0             STR      R0,[R6, #+12]
   \   0000008A   0x2204             MOVS     R2,#+4
   \   0000008C   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   00000090   0xF240 0x40BB      MOVW     R0,#+1211
   \   00000094   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_5: (+1)
   \   00000098   0x6930             LDR      R0,[R6, #+16]
   \   0000009A   0x68F9             LDR      R1,[R7, #+12]
   \   0000009C   0x.... 0x....      BL       __aeabi_fsub
   \   000000A0   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000000A4   0x4641             MOV      R1,R8
   \   000000A6   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000AA   0xD808             BHI.N    ??mks_PrintStatePolling_6
   \   000000AC   0x68F8             LDR      R0,[R7, #+12]
   \   000000AE   0x6130             STR      R0,[R6, #+16]
   \   000000B0   0x2204             MOVS     R2,#+4
   \   000000B2   0xF504 0x61FF      ADD      R1,R4,#+2040
   \   000000B6   0xF240 0x40BF      MOVW     R0,#+1215
   \   000000BA   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_6: (+1)
   \   000000BE   0x6970             LDR      R0,[R6, #+20]
   \   000000C0   0x6939             LDR      R1,[R7, #+16]
   \   000000C2   0x.... 0x....      BL       __aeabi_fsub
   \   000000C6   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000000CA   0x4641             MOV      R1,R8
   \   000000CC   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000D0   0xD808             BHI.N    ??mks_PrintStatePolling_4
   \   000000D2   0x6938             LDR      R0,[R7, #+16]
   \   000000D4   0x6170             STR      R0,[R6, #+20]
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF204 0x71FC      ADDW     R1,R4,#+2044
   \   000000DC   0xF240 0x40C3      MOVW     R0,#+1219
   \   000000E0   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_4: (+1)
   \   000000E4   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   000000E8   0x28A8             CMP      R0,#+168
   \   000000EA   0xD11F             BNE.N    ??mks_PrintStatePolling_7
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable217_4
   \   000000F0   0x7801             LDRB     R1,[R0, #+0]
   \   000000F2   0x2901             CMP      R1,#+1
   \   000000F4   0xD11A             BNE.N    ??mks_PrintStatePolling_7
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x7001             STRB     R1,[R0, #+0]
   \   000000FA   0x6870             LDR      R0,[R6, #+4]
   \   000000FC   0x.... 0x....      BL       mks_preExtrude
   \   00000100   0x6A31             LDR      R1,[R6, #+32]
   \   00000102   0x69F0             LDR      R0,[R6, #+28]
   \   00000104   0x.... 0x....      BL       mks_moveXY
   \   00000108   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   0000010C   0x28AD             CMP      R0,#+173
   \   0000010E   0xD103             BNE.N    ??mks_PrintStatePolling_8
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   00000116   0xE0B6             B.N      ??mks_PrintStatePolling_9
   \                     ??mks_PrintStatePolling_8: (+1)
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x.... 0x....      BL       mks_moveZ
   \   0000011E   0x4620             MOV      R0,R4
   \   00000120   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   \   00000124   0xF604 0x20E8      ADDW     R0,R4,#+2792
   \   00000128   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   \                     ??mks_PrintStatePolling_7: (+1)
   \   0000012C   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000130   0x28A7             CMP      R0,#+167
   \   00000132   0xD12C             BNE.N    ??mks_PrintStatePolling_10
   \   00000134   0xF894 0x0760      LDRB     R0,[R4, #+1888]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD103             BNE.N    ??mks_PrintStatePolling_11
   \   0000013C   0x8EA8             LDRH     R0,[R5, #+52]
   \   0000013E   0x1C40             ADDS     R0,R0,#+1
   \   00000140   0x86A8             STRH     R0,[R5, #+52]
   \   00000142   0xE001             B.N      ??mks_PrintStatePolling_12
   \                     ??mks_PrintStatePolling_11: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x86A8             STRH     R0,[R5, #+52]
   \                     ??mks_PrintStatePolling_12: (+1)
   \   00000148   0x8EA8             LDRH     R0,[R5, #+52]
   \   0000014A   0x2815             CMP      R0,#+21
   \   0000014C   0xDB1F             BLT.N    ??mks_PrintStatePolling_10
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x86A8             STRH     R0,[R5, #+52]
   \   00000152   0x20A6             MOVS     R0,#+166
   \   00000154   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   00000158   0x.... 0x....      LDR.W    R8,??DataTable215_1
   \   0000015C   0xF898 0x019F      LDRB     R0,[R8, #+415]
   \   00000160   0x2801             CMP      R0,#+1
   \   00000162   0xD007             BEQ.N    ??mks_PrintStatePolling_13
   \   00000164   0x2201             MOVS     R2,#+1
   \   00000166   0x4629             MOV      R1,R5
   \   00000168   0xF44F 0x6096      MOV      R0,#+1200
   \   0000016C   0x.... 0x....      BL       epr_write_data
   \   00000170   0x.... 0x....      BL       mks_clearFile
   \                     ??mks_PrintStatePolling_13: (+1)
   \   00000174   0xF898 0x00D9      LDRB     R0,[R8, #+217]
   \   00000178   0x2801             CMP      R0,#+1
   \   0000017A   0xD108             BNE.N    ??mks_PrintStatePolling_10
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable217_5
   \   00000180   0x7800             LDRB     R0,[R0, #+0]
   \   00000182   0x2801             CMP      R0,#+1
   \   00000184   0xD103             BNE.N    ??mks_PrintStatePolling_10
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable219
   \   0000018C   0x7488             STRB     R0,[R1, #+18]
   \                     ??mks_PrintStatePolling_10: (+1)
   \   0000018E   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000192   0x28AD             CMP      R0,#+173
   \   00000194   0xD136             BNE.N    ??mks_PrintStatePolling_14
   \   00000196   0x20A6             MOVS     R0,#+166
   \   00000198   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   0000019C   0x.... 0x....      LDR.W    R8,??DataTable215_1
   \   000001A0   0xF898 0x019F      LDRB     R0,[R8, #+415]
   \   000001A4   0x2801             CMP      R0,#+1
   \   000001A6   0xD005             BEQ.N    ??mks_PrintStatePolling_15
   \   000001A8   0x2201             MOVS     R2,#+1
   \   000001AA   0x4629             MOV      R1,R5
   \   000001AC   0xF44F 0x6096      MOV      R0,#+1200
   \   000001B0   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_15: (+1)
   \   000001B4   0x.... 0x....      BL       _Z19clear_command_queuev
   \   000001B8   0x.... 0x....      BL       _Z17quickstop_stepperv
   \   000001BC   0x.... 0x....      LDR.W    R7,??DataTable217_1
   \   000001C0   0x6A38             LDR      R0,[R7, #+32]
   \   000001C2   0x6270             STR      R0,[R6, #+36]
   \   000001C4   0xF8D4 0x07E8      LDR      R0,[R4, #+2024]
   \   000001C8   0x.... 0x....      BL       mks_moveZ
   \   000001CC   0x.... 0x....      LDR.W    R0,??DataTable218
   \   000001D0   0x.... 0x....      BL       _Z7mks_G28Pc
   \   000001D4   0xF604 0x20E8      ADDW     R0,R4,#+2792
   \   000001D8   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   \   000001DC   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0x.... 0x....      LDR.W    R1,??DataTable220  ;; 0x40000440
   \   000001E6   0xE003             B.N      ??mks_PrintStatePolling_16
   \                     ??mks_PrintStatePolling_17: (+1)
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x66F8             STR      R0,[R7, #+108]
   \   000001EC   0x6008             STR      R0,[R1, #+0]
   \   000001EE   0x2001             MOVS     R0,#+1
   \                     ??mks_PrintStatePolling_16: (+1)
   \   000001F0   0x2800             CMP      R0,#+0
   \   000001F2   0xD0F9             BEQ.N    ??mks_PrintStatePolling_17
   \   000001F4   0x2000             MOVS     R0,#+0
   \   000001F6   0x7138             STRB     R0,[R7, #+4]
   \   000001F8   0xF898 0x019F      LDRB     R0,[R8, #+415]
   \   000001FC   0x2801             CMP      R0,#+1
   \   000001FE   0xD001             BEQ.N    ??mks_PrintStatePolling_14
   \   00000200   0x.... 0x....      BL       mks_clearFile
   \                     ??mks_PrintStatePolling_14: (+1)
   \   00000204   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000208   0x28AC             CMP      R0,#+172
   \   0000020A   0xD119             BNE.N    ??mks_PrintStatePolling_18
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable212_2
   \   00000210   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000214   0x2801             CMP      R0,#+1
   \   00000216   0xD005             BEQ.N    ??mks_PrintStatePolling_19
   \   00000218   0x2802             CMP      R0,#+2
   \   0000021A   0xD00F             BEQ.N    ??mks_PrintStatePolling_20
   \   0000021C   0x2804             CMP      R0,#+4
   \   0000021E   0xD001             BEQ.N    ??mks_PrintStatePolling_19
   \   00000220   0x2808             CMP      R0,#+8
   \   00000222   0xD10D             BNE.N    ??mks_PrintStatePolling_18
   \                     ??mks_PrintStatePolling_19: (+1)
   \   00000224   0xF994 0x0AE4      LDRSB    R0,[R4, #+2788]
   \   00000228   0x2801             CMP      R0,#+1
   \   0000022A   0xD102             BNE.N    ??mks_PrintStatePolling_21
   \   0000022C   0x.... 0x....      BL       mks_contiuePrintPause
   \   00000230   0xE006             B.N      ??mks_PrintStatePolling_18
   \                     ??mks_PrintStatePolling_21: (+1)
   \   00000232   0x2802             CMP      R0,#+2
   \   00000234   0xD104             BNE.N    ??mks_PrintStatePolling_18
   \   00000236   0x.... 0x....      BL       mks_contiuePrintPwdwn
   \   0000023A   0xE001             B.N      ??mks_PrintStatePolling_18
   \                     ??mks_PrintStatePolling_20: (+1)
   \   0000023C   0x.... 0x....      BL       mks_contiuePrintDelta
   \                     ??mks_PrintStatePolling_18: (+1)
   \   00000240   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000244   0x28A7             CMP      R0,#+167
   \   00000246   0xD10D             BNE.N    ??mks_PrintStatePolling_22
   \   00000248   0xF894 0x0760      LDRB     R0,[R4, #+1888]
   \   0000024C   0x7D29             LDRB     R1,[R5, #+20]
   \   0000024E   0x4208             TST      R0,R1
   \   00000250   0xD008             BEQ.N    ??mks_PrintStatePolling_22
   \   00000252   0x4620             MOV      R0,R4
   \   00000254   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000258   0x2865             CMP      R0,#+101
   \   0000025A   0xD301             BCC.N    ??mks_PrintStatePolling_23
   \   0000025C   0x.... 0x....      BL       mks_WriteToFile
   \                     ??mks_PrintStatePolling_23: (+1)
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0x7528             STRB     R0,[R5, #+20]

  	if(mksReprint.mks_printer_state == MKS_IDLE && print_finish_close_machine == true)
  	                                                                          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",763  Warning[Pa118]: 
          mixing boolean and non-boolean types in a comparison results in the
          boolean being promoted
   \                     ??mks_PrintStatePolling_22: (+1)
   \   00000264   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000268   0x28A6             CMP      R0,#+166
   \   0000026A   0xD10C             BNE.N    ??mks_PrintStatePolling_9
   \   0000026C   0x.... 0x....      LDR.W    R0,??DataTable219
   \   00000270   0x7CC1             LDRB     R1,[R0, #+19]
   \   00000272   0x2901             CMP      R1,#+1
   \   00000274   0xD107             BNE.N    ??mks_PrintStatePolling_9
   \   00000276   0x2100             MOVS     R1,#+0
   \   00000278   0x74C1             STRB     R1,[R0, #+19]
   \   0000027A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   0000027E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000282   0x.... 0x....      B.W      _Z21Close_machine_displayv
   \                     ??mks_PrintStatePolling_9: (+1)
   \   00000286   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setTemperature()
   \                     _Z18mks_setTemperaturev: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable212_1
   \   0000000A   0xF604 0x0532      ADDW     R5,R4,#+2098
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable212_2
   \   00000012   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD01E             BEQ.N    ??mks_setTemperature_0
   \   0000001A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD01B             BEQ.N    ??mks_setTemperature_0
   \   00000020   0x2260             MOVS     R2,#+96
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF604 0x0052      ADDW     R0,R4,#+2130
   \   00000028   0x.... 0x....      BL       memset
   \   0000002C   0xF604 0x0752      ADDW     R7,R4,#+2130
   \   00000030   0x2207             MOVS     R2,#+7
   \   00000032   0x.... 0x....      ADR.W    R1,`?<Constant "M140 S">`
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
   \   0000003C   0x88AA             LDRH     R2,[R5, #+4]
   \   0000003E   0x....             ADR.N    R1,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       sprintf
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0x4638             MOV      R0,R7
   \   0000004A   0x.... 0x....      BL       strcat
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000054   0x.... 0x....      BL       _Z10gcode_M140v
   \                     ??mks_setTemperature_0: (+1)
   \   00000058   0xF8B4 0x0832      LDRH     R0,[R4, #+2098]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD03E             BEQ.N    ??mks_setTemperature_1
   \   00000060   0xF604 0x0752      ADDW     R7,R4,#+2130
   \   00000064   0xF604 0x0852      ADDW     R8,R4,#+2130
   \   00000068   0xF04F 0x090A      MOV      R9,#+10
   \   0000006C   0x.... 0x....      ADR.W    R10,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
   \   00000070   0xF896 0x00F7      LDRB     R0,[R6, #+247]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD118             BNE.N    ??mks_setTemperature_2
   \   00000078   0x2260             MOVS     R2,#+96
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0x.... 0x....      BL       memset
   \   00000082   0x464A             MOV      R2,R9
   \   00000084   0x.... 0x....      ADR.W    R1,`?<Constant "M104 T1 S">`
   \   00000088   0x4638             MOV      R0,R7
   \   0000008A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000008E   0x886A             LDRH     R2,[R5, #+2]
   \   00000090   0x4651             MOV      R1,R10
   \   00000092   0xA800             ADD      R0,SP,#+0
   \   00000094   0x.... 0x....      BL       sprintf
   \   00000098   0xA900             ADD      R1,SP,#+0
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       strcat
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000A6   0x.... 0x....      BL       _Z10gcode_M104v
   \                     ??mks_setTemperature_2: (+1)
   \   000000AA   0x2260             MOVS     R2,#+96
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x4640             MOV      R0,R8
   \   000000B0   0x.... 0x....      BL       memset
   \   000000B4   0x464A             MOV      R2,R9
   \   000000B6   0x.... 0x....      ADR.W    R1,`?<Constant "M109 T0 S">`
   \   000000BA   0x4638             MOV      R0,R7
   \   000000BC   0x.... 0x....      BL       __aeabi_memcpy
   \   000000C0   0xF8B4 0x2832      LDRH     R2,[R4, #+2098]
   \   000000C4   0x4651             MOV      R1,R10
   \   000000C6   0xA800             ADD      R0,SP,#+0
   \   000000C8   0x.... 0x....      BL       sprintf
   \   000000CC   0xA900             ADD      R1,SP,#+0
   \   000000CE   0x4638             MOV      R0,R7
   \   000000D0   0x.... 0x....      BL       strcat
   \   000000D4   0x4638             MOV      R0,R7
   \   000000D6   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000DA   0x.... 0x....      BL       _Z10gcode_M109v
   \                     ??mks_setTemperature_1: (+1)
   \   000000DE   0xF896 0x00F7      LDRB     R0,[R6, #+247]
   \   000000E2   0x2802             CMP      R0,#+2
   \   000000E4   0xD11E             BNE.N    ??mks_setTemperature_3
   \   000000E6   0x8868             LDRH     R0,[R5, #+2]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD01B             BEQ.N    ??mks_setTemperature_3
   \   000000EC   0x2260             MOVS     R2,#+96
   \   000000EE   0x2100             MOVS     R1,#+0
   \   000000F0   0xF604 0x0052      ADDW     R0,R4,#+2130
   \   000000F4   0x.... 0x....      BL       memset
   \   000000F8   0xF604 0x0752      ADDW     R7,R4,#+2130
   \   000000FC   0x220A             MOVS     R2,#+10
   \   000000FE   0x.... 0x....      ADR.W    R1,`?<Constant "M109 T1 S">`
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x.... 0x....      BL       __aeabi_memcpy
   \   00000108   0x886A             LDRH     R2,[R5, #+2]
   \   0000010A   0x....             ADR.N    R1,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
   \   0000010C   0xA800             ADD      R0,SP,#+0
   \   0000010E   0x.... 0x....      BL       sprintf
   \   00000112   0xA900             ADD      R1,SP,#+0
   \   00000114   0x4638             MOV      R0,R7
   \   00000116   0x.... 0x....      BL       strcat
   \   0000011A   0x4638             MOV      R0,R7
   \   0000011C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000120   0x.... 0x....      BL       _Z10gcode_M109v
   \                     ??mks_setTemperature_3: (+1)
   \   00000124   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD01E             BEQ.N    ??mks_setTemperature_4
   \   0000012C   0x88A8             LDRH     R0,[R5, #+4]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD01B             BEQ.N    ??mks_setTemperature_4
   \   00000132   0x2260             MOVS     R2,#+96
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0xF604 0x0052      ADDW     R0,R4,#+2130
   \   0000013A   0x.... 0x....      BL       memset
   \   0000013E   0xF604 0x0752      ADDW     R7,R4,#+2130
   \   00000142   0x2207             MOVS     R2,#+7
   \   00000144   0x.... 0x....      ADR.W    R1,`?<Constant "M190 S">`
   \   00000148   0x4638             MOV      R0,R7
   \   0000014A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000014E   0x88AA             LDRH     R2,[R5, #+4]
   \   00000150   0x....             ADR.N    R1,??DataTable206  ;; 0x25, 0x64, 0x00, 0x00
   \   00000152   0xA800             ADD      R0,SP,#+0
   \   00000154   0x.... 0x....      BL       sprintf
   \   00000158   0xA900             ADD      R1,SP,#+0
   \   0000015A   0x4638             MOV      R0,R7
   \   0000015C   0x.... 0x....      BL       strcat
   \   00000160   0x4638             MOV      R0,R7
   \   00000162   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000166   0x.... 0x....      BL       _Z10gcode_M190v
   \                     ??mks_setTemperature_4: (+1)
   \   0000016A   0xB006             ADD      SP,SP,#+24
   \   0000016C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setPositionZ()
   \                     mks_setPositionZ: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable212_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF604 0x0052      ADDW     R0,R4,#+2130
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF604 0x0552      ADDW     R5,R4,#+2130
   \   00000018   0x2206             MOVS     R2,#+6
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "G92 Z">`
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       memset
   \   0000002E   0xF8D4 0x07FC      LDR      R0,[R4, #+2044]
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4602             MOV      R2,R0
   \   00000038   0x460B             MOV      R3,R1
   \   0000003A   0x....             ADR.N    R1,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       sprintf
   \   00000042   0xA900             ADD      R1,SP,#+0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       strcat
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000050   0x.... 0x....      BL       _Z9gcode_G92v
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable217_1
   \   0000005A   0x64C8             STR      R0,[R1, #+76]
   \   0000005C   0xB005             ADD      SP,SP,#+20
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ResetPositionZ(float)
   \                     _Z18mks_ResetPositionZf: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable212_1
   \   0000000A   0x2260             MOVS     R2,#+96
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF605 0x0052      ADDW     R0,R5,#+2130
   \   00000012   0x.... 0x....      BL       memset
   \   00000016   0xF605 0x0552      ADDW     R5,R5,#+2130
   \   0000001A   0x2206             MOVS     R2,#+6
   \   0000001C   0x.... 0x....      ADR.W    R1,`?<Constant "G92 Z">`
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
   \   00000026   0x2214             MOVS     R2,#+20
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       memset
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4602             MOV      R2,R0
   \   00000038   0x460B             MOV      R3,R1
   \   0000003A   0x....             ADR.N    R1,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       sprintf
   \   00000042   0xA900             ADD      R1,SP,#+0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       strcat
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000050   0x.... 0x....      BL       _Z9gcode_G92v
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable217_1
   \   0000005A   0x64C8             STR      R0,[R1, #+76]
   \   0000005C   0xB005             ADD      SP,SP,#+20
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setFeedrate()
   \                     _Z15mks_setFeedratev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable212_1
   \   00000004   0xF8D0 0x0838      LDR      R0,[R0, #+2104]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable217_1
   \   0000000C   0x65C8             STR      R0,[R1, #+92]
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_preExtrude(float)
   \                     mks_preExtrude: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable221_1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x7160             STRB     R0,[R4, #+5]
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable212_1
   \   00000014   0xF605 0x0852      ADDW     R8,R5,#+2130
   \   00000018   0x2260             MOVS     R2,#+96
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x4640             MOV      R0,R8
   \   0000001E   0x.... 0x....      BL       memset
   \   00000022   0xF605 0x0652      ADDW     R6,R5,#+2130
   \   00000026   0x2205             MOVS     R2,#+5
   \   00000028   0x.... 0x....      ADR.W    R1,`?<Constant "G1 E">`
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000032   0x2214             MOVS     R2,#+20
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xA800             ADD      R0,SP,#+0
   \   00000038   0x.... 0x....      BL       memset
   \   0000003C   0x....             ADR.N    R7,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003E   0x4648             MOV      R0,R9
   \   00000040   0x.... 0x....      BL       __aeabi_f2d
   \   00000044   0x4602             MOV      R2,R0
   \   00000046   0x460B             MOV      R3,R1
   \   00000048   0x4639             MOV      R1,R7
   \   0000004A   0xA800             ADD      R0,SP,#+0
   \   0000004C   0x.... 0x....      BL       sprintf
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       strcat
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000005E   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000062   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x7160             STRB     R0,[R4, #+5]
   \   0000006A   0x2260             MOVS     R2,#+96
   \   0000006C   0x4601             MOV      R1,R0
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       memset
   \   00000074   0x2206             MOVS     R2,#+6
   \   00000076   0x.... 0x....      ADR.W    R1,`?<Constant "G92 E">`
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000080   0x2214             MOVS     R2,#+20
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0xA800             ADD      R0,SP,#+0
   \   00000086   0x.... 0x....      BL       memset
   \   0000008A   0xF8D5 0x0810      LDR      R0,[R5, #+2064]
   \   0000008E   0x.... 0x....      BL       __aeabi_f2d
   \   00000092   0x4602             MOV      R2,R0
   \   00000094   0x460B             MOV      R3,R1
   \   00000096   0x4639             MOV      R1,R7
   \   00000098   0xA800             ADD      R0,SP,#+0
   \   0000009A   0x.... 0x....      BL       sprintf
   \   0000009E   0xA900             ADD      R1,SP,#+0
   \   000000A0   0x4630             MOV      R0,R6
   \   000000A2   0x.... 0x....      BL       strcat
   \   000000A6   0x4630             MOV      R0,R6
   \   000000A8   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000AC   0x.... 0x....      BL       _Z9gcode_G92v
   \   000000B0   0xB005             ADD      SP,SP,#+20
   \   000000B2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveXY(float, float)
   \                     mks_moveXY: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x....             LDR.N    R6,??DataTable212_1
   \   0000000A   0x2260             MOVS     R2,#+96
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF606 0x0052      ADDW     R0,R6,#+2130
   \   00000012   0x.... 0x....      BL       memset
   \   00000016   0xF606 0x0652      ADDW     R6,R6,#+2130
   \   0000001A   0x2205             MOVS     R2,#+5
   \   0000001C   0x.... 0x....      ADR.W    R1,`?<Constant "G1 X">`
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
   \   00000026   0x2214             MOVS     R2,#+20
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       memset
   \   00000030   0x....             ADR.N    R7,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       __aeabi_f2d
   \   00000038   0x4602             MOV      R2,R0
   \   0000003A   0x460B             MOV      R3,R1
   \   0000003C   0x4639             MOV      R1,R7
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       sprintf
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       strcat
   \   0000004C   0x....             ADR.N    R1,??DataTable212  ;; 0x20, 0x59, 0x00, 0x00
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       strcat
   \   00000054   0x2214             MOVS     R2,#+20
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x.... 0x....      BL       memset
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_f2d
   \   00000064   0x4602             MOV      R2,R0
   \   00000066   0x460B             MOV      R3,R1
   \   00000068   0x4639             MOV      R1,R7
   \   0000006A   0xA800             ADD      R0,SP,#+0
   \   0000006C   0x.... 0x....      BL       sprintf
   \   00000070   0xA900             ADD      R1,SP,#+0
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x.... 0x....      BL       strcat
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000007E   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000082   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000086   0xB005             ADD      SP,SP,#+20
   \   00000088   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_home_moveXY(float, float, float)
   \                     mks_home_moveXY: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x....             LDR.N    R7,??DataTable212_1
   \   0000000C   0x2260             MOVS     R2,#+96
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF607 0x0052      ADDW     R0,R7,#+2130
   \   00000014   0x.... 0x....      BL       memset
   \   00000018   0xF607 0x0752      ADDW     R7,R7,#+2130
   \   0000001C   0x2205             MOVS     R2,#+5
   \   0000001E   0x.... 0x....      ADR.W    R1,`?<Constant "G1 X">`
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy
   \   00000028   0x2214             MOVS     R2,#+20
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xA801             ADD      R0,SP,#+4
   \   0000002E   0x.... 0x....      BL       memset
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       __aeabi_f2d
   \   00000038   0x4602             MOV      R2,R0
   \   0000003A   0x460B             MOV      R3,R1
   \   0000003C   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f">`
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       sprintf
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0x4638             MOV      R0,R7
   \   0000004A   0x.... 0x....      BL       strcat
   \   0000004E   0x....             ADR.N    R1,??DataTable212  ;; 0x20, 0x59, 0x00, 0x00
   \   00000050   0x4638             MOV      R0,R7
   \   00000052   0x.... 0x....      BL       strcat
   \   00000056   0x2214             MOVS     R2,#+20
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       memset
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       __aeabi_f2iz
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       __aeabi_f2d
   \   0000006E   0x4602             MOV      R2,R0
   \   00000070   0x460B             MOV      R3,R1
   \   00000072   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f F%d">`
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x.... 0x....      BL       sprintf
   \   0000007C   0xA901             ADD      R1,SP,#+4
   \   0000007E   0x4638             MOV      R0,R7
   \   00000080   0x.... 0x....      BL       strcat
   \   00000084   0x4638             MOV      R0,R7
   \   00000086   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000008A   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   0000008E   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000092   0xB007             ADD      SP,SP,#+28
   \   00000094   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_home_moveZ(float)
   \                     mks_home_moveZ: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x....             LDR.N    R5,??DataTable212_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF605 0x0052      ADDW     R0,R5,#+2130
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF605 0x0552      ADDW     R5,R5,#+2130
   \   00000018   0x2205             MOVS     R2,#+5
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       memset
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       __aeabi_f2d
   \   00000034   0x4602             MOV      R2,R0
   \   00000036   0x460B             MOV      R3,R1
   \   00000038   0x....             ADR.N    R1,??DataTable208  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x.... 0x....      BL       sprintf
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       strcat
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000004E   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000052   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000056   0xB005             ADD      SP,SP,#+20
   \   00000058   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveZ(float)
   \                     mks_moveZ: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x....             LDR.N    R5,??DataTable212_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF605 0x0052      ADDW     R0,R5,#+2130
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF605 0x0652      ADDW     R6,R5,#+2130
   \   00000018   0x2205             MOVS     R2,#+5
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       memset
   \   0000002E   0xF8D5 0x080C      LDR      R0,[R5, #+2060]
   \   00000032   0x4621             MOV      R1,R4
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x.... 0x....      BL       __aeabi_f2d
   \   0000003C   0x4602             MOV      R2,R0
   \   0000003E   0x460B             MOV      R3,R1
   \   00000040   0x....             ADR.N    R1,??DataTable215  ;; 0x25, 0x66, 0x00, 0x00
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       sprintf
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       strcat
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000056   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   0000005A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   0000005E   0xB006             ADD      SP,SP,#+24
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveZ_relative(float)
   \                     _Z18mks_moveZ_relativef: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable221_1
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7160             STRB     R0,[R4, #+5]
   \   0000000E   0x....             LDR.N    R6,??DataTable212_1
   \   00000010   0x2260             MOVS     R2,#+96
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF606 0x0052      ADDW     R0,R6,#+2130
   \   00000018   0x.... 0x....      BL       memset
   \   0000001C   0xF606 0x0652      ADDW     R6,R6,#+2130
   \   00000020   0x2205             MOVS     R2,#+5
   \   00000022   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       memset
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       __aeabi_f2d
   \   0000003C   0x4602             MOV      R2,R0
   \   0000003E   0x460B             MOV      R3,R1
   \   00000040   0x....             ADR.N    R1,??DataTable215  ;; 0x25, 0x66, 0x00, 0x00
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       sprintf
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       strcat
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000056   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   0000005A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x7160             STRB     R0,[R4, #+5]
   \   00000062   0xB006             ADD      SP,SP,#+24
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_G28(char *)
   \                     _Z7mks_G28Pc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable212_1
   \   00000006   0x2260             MOVS     R2,#+96
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF605 0x0052      ADDW     R0,R5,#+2130
   \   0000000E   0x.... 0x....      BL       memset
   \   00000012   0xF605 0x0552      ADDW     R5,R5,#+2130
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       strcpy
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       _Z9gcode_G28b
   \   0000002A   0x....             LDR.N    R4,??DataTable212_2
   \   0000002C   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   00000030   0x213E             MOVS     R1,#+62
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD018             BEQ.N    ??mks_G28_0
   \   00000036   0x2810             CMP      R0,#+16
   \   00000038   0xD016             BEQ.N    ??mks_G28_0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   \   00000040   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000044   0x2802             CMP      R0,#+2
   \   00000046   0xD00F             BEQ.N    ??mks_G28_0
   \   00000048   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   0000004C   0x06C0             LSLS     R0,R0,#+27
   \   0000004E   0xD50B             BPL.N    ??mks_G28_0
   \   00000050   0x205A             MOVS     R0,#+90
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD006             BEQ.N    ??mks_G28_0
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000064   0x.... 0x....      B.W      _Z17set_z_fade_heightfb
   \                     ??mks_G28_0: (+1)
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_leveling_moveZ(float)
   \                     _Z18mks_leveling_moveZf: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x....             LDR.N    R5,??DataTable212_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF605 0x0052      ADDW     R0,R5,#+2130
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF605 0x0652      ADDW     R6,R5,#+2130
   \   00000018   0x2205             MOVS     R2,#+5
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA802             ADD      R0,SP,#+8
   \   0000002A   0x.... 0x....      BL       memset
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable225_1
   \   00000032   0x6881             LDR      R1,[R0, #+8]
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable226_1  ;; 0x42700000
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x.... 0x....      BL       __aeabi_f2d
   \   00000040   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000044   0xF8D5 0x080C      LDR      R0,[R5, #+2060]
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0x.... 0x....      BL       __aeabi_fadd
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0x460B             MOV      R3,R1
   \   00000056   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f F%.3f">`
   \   0000005A   0xA802             ADD      R0,SP,#+8
   \   0000005C   0x.... 0x....      BL       sprintf
   \   00000060   0xA902             ADD      R1,SP,#+8
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       strcat
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000006E   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000072   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000076   0xB008             ADD      SP,SP,#+32
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_leveling_moveXY(float, float)
   \                     _Z19mks_leveling_moveXYff: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable225_2
   \   0000000C   0x2260             MOVS     R2,#+96
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF606 0x0052      ADDW     R0,R6,#+2130
   \   00000014   0x.... 0x....      BL       memset
   \   00000018   0xF606 0x0652      ADDW     R6,R6,#+2130
   \   0000001C   0x2205             MOVS     R2,#+5
   \   0000001E   0x.... 0x....      ADR.W    R1,`?<Constant "G1 X">`
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy
   \   00000028   0x2214             MOVS     R2,#+20
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xA802             ADD      R0,SP,#+8
   \   0000002E   0x.... 0x....      BL       memset
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       __aeabi_f2d
   \   00000038   0x4602             MOV      R2,R0
   \   0000003A   0x460B             MOV      R3,R1
   \   0000003C   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f">`
   \   00000040   0xA802             ADD      R0,SP,#+8
   \   00000042   0x.... 0x....      BL       sprintf
   \   00000046   0xA902             ADD      R1,SP,#+8
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       strcat
   \   0000004E   0x....             ADR.N    R1,??DataTable217  ;; 0x20, 0x59, 0x00, 0x00
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       strcat
   \   00000056   0x2214             MOVS     R2,#+20
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xA802             ADD      R0,SP,#+8
   \   0000005C   0x.... 0x....      BL       memset
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable228
   \   00000064   0x6A40             LDR      R0,[R0, #+36]
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       __aeabi_f2d
   \   00000074   0x4602             MOV      R2,R0
   \   00000076   0x460B             MOV      R3,R1
   \   00000078   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f F%.3f">`
   \   0000007C   0xA802             ADD      R0,SP,#+8
   \   0000007E   0x.... 0x....      BL       sprintf
   \   00000082   0xA902             ADD      R1,SP,#+8
   \   00000084   0x4630             MOV      R0,R6
   \   00000086   0x.... 0x....      BL       strcat
   \   0000008A   0x4630             MOV      R0,R6
   \   0000008C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000090   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000094   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000098   0xB008             ADD      SP,SP,#+32
   \   0000009A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
   \                     mks_manual_leveling: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1

      char string[20];
           ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1078  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable225_3
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD104             BNE.N    ??mks_manual_leveling_0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0x....             ADR.N    R0,??DataTable217_2  ;; "G28"
   \   00000016   0x.... 0x....      BL       _Z7mks_G28Pc
   \                     ??mks_manual_leveling_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable217_1
   \   0000001C   0x6900             LDR      R0,[R0, #+16]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable225_2
   \   00000022   0xF8C1 0x080C      STR      R0,[R1, #+2060]
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable229  ;; 0x41200000
   \   0000002A   0x.... 0x....      BL       _Z18mks_leveling_moveZf
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       __aeabi_i2f
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x460D             MOV      R5,R1
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       __aeabi_i2f
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x.... 0x....      BL       _Z19mks_leveling_moveXYff
   \   00000044   0x.... 0x....      ADR.W    R0,`?<Constant "G1 Z0">`
   \   00000048   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000004C   0x.... 0x....      B.W      _Z27enqueue_and_echo_commands_PPKc

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPause()
   \                     mks_contiuePrintPause: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}

  	char string[20];
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1094  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable225_2
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   0000000C   0x.... 0x....      BL       _Z18mks_setTemperaturev
   \   00000010   0x.... 0x....      ADR.W    R0,`?<Constant "G28 X0 Y0">`
   \   00000014   0x.... 0x....      BL       _Z7mks_G28Pc
   \   00000018   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   0000001C   0x28AD             CMP      R0,#+173
   \   0000001E   0xD103             BNE.N    ??mks_contiuePrintPause_0
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   00000026   0xBD10             POP      {R4,PC}
   \                     ??mks_contiuePrintPause_0: (+1)
   \   00000028   0xF8D4 0x07EC      LDR      R0,[R4, #+2028]
   \   0000002C   0x.... 0x....      BL       mks_preExtrude
   \   00000030   0xF204 0x70EC      ADDW     R0,R4,#+2028
   \   00000034   0x69C1             LDR      R1,[R0, #+28]
   \   00000036   0x6980             LDR      R0,[R0, #+24]
   \   00000038   0x.... 0x....      BL       mks_moveXY
   \   0000003C   0x.... 0x....      BL       mks_setPositionZ
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       mks_moveZ
   \   00000046   0x.... 0x....      BL       _Z15mks_setFeedratev
   \   0000004A   0xF894 0x083C      LDRB     R0,[R4, #+2108]
   \   0000004E   0x....             LDR.N    R1,??DataTable217_1
   \   00000050   0x66C8             STR      R0,[R1, #+108]
   \   00000052   0xF242 0x7110      MOVW     R1,#+10000
   \   00000056   0x4348             MULS     R0,R1,R0
   \   00000058   0x21FF             MOVS     R1,#+255
   \   0000005A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable220  ;; 0x40000440
   \   00000062   0x6008             STR      R0,[R1, #+0]
   \   00000064   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000068   0x28AD             CMP      R0,#+173
   \   0000006A   0xD103             BNE.N    ??mks_contiuePrintPause_1
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   00000072   0xBD10             POP      {R4,PC}
   \                     ??mks_contiuePrintPause_1: (+1)
   \   00000074   0x20A7             MOVS     R0,#+167
   \   00000076   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   0000007A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000007E   0x.... 0x....      B.W      _Z9gcode_M24v

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPwdwn()
   \                     mks_contiuePrintPwdwn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	char string[20];
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1145  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable225_2
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0xF44F 0x7180      MOV      R1,#+256
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable228_1  ;; 0x40010c00
   \   00000016   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2108             MOVS     R1,#+8
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable228_2  ;; 0x40010800
   \   00000022   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000026   0x.... 0x....      BL       _Z18mks_setTemperaturev
   \   0000002A   0x.... 0x....      BL       mks_setPositionZ
   \   0000002E   0xF8D4 0x07E8      LDR      R0,[R4, #+2024]
   \   00000032   0x.... 0x....      BL       mks_moveZ
   \   00000036   0x.... 0x....      ADR.W    R0,`?<Constant "G28 X0 Y0">`
   \   0000003A   0x.... 0x....      BL       _Z7mks_G28Pc
   \   0000003E   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   00000042   0x28AD             CMP      R0,#+173
   \   00000044   0xD103             BNE.N    ??mks_contiuePrintPwdwn_0
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??mks_contiuePrintPwdwn_0: (+1)
   \   0000004E   0xF204 0x75E8      ADDW     R5,R4,#+2024
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable228
   \   00000056   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000005A   0x2808             CMP      R0,#+8
   \   0000005C   0xD106             BNE.N    ??mks_contiuePrintPwdwn_1
   \   0000005E   0x6968             LDR      R0,[R5, #+20]
   \   00000060   0xF8D4 0x17E8      LDR      R1,[R4, #+2024]
   \   00000064   0x.... 0x....      BL       __aeabi_fadd
   \   00000068   0x.... 0x....      BL       _Z18mks_ResetPositionZf
   \                     ??mks_contiuePrintPwdwn_1: (+1)
   \   0000006C   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000070   0x.... 0x....      BL       HAL_Delay
   \   00000074   0x6868             LDR      R0,[R5, #+4]
   \   00000076   0x.... 0x....      BL       mks_preExtrude
   \   0000007A   0x6A29             LDR      R1,[R5, #+32]
   \   0000007C   0x69E8             LDR      R0,[R5, #+28]
   \   0000007E   0x.... 0x....      BL       mks_moveXY
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       mks_moveZ
   \   00000088   0x.... 0x....      BL       _Z15mks_setFeedratev
   \   0000008C   0xF894 0x083C      LDRB     R0,[R4, #+2108]
   \   00000090   0x....             LDR.N    R1,??DataTable217_1
   \   00000092   0x66C8             STR      R0,[R1, #+108]
   \   00000094   0xF242 0x7110      MOVW     R1,#+10000
   \   00000098   0x4348             MULS     R0,R1,R0
   \   0000009A   0x21FF             MOVS     R1,#+255
   \   0000009C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable220  ;; 0x40000440
   \   000000A4   0x6008             STR      R0,[R1, #+0]
   \   000000A6   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   000000AA   0x28AD             CMP      R0,#+173
   \   000000AC   0xD103             BNE.N    ??mks_contiuePrintPwdwn_2
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   000000B4   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??mks_contiuePrintPwdwn_2: (+1)
   \   000000B6   0x20A7             MOVS     R0,#+167
   \   000000B8   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   000000BC   0x.... 0x....      BL       _Z9gcode_M24v
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF884 0x0830      STRB     R0,[R4, #+2096]
   \   000000C6   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintDelta()
   \                     mks_contiuePrintDelta: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	char string[20];
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1208  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable225_2
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   0000000C   0x.... 0x....      BL       _Z18mks_setTemperaturev
   \   00000010   0x....             ADR.N    R0,??DataTable217_2  ;; "G28"
   \   00000012   0x.... 0x....      BL       _Z7mks_G28Pc
   \   00000016   0xF8D4 0x07E8      LDR      R0,[R4, #+2024]
   \   0000001A   0x.... 0x....      BL       mks_moveZ
   \   0000001E   0xF204 0x75E8      ADDW     R5,R4,#+2024
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x.... 0x....      BL       mks_preExtrude
   \   00000028   0x6A29             LDR      R1,[R5, #+32]
   \   0000002A   0x69E8             LDR      R0,[R5, #+28]
   \   0000002C   0x.... 0x....      BL       mks_moveXY
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       mks_moveZ
   \   00000036   0x.... 0x....      BL       _Z15mks_setFeedratev
   \   0000003A   0xF894 0x083C      LDRB     R0,[R4, #+2108]
   \   0000003E   0x....             LDR.N    R1,??DataTable217_1
   \   00000040   0x66C8             STR      R0,[R1, #+108]
   \   00000042   0xF242 0x7110      MOVW     R1,#+10000
   \   00000046   0x4348             MULS     R0,R1,R0
   \   00000048   0x21FF             MOVS     R1,#+255
   \   0000004A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable220  ;; 0x40000440
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0x20A7             MOVS     R0,#+167
   \   00000056   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   0000005A   0x.... 0x....      BL       _Z9gcode_M24v
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x0830      STRB     R0,[R4, #+2096]
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 1
   \   static __absolute uint8_t first_resu
   \                     first_resu:
   \   00000000   0x01               DC8 1

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_getPositionXYZE()
   \                     mks_getPositionXYZE: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable230
   \   00000010   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD077             BEQ.N    ??mks_getPositionXYZE_0
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable225_2
   \   0000001C   0xF204 0x75FC      ADDW     R5,R4,#+2044
   \   00000020   0x6A69             LDR      R1,[R5, #+36]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   0000002E   0x.... 0x....      BL       _Z19get_sdcard_commandsv
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   00000038   0xF884 0x0830      STRB     R0,[R4, #+2096]
   \   0000003C   0x.... 0x....      LDR.W    R6,??DataTable226_2
   \   00000040   0x4602             MOV      R2,R0
   \   00000042   0xE004             B.N      ??mks_getPositionXYZE_1
   \                     ??mks_getPositionXYZE_2: (+1)
   \   00000044   0xEB06 0x0180      ADD      R1,R6,R0, LSL #+2
   \   00000048   0x608A             STR      R2,[R1, #+8]
   \   0000004A   0x618A             STR      R2,[R1, #+24]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \                     ??mks_getPositionXYZE_1: (+1)
   \   0000004E   0x2804             CMP      R0,#+4
   \   00000050   0xDBF8             BLT.N    ??mks_getPositionXYZE_2
   \   00000052   0x4617             MOV      R7,R2
   \   00000054   0xE019             B.N      ??mks_getPositionXYZE_3
   \                     ??mks_getPositionXYZE_4: (+1)
   \   00000056   0xEB04 0x0283      ADD      R2,R4,R3, LSL #+2
   \   0000005A   0xF8D2 0x0804      LDR      R0,[R2, #+2052]
   \   0000005E   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000062   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000066   0xD20C             BCS.N    ??mks_getPositionXYZE_5
   \   00000068   0x.... 0x....      LDR.W    R6,??DataTable226_2
   \   0000006C   0xEB06 0x0683      ADD      R6,R6,R3, LSL #+2
   \   00000070   0x69B0             LDR      R0,[R6, #+24]
   \   00000072   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000076   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000007A   0xD802             BHI.N    ??mks_getPositionXYZE_5
   \   0000007C   0x69B0             LDR      R0,[R6, #+24]
   \   0000007E   0xF8C2 0x0804      STR      R0,[R2, #+2052]
   \                     ??mks_getPositionXYZE_5: (+1)
   \   00000082   0x1C5B             ADDS     R3,R3,#+1
   \                     ??mks_getPositionXYZE_6: (+1)
   \   00000084   0x2B04             CMP      R3,#+4
   \   00000086   0xDBE6             BLT.N    ??mks_getPositionXYZE_4
   \   00000088   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mks_getPositionXYZE_3: (+1)
   \   0000008A   0x2F04             CMP      R7,#+4
   \   0000008C   0xDA36             BGE.N    ??mks_getPositionXYZE_7
   \   0000008E   0x2F00             CMP      R7,#+0
   \   00000090   0xD126             BNE.N    ??mks_getPositionXYZE_8
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable230_1
   \   00000096   0x7801             LDRB     R1,[R0, #+0]
   \   00000098   0x2901             CMP      R1,#+1
   \   0000009A   0xD121             BNE.N    ??mks_getPositionXYZE_8
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x7001             STRB     R1,[R0, #+0]
   \   000000A0   0x215A             MOVS     R1,#+90
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable230_2
   \   000000A6   0x.... 0x....      BL       _Z6strchrPci
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xAB01             ADD      R3,SP,#+4
   \   000000AE   0xD021             BEQ.N    ??mks_getPositionXYZE_9
   \                     ??mks_getPositionXYZE_10: (+1)
   \   000000B0   0xF910 0x1B01      LDRSB    R1,[R0], #+1
   \   000000B4   0x2900             CMP      R1,#+0
   \   000000B6   0xD00A             BEQ.N    ??mks_getPositionXYZE_11
   \   000000B8   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   000000BC   0x1C4A             ADDS     R2,R1,#+1
   \   000000BE   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   000000C2   0x7802             LDRB     R2,[R0, #+0]
   \   000000C4   0x54CA             STRB     R2,[R1, R3]
   \   000000C6   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   000000CA   0x2915             CMP      R1,#+21
   \   000000CC   0xDBF0             BLT.N    ??mks_getPositionXYZE_10
   \                     ??mks_getPositionXYZE_11: (+1)
   \   000000CE   0xA801             ADD      R0,SP,#+4
   \   000000D0   0x.... 0x....      BL       atof
   \   000000D4   0x.... 0x....      BL       __aeabi_d2f
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable226_2
   \   000000DC   0x6208             STR      R0,[R1, #+32]
   \   000000DE   0xE009             B.N      ??mks_getPositionXYZE_9
   \                     ??mks_getPositionXYZE_8: (+1)
   \   000000E0   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable230_2
   \   000000E8   0xEB01 0x1040      ADD      R0,R1,R0, LSL #+5
   \   000000EC   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000F0   0x.... 0x....      BL       _Z21gcode_get_destinationv
   \                     ??mks_getPositionXYZE_9: (+1)
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable230_3  ;; 0x38d1b718
   \   000000FA   0xE7C3             B.N      ??mks_getPositionXYZE_6
   \                     ??mks_getPositionXYZE_7: (+1)
   \   000000FC   0x6928             LDR      R0,[R5, #+16]
   \   000000FE   0xF8C4 0x07FC      STR      R0,[R4, #+2044]
   \   00000102   0x6968             LDR      R0,[R5, #+20]
   \   00000104   0x6068             STR      R0,[R5, #+4]
   \   00000106   0xE096             B.N      ??mks_getPositionXYZE_12
   \                     ??mks_getPositionXYZE_0: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x.... 0x....      LDR.W    R6,??DataTable226_2
   \   0000010E   0x4602             MOV      R2,R0
   \   00000110   0xE004             B.N      ??mks_getPositionXYZE_13
   \                     ??mks_getPositionXYZE_14: (+1)
   \   00000112   0xEB06 0x0180      ADD      R1,R6,R0, LSL #+2
   \   00000116   0x608A             STR      R2,[R1, #+8]
   \   00000118   0x618A             STR      R2,[R1, #+24]
   \   0000011A   0x1C40             ADDS     R0,R0,#+1
   \                     ??mks_getPositionXYZE_13: (+1)
   \   0000011C   0x2804             CMP      R0,#+4
   \   0000011E   0xDBF8             BLT.N    ??mks_getPositionXYZE_14
   \   00000120   0x.... 0x....      LDR.W    R4,??DataTable225_2
   \   00000124   0xF204 0x75FC      ADDW     R5,R4,#+2044
   \   00000128   0x6AA9             LDR      R1,[R5, #+40]
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000130   0xE004             B.N      ??mks_getPositionXYZE_15
   \                     ??mks_getPositionXYZE_16: (+1)
   \   00000132   0x6928             LDR      R0,[R5, #+16]
   \   00000134   0xF8C4 0x07FC      STR      R0,[R4, #+2044]
   \   00000138   0x6968             LDR      R0,[R5, #+20]
   \   0000013A   0x6068             STR      R0,[R5, #+4]
   \                     ??mks_getPositionXYZE_15: (+1)
   \   0000013C   0x4620             MOV      R0,R4
   \   0000013E   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000142   0x6AE9             LDR      R1,[R5, #+44]
   \   00000144   0x4288             CMP      R0,R1
   \   00000146   0xD271             BCS.N    ??mks_getPositionXYZE_17
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0x70B0             STRB     R0,[R6, #+2]
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   00000152   0x.... 0x....      BL       _Z19get_sdcard_commandsv
   \   00000156   0x2700             MOVS     R7,#+0
   \   00000158   0xE000             B.N      ??mks_getPositionXYZE_18
   \                     ??mks_getPositionXYZE_19: (+1)
   \   0000015A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mks_getPositionXYZE_18: (+1)
   \   0000015C   0x2F04             CMP      R7,#+4
   \   0000015E   0xDAE8             BGE.N    ??mks_getPositionXYZE_16
   \   00000160   0x2F00             CMP      R7,#+0
   \   00000162   0xD124             BNE.N    ??mks_getPositionXYZE_20
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable230_1
   \   00000168   0x7801             LDRB     R1,[R0, #+0]
   \   0000016A   0x2901             CMP      R1,#+1
   \   0000016C   0xD11F             BNE.N    ??mks_getPositionXYZE_20
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0x7001             STRB     R1,[R0, #+0]
   \   00000172   0x215A             MOVS     R1,#+90
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable230_2
   \   00000178   0x.... 0x....      BL       _Z6strchrPci
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xAB01             ADD      R3,SP,#+4
   \   00000180   0xD01F             BEQ.N    ??mks_getPositionXYZE_21
   \                     ??mks_getPositionXYZE_22: (+1)
   \   00000182   0xF910 0x1B01      LDRSB    R1,[R0], #+1
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD00A             BEQ.N    ??mks_getPositionXYZE_23
   \   0000018A   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   0000018E   0x1C4A             ADDS     R2,R1,#+1
   \   00000190   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   00000194   0x7802             LDRB     R2,[R0, #+0]
   \   00000196   0x54CA             STRB     R2,[R1, R3]
   \   00000198   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   0000019C   0x2915             CMP      R1,#+21
   \   0000019E   0xDBF0             BLT.N    ??mks_getPositionXYZE_22
   \                     ??mks_getPositionXYZE_23: (+1)
   \   000001A0   0xA801             ADD      R0,SP,#+4
   \   000001A2   0x.... 0x....      BL       atof
   \   000001A6   0x.... 0x....      BL       __aeabi_d2f
   \   000001AA   0x6230             STR      R0,[R6, #+32]
   \   000001AC   0xE009             B.N      ??mks_getPositionXYZE_21
   \                     ??mks_getPositionXYZE_20: (+1)
   \   000001AE   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable230_2
   \   000001B6   0xEB01 0x1040      ADD      R0,R1,R0, LSL #+5
   \   000001BA   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000001BE   0x.... 0x....      BL       _Z21gcode_get_destinationv
   \                     ??mks_getPositionXYZE_21: (+1)
   \   000001C2   0xF04F 0x0800      MOV      R8,#+0
   \   000001C6   0xE00A             B.N      ??mks_getPositionXYZE_24
   \                     ??mks_getPositionXYZE_25: (+1)
   \   000001C8   0x2000             MOVS     R0,#+0
   \                     ??mks_getPositionXYZE_26: (+1)
   \   000001CA   0x.... 0x....      BL       abs
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD003             BEQ.N    ??mks_getPositionXYZE_27
   \   000001D2   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   000001D6   0xF8C9 0x0804      STR      R0,[R9, #+2052]
   \                     ??mks_getPositionXYZE_27: (+1)
   \   000001DA   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??mks_getPositionXYZE_24: (+1)
   \   000001DE   0xF1B8 0x0F04      CMP      R8,#+4
   \   000001E2   0xDABA             BGE.N    ??mks_getPositionXYZE_19
   \   000001E4   0xEB04 0x0988      ADD      R9,R4,R8, LSL #+2
   \   000001E8   0x.... 0x....      LDR.W    R1,??DataTable230_3  ;; 0x38d1b718
   \   000001EC   0xF8D9 0x0804      LDR      R0,[R9, #+2052]
   \   000001F0   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000001F4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001F8   0xD20C             BCS.N    ??mks_getPositionXYZE_28
   \   000001FA   0xEB06 0x0A88      ADD      R10,R6,R8, LSL #+2
   \   000001FE   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000202   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000206   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000020A   0xD803             BHI.N    ??mks_getPositionXYZE_28
   \   0000020C   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000210   0xF8C9 0x0804      STR      R0,[R9, #+2052]
   \                     ??mks_getPositionXYZE_28: (+1)
   \   00000214   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000218   0xD0DF             BEQ.N    ??mks_getPositionXYZE_27
   \   0000021A   0xEB06 0x0A88      ADD      R10,R6,R8, LSL #+2
   \   0000021E   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000222   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000226   0xD8CF             BHI.N    ??mks_getPositionXYZE_25
   \   00000228   0x2001             MOVS     R0,#+1
   \   0000022A   0xE7CE             B.N      ??mks_getPositionXYZE_26
   \                     ??mks_getPositionXYZE_17: (+1)
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   00000232   0xF884 0x0830      STRB     R0,[R4, #+2096]
   \                     ??mks_getPositionXYZE_12: (+1)
   \   00000236   0x2000             MOVS     R0,#+0
   \   00000238   0x.... 0x....      LDR.W    R6,??DataTable226_2
   \   0000023C   0x4602             MOV      R2,R0
   \   0000023E   0xE004             B.N      ??mks_getPositionXYZE_29
   \                     ??mks_getPositionXYZE_30: (+1)
   \   00000240   0xEB06 0x0180      ADD      R1,R6,R0, LSL #+2
   \   00000244   0x608A             STR      R2,[R1, #+8]
   \   00000246   0x618A             STR      R2,[R1, #+24]
   \   00000248   0x1C40             ADDS     R0,R0,#+1
   \                     ??mks_getPositionXYZE_29: (+1)
   \   0000024A   0x2804             CMP      R0,#+4
   \   0000024C   0xDBF8             BLT.N    ??mks_getPositionXYZE_30
   \   0000024E   0x4614             MOV      R4,R2
   \   00000250   0xE00A             B.N      ??mks_getPositionXYZE_31
   \                     ??mks_getPositionXYZE_32: (+1)
   \   00000252   0x2260             MOVS     R2,#+96
   \   00000254   0x2100             MOVS     R1,#+0
   \   00000256   0xEB04 0x0044      ADD      R0,R4,R4, LSL #+1
   \   0000025A   0x.... 0x....      LDR.W    R3,??DataTable230_2
   \   0000025E   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   00000262   0x.... 0x....      BL       memset
   \   00000266   0x1C64             ADDS     R4,R4,#+1
   \                     ??mks_getPositionXYZE_31: (+1)
   \   00000268   0x2C04             CMP      R4,#+4
   \   0000026A   0xDBF2             BLT.N    ??mks_getPositionXYZE_32
   \   0000026C   0x.... 0x....      BL       _Z19clear_command_queuev
   \   00000270   0xB006             ADD      SP,SP,#+24
   \   00000272   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_clearDir()
   \                     mks_clearDir: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable230_4
   \   00000008   0xE007             B.N      ??mks_clearDir_0
   \                     ??mks_clearDir_1: (+1)
   \   0000000A   0x1C41             ADDS     R1,R0,#+1
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       strcpy
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       strcpy
   \                     ??mks_clearDir_0: (+1)
   \   0000001A   0x....             ADR.N    R1,??DataTable221  ;; "/"
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F1             BNE.N    ??mks_clearDir_1
   \   00000026   0xB008             ADD      SP,SP,#+32
   \   00000028   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrint_UI()
   \                     mks_contiuePrint_UI: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "Resume print?">`
   \   00000008   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable225_2
   \   00000010   0xF204 0x757C      ADDW     R5,R4,#+1916
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0x461A             MOV      R2,R3
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable230_5
   \   00000026   0x.... 0x....      BL       strcpy
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD108             BNE.N    ??mks_contiuePrint_UI_0
   \   00000034   0xF44F 0x6096      MOV      R0,#+1200
   \   00000038   0x.... 0x....      BL       _Z6Beeperj
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000042   0x.... 0x....      B.W      draw_dialog
   \                     ??mks_contiuePrint_UI_0: (+1)
   \   00000046   0xF604 0x061C      ADDW     R6,R4,#+2076
   \   0000004A   0x6870             LDR      R0,[R6, #+4]
   \   0000004C   0x2865             CMP      R0,#+101
   \   0000004E   0xD202             BCS.N    ??mks_contiuePrint_UI_1
   \   00000050   0x68F0             LDR      R0,[R6, #+12]
   \   00000052   0x2865             CMP      R0,#+101
   \   00000054   0xD359             BCC.N    ??mks_contiuePrint_UI_2
   \                     ??mks_contiuePrint_UI_1: (+1)
   \   00000056   0x2264             MOVS     R2,#+100
   \   00000058   0xF204 0x717C      ADDW     R1,R4,#+1916
   \   0000005C   0xF240 0x40FD      MOVW     R0,#+1277
   \   00000060   0x.... 0x....      BL       epr_write_data
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x0760      STRB     R0,[R4, #+1888]
   \   0000006A   0xF994 0x0AE4      LDRSB    R0,[R4, #+2788]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD101             BNE.N    ??mks_contiuePrint_UI_3
   \   00000072   0x.... 0x....      BL       mks_getPositionXYZE
   \                     ??mks_contiuePrint_UI_3: (+1)
   \   00000076   0x.... 0x....      LDR.W    R5,??DataTable230
   \   0000007A   0xF895 0x019F      LDRB     R0,[R5, #+415]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD004             BEQ.N    ??mks_contiuePrint_UI_4
   \   00000082   0x6871             LDR      R1,[R6, #+4]
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   0000008A   0xE003             B.N      ??mks_contiuePrint_UI_5
   \                     ??mks_contiuePrint_UI_4: (+1)
   \   0000008C   0x68F1             LDR      R1,[R6, #+12]
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \                     ??mks_contiuePrint_UI_5: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable226_2
   \   00000098   0xF8D4 0x17F4      LDR      R1,[R4, #+2036]
   \   0000009C   0x6081             STR      R1,[R0, #+8]
   \   0000009E   0xF204 0x71F4      ADDW     R1,R4,#+2036
   \   000000A2   0x684A             LDR      R2,[R1, #+4]
   \   000000A4   0x60C2             STR      R2,[R0, #+12]
   \   000000A6   0x6889             LDR      R1,[R1, #+8]
   \   000000A8   0x6101             STR      R1,[R0, #+16]
   \   000000AA   0xF895 0x019F      LDRB     R0,[R5, #+415]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD001             BEQ.N    ??mks_contiuePrint_UI_6
   \   000000B2   0x.... 0x....      BL       mks_clearDir
   \                     ??mks_contiuePrint_UI_6: (+1)
   \   000000B6   0x.... 0x....      BL       getTick
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable230_6
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable230_7
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0x.... 0x....      BL       getTickDiff
   \   000000CA   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD203             BCS.N    ??mks_contiuePrint_UI_7
   \   000000D2   0xF995 0x00BA      LDRSB    R0,[R5, #+186]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD1ED             BNE.N    ??mks_contiuePrint_UI_6
   \                     ??mks_contiuePrint_UI_7: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R4,??DataTable230_8
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x4621             MOV      R1,R4
   \   000000E2   0xF44F 0x60E0      MOV      R0,#+1792
   \   000000E6   0x.... 0x....      BL       AT24CXX_Read
   \   000000EA   0x7820             LDRB     R0,[R4, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD004             BEQ.N    ??mks_contiuePrint_UI_8
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable230_9
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
   \   000000F8   0xE003             B.N      ??mks_contiuePrint_UI_9
   \                     ??mks_contiuePrint_UI_8: (+1)
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable230_10
   \   00000100   0x7008             STRB     R0,[R1, #+0]
   \                     ??mks_contiuePrint_UI_9: (+1)
   \   00000102   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000106   0x.... 0x....      B.W      draw_printing
   \                     ??mks_contiuePrint_UI_2: (+1)
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xF884 0x0AE4      STRB     R0,[R4, #+2788]
   \   00000110   0x20A6             MOVS     R0,#+166
   \   00000112   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable230
   \   0000011A   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD005             BEQ.N    ??mks_contiuePrint_UI_10
   \   00000122   0x2201             MOVS     R2,#+1
   \   00000124   0x4631             MOV      R1,R6
   \   00000126   0xF44F 0x6096      MOV      R0,#+1200
   \   0000012A   0x.... 0x....      BL       epr_write_data
   \                     ??mks_contiuePrint_UI_10: (+1)
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable230_11
   \   00000134   0x7008             STRB     R0,[R1, #+0]
   \   00000136   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_rePrintCheck()
   \                     mks_rePrintCheck: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	bool pft_ok = false;
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1550  Warning[Pe550]: 
          variable "pft_ok" was set but never used
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable230_12
   \   00000006   0xF604 0x051C      ADDW     R5,R4,#+2076
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0xF44F 0x6096      MOV      R0,#+1200
   \   00000012   0x.... 0x....      BL       epr_read_data
   \   00000016   0xF894 0x081C      LDRB     R0,[R4, #+2076]
   \   0000001A   0x28AA             CMP      R0,#+170
   \   0000001C   0xD10A             BNE.N    ??mks_rePrintCheck_0
   \   0000001E   0x20AB             MOVS     R0,#+171
   \   00000020   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   00000024   0x.... 0x....      BL       mks_ReadFromEpr
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0AE4      STRB     R0,[R4, #+2788]
   \   0000002E   0x.... 0x....      BL       mks_contiuePrint_UI
   \   00000032   0xE035             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_0: (+1)
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable230
   \   00000038   0x28A7             CMP      R0,#+167
   \   0000003A   0xD120             BNE.N    ??mks_rePrintCheck_2
   \   0000003C   0xF891 0x019F      LDRB     R0,[R1, #+415]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD10A             BNE.N    ??mks_rePrintCheck_3
   \   00000044   0x20AB             MOVS     R0,#+171
   \   00000046   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   0000004A   0x.... 0x....      BL       _Z22mks_ReadFromEpr_pwroffv
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0xF884 0x0AE4      STRB     R0,[R4, #+2788]
   \   00000054   0x.... 0x....      BL       mks_contiuePrint_UI
   \   00000058   0xE022             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_3: (+1)
   \   0000005A   0x20AB             MOVS     R0,#+171
   \   0000005C   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   00000060   0x2264             MOVS     R2,#+100
   \   00000062   0xF204 0x717C      ADDW     R1,R4,#+1916
   \   00000066   0xF240 0x40FD      MOVW     R0,#+1277
   \   0000006A   0x.... 0x....      BL       epr_read_data
   \   0000006E   0x.... 0x....      BL       mks_ReadFromFile
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0xF884 0x0AE4      STRB     R0,[R4, #+2788]
   \   00000078   0x.... 0x....      BL       mks_contiuePrint_UI
   \   0000007C   0xE010             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_2: (+1)
   \   0000007E   0x20A6             MOVS     R0,#+166
   \   00000080   0xF884 0x081C      STRB     R0,[R4, #+2076]
   \   00000084   0xF891 0x019F      LDRB     R0,[R1, #+415]
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD005             BEQ.N    ??mks_rePrintCheck_4
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0xF44F 0x6096      MOV      R0,#+1200
   \   00000094   0x.... 0x....      BL       epr_write_data
   \                     ??mks_rePrintCheck_4: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable230_11
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   \                     ??mks_rePrintCheck_1: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable230_11
   \   000000A4   0x7801             LDRB     R1,[R0, #+0]
   \   000000A6   0x2901             CMP      R1,#+1
   \   000000A8   0xD118             BNE.N    ??mks_rePrintCheck_5
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x7001             STRB     R1,[R0, #+0]
   \                     ??mks_rePrintCheck_6: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable230_13
   \   000000B2   0x7CC0             LDRB     R0,[R0, #+19]
   \   000000B4   0x2801             CMP      R0,#+1
   \   000000B6   0xD011             BEQ.N    ??mks_rePrintCheck_5
   \   000000B8   0x.... 0x....      BL       getTick
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable230_6
   \   000000C0   0x6008             STR      R0,[R1, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable230_7
   \   000000C6   0x6809             LDR      R1,[R1, #+0]
   \   000000C8   0x.... 0x....      BL       getTickDiff
   \   000000CC   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD3EC             BCC.N    ??mks_rePrintCheck_6
   \   000000D4   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   000000D8   0x.... 0x....      B.W      draw_ready_print
   \                     ??mks_rePrintCheck_5: (+1)
   \   000000DC   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToFile()
   \                     mks_WriteToFile: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08E             SUB      SP,SP,#+56
   \   00000006   0xA805             ADD      R0,SP,#+20
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   \   0000000E   0x.... 0x....      LDR.W    R7,??DataTable225_2
   \   00000012   0xF897 0x0763      LDRB     R0,[R7, #+1891]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??mks_WriteToFile_0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable230_14
   \   0000001E   0xA805             ADD      R0,SP,#+20
   \   00000020   0x.... 0x....      BL       strcat
   \                     ??mks_WriteToFile_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable230_15
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xA805             ADD      R0,SP,#+20
   \   0000002C   0x.... 0x....      BL       strcat
   \   00000030   0xF607 0x04B4      ADDW     R4,R7,#+2228
   \   00000034   0x2203             MOVS     R2,#+3
   \   00000036   0xA905             ADD      R1,SP,#+20
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       f_open
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xF040 0x8111      BNE.W    ??mks_WriteToFile_1
   \   00000044   0x2214             MOVS     R2,#+20
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       memset
   \   0000004E   0x2207             MOVS     R2,#+7
   \   00000050   0x.... 0x....      ADR.W    R1,`?<Constant "start\\n">`
   \   00000054   0xA800             ADD      R0,SP,#+0
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       f_printf
   \   00000062   0x2214             MOVS     R2,#+20
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xA800             ADD      R0,SP,#+0
   \   00000068   0x.... 0x....      BL       memset
   \   0000006C   0x....             ADR.N    R5,??DataTable223  ;; 0x25, 0x64, 0x00, 0x00
   \   0000006E   0xF8D7 0x2820      LDR      R2,[R7, #+2080]
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0xA800             ADD      R0,SP,#+0
   \   00000076   0x.... 0x....      BL       sprintf
   \   0000007A   0x....             ADR.N    R6,??DataTable223_1  ;; "\n"
   \   0000007C   0x4631             MOV      R1,R6
   \   0000007E   0xA800             ADD      R0,SP,#+0
   \   00000080   0x.... 0x....      BL       strcat
   \   00000084   0xA900             ADD      R1,SP,#+0
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       f_printf
   \   0000008C   0x2214             MOVS     R2,#+20
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0xA800             ADD      R0,SP,#+0
   \   00000092   0x.... 0x....      BL       memset
   \   00000096   0x.... 0x....      LDR.W    R8,??DataTable230_16
   \   0000009A   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \   0000009E   0x4629             MOV      R1,R5
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       sprintf
   \   000000A6   0x4631             MOV      R1,R6
   \   000000A8   0xA800             ADD      R0,SP,#+0
   \   000000AA   0x.... 0x....      BL       strcat
   \   000000AE   0xA900             ADD      R1,SP,#+0
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       f_printf
   \   000000B6   0x2214             MOVS     R2,#+20
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0xA800             ADD      R0,SP,#+0
   \   000000BC   0x.... 0x....      BL       memset
   \   000000C0   0xF8D8 0x2004      LDR      R2,[R8, #+4]
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0xA800             ADD      R0,SP,#+0
   \   000000C8   0x.... 0x....      BL       sprintf
   \   000000CC   0x4631             MOV      R1,R6
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      BL       strcat
   \   000000D4   0xA900             ADD      R1,SP,#+0
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       f_printf
   \   000000DC   0x2214             MOVS     R2,#+20
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0xA800             ADD      R0,SP,#+0
   \   000000E2   0x.... 0x....      BL       memset
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable230_17
   \   000000EA   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   000000EE   0x4629             MOV      R1,R5
   \   000000F0   0xA800             ADD      R0,SP,#+0
   \   000000F2   0x.... 0x....      BL       sprintf
   \   000000F6   0x4631             MOV      R1,R6
   \   000000F8   0xA800             ADD      R0,SP,#+0
   \   000000FA   0x.... 0x....      BL       strcat
   \   000000FE   0xA900             ADD      R1,SP,#+0
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x.... 0x....      BL       f_printf
   \   00000106   0xF607 0x0348      ADDW     R3,R7,#+2120
   \   0000010A   0xF607 0x0244      ADDW     R2,R7,#+2116
   \   0000010E   0xF507 0x6104      ADD      R1,R7,#+2112
   \   00000112   0xF607 0x20E8      ADDW     R0,R7,#+2792
   \   00000116   0x.... 0x....      BL       _ZN9Stopwatch7getTimeEPmS0_S0_
   \   0000011A   0x.... 0x....      BL       HAL_GetTick
   \   0000011E   0xF607 0x0720      ADDW     R7,R7,#+2080
   \   00000122   0x62F8             STR      R0,[R7, #+44]
   \   00000124   0x6AB9             LDR      R1,[R7, #+40]
   \   00000126   0x6A7A             LDR      R2,[R7, #+36]
   \   00000128   0x4291             CMP      R1,R2
   \   0000012A   0xD200             BCS.N    ??mks_WriteToFile_2
   \   0000012C   0x62B8             STR      R0,[R7, #+40]
   \                     ??mks_WriteToFile_2: (+1)
   \   0000012E   0x2214             MOVS     R2,#+20
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0xA800             ADD      R0,SP,#+0
   \   00000134   0x.... 0x....      BL       memset
   \   00000138   0x6A3A             LDR      R2,[R7, #+32]
   \   0000013A   0x4629             MOV      R1,R5
   \   0000013C   0xA800             ADD      R0,SP,#+0
   \   0000013E   0x.... 0x....      BL       sprintf
   \   00000142   0x4631             MOV      R1,R6
   \   00000144   0xA800             ADD      R0,SP,#+0
   \   00000146   0x.... 0x....      BL       strcat
   \   0000014A   0xA900             ADD      R1,SP,#+0
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       f_printf
   \   00000152   0x2214             MOVS     R2,#+20
   \   00000154   0x2100             MOVS     R1,#+0
   \   00000156   0xA800             ADD      R0,SP,#+0
   \   00000158   0x.... 0x....      BL       memset
   \   0000015C   0x.... 0x....      LDR.W    R7,??DataTable230_18
   \   00000160   0x887A             LDRH     R2,[R7, #+2]
   \   00000162   0x4629             MOV      R1,R5
   \   00000164   0xA800             ADD      R0,SP,#+0
   \   00000166   0x.... 0x....      BL       sprintf
   \   0000016A   0x4631             MOV      R1,R6
   \   0000016C   0xA800             ADD      R0,SP,#+0
   \   0000016E   0x.... 0x....      BL       strcat
   \   00000172   0xA900             ADD      R1,SP,#+0
   \   00000174   0x4620             MOV      R0,R4
   \   00000176   0x.... 0x....      BL       f_printf
   \   0000017A   0x2214             MOVS     R2,#+20
   \   0000017C   0x2100             MOVS     R1,#+0
   \   0000017E   0xA800             ADD      R0,SP,#+0
   \   00000180   0x.... 0x....      BL       memset
   \   00000184   0x793A             LDRB     R2,[R7, #+4]
   \   00000186   0x4629             MOV      R1,R5
   \   00000188   0xA800             ADD      R0,SP,#+0
   \   0000018A   0x.... 0x....      BL       sprintf
   \   0000018E   0x4631             MOV      R1,R6
   \   00000190   0xA800             ADD      R0,SP,#+0
   \   00000192   0x.... 0x....      BL       strcat
   \   00000196   0xA900             ADD      R1,SP,#+0
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       f_printf
   \   0000019E   0x2214             MOVS     R2,#+20
   \   000001A0   0x2100             MOVS     R1,#+0
   \   000001A2   0xA800             ADD      R0,SP,#+0
   \   000001A4   0x.... 0x....      BL       memset
   \   000001A8   0xF997 0x2005      LDRSB    R2,[R7, #+5]
   \   000001AC   0x4629             MOV      R1,R5
   \   000001AE   0xA800             ADD      R0,SP,#+0
   \   000001B0   0x.... 0x....      BL       sprintf
   \   000001B4   0x4631             MOV      R1,R6
   \   000001B6   0xA800             ADD      R0,SP,#+0
   \   000001B8   0x.... 0x....      BL       strcat
   \   000001BC   0xA900             ADD      R1,SP,#+0
   \   000001BE   0x4620             MOV      R0,R4
   \   000001C0   0x.... 0x....      BL       f_printf
   \   000001C4   0x2214             MOVS     R2,#+20
   \   000001C6   0x2100             MOVS     R1,#+0
   \   000001C8   0xA800             ADD      R0,SP,#+0
   \   000001CA   0x.... 0x....      BL       memset
   \   000001CE   0x.... 0x....      LDR.W    R7,??DataTable226_2
   \   000001D2   0x6EFA             LDR      R2,[R7, #+108]
   \   000001D4   0x4629             MOV      R1,R5
   \   000001D6   0xA800             ADD      R0,SP,#+0
   \   000001D8   0x.... 0x....      BL       sprintf
   \   000001DC   0x4631             MOV      R1,R6
   \   000001DE   0xA800             ADD      R0,SP,#+0
   \   000001E0   0x.... 0x....      BL       strcat
   \   000001E4   0xA900             ADD      R1,SP,#+0
   \   000001E6   0x4620             MOV      R0,R4
   \   000001E8   0x.... 0x....      BL       f_printf
   \   000001EC   0x2214             MOVS     R2,#+20
   \   000001EE   0x2100             MOVS     R1,#+0
   \   000001F0   0xA800             ADD      R0,SP,#+0
   \   000001F2   0x.... 0x....      BL       memset
   \   000001F6   0x6DF8             LDR      R0,[R7, #+92]
   \   000001F8   0x.... 0x....      BL       __aeabi_f2d
   \   000001FC   0x4602             MOV      R2,R0
   \   000001FE   0x460B             MOV      R3,R1
   \   00000200   0x....             ADR.N    R1,??DataTable225  ;; 0x25, 0x66, 0x00, 0x00
   \   00000202   0xA800             ADD      R0,SP,#+0
   \   00000204   0x.... 0x....      BL       sprintf
   \   00000208   0x4631             MOV      R1,R6
   \   0000020A   0xA800             ADD      R0,SP,#+0
   \   0000020C   0x.... 0x....      BL       strcat
   \   00000210   0xA900             ADD      R1,SP,#+0
   \   00000212   0x4620             MOV      R0,R4
   \   00000214   0x.... 0x....      BL       f_printf
   \   00000218   0x2214             MOVS     R2,#+20
   \   0000021A   0x2100             MOVS     R1,#+0
   \   0000021C   0xA800             ADD      R0,SP,#+0
   \   0000021E   0x.... 0x....      BL       memset
   \   00000222   0x78FA             LDRB     R2,[R7, #+3]
   \   00000224   0x4629             MOV      R1,R5
   \   00000226   0xA800             ADD      R0,SP,#+0
   \   00000228   0x.... 0x....      BL       sprintf
   \   0000022C   0x4631             MOV      R1,R6
   \   0000022E   0xA800             ADD      R0,SP,#+0
   \   00000230   0x.... 0x....      BL       strcat
   \   00000234   0xA900             ADD      R1,SP,#+0
   \   00000236   0x4620             MOV      R0,R4
   \   00000238   0x.... 0x....      BL       f_printf
   \   0000023C   0x2214             MOVS     R2,#+20
   \   0000023E   0x2100             MOVS     R1,#+0
   \   00000240   0xA800             ADD      R0,SP,#+0
   \   00000242   0x.... 0x....      BL       memset
   \   00000246   0x2204             MOVS     R2,#+4
   \   00000248   0x....             ADR.N    R1,??DataTable226  ;; "end"
   \   0000024A   0xA800             ADD      R0,SP,#+0
   \   0000024C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000250   0x4631             MOV      R1,R6
   \   00000252   0xA800             ADD      R0,SP,#+0
   \   00000254   0x.... 0x....      BL       strcat
   \   00000258   0xA900             ADD      R1,SP,#+0
   \   0000025A   0x4620             MOV      R0,R4
   \   0000025C   0x.... 0x....      BL       f_printf
   \   00000260   0x4620             MOV      R0,R4
   \   00000262   0x.... 0x....      BL       f_close
   \                     ??mks_WriteToFile_1: (+1)
   \   00000266   0xB00E             ADD      SP,SP,#+56
   \   00000268   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToEpr_pwroff()
   \                     _Z21mks_WriteToEpr_pwroffv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable225_2
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF604 0x011C      ADDW     R1,R4,#+2076
   \   0000000A   0xF44F 0x6096      MOV      R0,#+1200
   \   0000000E   0x.... 0x....      BL       epr_write_data
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xF604 0x0124      ADDW     R1,R4,#+2084
   \   00000018   0xF240 0x40F5      MOVW     R0,#+1269
   \   0000001C   0x.... 0x....      BL       epr_write_data
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000026   0xF8C4 0x0820      STR      R0,[R4, #+2080]
   \   0000002A   0xF604 0x0520      ADDW     R5,R4,#+2080
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0xF240 0x40B1      MOVW     R0,#+1201
   \   00000036   0x.... 0x....      BL       epr_write_data
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable230_16
   \   0000003E   0x6830             LDR      R0,[R6, #+0]
   \   00000040   0x8268             STRH     R0,[R5, #+18]
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0xF604 0x0132      ADDW     R1,R4,#+2098
   \   00000048   0xF240 0x40B5      MOVW     R0,#+1205
   \   0000004C   0x.... 0x....      BL       epr_write_data
   \   00000050   0x.... 0x....      LDR.W    R7,??DataTable228
   \   00000054   0xF897 0x00F7      LDRB     R0,[R7, #+247]
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0xD108             BNE.N    ??mks_WriteToEpr_pwroff_0
   \   0000005C   0x6870             LDR      R0,[R6, #+4]
   \   0000005E   0x82A8             STRH     R0,[R5, #+20]
   \   00000060   0x2202             MOVS     R2,#+2
   \   00000062   0xF604 0x0134      ADDW     R1,R4,#+2100
   \   00000066   0xF240 0x40B7      MOVW     R0,#+1207
   \   0000006A   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_pwroff_0: (+1)
   \   0000006E   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD00A             BEQ.N    ??mks_WriteToEpr_pwroff_1
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable230_17
   \   0000007A   0x8800             LDRH     R0,[R0, #+0]
   \   0000007C   0x82E8             STRH     R0,[R5, #+22]
   \   0000007E   0x2202             MOVS     R2,#+2
   \   00000080   0xF604 0x0136      ADDW     R1,R4,#+2102
   \   00000084   0xF240 0x40B9      MOVW     R0,#+1209
   \   00000088   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_pwroff_1: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R6,??DataTable230_18
   \   00000090   0x2202             MOVS     R2,#+2
   \   00000092   0x1CB1             ADDS     R1,R6,#+2
   \   00000094   0xF44F 0x609E      MOV      R0,#+1264
   \   00000098   0x.... 0x....      BL       epr_write_data
   \   0000009C   0x2201             MOVS     R2,#+1
   \   0000009E   0x1D31             ADDS     R1,R6,#+4
   \   000000A0   0xF240 0x40F2      MOVW     R0,#+1266
   \   000000A4   0x.... 0x....      BL       epr_write_data
   \   000000A8   0x2201             MOVS     R2,#+1
   \   000000AA   0x1D71             ADDS     R1,R6,#+5
   \   000000AC   0xF240 0x40F3      MOVW     R0,#+1267
   \   000000B0   0x.... 0x....      BL       epr_write_data
   \   000000B4   0x....             LDR.N    R6,??DataTable226_2
   \   000000B6   0x6EF0             LDR      R0,[R6, #+108]
   \   000000B8   0x7728             STRB     R0,[R5, #+28]
   \   000000BA   0x2201             MOVS     R2,#+1
   \   000000BC   0xF604 0x013C      ADDW     R1,R4,#+2108
   \   000000C0   0xF240 0x40DF      MOVW     R0,#+1247
   \   000000C4   0x.... 0x....      BL       epr_write_data
   \   000000C8   0x6DF0             LDR      R0,[R6, #+92]
   \   000000CA   0x61A8             STR      R0,[R5, #+24]
   \   000000CC   0x2204             MOVS     R2,#+4
   \   000000CE   0xF604 0x0138      ADDW     R1,R4,#+2104
   \   000000D2   0xF240 0x40DB      MOVW     R0,#+1243
   \   000000D6   0x.... 0x....      BL       epr_write_data
   \   000000DA   0x2201             MOVS     R2,#+1
   \   000000DC   0x1CF1             ADDS     R1,R6,#+3
   \   000000DE   0xF240 0x40F4      MOVW     R0,#+1268
   \   000000E2   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   000000E6   0x.... 0x....      B.W      epr_write_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ReadFromEpr_pwroff()
   \                     _Z22mks_ReadFromEpr_pwroffv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable225_2
   \   00000004   0x2264             MOVS     R2,#+100
   \   00000006   0xF204 0x717C      ADDW     R1,R4,#+1916
   \   0000000A   0xF240 0x40FD      MOVW     R0,#+1277
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xF604 0x0128      ADDW     R1,R4,#+2088
   \   00000018   0xF240 0x40B1      MOVW     R0,#+1201
   \   0000001C   0x.... 0x....      BL       epr_read_data
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF604 0x0124      ADDW     R1,R4,#+2084
   \   00000026   0xF240 0x40F5      MOVW     R0,#+1269
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0x2202             MOVS     R2,#+2
   \   00000030   0xF604 0x0132      ADDW     R1,R4,#+2098
   \   00000034   0xF240 0x40B5      MOVW     R0,#+1205
   \   00000038   0x.... 0x....      BL       epr_read_data
   \   0000003C   0x....             LDR.N    R5,??DataTable228
   \   0000003E   0xF895 0x00F7      LDRB     R0,[R5, #+247]
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD106             BNE.N    ??mks_ReadFromEpr_pwroff_0
   \   00000046   0x2202             MOVS     R2,#+2
   \   00000048   0xF604 0x0134      ADDW     R1,R4,#+2100
   \   0000004C   0xF240 0x40B7      MOVW     R0,#+1207
   \   00000050   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_pwroff_0: (+1)
   \   00000054   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD006             BEQ.N    ??mks_ReadFromEpr_pwroff_1
   \   0000005C   0x2202             MOVS     R2,#+2
   \   0000005E   0xF604 0x0136      ADDW     R1,R4,#+2102
   \   00000062   0xF240 0x40B9      MOVW     R0,#+1209
   \   00000066   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_pwroff_1: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R5,??DataTable230_18
   \   0000006E   0x2202             MOVS     R2,#+2
   \   00000070   0x1CA9             ADDS     R1,R5,#+2
   \   00000072   0xF44F 0x609E      MOV      R0,#+1264
   \   00000076   0x.... 0x....      BL       epr_read_data
   \   0000007A   0x2201             MOVS     R2,#+1
   \   0000007C   0x1D29             ADDS     R1,R5,#+4
   \   0000007E   0xF240 0x40F2      MOVW     R0,#+1266
   \   00000082   0x.... 0x....      BL       epr_read_data
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0x1D69             ADDS     R1,R5,#+5
   \   0000008A   0xF240 0x40F3      MOVW     R0,#+1267
   \   0000008E   0x.... 0x....      BL       epr_read_data
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0xF604 0x013C      ADDW     R1,R4,#+2108
   \   00000098   0xF240 0x40DF      MOVW     R0,#+1247
   \   0000009C   0x.... 0x....      BL       epr_read_data
   \   000000A0   0x2204             MOVS     R2,#+4
   \   000000A2   0xF604 0x0138      ADDW     R1,R4,#+2104
   \   000000A6   0xF240 0x40DB      MOVW     R0,#+1243
   \   000000AA   0x.... 0x....      BL       epr_read_data
   \   000000AE   0x....             LDR.N    R4,??DataTable226_2
   \   000000B0   0x2201             MOVS     R2,#+1
   \   000000B2   0x1CE1             ADDS     R1,R4,#+3
   \   000000B4   0xF240 0x40F4      MOVW     R0,#+1268
   \   000000B8   0x.... 0x....      BL       epr_read_data
   \   000000BC   0xF994 0x0003      LDRSB    R0,[R4, #+3]
   \   000000C0   0x....             LDR.N    R1,??DataTable230
   \   000000C2   0xF881 0x009C      STRB     R0,[R1, #+156]
   \   000000C6   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp int16_t pft_get()
   \                     _Z7pft_getv: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable230_12
   \   00000004   0xAB01             ADD      R3,SP,#+4
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xF604 0x00B4      ADDW     R0,R4,#+2228
   \   0000000E   0x.... 0x....      BL       f_read
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??pft_get_0
   \   00000016   0x20FF             MOVS     R0,#+255
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000001C   0xE005             B.N      ??pft_get_1
   \                     ??pft_get_0: (+1)
   \   0000001E   0xF8D4 0x082C      LDR      R0,[R4, #+2092]
   \   00000022   0x9901             LDR      R1,[SP, #+4]
   \   00000024   0x1808             ADDS     R0,R1,R0
   \   00000026   0xF8C4 0x082C      STR      R0,[R4, #+2092]
   \                     ??pft_get_1: (+1)
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xBD16             POP      {R1,R2,R4,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp bool mks_get_commands()
   \                     _Z16mks_get_commandsv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x46A8             MOV      R8,R5
   \   0000000A   0x462C             MOV      R4,R5
   \   0000000C   0x....             LDR.N    R7,??DataTable230_12
   \   0000000E   0xE00E             B.N      ??mks_get_commands_1

  				gCfgItems.curSprayerChoose = atof(string);
  				                           ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1972  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??mks_get_commands_2: (+1)
   \   00000010   0x....             ADR.N    R1,??DataTable226  ;; "end"
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       strcmp
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD100             BNE.N    ??mks_get_commands_3
   \   0000001C   0x2401             MOVS     R4,#+1
   \                     ??mks_get_commands_3: (+1)
   \   0000001E   0xF04F 0x0800      MOV      R8,#+0
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0x4641             MOV      R1,R8
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       memset
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mks_get_commands_1: (+1)
   \   0000002E   0xF607 0x0620      ADDW     R6,R7,#+2080
   \   00000032   0x68F0             LDR      R0,[R6, #+12]
   \   00000034   0xF8D7 0x1AE0      LDR      R1,[R7, #+2784]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD26A             BCS.N    ??mks_get_commands_4
   \   0000003C   0x.... 0x....      BL       _Z7pft_getv
   \   00000040   0xF110 0x0F01      CMN      R0,#+1
   \   00000044   0xD065             BEQ.N    ??mks_get_commands_4
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0xB240             SXTB     R0,R0
   \   0000004A   0x280A             CMP      R0,#+10
   \   0000004C   0xD158             BNE.N    ??mks_get_commands_5
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0x1889             ADDS     R1,R1,R2
   \   00000054   0xF801 0x0C01      STRB     R0,[R1, #-1]
   \   00000058   0xB26D             SXTB     R5,R5
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x280B             CMP      R0,#+11
   \   00000060   0xD8DD             BHI.N    ??mks_get_commands_3
   \   00000062   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mks_get_commands_0:
   \   00000066   0x08 0x0E          DC8      0x8,0xE,0x13,0x18
   \              0x13 0x18    
   \   0000006A   0x1D 0x22          DC8      0x1D,0x22,0x28,0x2E
   \              0x28 0x2E    
   \   0000006E   0x34 0x39          DC8      0x34,0x39,0x40,0x6
   \              0x40 0x06    
   \                     ??mks_get_commands_6: (+1)
   \   00000072   0xE7CD             B.N      ??mks_get_commands_2
   \                     ??mks_get_commands_7: (+1)
   \   00000074   0xE7D3             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_8: (+1)
   \   00000076   0xA800             ADD      R0,SP,#+0
   \   00000078   0x.... 0x....      BL       atoi
   \   0000007C   0xF8C7 0x0820      STR      R0,[R7, #+2080]
   \   00000080   0xE7CD             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_9: (+1)
   \   00000082   0xA800             ADD      R0,SP,#+0
   \   00000084   0x.... 0x....      BL       atoi
   \   00000088   0x8270             STRH     R0,[R6, #+18]
   \   0000008A   0xE7C8             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_10: (+1)
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       atoi
   \   00000092   0x82B0             STRH     R0,[R6, #+20]
   \   00000094   0xE7C3             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_11: (+1)
   \   00000096   0xA800             ADD      R0,SP,#+0
   \   00000098   0x.... 0x....      BL       atoi
   \   0000009C   0x82F0             STRH     R0,[R6, #+22]
   \   0000009E   0xE7BE             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_12: (+1)
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       atoi
   \   000000A6   0x6230             STR      R0,[R6, #+32]
   \   000000A8   0xE7B9             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_13: (+1)
   \   000000AA   0xA800             ADD      R0,SP,#+0
   \   000000AC   0x.... 0x....      BL       atoi
   \   000000B0   0x....             LDR.N    R1,??DataTable230_18
   \   000000B2   0x8048             STRH     R0,[R1, #+2]
   \   000000B4   0xE7B3             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_14: (+1)
   \   000000B6   0xA800             ADD      R0,SP,#+0
   \   000000B8   0x.... 0x....      BL       atoi
   \   000000BC   0x....             LDR.N    R1,??DataTable230_18
   \   000000BE   0x7108             STRB     R0,[R1, #+4]
   \   000000C0   0xE7AD             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_15: (+1)
   \   000000C2   0xA800             ADD      R0,SP,#+0
   \   000000C4   0x.... 0x....      BL       atoi
   \   000000C8   0x....             LDR.N    R1,??DataTable230_18
   \   000000CA   0x7148             STRB     R0,[R1, #+5]
   \   000000CC   0xE7A7             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_16: (+1)
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      BL       atoi
   \   000000D4   0x7730             STRB     R0,[R6, #+28]
   \   000000D6   0xE7A2             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_17: (+1)
   \   000000D8   0xA800             ADD      R0,SP,#+0
   \   000000DA   0x.... 0x....      BL       atof
   \   000000DE   0x.... 0x....      BL       __aeabi_d2f
   \   000000E2   0x61B0             STR      R0,[R6, #+24]
   \   000000E4   0xE79B             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_18: (+1)
   \   000000E6   0x....             LDR.N    R6,??DataTable230
   \   000000E8   0xA800             ADD      R0,SP,#+0
   \   000000EA   0x.... 0x....      BL       atof
   \   000000EE   0x.... 0x....      BL       __aeabi_d2iz
   \   000000F2   0xF886 0x009C      STRB     R0,[R6, #+156]
   \   000000F6   0xF896 0x009C      LDRB     R0,[R6, #+156]
   \   000000FA   0x....             LDR.N    R1,??DataTable226_2
   \   000000FC   0x70C8             STRB     R0,[R1, #+3]
   \   000000FE   0xE78E             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_5: (+1)
   \   00000100   0xAA00             ADD      R2,SP,#+0
   \   00000102   0x5488             STRB     R0,[R1, R2]
   \   00000104   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000108   0xFA1F 0xF888      UXTH     R8,R8
   \   0000010C   0xF1B8 0x0F14      CMP      R8,#+20
   \   00000110   0xDB8D             BLT.N    ??mks_get_commands_1
   \                     ??mks_get_commands_4: (+1)
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0xB006             ADD      SP,SP,#+24
   \   00000116   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp bool mks_ReadFromFile()
   \                     mks_ReadFromFile: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   \   0000000E   0x....             LDR.N    R5,??DataTable230_12
   \   00000010   0xF895 0x0763      LDRB     R0,[R5, #+1891]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??mks_ReadFromFile_0
   \   00000018   0x....             LDR.N    R1,??DataTable230_14
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       strcat
   \                     ??mks_ReadFromFile_0: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable230_15
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       strcat
   \   0000002A   0xF605 0x06B4      ADDW     R6,R5,#+2228
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       f_open
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD10C             BNE.N    ??mks_ReadFromFile_1
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xF8C5 0x082C      STR      R0,[R5, #+2092]
   \   00000042   0xF8D5 0x0AC0      LDR      R0,[R5, #+2752]
   \   00000046   0xF8C5 0x0AE0      STR      R0,[R5, #+2784]
   \   0000004A   0x.... 0x....      BL       _Z16mks_get_commandsv
   \   0000004E   0x4604             MOV      R4,R0
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       f_close
   \                     ??mks_ReadFromFile_1: (+1)
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xB008             ADD      SP,SP,#+32
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_clearFile()
   \                     mks_clearFile: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08E             SUB      SP,SP,#+56
   \   00000004   0xA808             ADD      R0,SP,#+32
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant "clear">`
   \   0000000A   0x2214             MOVS     R2,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x2120             MOVS     R1,#+32
   \   00000014   0x.... 0x....      BL       __aeabi_memclr4
   \   00000018   0x....             LDR.N    R4,??DataTable230_12
   \   0000001A   0xF894 0x0763      LDRB     R0,[R4, #+1891]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??mks_clearFile_0
   \   00000022   0x....             LDR.N    R1,??DataTable230_14
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       strcat
   \                     ??mks_clearFile_0: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable230_15
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       strcat
   \   00000034   0xF604 0x04B4      ADDW     R4,R4,#+2228
   \   00000038   0x220A             MOVS     R2,#+10
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       f_open
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD106             BNE.N    ??mks_clearFile_1
   \   00000046   0xA908             ADD      R1,SP,#+32
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       f_printf
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       f_close
   \                     ??mks_clearFile_1: (+1)
   \   00000054   0xB00E             ADD      SP,SP,#+56
   \   00000056   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_saveFileName(char *)
   \                     mks_saveFileName: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable230_12
   \   00000006   0x2264             MOVS     R2,#+100
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF205 0x707C      ADDW     R0,R5,#+1916
   \   0000000E   0x.... 0x....      BL       memset
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0xF205 0x707C      ADDW     R0,R5,#+1916
   \   00000018   0x.... 0x....      BL       strcpy
   \   0000001C   0x2264             MOVS     R2,#+100
   \   0000001E   0xF205 0x717C      ADDW     R1,R5,#+1916
   \   00000022   0xF240 0x40FD      MOVW     R0,#+1277
   \   00000026   0x.... 0x....      BL       epr_write_data
   \   0000002A   0xF895 0x081C      LDRB     R0,[R5, #+2076]
   \   0000002E   0x28A6             CMP      R0,#+166
   \   00000030   0xD107             BNE.N    ??mks_saveFileName_0
   \   00000032   0x....             LDR.N    R0,??DataTable230
   \   00000034   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD002             BEQ.N    ??mks_saveFileName_0
   \   0000003C   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000040   0x....             B.N      mks_clearFile
   \                     ??mks_saveFileName_0: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void EXTI9_5_IRQHandler()
   \                     EXTI9_5_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable230_19  ;; 0x422281b4
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x....             LDR.N    R0,??DataTable230_20  ;; 0x40010414
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0689             LSLS     R1,R1,#+26
   \   0000000E   0xD522             BPL.N    ??EXTI9_5_IRQHandler_0
   \   00000010   0x2120             MOVS     R1,#+32
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \   00000014   0x....             LDR.N    R0,??DataTable230_12
   \   00000016   0xF890 0x081C      LDRB     R0,[R0, #+2076]
   \   0000001A   0x28A6             CMP      R0,#+166
   \   0000001C   0xD005             BEQ.N    ??EXTI9_5_IRQHandler_1

  		||(mksReprint.mks_printer_state == MKS_REPRINTING))
  		^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",2090  Warning[Pa134]: 
          left and right operands are identical

  static uint32_t After_finish_print_time = 0;
                  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp",301  Warning[Pe177]: 
          variable "After_finish_print_time" was declared but never referenced

  static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
                                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp",455  Warning[Pe550]: 
          variable "Stopped_gcode_LastN" was set but never used

  static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
                            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp",827  Warning[Pe177]: 
          function "pgm_read_any(signed char const *)" was declared but never
          referenced

  static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
                      ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\Marlin_main.cpp",826  Warning[Pe177]: 
          function "pgm_read_any(float const *)" was declared but never
          referenced

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Middlewares\Third_Party\Marlin\planner.h",549  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                            z_dest[k++]=*ZPOS_TEMP;
                            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1302  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                            z_dest[k++]=*ZPOS_TEMP;
                            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano_tft35_ºŒ∫Ã»˝Œ¨\mksRobin_Nano_code\Src\mks_reprint.cpp",1368  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \   0000001E   0x28AB             CMP      R0,#+171
   \   00000020   0xD003             BEQ.N    ??EXTI9_5_IRQHandler_1
   \   00000022   0x28A9             CMP      R0,#+169
   \   00000024   0xD001             BEQ.N    ??EXTI9_5_IRQHandler_1
   \   00000026   0x28AA             CMP      R0,#+170
   \   00000028   0xD103             BNE.N    ??EXTI9_5_IRQHandler_2
   \                     ??EXTI9_5_IRQHandler_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable230_21  ;; 0x422381a8
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xBD01             POP      {R0,PC}
   \                     ??EXTI9_5_IRQHandler_2: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable230
   \   00000034   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD10C             BNE.N    ??EXTI9_5_IRQHandler_0
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable230_22  ;; 0x42210180
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0x.... 0x....      BL       _Z21mks_WriteToEpr_pwroffv
   \   00000046   0xF44F 0x707A      MOV      R0,#+1000
   \   0000004A   0x.... 0x....      BL       HAL_Delay
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x....             LDR.N    R1,??DataTable230_21  ;; 0x422381a8
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \                     ??EXTI9_5_IRQHandler_3: (+1)
   \   00000054   0xE7FE             B.N      ??EXTI9_5_IRQHandler_3
   \                     ??EXTI9_5_IRQHandler_0: (+1)
   \   00000056   0xB662             cpsie i
   \   00000058   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "enqueueing \\"">`:
   \   00000000   0x65 0x6E          DC8 "enqueueing \""
   \              0x71 0x75    
   \              0x65 0x75    
   \              0x65 0x69    
   \              0x6E 0x67    
   \              0x20 0x22    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "sd:%d">`:
   \   00000000   0x73 0x64          DC8 "sd:%d"
   \              0x3A 0x25    
   \              0x64 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Invalid extruder ">`:
   \   00000000   0x20 0x49          DC8 " Invalid extruder "
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*** Z HOMED TO ENDSTO...">`:
   \   00000000   0x2A 0x2A          DC8 "*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***\012"
   \              0x2A 0x20    
   \              0x5A 0x20    
   \              0x48 0x4F    
   \              0x4D 0x45    
   \              0x44 0x20    
   \              0x54 0x4F    
   \              0x20 0x45    
   \              0x4E 0x44    
   \              0x53 0x54    
   \              0x4F 0x50    
   \              0x20 0x28    
   \              0x5A 0x5F    
   \              0x4D 0x49    
   \              0x4E 0x5F    
   \              0x50 0x52    
   \              0x4F 0x42    
   \              0x45 0x5F    
   \              0x45 0x4E    
   \              0x44 0x53    
   \              0x54 0x4F    
   \              0x50 0x29    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0A 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Home ">`:
   \   00000000   0x48 0x6F          DC8 "Home "
   \              0x6D 0x65    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " first\\n">`:
   \   00000000   0x20 0x66          DC8 " first\012"
   \              0x69 0x72    
   \              0x73 0x74    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "STOP called because o...">`:
   \   00000000   0x53 0x54          DC8 53H, 54H, 4FH, 50H, 20H, 63H, 61H, 6CH
   \              0x4F 0x50    
   \              0x20 0x63    
   \              0x61 0x6C    
   \   00000008   0x6C 0x65          DC8 6CH, 65H, 64H, 20H, 62H, 65H, 63H, 61H
   \              0x64 0x20    
   \              0x62 0x65    
   \              0x63 0x61    
   \   00000010   0x75 0x73          DC8 75H, 73H, 65H, 20H, 6FH, 66H, 20H, 42H
   \              0x65 0x20    
   \              0x6F 0x66    
   \              0x20 0x42    
   \   00000018   0x4C 0x54          DC8 4CH, 54H, 6FH, 75H, 63H, 68H, 20H, 65H
   \              0x6F 0x75    
   \              0x63 0x68    
   \              0x20 0x65    
   \   00000020   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 20H, 2DH, 20H, 72H
   \              0x6F 0x72    
   \              0x20 0x2D    
   \              0x20 0x72    
   \   00000028   0x65 0x73          DC8 65H, 73H, 74H, 61H, 72H, 74H, 20H, 77H
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x20 0x77    
   \   00000030   0x69 0x74          DC8 69H, 74H, 68H, 20H, 4DH, 39H, 39H, 39H
   \              0x68 0x20    
   \              0x4D 0x39    
   \              0x39 0x39    
   \   00000038   0x0A 0x00          DC8 0AH, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136:
   \   00000000   0x58 0x00          DC8      "X",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_1:
   \   00000000   0x59 0x00          DC8      "Y",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_2:
   \   00000000   0x5A 0x00          DC8      "Z",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_3:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_4:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_5:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_6:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_7:
   \   00000000   0x43160000         DC32     0x43160000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_8:
   \   00000000   0x........         DC32     home_dir_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_9:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable137:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Bed X: ">`:
   \   00000000   0x42 0x65          DC8 "Bed X: "
   \              0x64 0x20    
   \              0x58 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Y: ">`:
   \   00000000   0x20 0x59          DC8 " Y: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Z: ">`:
   \   00000000   0x20 0x5A          DC8 " Z: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Probing failed">`:
   \   00000000   0x50 0x72          DC8 "Probing failed"
   \              0x6F 0x62    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Probing failed\\n">`:
   \   00000000   0x50 0x72          DC8 "Probing failed\012"
   \              0x6F 0x62    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139:
   \   00000000   0x........         DC32     home_bump_mm_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_1:
   \   00000000   0x........         DC32     injected_commands_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_2:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_3:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_4:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_5:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(-9.9999990233E+3F), (-9.999999023`:
   \   00000000   0xC61C3FFF         DC32 0C61C3FFFH, 0C61C3FFFH, 0H
   \              0xC61C3FFF   
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable141:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable141_1:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145:
   \   00000000   0x47AE147B         DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Bilinear Leveling Grid:\\n">`:
   \   00000000   0x42 0x69          DC8 "Bilinear Leveling Grid:\012"
   \              0x6C 0x69    
   \              0x6E 0x65    
   \              0x61 0x72    
   \              0x20 0x4C    
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x47 0x72    
   \              0x69 0x64    
   \              0x3A 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable146:
   \   00000000   0x3F847AE1         DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147:
   \   00000000   0x........         DC32     mks_heating_busy+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147_1:
   \   00000000   0x........         DC32     saved_feedrate_percentage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147_2:
   \   00000000   0x40012C34         DC32     0x40012c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147_3:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147_4:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable148:
   \   00000000   0x........         DC32     _ZN8Endstops15z_probe_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable150:
   \   00000000   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "busy: processing\\n">`:
   \   00000000   0x62 0x75          DC8 "busy: processing\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x72    
   \              0x6F 0x63    
   \              0x65 0x73    
   \              0x73 0x69    
   \              0x6E 0x67    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "busy: paused for user\\n">`:
   \   00000000   0x62 0x75          DC8 "busy: paused for user\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x61    
   \              0x75 0x73    
   \              0x65 0x64    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x75    
   \              0x73 0x65    
   \              0x72 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "busy: paused for input\\n">`:
   \   00000000   0x62 0x75          DC8 "busy: paused for input\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x61    
   \              0x75 0x73    
   \              0x65 0x64    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x69    
   \              0x6E 0x70    
   \              0x75 0x74    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151:
   \   00000000   0xC1200000         DC32     0xc1200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151_1:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151_2:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "?Probe ">`:
   \   00000000   0x3F 0x50          DC8 "?Probe "
   \              0x72 0x6F    
   \              0x62 0x65    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " position out of range.\\n">`:
   \   00000000   0x20 0x70          DC8 " position out of range.\012"
   \              0x6F 0x73    
   \              0x69 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x6F 0x75    
   \              0x74 0x20    
   \              0x6F 0x66    
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " not entered.\\n">`:
   \   00000000   0x20 0x6E          DC8 " not entered.\012"
   \              0x6F 0x74    
   \              0x20 0x65    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x65 0x64    
   \              0x2E 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling8has_meshE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153_1:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Num X,Y: ">`:
   \   00000000   0x4E 0x75          DC8 "Num X,Y: "
   \              0x6D 0x20    
   \              0x58 0x2C    
   \              0x59 0x3A    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Z offset: ">`:
   \   00000000   0x5A 0x20          DC8 "Z offset: "
   \              0x6F 0x66    
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x3A 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\nMeasured points:\\n">`:
   \   00000000   0x0A 0x4D          DC8 "\012Measured points:\012"
   \              0x65 0x61    
   \              0x73 0x75    
   \              0x72 0x65    
   \              0x64 0x20    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x73    
   \              0x3A 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154:
   \   00000000   0x........         DC32     mks_heating_busy+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_1:
   \   00000000   0x........         DC32     _ZN7Planner13z_fade_heightE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SCARA Theta:">`:
   \   00000000   0x53 0x43          DC8 "SCARA Theta:"
   \              0x41 0x52    
   \              0x41 0x20    
   \              0x54 0x68    
   \              0x65 0x74    
   \              0x61 0x3A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "   Psi+Theta:">`:
   \   00000000   0x20 0x20          DC8 "   Psi+Theta:"
   \              0x20 0x50    
   \              0x73 0x69    
   \              0x2B 0x54    
   \              0x68 0x65    
   \              0x74 0x61    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Cap:">`:
   \   00000000   0x43 0x61          DC8 "Cap:"
   \              0x70 0x3A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156:
   \   00000000   0x........         DC32     z_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_1:
   \   00000000   0x........         DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_2:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_3:
   \   00000000   0x58 0x3A          DC8      0x58, 0x3A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_4:
   \   00000000   0x20 0x59          DC8      " Y:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_5:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_6:
   \   00000000   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_7:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157:
   \   00000000   0x20 0x45          DC8      " E:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_1:
   \   00000000   0x3A 0x00          DC8      ":",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_2:
   \   00000000   0x40400000         DC32     0x40400000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_3:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_4:
   \   00000000   0x3FF80000         DC32     0x3ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_5:
   \   00000000   0x........         DC32     z_endstop_adj

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_6:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_7:
   \   00000000   0x3FB99999         DC32     0x3fb99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_8:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Active Extruder: ">`:
   \   00000000   0x41 0x63          DC8 "Active Extruder: "
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x20 0x45    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x3A    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable158:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable158_1:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "HAS_NO_TEMP_BED!\\n">`:
   \   00000000   0x48 0x41          DC8 "HAS_NO_TEMP_BED!\012"
   \              0x53 0x5F    
   \              0x4E 0x4F    
   \              0x5F 0x54    
   \              0x45 0x4D    
   \              0x50 0x5F    
   \              0x42 0x45    
   \              0x44 0x21    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Resend: ">`:
   \   00000000   0x52 0x65          DC8 "Resend: "
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling8z_offsetE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162:
   \   00000000   0x6F 0x6B          DC8      0x6F, 0x6B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162_1:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162_2:
   \   00000000   0x........         DC32     hotend_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162_3:
   \   00000000   0x........         DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162_4:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162_5:
   \   00000000   0x........         DC32     _ZN11GCodeParser14command_letterE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162_6:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_1:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_2:
   \   00000000   0x........         DC32     _ZN11GCodeParser7codenumE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_3:
   \   00000000   0x........         DC32     mksCfg+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_4:
   \   00000000   0x........         DC32     `?<Constant "bed leveling hasn\\'t d...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165_1:
   \   00000000   0x........         DC32     curFileName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165_2:
   \   00000000   0x........         DC32     from_flash_pic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165_3:
   \   00000000   0x........         DC32     flash_preview_begin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165_4:
   \   00000000   0x........         DC32     default_preview_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168:
   \   00000000   0x........         DC32     parser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_1:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_2:
   \   00000000   0x........         DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_3:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_4:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_5:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170:
   \   00000000   0x........         DC32     z_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_1:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_2:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_3:
   \   00000000   0x43520000         DC32     0x43520000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_4:
   \   00000000   0x40668000         DC32     0x40668000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_5:
   \   00000000   0x43A50000         DC32     0x43a50000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable171:
   \   00000000   0x42B40000         DC32     0x42b40000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " cold extrusion preve...">`:
   \   00000000   0x20 0x63          DC8 " cold extrusion prevented\012"
   \              0x6F 0x6C    
   \              0x64 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " too long extrusion p...">`:
   \   00000000   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M600">`:
   \   00000000   0x4D 0x36          DC8 "M600"
   \              0x30 0x30    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable179:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable179_1:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable179_2:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable180:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILL caused by too mu...">`:
   \   00000000   0x4B 0x49          DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
   \              0x4C 0x4C    
   \              0x20 0x63    
   \              0x61 0x75    
   \   00000008   0x73 0x65          DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x74    
   \   00000010   0x6F 0x6F          DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
   \              0x20 0x6D    
   \              0x75 0x63    
   \              0x68 0x20    
   \   00000018   0x69 0x6E          DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
   \              0x61 0x63    
   \              0x74 0x69    
   \              0x76 0x65    
   \   00000020   0x20 0x74          DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x2D 0x20    
   \   00000028   0x63 0x75          DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x20    
   \   00000030   0x63 0x6F          DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x3A    
   \   00000038   0x20 0x00          DC8 20H, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILLED. ">`:
   \   00000000   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err%d">`:
   \   00000000   0x45 0x72          DC8 "Err%d"
   \              0x72 0x25    
   \              0x64 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Printer halted. kill(...">`:
   \   00000000   0x50 0x72          DC8 "Printer halted. kill() called!\012"
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x68 0x61    
   \              0x6C 0x74    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x6B 0x69    
   \              0x6C 0x6C    
   \              0x28 0x29    
   \              0x20 0x63    
   \              0x61 0x6C    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_1:
   \   00000000   0x........         DC32     _ZN7Planner8e_factorE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_2:
   \   00000000   0x447A0001         DC32     0x447a0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_3:
   \   00000000   0x47AE147B         DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Printer stopped due t...">`:
   \   00000000   0x50 0x72          DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \   00000008   0x73 0x74          DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
   \              0x6F 0x70    
   \              0x70 0x65    
   \              0x64 0x20    
   \   00000010   0x64 0x75          DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x65    
   \   00000018   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
   \              0x6F 0x72    
   \              0x73 0x2E    
   \              0x20 0x46    
   \   00000020   0x69 0x78          DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x65    
   \   00000028   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
   \              0x6F 0x72    
   \              0x20 0x61    
   \              0x6E 0x64    
   \   00000030   0x20 0x75          DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
   \              0x73 0x65    
   \              0x20 0x4D    
   \              0x39 0x39    
   \   00000038   0x39 0x20          DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
   \              0x74 0x6F    
   \              0x20 0x72    
   \              0x65 0x73    
   \   00000040   0x74 0x61          DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
   \              0x72 0x74    
   \              0x2E 0x20    
   \              0x28 0x54    
   \   00000048   0x65 0x6D          DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \   00000050   0x72 0x65          DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x72 0x65    
   \   00000058   0x73 0x65          DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
   \              0x74 0x2E    
   \              0x20 0x53    
   \              0x65 0x74    
   \   00000060   0x20 0x69          DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
   \              0x74 0x20    
   \              0x61 0x66    
   \              0x74 0x65    
   \   00000068   0x72 0x20          DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
   \              0x72 0x65    
   \              0x73 0x74    
   \              0x61 0x72    
   \   00000070   0x74 0x69          DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
   \              0x6E 0x67    
   \              0x29 0x0A    
   \              0x00         
   \   00000077   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "STOPPED. ">`:
   \   00000000   0x53 0x54          DC8 "STOPPED. "
   \              0x4F 0x50    
   \              0x50 0x45    
   \              0x44 0x2E    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable188:
   \   00000000   0x3F847AE1         DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable188_1:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable188_2:
   \   00000000   0x401921FB         DC32     0x401921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable188_3:
   \   00000000   0xC01921FB         DC32     0xc01921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable188_4:
   \   00000000   0x40C90FDB         DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MKS Robin Nano">`:
   \   00000000   0x4D 0x4B          DC8 "MKS Robin Nano"
   \              0x53 0x20    
   \              0x52 0x6F    
   \              0x62 0x69    
   \              0x6E 0x20    
   \              0x4E 0x61    
   \              0x6E 0x6F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "1.0.0\\n">`:
   \   00000000   0x31 0x2E          DC8 "1.0.0\012"
   \              0x30 0x2E    
   \              0x30 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Last Updated: ">`:
   \   00000000   0x20 0x4C          DC8 " Last Updated: "
   \              0x61 0x73    
   \              0x74 0x20    
   \              0x55 0x70    
   \              0x64 0x61    
   \              0x74 0x65    
   \              0x64 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "2017-12-25 12:00">`:
   \   00000000   0x32 0x30          DC8 "2017-12-25 12:00"
   \              0x31 0x37    
   \              0x2D 0x31    
   \              0x32 0x2D    
   \              0x32 0x35    
   \              0x20 0x31    
   \              0x32 0x3A    
   \              0x30 0x30    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " | Author: (none, def...">`:
   \   00000000   0x20 0x7C          DC8 " | Author: (none, default config)\012"
   \              0x20 0x41    
   \              0x75 0x74    
   \              0x68 0x6F    
   \              0x72 0x3A    
   \              0x20 0x28    
   \              0x6E 0x6F    
   \              0x6E 0x65    
   \              0x2C 0x20    
   \              0x64 0x65    
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x29 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Compiled: Feb 25 2020\\n">`:
   \   00000000   0x43 0x6F          DC8 "Compiled: Feb 25 2020\012"
   \              0x6D 0x70    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x3A 0x20    
   \              0x46 0x65    
   \              0x62 0x20    
   \              0x32 0x35    
   \              0x20 0x32    
   \              0x30 0x32    
   \              0x30 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Free Memory: ">`:
   \   00000000   0x20 0x46          DC8 " Free Memory: "
   \              0x72 0x65    
   \              0x65 0x20    
   \              0x4D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x3A 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "  PlannerBufferBytes: ">`:
   \   00000000   0x20 0x20          DC8 "  PlannerBufferBytes: "
   \              0x50 0x6C    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x72 0x42    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x42    
   \              0x79 0x74    
   \              0x65 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable189:
   \   00000000   0x3A83126F         DC32     0x3a83126f

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Done saving file.\\n">`:
   \   00000000   0x44 0x6F          DC8 "Done saving file.\012"
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x61 0x76    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x69    
   \              0x6C 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_1:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_2:
   \   00000000   0x4D 0x32          DC8      "M29"
   \              0x39 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_3:
   \   00000000   0x4062C000         DC32     0x4062c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_4:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_5:
   \   00000000   0x40668000         DC32     0x40668000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_6:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_7:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_8:
   \   00000000   0xC2C80000         DC32     0xc2c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_9:
   \   00000000   0x42600000         DC32     0x42600000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_10:
   \   00000000   0xBF800000         DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable190_11:
   \   00000000   0x........         DC32     ??C2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191:
   \   00000000   0xC2600000         DC32     0xc2600000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191_1:
   \   00000000   0x43160000         DC32     0x43160000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191_2:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191_3:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192:
   \   00000000   0x........         DC32     filament_ran_out

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_1:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_2:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_3:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_4:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_5:
   \   00000000   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_6:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_7:
   \   00000000   0x........         DC32     disp_state_stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_8:
   \   00000000   0x........         DC32     button_disp_pause_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_9:
   \   00000000   0x422281B4         DC32     0x422281b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_10:
   \   00000000   0x........         DC32     wifi_link_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_1:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_2:
   \   00000000   0x........         DC32     temper_error_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_3:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_4:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0.000">`:
   \   00000000   0x30 0x2E          DC8 "0.000"
   \              0x30 0x30    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TP-LINK_MKS">`:
   \   00000000   0x54 0x50          DC8 "TP-LINK_MKS"
   \              0x2D 0x4C    
   \              0x49 0x4E    
   \              0x4B 0x5F    
   \              0x4D 0x4B    
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "makerbase">`:
   \   00000000   0x6D 0x61          DC8 "makerbase"
   \              0x6B 0x65    
   \              0x72 0x62    
   \              0x61 0x73    
   \              0x65 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.100">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.100"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x31 0x30    
   \              0x30 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "255.255.255.0">`:
   \   00000000   0x32 0x35          DC8 "255.255.255.0"
   \              0x35 0x2E    
   \              0x32 0x35    
   \              0x35 0x2E    
   \              0x32 0x35    
   \              0x35 0x2E    
   \              0x30 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.1">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.1"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.255">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.255"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x32 0x35    
   \              0x35 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "baizhongyun.cn">`:
   \   00000000   0x62 0x61          DC8 "baizhongyun.cn"
   \              0x69 0x7A    
   \              0x68 0x6F    
   \              0x6E 0x67    
   \              0x79 0x75    
   \              0x6E 0x2E    
   \              0x63 0x6E    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195:
   \   00000000   0x........         DC32     thermalManager

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_1:
   \   00000000   0x........         DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196:
   \   00000000   0x42220194         DC32     0x42220194

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_1:
   \   00000000   0x408F4000         DC32     0x408f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_2:
   \   00000000   0x40590000         DC32     0x40590000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_3:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_4:
   \   00000000   0x........         DC32     filament_rate

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_5:
   \   00000000   0x........         DC32     temperature_change_frequency

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_6:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_7:
   \   00000000   0x........         DC32     poweroff_det_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_8:
   \   00000000   0x........         DC32     poweroff_det_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196_9:
   \   00000000   0x........         DC32     filament_det1_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable197:
   \   00000000   0x........         DC32     filament_det1_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable197_1:
   \   00000000   0x........         DC32     filament_det1_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable197_2:
   \   00000000   0x........         DC32     filament_det1_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable197_3:
   \   00000000   0x........         DC32     filament_det1_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable197_4:
   \   00000000   0x........         DC32     filament_det1_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable198:
   \   00000000   0x........         DC32     filament_det2_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable198_1:
   \   00000000   0x........         DC32     filament_det2_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable198_2:
   \   00000000   0x........         DC32     filament_det2_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable198_3:
   \   00000000   0x........         DC32     filament_det2_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable198_4:
   \   00000000   0x........         DC32     filament_det2_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable198_5:
   \   00000000   0x........         DC32     filament_det2_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable199:
   \   00000000   0x........         DC32     poweroff_det_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable199_1:
   \   00000000   0x........         DC32     poweroff_det_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable199_2:
   \   00000000   0x........         DC32     poweroff_det_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable199_3:
   \   00000000   0x........         DC32     poweroff_det_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable199_4:
   \   00000000   0x........         DC32     wifi_check_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable200:
   \   00000000   0x76313030         DC32     0x76313030

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M140 S">`:
   \   00000000   0x4D 0x31          DC8 "M140 S"
   \              0x34 0x30    
   \              0x20 0x53    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M104 T1 S">`:
   \   00000000   0x4D 0x31          DC8 "M104 T1 S"
   \              0x30 0x34    
   \              0x20 0x54    
   \              0x31 0x20    
   \              0x53 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M109 T0 S">`:
   \   00000000   0x4D 0x31          DC8 "M109 T0 S"
   \              0x30 0x39    
   \              0x20 0x54    
   \              0x30 0x20    
   \              0x53 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M109 T1 S">`:
   \   00000000   0x4D 0x31          DC8 "M109 T1 S"
   \              0x30 0x39    
   \              0x20 0x54    
   \              0x31 0x20    
   \              0x53 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M190 S">`:
   \   00000000   0x4D 0x31          DC8 "M190 S"
   \              0x39 0x30    
   \              0x20 0x53    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G92 Z">`:
   \   00000000   0x47 0x39          DC8 "G92 Z"
   \              0x32 0x20    
   \              0x5A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable205:
   \   00000000   0x00494949         DC32     0x494949

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 E">`:
   \   00000000   0x47 0x31          DC8 "G1 E"
   \              0x20 0x45    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G92 E">`:
   \   00000000   0x47 0x39          DC8 "G92 E"
   \              0x32 0x20    
   \              0x45 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable206:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable206_1:
   \   00000000   0x00AAAAAA         DC32     0xaaaaaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable207:
   \   00000000   0x........         DC32     wifiPara

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable207_1:
   \   00000000   0x........         DC32     ipPara

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%.3f F%d">`:
   \   00000000   0x25 0x2E          DC8 "%.3f F%d"
   \              0x33 0x66    
   \              0x20 0x46    
   \              0x25 0x64    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable208:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210:
   \   00000000   0x........         DC32     DeviceCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable211:
   \   00000000   0x........         DC32     BMP_PIC_X

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable212:
   \   00000000   0x20 0x59          DC8      0x20, 0x59, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable212_1:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable212_2:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 Z">`:
   \   00000000   0x47 0x31          DC8 "G1 Z"
   \              0x20 0x5A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable213:
   \   00000000   0x........         DC32     BMP_PIC_Y

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable213_1:
   \   00000000   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable213_2:
   \   00000000   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 X">`:
   \   00000000   0x47 0x31          DC8 "G1 X"
   \              0x20 0x58    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%.3f">`:
   \   00000000   0x25 0x2E          DC8 "%.3f"
   \              0x33 0x66    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%.3f F%.3f">`:
   \   00000000   0x25 0x2E          DC8 "%.3f F%.3f"
   \              0x33 0x66    
   \              0x20 0x46    
   \              0x25 0x2E    
   \              0x33 0x66    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable214:
   \   00000000   0x40A00000         DC32     0x40a00000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 Z0">`:
   \   00000000   0x47 0x31          DC8 "G1 Z0"
   \              0x20 0x5A    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable215:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable215_1:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable216:
   \   00000000   0x........         DC32     mks_heating_busy+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable216_1:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G28 X0 Y0">`:
   \   00000000   0x47 0x32          DC8 "G28 X0 Y0"
   \              0x38 0x20    
   \              0x58 0x30    
   \              0x20 0x59    
   \              0x30 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217:
   \   00000000   0x20 0x59          DC8      0x20, 0x59, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217_1:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217_2:
   \   00000000   0x47 0x32          DC8      "G28"
   \              0x38 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217_3:
   \   00000000   0x38D1B718         DC32     0x38d1b718

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217_4:
   \   00000000   0x........         DC32     pause_resum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217_5:
   \   00000000   0x........         DC32     IsChooseAutoShutdown

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable218:
   \   00000000   0x........         DC32     `?<Constant "G28 X0 Y0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable219:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable220:
   \   00000000   0x40000440         DC32     0x40000440

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Resume print?">`:
   \   00000000   0x52 0x65          DC8 "Resume print?"
   \              0x73 0x75    
   \              0x6D 0x65    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x3F 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable221:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable221_1:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "start\\n">`:
   \   00000000   0x73 0x74          DC8 "start\012"
   \              0x61 0x72    
   \              0x74 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable223:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable223_1:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable225:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable225_1:
   \   00000000   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable225_2:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable225_3:
   \   00000000   0x........         DC32     leveling_first_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226:
   \   00000000   0x65 0x6E          DC8      "end"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_1:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_2:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable228:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable228_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable228_2:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable229:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_1:
   \   00000000   0x........         DC32     first_resu

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_2:
   \   00000000   0x........         DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_3:
   \   00000000   0x38D1B718         DC32     0x38d1b718

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_4:
   \   00000000   0x........         DC32     card+0x77C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_5:
   \   00000000   0x........         DC32     curFileName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_6:
   \   00000000   0x........         DC32     logo_tick2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_7:
   \   00000000   0x........         DC32     logo_tick1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_8:
   \   00000000   0x........         DC32     from_flash_pic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_9:
   \   00000000   0x........         DC32     flash_preview_begin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_10:
   \   00000000   0x........         DC32     default_preview_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_11:
   \   00000000   0x........         DC32     continue_print_error_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_12:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_13:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_14:
   \   00000000   0x........         DC32     SD_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_15:
   \   00000000   0x........         DC32     mks_pft_name

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_16:
   \   00000000   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_17:
   \   00000000   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_18:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_19:
   \   00000000   0x422281B4         DC32     0x422281b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_20:
   \   00000000   0x40010414         DC32     0x40010414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_21:
   \   00000000   0x422381A8         DC32     0x422381a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable230_22:
   \   00000000   0x42210180         DC32     0x42210180

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "clear">`:
   \   00000000   0x63 0x6C          DC8 "clear"
   \              0x65 0x61    
   \              0x72 0x00    
   \   00000006   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "mks_pft.sys">`:
   \   00000000   0x6D 0x6B          DC8 "mks_pft.sys"
   \              0x73 0x5F    
   \              0x70 0x66    
   \              0x74 0x2E    
   \              0x73 0x79    
   \              0x73 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "X">`:
   \   00000000   0x58 0x00          DC8 "X"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "Y">`:
   \   00000000   0x59 0x00          DC8 "Y"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "Z">`:
   \   00000000   0x5A 0x00          DC8 "Z"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(0.0F), (0.0F)}>`:
   \   00000000   0x00000000         DC32 0H, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "X:">`:
   \   00000000   0x58 0x3A          DC8 "X:"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y:">`:
   \   00000000   0x20 0x59          DC8 " Y:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Z:">`:
   \   00000000   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " E:">`:
   \   00000000   0x20 0x45          DC8 " E:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant ":">`:
   \   00000000   0x3A 0x00          DC8 ":"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "bed leveling hasn\\'t d...">`:
   \   00000000   0x62 0x65          DC8 "bed leveling hasn't defined!"
   \              0x64 0x20    
   \              0x6C 0x65    
   \              0x76 0x65    
   \              0x6C 0x69    
   \              0x6E 0x67    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x6E 0x27    
   \              0x74 0x20    
   \              0x64 0x65    
   \              0x66 0x69    
   \              0x6E 0x65    
   \              0x64 0x21    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ok">`:
   \   00000000   0x6F 0x6B          DC8 "ok"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(0.0F), (0.0F), (0.0F)}>`:
   \   00000000   0x00000000         DC32 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_1`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "M29">`:
   \   00000000   0x4D 0x32          DC8 "M29"
   \              0x39 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%d">`:
   \   00000000   0x25 0x64          DC8 "%d"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%f">`:
   \   00000000   0x25 0x66          DC8 "%f"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y">`:
   \   00000000   0x20 0x59          DC8 " Y"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "G28">`:
   \   00000000   0x47 0x32          DC8 "G28"
   \              0x38 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "/">`:
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_2`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "end">`:
   \   00000000   0x65 0x6E          DC8 "end"
   \              0x64 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_3`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_4`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
  16397          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADJUST_DELTA(float const *)
        16   -> __aeabi_fadd
        16   -> bilinear_z_offset(float const *)
       0   Beeper(uint32_t)
       0   CardReader::eof()
      16   CardReader::get()
        16   -> f_read
       0   CardReader::isFileOpen()
       0   CardReader::setIndex(long)
         0   -> f_lseek
       8   EXTI9_5_IRQHandler
         8   -> HAL_Delay
         8   -> mks_WriteToEpr_pwroff()
       0   Endstops::enable(bool)
       0   Endstops::enable_globally(bool)
       0   Endstops::enable_z_probe(bool)
       0   Endstops::hit_on_purpose()
       0   Endstops::not_homing()
       8   FlushSerialRequestResend()
         8   -> Print::print(long, int)
         8   -> USARTClass::flush()
         8   -> USARTClass::write(uint8_t)
         0   -> ok_to_send()
         8   -> serialprintPGM(char const *)
       8   GCodeParser::boolval(char)
         0   -> GCodeParser::seen(char)
         8   -> GCodeParser::seenval(char)
         0   -> GCodeParser::value_bool()
       8   GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_byte()
       8   GCodeParser::celsiusval(char, float)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_celsius()
       0   GCodeParser::has_value()
       8   GCodeParser::intval(char, int16_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
       8   GCodeParser::linearval(char, float)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_linear_units()
       0   GCodeParser::seen(char)
       8   GCodeParser::seenval(char)
         0   -> GCodeParser::has_value()
         8   -> GCodeParser::seen(char)
       8   GCodeParser::ushortval(char, uint16_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_ushort()
       0   GCodeParser::value_axis_units(AxisEnum)
         0   -> GCodeParser::value_float()
       8   GCodeParser::value_bool()
         8   -> GCodeParser::has_value()
         8   -> GCodeParser::value_byte()
       8   GCodeParser::value_byte()
         8   -> GCodeParser::value_long()
       0   GCodeParser::value_celsius()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_feedrate()
         0   -> GCodeParser::value_linear_units()
      16   GCodeParser::value_float()
         0   -> __aeabi_d2f
        16   -> __aeabi_d2f
        16   -> strtod
       8   GCodeParser::value_int()
         8   -> GCodeParser::value_long()
       0   GCodeParser::value_linear_units()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_long()
         0   -> strtol
       0   GCodeParser::value_millis()
         0   -> GCodeParser::value_ulong()
       8   GCodeParser::value_millis_from_seconds()
         8   -> GCodeParser::value_float()
         0   -> __aeabi_f2uiz
         8   -> __aeabi_fmul
       0   GCodeParser::value_per_axis_unit(AxisEnum)
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_ulong()
         0   -> strtoul
       8   GCodeParser::value_ushort()
         8   -> GCodeParser::value_long()
       0   IsRunning()
       0   IsStopped()
       0   Planner::apply_leveling(float (&)[3])
         0   -> Planner::apply_leveling(float &, float &, float &)
       0   Planner::blocks_queued()
      32   Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        32   -> Planner::apply_leveling(float &, float &, float &)
        32   -> Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
      40   Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        40   -> Planner::apply_leveling(float (&)[3])
        40   -> Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_fmul
        40   -> inverse_kinematics(float const *)
        40   -> inverse_kinematics_MORGAN_SCARA(float const *)
        40   -> lroundf
       0   Planner::force_fade_recalc()
       8   Planner::leveling_active_at_z(float const &)
         8   -> __aeabi_cfcmpeq
         8   -> __aeabi_cfcmple
      16   Planner::refresh_e_factor(uint8_t)
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_i2d
       0   Planner::set_e_position_mm(float const &)
         0   -> Planner::set_position_mm(AxisEnum, float const &)
       8   Planner::set_filament_size(uint8_t, float const &)
         8   -> __aeabi_cfcmpeq
      24   Planner::set_position_mm(float, float, float, float const &)
        24   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        24   -> Planner::apply_leveling(float &, float &, float &)
       8   Planner::set_z_fade_height(float const &)
         0   -> Planner::force_fade_recalc()
         8   -> __aeabi_cfcmple
         8   -> __aeabi_cfrcmple
         8   -> __aeabi_fdiv
      24   SCARA_move_to_cal(uint8_t, uint8_t)
        24   -> IsRunning()
        24   -> __aeabi_ui2f
        24   -> forward_kinematics_SCARA(float const &, float const &)
        24   -> prepare_move_to_destination()
       0   SYNC_PLAN_POSITION_KINEMATIC()
         0   -> sync_plan_position()
         0   -> sync_plan_position_kinematic()
       0   Stepper::get_axis_position_degrees(AxisEnum)
         0   -> Stepper::get_axis_position_mm(AxisEnum)
       0   Stepper::set_homing_flag_z(bool)
       0   Stepper::set_z2_lock(bool)
       0   Stepper::set_z_lock(bool)
      40   SysTick_Handler_User()
        40   -> __aeabi_d2uiz
        40   -> __aeabi_dadd
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_ui2d
        40   -> mksBeeperAlarm()
       0   Temperature::degBed()
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetBed()
         0   -> __aeabi_i2f
       0   Temperature::degTargetHotend(uint8_t)
         0   -> __aeabi_i2f
       8   Temperature::isCoolingBed()
         8   -> __aeabi_cfcmple
         8   -> __aeabi_i2f
       8   Temperature::isCoolingHotend(uint8_t)
         8   -> __aeabi_cfcmple
         8   -> __aeabi_i2f
      16   Temperature::setTargetBed(float)
         0   -> Temperature::start_watching_bed()
        16   -> __aeabi_cfcmple
        16   -> __aeabi_f2iz
        16   -> __aeabi_i2f
       8   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
         8   -> __aeabi_f2iz
       8   Temperature::set_auto_report_interval(uint8_t)
         8   -> HAL_GetTick
      16   Temperature::tooColdToExtrude(uint8_t)
        16   -> Temperature::degHotend(uint8_t)
        16   -> __aeabi_cfcmple
        16   -> __aeabi_i2f
       0   Temperature::updatePID()
      32   __sti__routine()
        32   -> CardReader::CardReader()
        32   -> Stopwatch::Stopwatch()
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> unified_bed_leveling::unified_bed_leveling()
       0   _commit_command(bool)
       8   _enqueuecommand(char const *, bool)
         8   -> _commit_command(bool)
         8   -> strcpy
      32   _manual_goto_xy(float const &, float const &)
        32   -> __aeabi_cfrcmple
        32   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
        32   -> do_blocking_move_to_xy(float const &, float const &, float const &)
        32   -> do_blocking_move_to_z(float const &, float const &)
      16   axis_unhomed_error(bool, bool, bool)
        16   -> serialprintPGM(char const *)
       0   base_home_pos(AxisEnum)
       0   base_max_pos(AxisEnum)
       0   base_min_pos(AxisEnum)
      64   bilinear_line_to_destination(float, uint16_t, uint16_t)
        64   -> __aeabi_f2iz
        64   -> __aeabi_fadd
        64   -> __aeabi_fdiv
        64   -> __aeabi_fmul
        64   -> __aeabi_fsub
        64   -> __aeabi_i2f
        64   -> bilinear_line_to_destination(float, uint16_t, uint16_t)
        64   -> buffer_line_to_destination(float)
        64   -> memcpy
        64   -> set_current_from_destination()
      32   bilinear_z_offset(float const *)
        32   -> __aeabi_cfcmpeq
        32   -> __aeabi_cfcmple
        32   -> __aeabi_f2iz
         0   -> __aeabi_fadd
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> floorf
       0   bltouch_command(int)
         0   -> safe_delay(millis_t)
      16   buffer_line_to_current_position()
        16   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
      16   buffer_line_to_destination(float)
        16   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
      16   cap_line(char const *, bool)
        16   -> Print::print(int, int)
         0   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
      40   clamp_to_software_endstops(float *)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> sqrtf
       0   clean_up_after_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   clear_command_queue()
      32   delta_safe_distance_from_top()
        32   -> __aeabi_fsub
        32   -> inverse_kinematics(float const *)
        32   -> inverse_kinematics_MORGAN_SCARA(float const *)
      24   disable_all_steppers()
        24   -> HAL_GPIO_WritePin
         0   -> disable_e_steppers()
      24   disable_e_steppers()
         0   -> HAL_GPIO_WritePin
        24   -> HAL_GPIO_WritePin
      24   disable_noZ_steppers()
        24   -> HAL_GPIO_WritePin
         0   -> disable_e_steppers()
      48   display_sd_error()
        48   -> GUI_DispStringAt
        48   -> GUI_SetBkColor
        48   -> GUI_SetColor
        48   -> __aeabi_memclr4
        48   -> sprintf
      48   display_temper_error()
        48   -> GUI_DispStringAt
        48   -> GUI_SetBkColor
        48   -> GUI_SetColor
        48   -> __aeabi_memclr4
        48   -> sprintf
      32   do_blocking_move_to(float const &, float const &, float const &, float const &)
        32   -> Stepper::synchronize()
        32   -> __aeabi_cfcmpeq
        32   -> __aeabi_cfcmple
        32   -> buffer_line_to_current_position()
        32   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
        32   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
        32   -> prepare_uninterpolated_move_to_destination(float)
        32   -> set_destination_from_current()
       8   do_blocking_move_to_x(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       0   do_blocking_move_to_xy(float const &, float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       8   do_blocking_move_to_z(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
      40   do_homing_move(AxisEnum, float, float)
        40   -> Endstops::hit_on_purpose()
        40   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> Stepper::synchronize()
        40   -> __aeabi_cfcmpeq
        40   -> __aeabi_cfcmple
        40   -> inverse_kinematics(float const *)
        40   -> inverse_kinematics_MORGAN_SCARA(float const *)
        40   -> set_bltouch_deployed(bool)
        40   -> sync_plan_position()
      24   do_probe_move(float, float)
        24   -> Endstops::hit_on_purpose()
        24   -> SYNC_PLAN_POSITION_KINEMATIC()
        24   -> __aeabi_fdiv
        24   -> do_blocking_move_to_z(float const &, float const &)
        24   -> set_bltouch_deployed(bool)
        24   -> set_current_from_steppers_for_axis(AxisEnum)
      16   do_probe_raise(float)
        16   -> __aeabi_cfcmple
        16   -> __aeabi_fsub
        16   -> do_blocking_move_to_z(float const &, float const &)
      48   drain_injected_commands_P()
        48   -> enqueue_and_echo_command(char const *, bool)
        48   -> strncpy
       8   duration_t::day() const
         8   -> duration_t::hour() const
       0   duration_t::duration_t(uint32_t const &)
       8   duration_t::hour() const
         8   -> duration_t::minute() const
       8   duration_t::minute() const
         8   -> duration_t::second() const
       0   duration_t::second() const
      48   duration_t::toString(char *) const
        48   -> duration_t::day() const
        48   -> duration_t::hour() const
        48   -> duration_t::minute() const
        48   -> duration_t::second() const
        48   -> duration_t::year() const
         0   -> sprintf
        48   -> sprintf
       8   duration_t::year() const
         8   -> duration_t::day() const
       8   dwell(millis_t)
         8   -> HAL_GetTick
         8   -> idle()
         8   -> refresh_cmd_timeout()
       0   echo_not_entered()
         0   -> serialprintPGM(char const *)
      16   enable_all_steppers()
         0   -> HAL_GPIO_WritePin
        16   -> HAL_GPIO_WritePin
       8   enqueue_and_echo_command(char const *, bool)
         8   -> USARTClass::write(uint8_t)
         8   -> _enqueuecommand(char const *, bool)
         8   -> serial_echopair_P(char const *, char const *)
         8   -> serialprintPGM(char const *)
       0   enqueue_and_echo_commands_P(char const *)
         0   -> drain_injected_commands_P()
      40   extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
        40   -> USARTClass::write(uint8_t)
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __iar_FDtest
      56   extrapolate_unprobed_bed_level()
        56   -> extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
       0   forward_kinematics_DELTA(float *)
         0   -> forward_kinematics_DELTA(float, float, float)
      80   forward_kinematics_DELTA(float, float, float)
        80   -> __aeabi_fadd
        80   -> __aeabi_fdiv
        80   -> __aeabi_fmul
        80   -> __aeabi_fsub
        80   -> sqrtf
      40   forward_kinematics_SCARA(float const &, float const &)
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> cos
        40   -> sin
       0   freeMemory()
       8   gcode_G0_G1()
         8   -> IsRunning()
         8   -> gcode_get_destination()
         0   -> prepare_move_to_destination()
       8   gcode_G0_G1_SCARA(bool)
         8   -> IsRunning()
         8   -> gcode_get_destination()
         0   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
      48   gcode_G28(bool)
        48   -> Endstops::enable(bool)
        48   -> Endstops::not_homing()
        48   -> GCodeParser::seen(char)
        48   -> SYNC_PLAN_POSITION_KINEMATIC()
        48   -> Stepper::synchronize()
        48   -> __aeabi_cfcmple
        48   -> clean_up_after_endstop_or_probe_move()
        48   -> do_blocking_move_to_z(float const &, float const &)
        48   -> home_delta()
        48   -> homeaxis(AxisEnum)
        48   -> lcd_refresh()
        48   -> quick_home_xy()
        48   -> report_current_position()
        48   -> set_bed_leveling_enabled(bool)
        48   -> set_destination_from_current()
        48   -> setup_for_endstop_or_probe_move()
        48   -> tool_change(uint8_t, float, bool)
     864   gcode_G29()
       848   -> GCodeParser::boolval(char)
       848   -> GCodeParser::byteval(char, uint8_t)
       848   -> GCodeParser::intval(char, int16_t)
       848   -> GCodeParser::linearval(char, float)
       848   -> GCodeParser::seen(char)
       848   -> GCodeParser::seenval(char)
       848   -> GCodeParser::value_int()
       848   -> GCodeParser::value_linear_units()
       848   -> Planner::unapply_leveling(float *)
       848   -> Print::print(double, int)
       848   -> SYNC_PLAN_POSITION_KINEMATIC()
       848   -> Stepper::synchronize()
       848   -> USARTClass::write(uint8_t)
       848   -> __aeabi_cfcmpeq
       848   -> __aeabi_cfcmple
       848   -> __aeabi_cfrcmple
       848   -> __aeabi_d2f
       848   -> __aeabi_d2iz
       848   -> __aeabi_dadd
       848   -> __aeabi_ddiv
       848   -> __aeabi_f2d
       848   -> __aeabi_f2iz
       848   -> __aeabi_fadd
       848   -> __aeabi_fdiv
       848   -> __aeabi_fmul
       848   -> __aeabi_fsub
       848   -> __aeabi_i2f
       848   -> __aeabi_memcpy4
       864   -> __aeabi_memcpy4
       848   -> __aeabi_ui2f
       848   -> __iar_FDtest
       848   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
       848   -> axis_unhomed_error(bool, bool, bool)
       848   -> bilinear_z_offset(float const *)
       848   -> clean_up_after_endstop_or_probe_move()
       848   -> extrapolate_unprobed_bed_level()
       848   -> finish_incremental_LSF(linear_fit_data *)
       848   -> floor
       848   -> free
       848   -> idle()
       848   -> incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
       848   -> incremental_LSF_reset(linear_fit_data *)
       848   -> kill(char const *)
       848   -> leveling_is_valid()
       848   -> malloc
       848   -> matrix_3x3::create_look_at(vector_3)
       848   -> matrix_3x3::debug(char const *)
       848   -> memcpy
       848   -> out_of_range_error(char const *)
       848   -> position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
       848   -> print_bilinear_leveling_grid()
       848   -> probe_pt(float const &, float const &, bool, uint8_t, bool)
       848   -> rand
       848   -> refresh_bed_level()
       848   -> report_current_position()
       848   -> reset_bed_level()
       848   -> serialprintPGM(char const *)
       848   -> set_bed_leveling_enabled(bool)
       848   -> set_probe_deployed(bool)
       848   -> setup_for_endstop_or_probe_move()
       848   -> vector_3::cross(vector_3, vector_3)
       848   -> vector_3::get_normal()
       848   -> vector_3::operator-(vector_3)
       848   -> vector_3::vector_3(float, float, float)
      32   gcode_G29_MESH_BED_LEVELING()
        32   -> GCodeParser::byteval(char, uint8_t)
        32   -> GCodeParser::seenval(char)
        32   -> GCodeParser::value_int()
        32   -> GCodeParser::value_linear_units()
        32   -> Stepper::synchronize()
        32   -> USARTClass::write(uint8_t)
        32   -> __aeabi_fadd
        32   -> _manual_goto_xy(float const &, float const &)
        32   -> buffer_line_to_current_position()
        32   -> echo_not_entered()
        32   -> enqueue_and_echo_commands_P(char const *)
        32   -> home_all_axes()
        32   -> leveling_is_valid()
        32   -> mbl_mesh_report()
        32   -> mesh_bed_leveling::reset()
        32   -> mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
        32   -> mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
        32   -> report_current_position()
        32   -> reset_bed_level()
        32   -> serial_echopair_P(char const *, char const *)
        32   -> serial_echopair_P(char const *, int)
        32   -> serialprintPGM(char const *)
        32   -> set_bed_leveling_enabled(bool)
       0   gcode_G29_UBL()
         0   -> unified_bed_leveling::gcode_G29_UBL()
      72   gcode_G2_G3(bool)
        72   -> GCodeParser::seenval(char)
        72   -> GCodeParser::value_linear_units()
        72   -> IsRunning()
        72   -> __aeabi_cfcmpeq
        72   -> __aeabi_cfcmple
        72   -> __aeabi_d2f
        72   -> __aeabi_dmul
        72   -> __aeabi_dsub
        72   -> __aeabi_f2d
        72   -> __aeabi_fadd
        72   -> __aeabi_fdiv
        72   -> __aeabi_fmul
        72   -> __aeabi_fsub
        72   -> gcode_get_destination()
        72   -> plan_arc(float const (&)[4], float const (&)[2], bool)
        72   -> refresh_cmd_timeout()
        72   -> serialprintPGM(char const *)
        72   -> sqrt
        72   -> sqrtf
      32   gcode_G30()
        32   -> GCodeParser::boolval(char)
        32   -> GCodeParser::linearval(char, float)
        32   -> USARTClass::write(uint8_t)
        32   -> __aeabi_dadd
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __iar_FDtest
        32   -> clean_up_after_endstop_or_probe_move()
        32   -> position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
        32   -> position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
        32   -> probe_pt(float const &, float const &, bool, uint8_t, bool)
        32   -> report_current_position()
        32   -> serial_echopair_P(char const *, double)
        32   -> set_bed_leveling_enabled(bool)
        32   -> setup_for_endstop_or_probe_move()
       8   gcode_G4()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_millis()
         8   -> GCodeParser::value_millis_from_seconds()
         8   -> Stepper::synchronize()
         0   -> dwell(millis_t)
         8   -> lcd_hasstatus()
         8   -> lcd_setstatusPGM(char const *, int8_t)
      32   gcode_G42()
        32   -> GCodeParser::boolval(char)
        32   -> GCodeParser::linearval(char, float)
        32   -> GCodeParser::seenval(char)
        32   -> GCodeParser::value_int()
        32   -> IsRunning()
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fdiv
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
         0   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
         0   -> serialprintPGM(char const *)
        32   -> set_destination_from_current()
        32   -> unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        32   -> unified_bed_leveling::mesh_index_to_ypos(uint8_t)
      24   gcode_G92()
        24   -> GCodeParser::seen(char)
        24   -> GCodeParser::seenval(char)
        24   -> GCodeParser::value_axis_units(AxisEnum)
        24   -> SYNC_PLAN_POSITION_KINEMATIC()
        24   -> Stepper::synchronize()
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
         0   -> report_current_position()
        24   -> sync_plan_position_e()
        24   -> update_software_endstops(AxisEnum)
      16   gcode_M104()
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_celsius()
         0   -> Planner::autotemp_M104_M109()
        16   -> Stopwatch::stop()
        16   -> Temperature::degHotend(uint8_t)
        16   -> Temperature::setTargetHotend(float, uint8_t)
        16   -> __aeabi_cfcmple
        16   -> __aeabi_cfrcmple
        16   -> __aeabi_f2iz
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
        16   -> get_target_extruder_from_command(uint16_t)
        16   -> lcd_setstatusPGM(char const *, int8_t)
       8   gcode_M105()
         8   -> Temperature::print_heaterstates()
         0   -> USARTClass::write(uint8_t)
         8   -> get_target_extruder_from_command(uint16_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M106()
         8   -> GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::ushortval(char, uint16_t)
       8   gcode_M107()
         8   -> GCodeParser::ushortval(char, uint16_t)
       0   gcode_M108()
      48   gcode_M109()
        48   -> GCodeParser::seenval(char)
        48   -> GCodeParser::value_celsius()
        48   -> HAL_GetTick
        48   -> Planner::autotemp_M104_M109()
        48   -> Print::print(long, int)
        48   -> Stopwatch::start()
        48   -> Stopwatch::stop()
        48   -> Temperature::degHotend(uint8_t)
        48   -> Temperature::degTargetHotend(uint8_t)
        48   -> Temperature::isCoolingHotend(uint8_t)
        48   -> Temperature::print_heaterstates()
        48   -> Temperature::setTargetHotend(float, uint8_t)
        48   -> Temperature::start_watching_heater(uint8_t)
        48   -> USARTClass::write(uint8_t)
        48   -> __aeabi_cfcmpeq
        48   -> __aeabi_cfcmple
        48   -> __aeabi_cfrcmple
        48   -> __aeabi_f2iz
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> get_target_extruder_from_command(uint16_t)
        48   -> idle()
         0   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> refresh_cmd_timeout()
        48   -> serialprintPGM(char const *)
       8   gcode_M110()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_long()
      16   gcode_M111()
        16   -> GCodeParser::byteval(char, uint8_t)
        16   -> GCodeParser::seen(char)
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       0   gcode_M112()
         0   -> kill(char const *)
       8   gcode_M113()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_byte()
         0   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, unsigned long)
         8   -> serialprintPGM(char const *)
       8   gcode_M114()
         8   -> Stepper::synchronize()
         0   -> report_current_position()
       8   gcode_M115()
         0   -> cap_line(char const *, bool)
         8   -> cap_line(char const *, bool)
         8   -> serialprintPGM(char const *)
       0   gcode_M117()
         0   -> lcd_setstatus(char const *, bool)
       8   gcode_M118()
         8   -> GCodeParser::boolval(char)
         8   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
         8   -> serialprintPGM(char const *)
       0   gcode_M119()
         0   -> Endstops::M119()
       0   gcode_M120()
         0   -> Endstops::enable_globally(bool)
       0   gcode_M121()
         0   -> Endstops::enable_globally(bool)
       8   gcode_M140()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_celsius()
         0   -> Temperature::setTargetBed(float)
       8   gcode_M155()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_byte()
         0   -> Temperature::set_auto_report_interval(uint8_t)
       8   gcode_M17()
         0   -> enable_all_steppers()
         8   -> lcd_setstatusPGM(char const *, int8_t)
      16   gcode_M18_M84()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_millis_from_seconds()
        16   -> HAL_GPIO_WritePin
         0   -> Stepper::finish_and_disable()
        16   -> Stepper::synchronize()
         0   -> disable_e_steppers()
      48   gcode_M190()
        48   -> GCodeParser::seenval(char)
        48   -> GCodeParser::value_celsius()
        48   -> HAL_GetTick
        48   -> Print::print(long, int)
        48   -> Stopwatch::start()
        48   -> Temperature::degBed()
        48   -> Temperature::degTargetBed()
        48   -> Temperature::isCoolingBed()
        48   -> Temperature::print_heaterstates()
        48   -> Temperature::setTargetBed(float)
        48   -> USARTClass::write(uint8_t)
        48   -> __aeabi_cfcmpeq
        48   -> __aeabi_cfcmple
        48   -> __aeabi_cfrcmple
        48   -> __aeabi_fsub
        48   -> idle()
         0   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> refresh_cmd_timeout()
        48   -> serialprintPGM(char const *)
       8   gcode_M20()
         8   -> CardReader::ls()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
      16   gcode_M200()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_linear_units()
        16   -> Planner::calculate_volumetric_multipliers()
        16   -> Planner::set_filament_size(uint8_t, float const &)
        16   -> __aeabi_cfcmpeq
        16   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M201()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
         0   -> Planner::reset_acceleration_rates()
        16   -> __aeabi_f2uiz
        16   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M203()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
        16   -> get_target_extruder_from_command(uint16_t)
       8   gcode_M204()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> USARTClass::write(uint8_t)
         8   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, float)
       8   gcode_M205()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         8   -> GCodeParser::value_ulong()
      16   gcode_M206()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_float()
        16   -> GCodeParser::value_linear_units()
         0   -> report_current_position()
        16   -> set_home_offset(AxisEnum, float)
      24   gcode_M211()
        24   -> GCodeParser::seen(char)
        24   -> GCodeParser::value_bool()
         0   -> USARTClass::write(uint8_t)
        24   -> __aeabi_fadd
        24   -> serial_echopair_P(char const *, float)
        24   -> serialprintPGM(char const *)
      24   gcode_M218()
        24   -> GCodeParser::seenval(char)
        24   -> GCodeParser::value_linear_units()
        24   -> Print::print(double, int)
         0   -> USARTClass::write(uint8_t)
        24   -> USARTClass::write(uint8_t)
        24   -> __aeabi_f2d
        24   -> get_target_extruder_from_command(uint16_t)
        24   -> serialprintPGM(char const *)
       0   gcode_M22()
         0   -> CardReader::release()
       8   gcode_M220()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
       8   gcode_M221()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
         0   -> Planner::refresh_e_factor(uint8_t)
         8   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M226()
        16   -> GCodeParser::intval(char, int16_t)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_int()
        16   -> HAL_GPIO_ReadPin
        16   -> Stepper::synchronize()
        16   -> idle()
        16   -> pin_is_protected(int8_t)
       8   gcode_M23()
         8   -> CardReader::openFile(char *, bool, bool)
         0   -> strcpy
       8   gcode_M24()
         8   -> CardReader::startFileprint()
         0   -> Stopwatch::start()
         8   -> mks_resumePrint
       8   gcode_M25()
         8   -> CardReader::pauseSDPrint()
         8   -> Stopwatch::pause()
       8   gcode_M26()
         0   -> CardReader::setIndex(long)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_long()
       0   gcode_M27()
         0   -> CardReader::getStatus()
       0   gcode_M28()
         0   -> CardReader::openFile(char *, bool, bool)
       8   gcode_M280()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_int()
         8   -> serial_echopair_P(char const *, int)
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M29()
       8   gcode_M30()
         8   -> CardReader::closefile(bool)
         0   -> CardReader::removeFile(char *)
       8   gcode_M301()
         8   -> GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_float()
         8   -> Print::print(char const *)
         8   -> Temperature::updatePID()
         0   -> USARTClass::write(uint8_t)
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> serial_echopair_P(char const *, double)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      16   gcode_M302()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_bool()
        16   -> GCodeParser::value_celsius()
        16   -> __aeabi_f2iz
        16   -> serial_echopair_P(char const *, char const *)
        16   -> serial_echopair_P(char const *, int)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
      16   gcode_M303()
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::celsiusval(char, float)
        16   -> GCodeParser::intval(char, int16_t)
         0   -> Temperature::PID_autotune(float, int8_t, int8_t, bool)
        16   -> __aeabi_f2iz
        16   -> __aeabi_i2f
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       8   gcode_M304()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_float()
         0   -> USARTClass::write(uint8_t)
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> serial_echopair_P(char const *, double)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      40   gcode_M31()
        40   -> Stopwatch::duration()
        40   -> USARTClass::write(uint8_t)
        40   -> duration_t::duration_t(uint32_t const &)
        40   -> duration_t::toString(char *) const
        40   -> lcd_setstatus(char const *, bool)
        40   -> serial_echopair_P(char const *, char const *)
        40   -> serialprintPGM(char const *)
      16   gcode_M32()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::setIndex(long)
        16   -> CardReader::startFileprint()
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_long()
        16   -> Stepper::synchronize()
         0   -> Stopwatch::start()
       8   gcode_M355()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       8   gcode_M360()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M361()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M362()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M363()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M364()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       0   gcode_M400()
         0   -> Stepper::synchronize()
       0   gcode_M401()
         0   -> set_probe_deployed(bool)
       0   gcode_M402()
         0   -> set_probe_deployed(bool)
       0   gcode_M410()
         0   -> quickstop_stepper()
      16   gcode_M42()
        16   -> GCodeParser::intval(char, int16_t)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_byte()
        16   -> HAL_GPIO_WritePin
        16   -> pin_is_protected(int8_t)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
      40   gcode_M420()
        40   -> GCodeParser::has_value()
        40   -> GCodeParser::seen(char)
        40   -> GCodeParser::value_bool()
        40   -> GCodeParser::value_int()
        40   -> GCodeParser::value_linear_units()
        40   -> MarlinSettings::calc_num_meshes()
        40   -> MarlinSettings::load_mesh(int8_t, void *)
        40   -> Print::print(double, int)
        40   -> USARTClass::write(uint8_t)
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_f2d
        40   -> leveling_is_valid()
        40   -> matrix_3x3::debug(char const *)
        40   -> mbl_mesh_report()
        40   -> memcmp
        40   -> print_bilinear_leveling_grid()
        40   -> report_current_position()
        40   -> serial_echopair_P(char const *, bool)
        40   -> serial_echopair_P(char const *, char const *)
        40   -> serial_echopair_P(char const *, int)
        40   -> serialprintPGM(char const *)
        40   -> set_bed_leveling_enabled(bool)
        40   -> set_z_fade_height(float, bool)
        40   -> unified_bed_leveling::display_map(int)
        40   -> unified_bed_leveling::mesh_is_valid()
      32   gcode_M421_AUTO_BED_LEVELING_BILINEAR()
        32   -> GCodeParser::intval(char, int16_t)
        32   -> GCodeParser::seen(char)
        32   -> GCodeParser::value_linear_units()
        32   -> __aeabi_fadd
         0   -> serialprintPGM(char const *)
        32   -> serialprintPGM(char const *)
      48   gcode_M421_AUTO_BED_LEVELING_UBL()
        48   -> GCodeParser::intval(char, int16_t)
        48   -> GCodeParser::seen(char)
        48   -> GCodeParser::value_linear_units()
        48   -> __aeabi_fadd
         0   -> serialprintPGM(char const *)
        48   -> serialprintPGM(char const *)
        48   -> unified_bed_leveling::find_closest_mesh_point_of_type(MeshPointType, float const &, float const &, bool, unsigned int *)
      40   gcode_M421_MESH_BED_LEVELING()
        40   -> GCodeParser::seen(char)
        40   -> GCodeParser::value_int()
        40   -> GCodeParser::value_linear_units()
        40   -> __aeabi_fadd
        40   -> mesh_bed_leveling::probe_index_x(float const &)
        40   -> mesh_bed_leveling::probe_index_y(float const &)
        40   -> mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
        40   -> serialprintPGM(char const *)
      32   gcode_M428()
        32   -> __aeabi_cfcmple
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fsub
        32   -> axis_unhomed_error(bool, bool, bool)
        32   -> base_home_pos(AxisEnum)
        32   -> home_dir(AxisEnum)
        32   -> lcd_setalertstatusPGM(char const *)
        32   -> lcd_setstatusPGM(char const *, int8_t)
        32   -> report_current_position()
        32   -> serialprintPGM(char const *)
        32   -> set_home_offset(AxisEnum, float)
       8   gcode_M49()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M500()
         0   -> MarlinSettings::save()
       0   gcode_M501()
         0   -> MarlinSettings::load()
       0   gcode_M502()
         0   -> MarlinSettings::reset()
       8   gcode_M503()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_bool()
         0   -> MarlinSettings::report(bool)
       8   gcode_M665()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_float()
         8   -> GCodeParser::value_linear_units()
         0   -> recalc_delta_settings()
      16   gcode_M666()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_linear_units()
        16   -> __aeabi_cfcmple
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
       8   gcode_M666_dual()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
       0   gcode_M75()
         0   -> Stopwatch::start()
       0   gcode_M76()
         0   -> Stopwatch::pause()
       0   gcode_M77()
         0   -> Stopwatch::stop()
       8   gcode_M81()
         8   -> Stepper::finish_and_disable()
         8   -> Temperature::disable_all_heaters()
         0   -> safe_delay(millis_t)
       0   gcode_M82()
       0   gcode_M83()
       8   gcode_M85()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_millis_from_seconds()
       8   gcode_M851()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> USARTClass::write(uint8_t)
         8   -> __aeabi_cfcmple
         8   -> __aeabi_cfrcmple
         8   -> serial_echopair_P(char const *, float)
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M907()
      32   gcode_M92()
        32   -> GCodeParser::seen(char)
        32   -> GCodeParser::value_per_axis_unit(AxisEnum)
         0   -> Planner::refresh_positioning()
        32   -> __aeabi_cfcmple
        32   -> __aeabi_f2uiz
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_ui2f
        32   -> get_target_extruder_from_command(uint16_t)
       0   gcode_M928()
         0   -> CardReader::openLogFile(char *)
       8   gcode_M998()
         8   -> CardReader::stopSDPrint()
         8   -> Stopwatch::stop()
         8   -> Temperature::disable_all_heaters()
         8   -> clear_command_queue()
         8   -> epr_write_data
         8   -> quickstop_stepper()
       8   gcode_M999()
         0   -> FlushSerialRequestResend()
         8   -> GCodeParser::boolval(char)
         8   -> lcd_reset_alert_level()
      16   gcode_T(uint8_t)
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::linearval(char, float)
        16   -> __aeabi_fdiv
         0   -> tool_change(uint8_t, float, bool)
      16   gcode_get_destination()
        16   -> GCodeParser::linearval(char, float)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
        16   -> GCodeParser::value_feedrate()
        16   -> __aeabi_cfrcmple
        16   -> __aeabi_fadd
        16   -> __aeabi_fdiv
      16   gcode_line_error(char const *, bool)
        16   -> FlushSerialRequestResend()
        16   -> Print::print(long, int)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       8   get_available_commands()
         8   -> drain_injected_commands_P()
         0   -> get_sdcard_commands()
         8   -> get_serial_commands()
         8   -> get_wifi_commands()
      24   get_cartesian_from_steppers()
        24   -> Stepper::get_axis_position_degrees(AxisEnum)
        24   -> Stepper::get_axis_position_mm(AxisEnum)
        24   -> forward_kinematics_DELTA(float, float, float)
        24   -> forward_kinematics_SCARA(float const &, float const &)
      32   get_homing_bump_feedrate(AxisEnum)
        32   -> __aeabi_fdiv
        32   -> __aeabi_ui2f
        32   -> serialprintPGM(char const *)
      32   get_sdcard_commands()
        32   -> CardReader::checkautostart(bool)
        32   -> CardReader::eof()
        32   -> CardReader::get()
        32   -> CardReader::getsdpos()
        32   -> CardReader::initsd()
        32   -> CardReader::printingHasFinished()
        32   -> CardReader::reopenfile(char *)
        32   -> CardReader::setIndex(long)
        32   -> GUI_Exec
        32   -> GUI_RefreshPage
        32   -> GUI_TOUCH_Exec
        32   -> SD_Init
        32   -> Temperature::manage_heater()
        32   -> _commit_command(bool)
        32   -> disp_pre_gcode
        32   -> display_temper_error()
        32   -> memset
        32   -> serialprintPGM(char const *)
      32   get_serial_commands()
        32   -> HAL_GetTick
        32   -> IsStopped()
        32   -> USARTClass::available()
        32   -> USARTClass::read()
        32   -> _enqueuecommand(char const *, bool)
         0   -> gcode_line_error(char const *, bool)
        32   -> kill(char const *)
        32   -> lcd_setstatusPGM(char const *, int8_t)
        32   -> quickstop_stepper()
        32   -> serialprintPGM(char const *)
        32   -> strchr(char *, int)
        32   -> strcmp
        32   -> strrchr(char *, int)
        32   -> strstr(char *, char const *)
        32   -> strtol
      16   get_target_extruder_from_command(uint16_t)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_byte()
        16   -> Print::print(int, int)
        16   -> USARTClass::write(uint8_t)
        16   -> serial_echopair_P(char const *, int)
        16   -> serialprintPGM(char const *)
      24   get_wifi_commands()
        24   -> IsStopped()
        24   -> _enqueuecommand(char const *, bool)
        24   -> kill(char const *)
        24   -> lcd_setstatusPGM(char const *, int8_t)
        24   -> quickstop_stepper()
        24   -> serialprintPGM(char const *)
        24   -> strchr(char *, int)
        24   -> strcmp
        24   -> strtol
       8   handle_filament_runout()
         0   -> Stepper::synchronize()
         8   -> enqueue_and_echo_commands_P(char const *)
       0   home_all_axes()
         0   -> gcode_G28(bool)
       0   home_bump_mm(AxisEnum)
       8   home_delta()
         8   -> Endstops::hit_on_purpose()
         8   -> SYNC_PLAN_POSITION_KINEMATIC()
         8   -> Stepper::synchronize()
         8   -> __aeabi_fadd
         8   -> buffer_line_to_current_position()
         8   -> homeaxis(AxisEnum)
         8   -> lcd_setstatusPGM(char const *, int8_t)
         8   -> memset
         8   -> serialprintPGM(char const *)
         8   -> set_axis_is_at_home(AxisEnum)
         8   -> sync_plan_position()
       0   home_dir(AxisEnum)
      40   homeaxis(AxisEnum)
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> Stepper::set_homing_flag_z(bool)
        40   -> Stepper::set_z2_lock(bool)
        40   -> Stepper::set_z_lock(bool)
        40   -> __aeabi_cfcmpeq
        40   -> __aeabi_cfcmple
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_dsub
        40   -> __aeabi_f2d
        40   -> __aeabi_fmul
        40   -> __aeabi_i2d
        40   -> __aeabi_i2f
        40   -> do_homing_move(AxisEnum, float, float)
        40   -> get_homing_bump_feedrate(AxisEnum)
        40   -> home_bump_mm(AxisEnum)
        40   -> home_dir(AxisEnum)
        40   -> max_length(AxisEnum)
        40   -> set_axis_is_at_home(AxisEnum)
         0   -> set_probe_deployed(bool)
        40   -> set_probe_deployed(bool)
        40   -> sync_plan_position()
      16   host_keepalive()
        16   -> HAL_GetTick
        16   -> serialprintPGM(char const *)
       8   idle()
         0   -> GUI_Exec
         8   -> GUI_RefreshPage
         8   -> GUI_TOUCH_Exec
         8   -> Temperature::auto_report_temperatures()
         8   -> Temperature::manage_heater()
         8   -> disp_pre_gcode
         8   -> display_temper_error()
         8   -> host_keepalive()
         8   -> lcd_reInit()
         8   -> lcd_update()
         8   -> manage_inactivity(bool)
         8   -> wifi_looping()
      40   incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
       0   incremental_LSF_reset(linear_fit_data *)
         0   -> memset
      16   invalid_extruder_error(uint8_t)
        16   -> Print::print(char const *)
        16   -> Print::print(unsigned char, int)
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
      40   inverse_kinematics(float const *)
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> sqrtf
      40   inverse_kinematics_MORGAN_SCARA(float const *)
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> atan2f
        40   -> sqrtf
       8   kill(char const *)
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
         8   -> suicide()
       8   kill_c
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
         8   -> suicide()
       0   lcd_hasstatus()
       0   lcd_init()
       8   lcd_reInit()
         8   -> GUI_Init
         8   -> GUI_UC_SetEncodeUTF8
         8   -> clear_cur_ui
         8   -> draw_return_ui
         8   -> gui_view_init
       0   lcd_refresh()
       0   lcd_reset_alert_level()
       0   lcd_setalertstatusPGM(char const *)
       0   lcd_setstatus(char const *, bool)
       0   lcd_setstatusPGM(char const *, int8_t)
       0   lcd_update()
       0   leveling_is_valid()
      24   loop
        24   -> CardReader::checkFilesys(unsigned char)
        24   -> CardReader::closefile(bool)
        24   -> CardReader::write_command(char *)
        24   -> Endstops::report_state()
        24   -> PowerOff_Filament_Check()
        24   -> USARTClass::MoremenuCmd()
        24   -> display_temper_error()
        24   -> get_available_commands()
        24   -> idle()
         0   -> mks_PrintStatePolling
        24   -> ok_to_send()
        24   -> process_next_command()
        24   -> serialprintPGM(char const *)
        24   -> strstr(char *, char const *)
      24   manage_inactivity(bool)
        24   -> HAL_GPIO_ReadPin
        24   -> HAL_GPIO_WritePin
        24   -> HAL_GetTick
        24   -> Planner::blocks_queued()
         0   -> Planner::check_axes_activity()
        24   -> Stopwatch::isRunning()
        24   -> USARTClass::write(uint8_t)
        24   -> disable_e_steppers()
        24   -> get_available_commands()
        24   -> handle_filament_runout()
        24   -> kill(char const *)
        24   -> serial_echopair_P(char const *, char const *)
        24   -> serialprintPGM(char const *)
       0   max_length(AxisEnum)
      24   mbl_mesh_report()
        24   -> Print::print(double, int)
        24   -> Print::print(int, int)
        24   -> USARTClass::write(uint8_t)
        24   -> __aeabi_f2d
         0   -> print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
        24   -> serialprintPGM(char const *)
      40   mesh_bed_leveling::cell_index_x(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   mesh_bed_leveling::cell_index_y(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      48   mesh_bed_leveling::probe_index_x(float const &)
        48   -> __aeabi_cfcmple
        48   -> __aeabi_d2iz
        48   -> __aeabi_dadd
        48   -> __aeabi_ddiv
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> __aeabi_ui2f
      48   mesh_bed_leveling::probe_index_y(float const &)
        48   -> __aeabi_cfcmple
        48   -> __aeabi_d2iz
        48   -> __aeabi_dadd
        48   -> __aeabi_ddiv
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> __aeabi_ui2f
       0   mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
      16   mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
        16   -> mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
        16   -> mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
       8   mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
      56   mesh_line_to_destination(float, uint8_t, uint8_t)
        56   -> __aeabi_fadd
        56   -> __aeabi_fdiv
        56   -> __aeabi_fmul
        56   -> __aeabi_fsub
        56   -> buffer_line_to_destination(float)
        56   -> memcpy
        56   -> mesh_bed_leveling::cell_index_x(float const &)
        56   -> mesh_bed_leveling::cell_index_y(float const &)
        56   -> mesh_line_to_destination(float, uint8_t, uint8_t)
        56   -> set_current_from_destination()
      16   mks_G28(char *)
        16   -> GCodeParser::parse(char *)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_linear_units()
        16   -> gcode_G28(bool)
        16   -> memset
        16   -> set_bed_leveling_enabled(bool)
         0   -> set_z_fade_height(float, bool)
        16   -> strcpy
      24   mks_PrintStatePolling
        24   -> CardReader::getsdpos()
        24   -> CardReader::startFileprint()
         0   -> Close_machine_display()
        24   -> Planner::blocks_queued()
        24   -> Stepper::synchronize()
        24   -> Stopwatch::start()
        24   -> Stopwatch::stop()
        24   -> Temperature::disable_all_heaters()
        24   -> __aeabi_cfrcmple
        24   -> __aeabi_fsub
        24   -> clear_command_queue()
        24   -> epr_write_data
        24   -> mks_G28(char *)
        24   -> mks_WriteToFile
        24   -> mks_clearFile
        24   -> mks_contiuePrintDelta
        24   -> mks_contiuePrintPause
        24   -> mks_contiuePrintPwdwn
        24   -> mks_moveXY
        24   -> mks_moveZ
        24   -> mks_pausePrint
        24   -> mks_preExtrude
        24   -> quickstop_stepper()
      16   mks_ReadFromEpr
        16   -> epr_read_data
      16   mks_ReadFromEpr_pwroff()
        16   -> epr_read_data
      48   mks_ReadFromFile
        48   -> __aeabi_memclr4
        48   -> f_close
        48   -> f_open
        48   -> mks_get_commands()
        48   -> strcat
      32   mks_ResetPositionZ(float)
        32   -> GCodeParser::parse(char *)
        32   -> __aeabi_f2d
        32   -> __aeabi_memcpy
        32   -> gcode_G92()
        32   -> memset
        32   -> sprintf
        32   -> strcat
      24   mks_WriteToEpr()
        24   -> CardReader::getsdpos()
         0   -> epr_write_data
        24   -> epr_write_data
      24   mks_WriteToEpr_pwroff()
        24   -> CardReader::getsdpos()
         0   -> epr_write_data
        24   -> epr_write_data
      80   mks_WriteToFile
        80   -> HAL_GetTick
        80   -> Stopwatch::getTime(millis_t *, millis_t *, millis_t *)
        80   -> __aeabi_f2d
        80   -> __aeabi_memclr4
        80   -> __aeabi_memcpy4
        80   -> f_close
        80   -> f_open
        80   -> f_printf
        80   -> memset
        80   -> sprintf
        80   -> strcat
      40   mks_clearDir
        40   -> strcpy
        40   -> strstr(char *, char const *)
      64   mks_clearFile
        64   -> __aeabi_memclr4
        64   -> __aeabi_memcpy4
        64   -> f_close
        64   -> f_open
        64   -> f_printf
        64   -> strcat
      16   mks_contiuePrintDelta
        16   -> gcode_M24()
        16   -> mks_G28(char *)
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
        16   -> mks_setFeedrate()
        16   -> mks_setTemperature()
       8   mks_contiuePrintPause
         0   -> gcode_M24()
         8   -> mks_G28(char *)
         8   -> mks_moveXY
         8   -> mks_moveZ
         8   -> mks_preExtrude
         8   -> mks_setFeedrate()
         8   -> mks_setPositionZ
         8   -> mks_setTemperature()
      16   mks_contiuePrintPwdwn
        16   -> HAL_Delay
        16   -> HAL_GPIO_WritePin
        16   -> __aeabi_fadd
        16   -> gcode_M24()
        16   -> mks_G28(char *)
        16   -> mks_ResetPositionZ(float)
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
        16   -> mks_setFeedrate()
        16   -> mks_setPositionZ
        16   -> mks_setTemperature()
      16   mks_contiuePrint_UI
        16   -> AT24CXX_Read
        16   -> Beeper(uint32_t)
        16   -> CardReader::isFileOpen()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::setIndex(long)
         0   -> draw_dialog
         0   -> draw_printing
        16   -> epr_write_data
        16   -> getTick
        16   -> getTickDiff
        16   -> lcd_setstatus(char const *, bool)
        16   -> mks_clearDir
        16   -> mks_getPositionXYZE
        16   -> strcpy
      56   mks_getPositionXYZE
        56   -> CardReader::getsdpos()
        56   -> CardReader::setIndex(long)
        56   -> GCodeParser::parse(char *)
        56   -> __aeabi_cfcmple
        56   -> __aeabi_cfrcmple
        56   -> __aeabi_d2f
        56   -> abs
        56   -> atof
        56   -> clear_command_queue()
        56   -> gcode_get_destination()
        56   -> get_sdcard_commands()
        56   -> memset
        56   -> strchr(char *, int)
      48   mks_get_commands()
        48   -> __aeabi_d2f
        48   -> __aeabi_d2iz
        48   -> atof
        48   -> atoi
        48   -> memset
        48   -> pft_get()
        48   -> strcmp
      48   mks_home_moveXY
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_f2iz
        48   -> __aeabi_memcpy
        48   -> gcode_G0_G1()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      32   mks_home_moveZ
        32   -> GCodeParser::parse(char *)
        32   -> Stepper::synchronize()
        32   -> __aeabi_f2d
        32   -> __aeabi_memcpy
        32   -> gcode_G0_G1()
        32   -> memset
        32   -> sprintf
        32   -> strcat
      16   mks_initPrint
        16   -> memset
      48   mks_leveling_moveXY(float, float)
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy
        48   -> gcode_G0_G1()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      48   mks_leveling_moveZ(float)
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> __aeabi_memcpy
        48   -> gcode_G0_G1()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      16   mks_manual_leveling
        16   -> __aeabi_i2f
         0   -> enqueue_and_echo_commands_P(char const *)
        16   -> mks_G28(char *)
        16   -> mks_leveling_moveXY(float, float)
        16   -> mks_leveling_moveZ(float)
      40   mks_moveXY
        40   -> GCodeParser::parse(char *)
        40   -> Stepper::synchronize()
        40   -> __aeabi_f2d
        40   -> __aeabi_memcpy
        40   -> gcode_G0_G1()
        40   -> memset
        40   -> sprintf
        40   -> strcat
      40   mks_moveZ
        40   -> GCodeParser::parse(char *)
        40   -> Stepper::synchronize()
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_memcpy
        40   -> gcode_G0_G1()
        40   -> memset
        40   -> sprintf
        40   -> strcat
      40   mks_moveZ_relative(float)
        40   -> GCodeParser::parse(char *)
        40   -> Stepper::synchronize()
        40   -> __aeabi_f2d
        40   -> __aeabi_memcpy
        40   -> gcode_G0_G1()
        40   -> memset
        40   -> sprintf
        40   -> strcat
      16   mks_pausePrint
        16   -> Stepper::synchronize()
         0   -> mks_WriteToEpr()
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
      48   mks_preExtrude
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy
        48   -> gcode_G0_G1()
        48   -> gcode_G92()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      16   mks_rePrintCheck
         0   -> draw_ready_print
        16   -> epr_read_data
        16   -> epr_write_data
        16   -> getTick
        16   -> getTickDiff
        16   -> mks_ReadFromEpr
        16   -> mks_ReadFromEpr_pwroff()
        16   -> mks_ReadFromFile
        16   -> mks_contiuePrint_UI
       8   mks_resumePrint
         8   -> lcd_setstatus(char const *, bool)
         8   -> mks_moveXY
         8   -> mks_moveZ
         8   -> mks_preExtrude
      16   mks_saveFileName
        16   -> epr_write_data
        16   -> memset
         0   -> mks_clearFile
        16   -> strcpy
       0   mks_setFeedrate()
      32   mks_setPositionZ
        32   -> GCodeParser::parse(char *)
        32   -> __aeabi_f2d
        32   -> __aeabi_memcpy
        32   -> gcode_G92()
        32   -> memset
        32   -> sprintf
        32   -> strcat
      56   mks_setTemperature()
        56   -> GCodeParser::parse(char *)
        56   -> __aeabi_memcpy
        56   -> gcode_M104()
        56   -> gcode_M109()
        56   -> gcode_M140()
        56   -> gcode_M190()
        56   -> memset
        56   -> sprintf
        56   -> strcat
      40   mkstft_ui_init
        40   -> __aeabi_memcpy
        40   -> __aeabi_memcpy4
        40   -> memset
        40   -> mkstft_ui_set_epr()
       8   mkstft_ui_load
         0   -> epr_read_data
         8   -> epr_read_data
      24   mkstft_ui_set_epr()
        24   -> epr_read_data
        24   -> epr_write_data
       8   ok_to_send()
         0   -> USARTClass::write(uint8_t)
         8   -> refresh_cmd_timeout()
         8   -> serialprintPGM(char const *)
       8   out_of_range_error(char const *)
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
      16   pft_get()
        16   -> f_read
       0   pin_is_protected(int8_t)
      96   plan_arc(float const (&)[4], float const (&)[2], bool)
        96   -> HAL_GetTick
        96   -> Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        96   -> Temperature::manage_heater()
        96   -> __aeabi_cfcmpeq
        96   -> __aeabi_cfcmple
        96   -> __aeabi_d2f
        96   -> __aeabi_dadd
        96   -> __aeabi_dmul
        96   -> __aeabi_dsub
        96   -> __aeabi_f2d
        96   -> __aeabi_f2iz
        96   -> __aeabi_fadd
        96   -> __aeabi_fdiv
        96   -> __aeabi_fmul
        96   -> __aeabi_fsub
        96   -> __aeabi_i2f
        96   -> __aeabi_ui2f
        96   -> atan2f
        96   -> clamp_to_software_endstops(float *)
        96   -> cosf
        96   -> floorf
        96   -> idle()
        96   -> set_current_from_destination()
        96   -> sinf
        96   -> sqrtf
      40   position_is_reachable_IS_CARTESIAN(float const &, float const &)
        40   -> __aeabi_cdrcmple
        40   -> __aeabi_dadd
        40   -> __aeabi_f2d
      32   position_is_reachable_IS_KINEMATIC(float const &, float const &)
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
      40   position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
        40   -> __aeabi_cdrcmple
        40   -> __aeabi_dadd
        40   -> __aeabi_f2d
      24   position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
        24   -> __aeabi_fsub
        24   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
      88   prepare_kinematic_move_to(float const (&)[4])
        88   -> ADJUST_DELTA(float const *)
        88   -> HAL_GetTick
        88   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        88   -> Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        88   -> Temperature::manage_heater()
        88   -> __aeabi_cfcmpeq
        88   -> __aeabi_cfcmple
        88   -> __aeabi_d2f
        88   -> __aeabi_dmul
        88   -> __aeabi_f2d
        88   -> __aeabi_f2iz
        88   -> __aeabi_fadd
        88   -> __aeabi_fdiv
        88   -> __aeabi_fmul
        88   -> __aeabi_fsub
        88   -> __aeabi_i2f
        88   -> __aeabi_ui2f
        88   -> idle()
        88   -> inverse_kinematics(float const *)
        88   -> lroundf
        88   -> memcpy
        88   -> position_is_reachable_IS_CARTESIAN(float const &, float const &)
        88   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
        88   -> sqrtf
      16   prepare_move_to_destination()
        16   -> Temperature::tooColdToExtrude(uint8_t)
        16   -> __aeabi_cfcmpeq
        16   -> __aeabi_cfrcmple
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_fmul
        16   -> __aeabi_fsub
        16   -> __aeabi_i2f
        16   -> clamp_to_software_endstops(float *)
        16   -> prepare_kinematic_move_to(float const (&)[4])
        16   -> prepare_move_to_destination_cartesian()
        16   -> refresh_cmd_timeout()
        16   -> serialprintPGM(char const *)
        16   -> set_current_from_destination()
        16   -> unified_bed_leveling::prepare_segmented_line_to(float const (&)[4], float const &)
      24   prepare_move_to_destination_cartesian()
        24   -> Planner::leveling_active_at_z(float const &)
        24   -> __aeabi_cfcmpeq
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_fmul
        24   -> __aeabi_i2f
        24   -> bilinear_line_to_destination(float, uint16_t, uint16_t)
        24   -> buffer_line_to_destination(float)
        24   -> mesh_line_to_destination(float, uint8_t, uint8_t)
        24   -> unified_bed_leveling::line_to_destination_cartesian(float const &, uint8_t)
      16   prepare_uninterpolated_move_to_destination(float)
        16   -> Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        16   -> __aeabi_cfcmpeq
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
        16   -> refresh_cmd_timeout()
        16   -> set_current_from_destination()
      40   print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
        40   -> Print::print(double, int)
        40   -> Print::print(int, int)
         0   -> USARTClass::write(uint8_t)
        40   -> USARTClass::write(uint8_t)
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_f2d
        40   -> __iar_FDtest
       8   print_bilinear_leveling_grid()
         0   -> print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
      64   probe_pt(float const &, float const &, bool, uint8_t, bool)
        64   -> Print::print(double, int)
        64   -> USARTClass::write(uint8_t)
        64   -> __aeabi_cfcmple
        64   -> __aeabi_f2d
        64   -> __aeabi_fadd
        64   -> __aeabi_fdiv
        64   -> __aeabi_fsub
        64   -> __iar_FDtest
        64   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
        64   -> do_blocking_move_to_z(float const &, float const &)
        64   -> lcd_setstatusPGM(char const *, int8_t)
        64   -> position_is_reachable_IS_CARTESIAN(float const &, float const &)
        64   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
        64   -> position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
        64   -> position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
        64   -> run_z_probe()
        64   -> serialprintPGM(char const *)
        64   -> set_probe_deployed(bool)
      16   process_next_command()
        16   -> GCodeParser::parse(char *)
        16   -> Print::print(char const *)
        16   -> USARTClass::write(uint8_t)
         0   -> process_parsed_command()
        16   -> serialprintPGM(char const *)
      16   process_parsed_command()
        16   -> CardReader::pauseSDPrint()
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::unknown_command_error()
        16   -> GCodeParser::value_linear_units()
        16   -> MarlinSettings::save()
        16   -> Print::print(char const *)
        16   -> Stopwatch::pause()
        16   -> USARTClass::write(uint8_t)
        16   -> clear_cur_ui
        16   -> draw_printing
        16   -> gcode_G0_G1()
        16   -> gcode_G0_G1_SCARA(bool)
        16   -> gcode_G26()
        16   -> gcode_G28(bool)
        16   -> gcode_G29()
        16   -> gcode_G29_MESH_BED_LEVELING()
        16   -> gcode_G29_UBL()
        16   -> gcode_G2_G3(bool)
        16   -> gcode_G30()
        16   -> gcode_G4()
        16   -> gcode_G42()
        16   -> gcode_G92()
        16   -> gcode_M104()
        16   -> gcode_M105()
        16   -> gcode_M106()
        16   -> gcode_M107()
        16   -> gcode_M108()
        16   -> gcode_M109()
        16   -> gcode_M110()
        16   -> gcode_M111()
        16   -> gcode_M112()
        16   -> gcode_M113()
        16   -> gcode_M114()
        16   -> gcode_M115()
        16   -> gcode_M117()
        16   -> gcode_M118()
        16   -> gcode_M119()
        16   -> gcode_M120()
        16   -> gcode_M121()
        16   -> gcode_M140()
        16   -> gcode_M155()
        16   -> gcode_M17()
        16   -> gcode_M18_M84()
        16   -> gcode_M190()
        16   -> gcode_M20()
        16   -> gcode_M200()
        16   -> gcode_M201()
        16   -> gcode_M203()
        16   -> gcode_M204()
        16   -> gcode_M205()
        16   -> gcode_M206()
        16   -> gcode_M211()
        16   -> gcode_M218()
        16   -> gcode_M22()
        16   -> gcode_M220()
        16   -> gcode_M221()
        16   -> gcode_M226()
        16   -> gcode_M23()
        16   -> gcode_M24()
        16   -> gcode_M25()
        16   -> gcode_M26()
        16   -> gcode_M27()
        16   -> gcode_M28()
        16   -> gcode_M280()
        16   -> gcode_M29()
        16   -> gcode_M30()
        16   -> gcode_M301()
        16   -> gcode_M302()
        16   -> gcode_M303()
        16   -> gcode_M304()
        16   -> gcode_M31()
        16   -> gcode_M32()
        16   -> gcode_M355()
        16   -> gcode_M360()
        16   -> gcode_M361()
        16   -> gcode_M362()
        16   -> gcode_M363()
        16   -> gcode_M364()
        16   -> gcode_M400()
        16   -> gcode_M401()
        16   -> gcode_M402()
        16   -> gcode_M410()
        16   -> gcode_M42()
        16   -> gcode_M420()
        16   -> gcode_M421_AUTO_BED_LEVELING_BILINEAR()
        16   -> gcode_M421_AUTO_BED_LEVELING_UBL()
        16   -> gcode_M421_MESH_BED_LEVELING()
        16   -> gcode_M428()
        16   -> gcode_M49()
        16   -> gcode_M500()
        16   -> gcode_M501()
        16   -> gcode_M502()
        16   -> gcode_M503()
        16   -> gcode_M665()
        16   -> gcode_M666()
        16   -> gcode_M666_dual()
        16   -> gcode_M75()
        16   -> gcode_M76()
        16   -> gcode_M77()
        16   -> gcode_M81()
        16   -> gcode_M82()
        16   -> gcode_M83()
        16   -> gcode_M85()
        16   -> gcode_M851()
        16   -> gcode_M907()
        16   -> gcode_M92()
        16   -> gcode_M928()
        16   -> gcode_M998()
        16   -> gcode_M999()
        16   -> gcode_T(uint8_t)
         0   -> ok_to_send()
        16   -> preview_gcode_prehandle
        16   -> reset_file_info
        16   -> reset_print_time
        16   -> serialprintPGM(char const *)
        16   -> set_bed_leveling_enabled(bool)
        16   -> set_z_fade_height(float, bool)
        16   -> start_print_time
        16   -> stop_print_time
      48   quick_home_xy()
        48   -> Endstops::hit_on_purpose()
        48   -> __aeabi_cfcmple
        48   -> __aeabi_d2f
        48   -> __aeabi_dadd
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_i2d
        48   -> do_blocking_move_to_xy(float const &, float const &, float const &)
        48   -> home_dir(AxisEnum)
        48   -> max_length(AxisEnum)
        48   -> sqrt
        48   -> sync_plan_position()
       8   quickstop_stepper()
         0   -> SYNC_PLAN_POSITION_KINEMATIC()
         8   -> Stepper::quick_stop()
         8   -> Stepper::synchronize()
         8   -> set_current_from_steppers_for_axis(AxisEnum)
      32   recalc_delta_settings()
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> cos
        32   -> sin
        32   -> update_software_endstops(AxisEnum)
       8   refresh_bed_level()
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_i2d
       8   refresh_cmd_timeout()
         8   -> HAL_GetTick
      16   report_current_position()
        16   -> Print::print(double, int)
        16   -> Stepper::get_axis_position_degrees(AxisEnum)
        16   -> Stepper::report_positions()
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> __aeabi_f2d
        16   -> serial_echopair_P(char const *, float)
        16   -> serialprintPGM(char const *)
       8   reset_bed_level()
         8   -> leveling_is_valid()
         0   -> matrix_3x3::set_to_identity()
         8   -> mesh_bed_leveling::reset()
         8   -> set_bed_leveling_enabled(bool)
         0   -> unified_bed_leveling::reset()
      24   run_z_probe()
        24   -> __aeabi_cfcmple
        24   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_fsub
        24   -> do_blocking_move_to_z(float const &, float const &)
        24   -> do_probe_move(float, float)
        24   -> refresh_cmd_timeout()
       0   serial_echopair_P(char const *, bool)
         0   -> serial_echopair_P(char const *, int)
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
       0   servo_init()
      48   set_axis_is_at_home(AxisEnum)
        48   -> __aeabi_fsub
        48   -> base_home_pos(AxisEnum)
        48   -> base_max_pos(AxisEnum)
        48   -> base_min_pos(AxisEnum)
        48   -> forward_kinematics_SCARA(float const &, float const &)
        48   -> inverse_kinematics_MORGAN_SCARA(float const *)
        48   -> serialprintPGM(char const *)
        48   -> update_software_endstops(AxisEnum)
      40   set_bed_leveling_enabled(bool)
        40   -> Planner::apply_leveling(float &, float &, float &)
        40   -> Planner::unapply_leveling(float *)
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> bilinear_z_offset(float const *)
        40   -> leveling_is_valid()
        40   -> set_current_from_steppers_for_axis(AxisEnum)
      24   set_bltouch_deployed(bool)
        24   -> HAL_GPIO_ReadPin
        24   -> bltouch_command(int)
        24   -> safe_delay(millis_t)
        24   -> serialprintPGM(char const *)
        24   -> stop()
       0   set_current_from_destination()
         0   -> memcpy
      16   set_current_from_steppers_for_axis(AxisEnum)
        16   -> Planner::unapply_leveling(float *)
        16   -> get_cartesian_from_steppers()
         0   -> memcpy
       0   set_destination_from_current()
         0   -> memcpy
       0   set_home_offset(AxisEnum, float)
         0   -> update_software_endstops(AxisEnum)
      24   set_probe_deployed(bool)
        24   -> Endstops::enable_z_probe(bool)
        24   -> __aeabi_cfcmple
        24   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
        24   -> do_probe_raise(float)
      32   set_z_fade_height(float, bool)
        32   -> Planner::set_z_fade_height(float const &)
        32   -> SYNC_PLAN_POSITION_KINEMATIC()
        32   -> __aeabi_cfcmpeq
        32   -> memcmp
        32   -> report_current_position()
        32   -> set_bed_leveling_enabled(bool)
        32   -> set_current_from_steppers_for_axis(AxisEnum)
      16   setup
        16   -> Endstops::enable_z_probe(bool)
        16   -> MarlinSettings::load()
        16   -> SYNC_PLAN_POSITION_KINEMATIC()
        16   -> Stepper::init()
        16   -> Temperature::init()
        16   -> USARTClass::write(uint8_t)
        16   -> bltouch_command(int)
        16   -> freeMemory()
        16   -> lcd_init()
        16   -> memcpy
        16   -> memset
        16   -> serial_echopair_P(char const *, int)
        16   -> serialprintPGM(char const *)
        16   -> servo_init()
        16   -> set_bltouch_deployed(bool)
        16   -> setup_filrunoutpin()
        16   -> setup_killpin()
        16   -> soft_endstop_min_init()
       0   setup_filrunoutpin()
       0   setup_for_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   setup_killpin()
       0   setup_powerhold()
      24   soft_endstop_min_init()
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
       8   stop()
         8   -> IsRunning()
         8   -> Temperature::disable_all_heaters()
         8   -> lcd_setstatusPGM(char const *, int8_t)
         8   -> safe_delay(millis_t)
         8   -> serialprintPGM(char const *)
       0   strchr(char *, int)
         0   -> __iar_Strchr
       0   strrchr(char *, int)
         0   -> __iar_Strrchr
       0   strstr(char *, char const *)
         0   -> __iar_Strstr
       0   suicide()
       0   sync_plan_position()
         0   -> Planner::set_position_mm(float, float, float, float const &)
       0   sync_plan_position_e()
         0   -> Planner::set_e_position_mm(float const &)
       0   sync_plan_position_kinematic()
         0   -> Planner::set_position_mm_kinematic(float const (&)[4])
       8   temper_error_kill()
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
     148   tool_change(uint8_t, float, bool)
       136   -> IsRunning()
       136   -> Planner::apply_leveling(float &, float &, float &)
       136   -> SYNC_PLAN_POSITION_KINEMATIC()
       136   -> Stepper::synchronize()
       136   -> USARTClass::write(uint8_t)
       136   -> __aeabi_cfrcmple
       136   -> __aeabi_fadd
       136   -> __aeabi_fsub
       148   -> __aeabi_memcpy4
       136   -> axis_unhomed_error(bool, bool, bool)
       136   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       136   -> invalid_extruder_error(uint8_t)
       136   -> matrix_3x3::transpose(matrix_3x3)
       136   -> serial_echopair_P(char const *, int)
       136   -> serialprintPGM(char const *)
       136   -> set_destination_from_current()
       136   -> vector_3::apply_rotation(matrix_3x3)
       136   -> vector_3::operator-(vector_3)
       136   -> vector_3::vector_3(float, float, float)
      40   unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   unified_bed_leveling::mesh_index_to_ypos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      16   unified_bed_leveling::mesh_is_valid()
        16   -> __aeabi_cfcmpeq
        16   -> __iar_FDtest
      32   update_software_endstops(AxisEnum)
        32   -> __aeabi_cfcmple
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> base_max_pos(AxisEnum)
        32   -> base_min_pos(AxisEnum)
        32   -> delta_safe_distance_from_top()


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "   Psi+Theta:">
      24  ?<Constant "  PlannerBufferBytes: ">
       4  ?<Constant " E:">
      16  ?<Constant " Free Memory: ">
      20  ?<Constant " Invalid extruder ">
      16  ?<Constant " Last Updated: ">
       4  ?<Constant " Y">
       8  ?<Constant " Y: ">
       4  ?<Constant " Y:">
       8  ?<Constant " Z: ">
       4  ?<Constant " Z:">
      28  ?<Constant " cold extrusion preve...">
       8  ?<Constant " first\n">
      16  ?<Constant " not entered.\n">
      28  ?<Constant " position out of range.\n">
      32  ?<Constant " too long extrusion p...">
      36  ?<Constant " | Author: (none, def...">
      12  ?<Constant "%.3f F%.3f">
      12  ?<Constant "%.3f F%d">
       8  ?<Constant "%.3f">
       4  ?<Constant "%d">
       4  ?<Constant "%f">
      52  ?<Constant "*** Z HOMED TO ENDSTO...">
       2  ?<Constant "/">
       8  ?<Constant "0.000">
       8  ?<Constant "1.0.0\n">
      12  ?<Constant "192.168.3.1">
      16  ?<Constant "192.168.3.100">
      16  ?<Constant "192.168.3.255">
      20  ?<Constant "2017-12-25 12:00">
      16  ?<Constant "255.255.255.0">
       2  ?<Constant ":">
       8  ?<Constant "?Probe ">
      20  ?<Constant "Active Extruder: ">
       8  ?<Constant "Bed X: ">
      28  ?<Constant "Bilinear Leveling Grid:\n">
       8  ?<Constant "Cap:">
      24  ?<Constant "Compiled: Feb 25 2020\n">
      20  ?<Constant "Done saving file.\n">
       8  ?<Constant "Err%d">
       8  ?<Constant "G1 E">
       8  ?<Constant "G1 X">
       8  ?<Constant "G1 Z">
       8  ?<Constant "G1 Z0">
      12  ?<Constant "G28 X0 Y0">
       4  ?<Constant "G28">
       8  ?<Constant "G92 E">
       8  ?<Constant "G92 Z">
      20  ?<Constant "HAS_NO_TEMP_BED!\n">
       8  ?<Constant "Home ">
      60  ?<Constant "KILL caused by too mu...">
      12  ?<Constant "KILLED. ">
      12  ?<Constant "M104 T1 S">
      12  ?<Constant "M109 T0 S">
      12  ?<Constant "M109 T1 S">
       8  ?<Constant "M140 S">
       8  ?<Constant "M190 S">
       4  ?<Constant "M29">
       8  ?<Constant "M600">
      16  ?<Constant "MKS Robin Nano">
      12  ?<Constant "Num X,Y: ">
      32  ?<Constant "Printer halted. kill(...">
     120  ?<Constant "Printer stopped due t...">
      16  ?<Constant "Probing failed">
      16  ?<Constant "Probing failed\n">
      12  ?<Constant "Resend: ">
      16  ?<Constant "Resume print?">
      16  ?<Constant "SCARA Theta:">
      60  ?<Constant "STOP called because o...">
      12  ?<Constant "STOPPED. ">
      12  ?<Constant "TP-LINK_MKS">
       2  ?<Constant "X">
       4  ?<Constant "X:">
       2  ?<Constant "Y">
      12  ?<Constant "Z offset: ">
       2  ?<Constant "Z">
       2  ?<Constant "\n">
      20  ?<Constant "\nMeasured points:\n">
      16  ?<Constant "baizhongyun.cn">
      32  ?<Constant "bed leveling hasn\'t d...">
      24  ?<Constant "busy: paused for input\n">
      24  ?<Constant "busy: paused for user\n">
      20  ?<Constant "busy: processing\n">
      20  ?<Constant "clear">
       4  ?<Constant "end">
      16  ?<Constant "enqueueing \"">
      12  ?<Constant "makerbase">
      12  ?<Constant "mks_pft.sys">
       4  ?<Constant "ok">
       8  ?<Constant "sd:%d">
       8  ?<Constant "start\n">
      32  ?<Constant {'\000'}>
      32  ?<Constant {'\000'}>_1
      32  ?<Constant {'\000'}>_2
      32  ?<Constant {'\000'}>_3
      32  ?<Constant {'\000'}>_4
      12  ?<Constant {(-9.9999990233E+3F), (-9.999999023
      12  ?<Constant {(0.0F), (0.0F), (0.0F)}>
       8  ?<Constant {(0.0F), (0.0F)}>
       4  ??DataTable136
       4  ??DataTable136_1
       4  ??DataTable136_2
       4  ??DataTable136_3
       4  ??DataTable136_4
       4  ??DataTable136_5
       4  ??DataTable136_6
       4  ??DataTable136_7
       4  ??DataTable136_8
       4  ??DataTable136_9
       4  ??DataTable137
       4  ??DataTable139
       4  ??DataTable139_1
       4  ??DataTable139_2
       4  ??DataTable139_3
       4  ??DataTable139_4
       4  ??DataTable139_5
       4  ??DataTable141
       4  ??DataTable141_1
       4  ??DataTable145
       4  ??DataTable146
       4  ??DataTable147
       4  ??DataTable147_1
       4  ??DataTable147_2
       4  ??DataTable147_3
       4  ??DataTable147_4
       4  ??DataTable148
       4  ??DataTable150
       4  ??DataTable151
       4  ??DataTable151_1
       4  ??DataTable151_2
       4  ??DataTable152
       4  ??DataTable153
       4  ??DataTable153_1
       4  ??DataTable154
       4  ??DataTable154_1
       4  ??DataTable156
       4  ??DataTable156_1
       4  ??DataTable156_2
       4  ??DataTable156_3
       4  ??DataTable156_4
       4  ??DataTable156_5
       4  ??DataTable156_6
       4  ??DataTable156_7
       4  ??DataTable157
       4  ??DataTable157_1
       4  ??DataTable157_2
       4  ??DataTable157_3
       4  ??DataTable157_4
       4  ??DataTable157_5
       4  ??DataTable157_6
       4  ??DataTable157_7
       4  ??DataTable157_8
       4  ??DataTable158
       4  ??DataTable158_1
       4  ??DataTable160
       4  ??DataTable161
       4  ??DataTable162
       4  ??DataTable162_1
       4  ??DataTable162_2
       4  ??DataTable162_3
       4  ??DataTable162_4
       4  ??DataTable162_5
       4  ??DataTable162_6
       4  ??DataTable163
       4  ??DataTable163_1
       4  ??DataTable163_2
       4  ??DataTable163_3
       4  ??DataTable163_4
       4  ??DataTable165
       4  ??DataTable165_1
       4  ??DataTable165_2
       4  ??DataTable165_3
       4  ??DataTable165_4
       4  ??DataTable168
       4  ??DataTable168_1
       4  ??DataTable168_2
       4  ??DataTable168_3
       4  ??DataTable168_4
       4  ??DataTable168_5
       4  ??DataTable170
       4  ??DataTable170_1
       4  ??DataTable170_2
       4  ??DataTable170_3
       4  ??DataTable170_4
       4  ??DataTable170_5
       4  ??DataTable171
       4  ??DataTable179
       4  ??DataTable179_1
       4  ??DataTable179_2
       4  ??DataTable180
       4  ??DataTable184
       4  ??DataTable187
       4  ??DataTable187_1
       4  ??DataTable187_2
       4  ??DataTable187_3
       4  ??DataTable188
       4  ??DataTable188_1
       4  ??DataTable188_2
       4  ??DataTable188_3
       4  ??DataTable188_4
       4  ??DataTable189
       4  ??DataTable190
       4  ??DataTable190_1
       4  ??DataTable190_10
       4  ??DataTable190_11
       4  ??DataTable190_2
       4  ??DataTable190_3
       4  ??DataTable190_4
       4  ??DataTable190_5
       4  ??DataTable190_6
       4  ??DataTable190_7
       4  ??DataTable190_8
       4  ??DataTable190_9
       4  ??DataTable191
       4  ??DataTable191_1
       4  ??DataTable191_2
       4  ??DataTable191_3
       4  ??DataTable192
       4  ??DataTable192_1
       4  ??DataTable192_10
       4  ??DataTable192_2
       4  ??DataTable192_3
       4  ??DataTable192_4
       4  ??DataTable192_5
       4  ??DataTable192_6
       4  ??DataTable192_7
       4  ??DataTable192_8
       4  ??DataTable192_9
       4  ??DataTable193
       4  ??DataTable193_1
       4  ??DataTable193_2
       4  ??DataTable193_3
       4  ??DataTable193_4
       4  ??DataTable194
       4  ??DataTable195
       4  ??DataTable195_1
       4  ??DataTable196
       4  ??DataTable196_1
       4  ??DataTable196_2
       4  ??DataTable196_3
       4  ??DataTable196_4
       4  ??DataTable196_5
       4  ??DataTable196_6
       4  ??DataTable196_7
       4  ??DataTable196_8
       4  ??DataTable196_9
       4  ??DataTable197
       4  ??DataTable197_1
       4  ??DataTable197_2
       4  ??DataTable197_3
       4  ??DataTable197_4
       4  ??DataTable198
       4  ??DataTable198_1
       4  ??DataTable198_2
       4  ??DataTable198_3
       4  ??DataTable198_4
       4  ??DataTable198_5
       4  ??DataTable199
       4  ??DataTable199_1
       4  ??DataTable199_2
       4  ??DataTable199_3
       4  ??DataTable199_4
       4  ??DataTable200
       4  ??DataTable205
       4  ??DataTable206
       4  ??DataTable206_1
       4  ??DataTable207
       4  ??DataTable207_1
       4  ??DataTable208
       4  ??DataTable210
       4  ??DataTable211
       4  ??DataTable212
       4  ??DataTable212_1
       4  ??DataTable212_2
       4  ??DataTable213
       4  ??DataTable213_1
       4  ??DataTable213_2
       4  ??DataTable214
       4  ??DataTable215
       4  ??DataTable215_1
       4  ??DataTable216
       4  ??DataTable216_1
       4  ??DataTable217
       4  ??DataTable217_1
       4  ??DataTable217_2
       4  ??DataTable217_3
       4  ??DataTable217_4
       4  ??DataTable217_5
       4  ??DataTable218
       4  ??DataTable219
       4  ??DataTable220
       4  ??DataTable221
       4  ??DataTable221_1
       4  ??DataTable223
       4  ??DataTable223_1
       4  ??DataTable225
       4  ??DataTable225_1
       4  ??DataTable225_2
       4  ??DataTable225_3
       4  ??DataTable226
       4  ??DataTable226_1
       4  ??DataTable226_2
       4  ??DataTable228
       4  ??DataTable228_1
       4  ??DataTable228_2
       4  ??DataTable229
       4  ??DataTable230
       4  ??DataTable230_1
       4  ??DataTable230_10
       4  ??DataTable230_11
       4  ??DataTable230_12
       4  ??DataTable230_13
       4  ??DataTable230_14
       4  ??DataTable230_15
       4  ??DataTable230_16
       4  ??DataTable230_17
       4  ??DataTable230_18
       4  ??DataTable230_19
       4  ??DataTable230_2
       4  ??DataTable230_20
       4  ??DataTable230_21
       4  ??DataTable230_22
       4  ??DataTable230_3
       4  ??DataTable230_4
       4  ??DataTable230_5
       4  ??DataTable230_6
       4  ??DataTable230_7
       4  ??DataTable230_8
       4  ??DataTable230_9
      88  ADJUST_DELTA(float const *)
      20  Beeper(uint32_t)
      24  C2
          S2
          SK1
          SK2
          THETA
          PSI
      18  CardReader::eof()
      46  CardReader::get()
      16  CardReader::isFileOpen()
       8  CardReader::setIndex(long)
      90  EXTI9_5_IRQHandler
      12  Endstops::enable(bool)
      20  Endstops::enable_globally(bool)
      12  Endstops::enable_z_probe(bool)
      12  Endstops::hit_on_purpose()
      20  Endstops::not_homing()
      48  FlushSerialRequestResend()
      30  GCodeParser::boolval(char)
      22  GCodeParser::byteval(char, uint8_t)
      22  GCodeParser::celsiusval(char, float)
      20  GCodeParser::has_value()
      22  GCodeParser::intval(char, int16_t)
      22  GCodeParser::linearval(char, float)
      76  GCodeParser::seen(char)
      22  GCodeParser::seenval(char)
      22  GCodeParser::ushortval(char, uint16_t)
       4  GCodeParser::value_axis_units(AxisEnum)
      28  GCodeParser::value_bool()
      34  GCodeParser::value_byte()
       4  GCodeParser::value_celsius()
       4  GCodeParser::value_feedrate()
      80  GCodeParser::value_float()
      10  GCodeParser::value_int()
       4  GCodeParser::value_linear_units()
      24  GCodeParser::value_long()
       4  GCodeParser::value_millis()
      24  GCodeParser::value_millis_from_seconds()
       4  GCodeParser::value_per_axis_unit(AxisEnum)
      24  GCodeParser::value_ulong()
      10  GCodeParser::value_ushort()
      12  IsRunning()
      16  IsStopped()
       4  L1
       4  L2
      10  Planner::apply_leveling(float (&)[3])
      28  Planner::blocks_queued()
      64  Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
     192  Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
      16  Planner::force_fade_recalc()
      40  Planner::leveling_active_at_z(float const &)
      76  Planner::refresh_e_factor(uint8_t)
       8  Planner::set_e_position_mm(float const &)
      48  Planner::set_filament_size(uint8_t, float const &)
      56  Planner::set_position_mm(float, float, float, float const &)
      88  Planner::set_z_fade_height(float const &)
      72  SCARA_move_to_cal(uint8_t, uint8_t)
      22  SYNC_PLAN_POSITION_KINEMATIC()
       4  Stepper::get_axis_position_degrees(AxisEnum)
      12  Stepper::set_homing_flag_z(bool)
      12  Stepper::set_z2_lock(bool)
      12  Stepper::set_z_lock(bool)
     684  SysTick_Handler_User()
      12  Temperature::degBed()
      12  Temperature::degHotend(uint8_t)
      16  Temperature::degTargetBed()
      16  Temperature::degTargetHotend(uint8_t)
      40  Temperature::isCoolingBed()
      44  Temperature::isCoolingHotend(uint8_t)
      52  Temperature::setTargetBed(float)
      28  Temperature::setTargetHotend(float, uint8_t)
      40  Temperature::set_auto_report_interval(uint8_t)
      60  Temperature::tooColdToExtrude(uint8_t)
       2  Temperature::updatePID()
     262  __sti__routine()
      40  _commit_command(bool)
      68  _enqueuecommand(char const *, bool)
     100  _manual_goto_xy(float const &, float const &)
       4  axis_codes
     120  axis_homed
          axis_known_position
          soft_endstops_enabled
          lcd_wait_for_move
          delta_tower
          soft_endstop_max
          delta_tower_angle_trim
          delta_diagonal_rod_2_tower
          cartes
          soft_endstop_radius
          soft_endstop_radius_2
          previous_cmd_ms
          max_inactive_time
          stepper_inactive_time
          delta_radius
          delta_diagonal_rod
          delta_calibration_radius
          delta_segments_per_second
     104  axis_relative_modes
          Running
          relative_mode
          busy_state
          host_keepalive_interval
          serial_wait_tick
          from_wifi_flag
          gridx
          gridy
          nextx
          nexty
          last_gridx
          last_gridy
          bilinear_grid_spacing
          bilinear_start
          bilinear_grid_factor
          gcode_N
          gcode_LastN
          Stopped_gcode_LastN
          serial_count
          wifi_read_count
          next_busy_signal_ms
          z1
          d2
          z3
          d4
          L
          D
          ratio_x
          ratio_y
          last_x
          last_y
     120  axis_unhomed_error(bool, bool, bool)
      12  base_home_pos(AxisEnum)
      12  base_max_pos(AxisEnum)
      12  base_min_pos(AxisEnum)
     590  bilinear_line_to_destination(float, uint16_t, uint16_t)
     478  bilinear_z_offset(float const *)
      60  bltouch_command(int)
      36  buffer_line_to_current_position()
      36  buffer_line_to_destination(float)
       1  button_disp_pause_state
      50  cap_line(char const *, bool)
    2808  card
          mksReprint
          print_job_timer
     294  clamp_to_software_endstops(float *)
      18  clean_up_after_endstop_or_probe_move()
      18  clear_command_queue()
     384  command_queue
       1  continue_print_error_flg
      20  debug_strings
      88  delta_safe_distance_from_top()
     112  disable_all_steppers()
      66  disable_e_steppers()
      70  disable_noZ_steppers()
      78  display_sd_error()
      94  display_temper_error()
     366  do_blocking_move_to(float const &, float const &, float const &, float const &)
      20  do_blocking_move_to_x(float const &, float const &)
       8  do_blocking_move_to_xy(float const &, float const &, float const &)
      22  do_blocking_move_to_z(float const &, float const &)
     272  do_homing_move(AxisEnum, float, float)
     122  do_probe_move(float, float)
      56  do_probe_raise(float)
      88  drain_injected_commands_P()
      16  duration_t::day() const
       6  duration_t::duration_t(uint32_t const &)
      14  duration_t::hour() const
      14  duration_t::minute() const
       4  duration_t::second() const
     232  duration_t::toString(char *) const
      18  duration_t::year() const
      32  dwell(millis_t)
       8  echo_not_entered()
      94  enable_all_steppers()
       1  enable_soft_endstops
      58  enqueue_and_echo_command(char const *, bool)
       8  enqueue_and_echo_commands_P(char const *)
     264  extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
     178  extrapolate_unprobed_bed_level()
       1  filament_heat_completed_load
       1  filament_heat_completed_unload
      68  filament_loading_time_flg
          filament_loading_completed
          filament_unloading_time_flg
          filament_unloading_completed
          printing_rate_update_flag
          preview_no_display
          loop_start
          cmd_queue_index_r
          cmd_queue_index_w
          sd_read_error_flg
          sd_read_cnt
          display_hold
          display_hold_release
          wifi_init_flg
          wifi_refresh_flg
          cloud_refresh_flg
          waiting_wifi_time
          beep_flg
          print_finish_start_timer
          print_finish_close_machine
          send_ok
          z_high_count
          temperature_change_frequency_cnt
          filament_loading_time_cnt
          filament_unloading_time_cnt
          TimeIncrease
          home_offset
          display_hold_cnt
          beep_cnt
          print_finish_timer_count
       1  filament_ran_out
       1  first_resu
       8  forward_kinematics_DELTA(float *)
    1164  forward_kinematics_DELTA(float, float, float)
     238  forward_kinematics_SCARA(float const &, float const &)
       6  freeMemory()
       1  g26_debug_flag
      24  gcode_G0_G1()
      40  gcode_G0_G1_SCARA(bool)
     408  gcode_G28(bool)
    3488  gcode_G29()
     672  gcode_G29_MESH_BED_LEVELING()
       4  gcode_G29_UBL()
     600  gcode_G2_G3(bool)
     260  gcode_G30()
      72  gcode_G4()
     396  gcode_G42()
     160  gcode_G92()
     228  gcode_M104()
      44  gcode_M105()
      60  gcode_M106()
      36  gcode_M107()
      12  gcode_M108()
     576  gcode_M109()
      28  gcode_M110()
     136  gcode_M111()
      12  gcode_M112()
      76  gcode_M113()
      14  gcode_M114()
     184  gcode_M115()
      16  gcode_M117()
      76  gcode_M118()
       4  gcode_M119()
       6  gcode_M120()
       6  gcode_M121()
      40  gcode_M140()
      36  gcode_M155()
      24  gcode_M17()
     268  gcode_M18_M84()
     404  gcode_M190()
      36  gcode_M20()
      84  gcode_M200()
      92  gcode_M201()
      80  gcode_M203()
     180  gcode_M204()
     148  gcode_M205()
     120  gcode_M206()
     228  gcode_M211()
     204  gcode_M218()
      12  gcode_M22()
      28  gcode_M220()
      56  gcode_M221()
     148  gcode_M226()
      68  gcode_M23()
      44  gcode_M24()
      32  gcode_M25()
      44  gcode_M26()
      12  gcode_M27()
      24  gcode_M28()
     160  gcode_M280()
       2  gcode_M29()
      44  gcode_M30()
     260  gcode_M301()
     160  gcode_M302()
     148  gcode_M303()
     208  gcode_M304()
      76  gcode_M31()
     104  gcode_M32()
      28  gcode_M355()
      24  gcode_M360()
      24  gcode_M361()
      24  gcode_M362()
      24  gcode_M363()
      24  gcode_M364()
       4  gcode_M400()
       6  gcode_M401()
       6  gcode_M402()
       4  gcode_M410()
     124  gcode_M42()
     548  gcode_M420()
     204  gcode_M421_AUTO_BED_LEVELING_BILINEAR()
     264  gcode_M421_AUTO_BED_LEVELING_UBL()
     264  gcode_M421_MESH_BED_LEVELING()
     216  gcode_M428()
      64  gcode_M49()
       4  gcode_M500()
       4  gcode_M501()
       4  gcode_M502()
      36  gcode_M503()
     152  gcode_M665()
      80  gcode_M666()
      76  gcode_M666_dual()
      12  gcode_M75()
      12  gcode_M76()
      12  gcode_M77()
      44  gcode_M81()
      12  gcode_M82()
      12  gcode_M83()
      28  gcode_M85()
     112  gcode_M851()
       2  gcode_M907()
     200  gcode_M92()
      20  gcode_M928()
     112  gcode_M998()
      36  gcode_M999()
      60  gcode_T(uint8_t)
     102  gcode_get_destination()
      60  gcode_line_error(char const *, bool)
      28  get_available_commands()
     108  get_cartesian_from_steppers()
     100  get_homing_bump_feedrate(AxisEnum)
     512  get_sdcard_commands()
     552  get_serial_commands()
      98  get_target_extruder_from_command(uint16_t)
     284  get_wifi_commands()
      34  handle_filament_runout()
       6  home_all_axes()
      10  home_bump_mm(AxisEnum)
      12  home_bump_mm_P
     156  home_delta()
       8  home_dir(AxisEnum)
      60  home_dir_P
          base_min_pos_P
          base_max_pos_P
          base_home_pos_P
          max_length_P
          L1_2
          L2_2
     644  homeaxis(AxisEnum)
     116  host_keepalive()
      24  hotend_offset
     140  idle()
     320  incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
       8  incremental_LSF_reset(linear_fit_data *)
       4  injected_commands_P
      72  invalid_extruder_error(uint8_t)
     408  inverse_kinematics(float const *)
     378  inverse_kinematics_MORGAN_SCARA(float const *)
      52  kill(char const *)
      52  kill_c
       4  last_wait_time
       4  lcd_hasstatus()
       2  lcd_init()
      70  lcd_reInit()
       2  lcd_refresh()
       2  lcd_reset_alert_level()
       2  lcd_setalertstatusPGM(char const *)
       2  lcd_setstatus(char const *, bool)
       2  lcd_setstatusPGM(char const *, int8_t)
       2  lcd_update()
      50  leveling_is_valid()
     194  loop
     278  manage_inactivity(bool)
      12  max_length(AxisEnum)
     120  mbl_mesh_report()
       4  mbl_probe_index
     360  mesh_bed_leveling::cell_index_x(float const &)
     356  mesh_bed_leveling::cell_index_y(float const &)
     448  mesh_bed_leveling::probe_index_x(float const &)
     444  mesh_bed_leveling::probe_index_y(float const &)
      24  mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
      32  mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
      56  mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
     418  mesh_line_to_destination(float, uint8_t, uint8_t)
     106  mks_G28(char *)
     650  mks_PrintStatePolling
     340  mks_ReadFromEpr
     200  mks_ReadFromEpr_pwroff()
      92  mks_ReadFromFile
      96  mks_ResetPositionZ(float)
     310  mks_WriteToEpr()
     234  mks_WriteToEpr_pwroff()
     620  mks_WriteToFile
      42  mks_clearDir
      88  mks_clearFile
     102  mks_contiuePrintDelta
     130  mks_contiuePrintPause
     200  mks_contiuePrintPwdwn
     312  mks_contiuePrint_UI
     630  mks_getPositionXYZE
     282  mks_get_commands()
     136  mks_heating_busy
          marlin_debug_flags
          commands_in_queue
          active_extruder
          wait_for_heatup
          target_extruder
          feedrate_percentage
          current_position
          destination
          homing_feedrate_mm_s
          workspace_offset
          soft_endstop_min
          delta
          feedrate_mm_s
          position_shift
          fanSpeeds
          zprobe_zoffset
          xy_probe_feedrate_mm_s
          delta_height
          delta_clip_start_height
          L1_2_2
          ubl
     150  mks_home_moveXY
      90  mks_home_moveZ
      96  mks_initPrint
     156  mks_leveling_moveXY(float, float)
     122  mks_leveling_moveZ(float)
      80  mks_manual_leveling
     138  mks_moveXY
      98  mks_moveZ
     102  mks_moveZ_relative(float)
      90  mks_pausePrint
       4  mks_pft_name
     182  mks_preExtrude
     222  mks_rePrintCheck
      72  mks_resumePrint
      68  mks_saveFileName
      16  mks_setFeedrate()
      96  mks_setPositionZ
     368  mks_setTemperature()
     736  mkstft_ui_init
     736  mkstft_ui_load
     774  mkstft_ui_set_epr()
       4  next_idle_ms
      42  ok_to_send()
      30  out_of_range_error(char const *)
      48  pft_get()
      30  pin_is_protected(int8_t)
    1008  plan_arc(float const (&)[4], float const (&)[2], bool)
     184  position_is_reachable_IS_CARTESIAN(float const &, float const &)
     376  position_is_reachable_IS_KINEMATIC(float const &, float const &)
     184  position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
      56  position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
    1144  prepare_kinematic_move_to(float const (&)[4])
     232  prepare_move_to_destination()
     264  prepare_move_to_destination_cartesian()
     118  prepare_uninterpolated_move_to_destination(float)
     308  print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
      32  print_bilinear_leveling_grid()
     422  probe_pt(float const &, float const &, bool, uint8_t, bool)
      70  process_next_command()
    1836  process_parsed_command()
     274  quick_home_xy()
      24  quickstop_stepper()
     568  recalc_delta_settings()
      80  refresh_bed_level()
      16  refresh_cmd_timeout()
     186  report_current_position()
     144  reset_bed_level()
     108  run_z_probe()
       8  saved_feedrate_percentage
          saved_feedrate_mm_s
       1  sd_comment_mode
      52  sensitive_pins
       1  serial_comment_mode
       4  serial_echopair_P(char const *, bool)
      96  serial_line_buffer
      28  serialprintPGM(char const *)
       2  servo_init()
     242  set_axis_is_at_home(AxisEnum)
     242  set_bed_leveling_enabled(bool)
     198  set_bltouch_deployed(bool)
      20  set_current_from_destination()
      68  set_current_from_steppers_for_axis(AxisEnum)
      20  set_destination_from_current()
      26  set_home_offset(AxisEnum, float)
      80  set_probe_deployed(bool)
     140  set_z_fade_height(float, bool)
     268  setup
       2  setup_filrunoutpin()
      22  setup_for_endstop_or_probe_move()
       2  setup_killpin()
       2  setup_powerhold()
     164  soft_endstop_min_init()
      62  stop()
       1  stop_buffering
       8  str_debug_1
      16  str_debug_16
       8  str_debug_2
       8  str_debug_4
       8  str_debug_8
       4  strchr(char *, int)
       4  strrchr(char *, int)
       4  strstr(char *, char const *)
       2  suicide()
      18  sync_plan_position()
      12  sync_plan_position_e()
      12  sync_plan_position_kinematic()
       4  t1
      12  t12
       4  t2
       2  temper_error_flg
          temper_error_type
      44  temper_error_kill()
     520  tool_change(uint8_t, float, bool)
     316  unified_bed_leveling::mesh_index_to_xpos(uint8_t)
     312  unified_bed_leveling::mesh_index_to_ypos(uint8_t)
     124  unified_bed_leveling::mesh_is_valid()
     286  update_software_endstops(AxisEnum)
       1  wifi_comment_mode
       1  wifi_init_state
      96  wifi_line_buffer
       4  wifi_loop_cycle
      16  z_endstop_adj
          delta_endstop_adj
     576  z_values
    3464  -- Other

 
  4 207 bytes in section .bss
    385 bytes in section .data
      4 bytes in section .init_array
  3 815 bytes in section .rodata
 52 120 bytes in section .text
 
 28 868 bytes of CODE  memory (+ 23 256 bytes shared)
    288 bytes of CONST memory (+  3 527 bytes shared)
  4 382 bytes of DATA  memory (+    210 bytes shared)

Errors: none
Warnings: 164
